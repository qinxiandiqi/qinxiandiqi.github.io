<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>线程安全 on 琴弦第七</title><link>https://www.qinxiandiqi.sbs/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</link><description>Recent content in 线程安全 on 琴弦第七</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2012-2022 Jianan. All Rights Reserved.</copyright><lastBuildDate>Sun, 26 Aug 2018 13:37:49 +0800</lastBuildDate><atom:link href="https://www.qinxiandiqi.sbs/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>libGDX的线程</title><link>https://www.qinxiandiqi.sbs/posts/libgdx/libgdx%E7%9A%84%E7%BA%BF%E7%A8%8B/</link><pubDate>Sun, 26 Aug 2018 13:37:49 +0800</pubDate><guid>https://www.qinxiandiqi.sbs/posts/libgdx/libgdx%E7%9A%84%E7%BA%BF%E7%A8%8B/</guid><description>所有ApplicationListener接口中的方法都会在同个OpenGL的渲染线程中被调用。对于大多数游戏来说，一般在ApplicationListener.render()方法中实现游戏的更新逻辑，这个方法会在渲染线程中执行。
任何涉及OpenGL的图形操作都需要在渲染线程上执行。如果在其它线程上执行会导致一些无法预测的结果，这是因为OpenGL Context只有在渲染线程中才处于激活状态，对于大多数Android设备而言，在其它线程中创建OpenGL Context会导致一些问题，因此不支持这</description></item></channel></rss>