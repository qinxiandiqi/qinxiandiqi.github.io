{"authors":["Jianan"],"categories":[],"pages":[{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"一、Window系统# 1.1 新建ssh密钥# 打开Terminal（Power Shell终端），使用ssh-keygen生成新密钥： $ ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 提示新密钥保存位置，直接回车保存到默认位置：%USERPROFILE%/.ssh/id_ed25519 \u0026gt; Enter a file in which to save the key (/c/Users/you/.ssh/id_algorithm):[Press enter] 提示键入安全密码，直接回车不使用密码： \u0026gt; Enter passphrase (empty for no passphrase): [Type a passphrase] \u0026gt; Enter same passphrase again: [Type passphrase again] 查看新密钥指纹： $ cat ~/.ssh/id_ed25519 1.2 添加新密钥到ssh-agent# Window系统ssh-agent服务默认禁用，先把ssh-agent服务启动方式改为自启动。以管理员身份打开Terminal（Power Shell终端），输入： Set-Service -Name ssh-agent -StartupType automatic 添加新密钥到ssh-agent： $ ssh-add ~/.ssh/id_ed25519 二、Linux或Mac系统# 2.1 新建ssh密钥# 打开终端，使用ssh-keygen生成新密钥： $ ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 提示新密钥保存位置，直接回车保存到默认位置：%USERPROFILE%/.ssh/id_ed25519 \u0026gt; \u0026gt; Enter a file in which to save the key (/home/you/.ssh/algorithm): [Press enter] 提示键入安全密码，直接回车不使用密码： \u0026gt; Enter passphrase (empty for no passphrase): [Type a passphrase] \u0026gt; Enter same passphrase again: [Type passphrase again] 查看新密钥指纹： $ cat ~/.ssh/id_ed25519 2.2 添加新秘钥到ssh-agent# 启动ssh-agent服务： $ eval \u0026#34;$(ssh-agent -s)\u0026#34; 添加新密钥到ssh-agent： $ ssh-add ~/.ssh/id_ed25519 ","date":"September 11, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/%E7%94%9F%E6%88%90%E6%96%B0ssh%E5%AF%86%E9%92%A5%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0ssh-agent/","series":[],"smallImg":"","tags":[{"title":"SSH","url":"https://www.qinxiandiqi.sbs/tags/ssh/"}],"title":"生成新SSH密钥并添加到ssh-Agent"},{"authors":[],"categories":[],"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremely fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","date":"February 28, 2019","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/about/","series":[],"smallImg":"","tags":[],"title":"About"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-30# 装饰模式：又叫包装模式，能够在不创造更多子类的情况下动态地将对象的功能加以扩展，是继承的一种替代方案。一个类对象装饰另一个类对象，就可以以装饰对象的方法处理被装饰对象，而整个处理过程对客户端是透明的，实际的过程是装饰对象的处理方法调用被装饰对象的处理方法，并在被装饰对象的处理方法上添加新的功能，也就是说最终是把客户端的调用委托到被装饰类。这种模式的好处就是在不造成类数量增加的情况下，构造更多功能的对象。\n装饰模式与继承的区别：装饰模式用来扩展特定对象的功能，并且是动态的，在运行时分配添加的职责，因此灵活性比较好；而继承是扩展类的功能，一旦扩展就不能修改，是静态的，在编译时分配添加的职责，因此灵活性比较差。另外，一个规定的对象同时能被对个装饰对象装饰，客户端可以通过选择合适的装饰对象操作被装饰对象。\n装饰模式的角色：\n抽象构建角色（Component）：一般是一个抽象类或者接口，用来规范被装饰对象的结构。如：InputStream和OutputStream。 具体构建角色（Concrete Component）：也就是真实对象，继承或实现了抽象构建角色。如：节点流FileInputStream和FileOutputStream。 装饰角色（Decorator）：继承或实现抽象构建角色的抽象类或者接口或者类，以实现客户端对象可以使用和具体构建角色相同的方式与装饰对象进行交互。装饰角色接收客户端对象的所有请求，装饰角色内部持有一个抽象构建角色的引用变量，通过这个引用才能最终将客户端的请求转发给构建角色，由构建角色去完成。如：过滤流FilterInputStream和FileOutputStream。 具体装饰角色（Concrete Decorator）：继承或实现抽象装饰角色的类，具体实现对被装饰对象的附加功能添加在这个类中，而不是装饰角色中。如：过滤流DataInputStream和DataOutputStream。 new DataInputStream（new BufferedInputStream（new FileInputStream（“C：\\test.text”）））；\nJava中采用Unicode字符，一个字符16位，字符流Reader和Wrider处理的都是Unicode字符，一次至少两个字节16位。\nInputStreamReader直接继承Reader，是字节流通向字符流的桥梁。构造方法有InputStreamReader（InputStream in）、InputStreamReader（InputStream in，String cs）等，用于接收一个InputStream对象，并使用cs编码格式编码，如果没有cs参数则使用系统默认编码格式。类中提供了getEncoding（）方法可以返回该流使用的字符编码格式名称。可以将InputStreamReader看做是把InputStream装饰成处理字符流的过滤流。\nOutputStreamWriter直接继承Writer，是字节通向字符流的桥梁。构造方法有OutputStreamWriter（OutputStream out）. OutputStreamWriter（OutputStream out，String cs）等，用于接收一个OutputStream对象，并使用cs格式编码，如果没有cs参数则使用系统默认的编码格式编码。类中提供了getEncoding（）方法可以返回该流使用的字符编码格式名称。flush（）方法可以强制刷新该流的缓冲。可以将OutputStreamReader看做是把OutputStream装饰成处理字符流的过滤流。由于继承了Writer，所以继承了其中的writer（String str）方法，可以一次写入一个字符串。\nBufferedReader直接继承Reader，类比于BufferedInputStream，只是类中的字节缓冲数组变更为字符缓冲数组，其类中其他方法使用方式与BufferedInputStream中方法使用几乎相同，是一个接收Reader的过滤流。类中提供了一个readLine（）方法读取Reader流中的一个文本行，并将游标转移到该行的行尾，如果游标已经到行尾，则会返回null。\nBufferedWriter直接继承Writer，类比于BufferedOutputStream，只是类中的字节缓冲数组变更为字符缓冲数组，其类中的方法使用方式与BufferedOutputStream中的方法几乎相同，是一个接受Writer的过滤流。由于继承了Writer，所以继承了其中的writer（String str）方法，可以一次写入一个字符串。\nFileReader继承InputStreamReader，类似于FileInputStream，只是处理的对象是字符。\nFileWriter继承OutputStreamWriter，类似于FileOutputStream，只是处理对象是字符。如果FileWriter依赖的文件不存在则会自动创建这个文件，如果FileWriter试图打开一个只读文件就会抛出一个IOException异常。\nCharArrayReader继承Reader，类似于ByteArrayInputStream，只是字节数组更改为字符数组。\n13.CharArrayWriter继承Writer，类似于ByteArrayOutputStream，只是字节数组更爱为字符数组。\nSystem.in其实是一个InputStream标准输入流，通常是从键盘输入；System.out其实是一个PrintStream标准输出流，一般是输出到控制台。\nString的getChars（int srcBegin，int srcEnd，char[] dst，int dstBegin）方法用于将原字符串中的srcBegin到srcEnd的字符以字符数组的方式复制到字符数组dst的dstBegin位置开始。\nASCII（American Standard Code for Information Interchange）：美国信息互换标准代码，采用8位二进制位编码，将英文中常用的字符、数字符号与最高位为0，相应十进制数为0-127的数值对应进行编码。另外还有128个扩展ASCII编码，其最高位为1，用于编制一些指标附后和其它符号。\nGB2312：信息交换用汉字编码字符集-基本集，使用两个字节表示一个中文字符，并且每个字节的最高位都是1.\nGBK：GB2312的扩展，完全兼容GB2312，并且多容纳了繁体中文和一些不常用的汉字。\n19.ISO-8859-1：西方国家使用的字符编码集，属于单字节的字符集，其中英文只用了其中数值小于128的部分。不兼容汉字。\nUnicode：通用字符集，可以对所有语言文字进行编码，每个字符都使用两个字节，Java中采用这个编码方式以实现字符的跨平台。这种编码的缺点在于在internet上传输的效率比较低，因为一些使用一个字节就能表示的字符也使用两个字节表示，高字节填0。\nUTF-8：不定长字符编码方式，根据字符需要的字节长度分配字节，有些字符用一个字节，有些两个，有些三个。互联网上常用这种编码方式，传输效率高，字符容量大。\njava.io.RandomAccessFile：随即访问文件类，直接继承Object，并实现了DataInput和DataOutput接口。构造方法有RandomAccessFile（File file，String access）或者RandomAccessFile（String name，String access），其中file或者name表示依赖的File对象或者文件名，access表明使用文件的方式是“r”（只读）还是“rw”（读写）。另外，由于类中包含一个long变量pos作为流的游标，使用该类的getFilePointer（）可以获得当前游标的位置，使用该类的seek（long pos）可以将游标定位到pos位置，使用skipBytes（int n）可以将游标向后移动n个字节。由于该类实现了DataInput和DataOutput接口，所以类中提供了大量读写各种数据类型的方法，特别的有readUTF（）和writeUFT（String str）方法以UFT的格式读写数据。该类的特点在于类中包含了输入流方法和输出流方法，相当于输入流和输出流的合体。\njava.nio.Charset类中的availableCharsets（）方法可以返回一个SorteMap\u0026lt;String，Charset\u0026gt;排序映射。其中的Key为当前系统所支持的字符集名。\n序列化/反序列化：将对象转换为字节流（因为对象不是字符，转换成字符流没有意义）保存起来，并在以后从字节流中还原这个对象的机制。若把一个对象序列化后保存到永久存储设备上，这个过程也叫做持久化。\n声明对象可序列化：一个对象能够序列化的前提是对象必须实现Serializable或者Externalizable接口。其中Serializable接口只是一个标识性接口，接口中没有定义任何方法，实现该接口仅是表示这个类可以被序列化而已。继承一个可序列化的类，其子类也可序列化，即序列化特性可以被继承。\n被序列化的对象中如果存在其它对象的引用，则其它对象的引用也会被序列化，并且引用的对象又包含其它对象的引用也会被序列化，也就是序列化会根据对象中的引用一层一层连接下去序列化。\n对象序列化的时候，如果对象中的某成员无法序列化，则会抛出NotSerializableException异常。此时，若将该无法被序列化的对象使用关键字transient（瞬间）修饰，则序列化的时候不会序列化该成员，对象的序列化能够正常进行。\n对象序列化的时候，不会序列化对象中的static变量和方法（因为它们属于类，不属于对象），也不会序列化被transient修饰的成员。只会将对象中的成员变量序列化，写入到字节流中（通过字节流可写入到存储设备上永久保存）。如果成员变量是一个对象的引用，则会按照同样序列化的规则序列化引用的对象，以此类推各个对象引用。\nObjectOutputStream类：继承了OutputStream类，并且实现了ObjectOutput接口，ObjectOutput接口又实现了DataOutput接口。构造方法有ObjectOutputStream（OutputStream out），可接收一个输出字节流，是一个过滤流，主要用于实现对象的序列化。另外，由于实现了DataOutput接口，所以类中包含大量写入各种类型数据的方法。\n将对象序列化的方法：使用ObjectOutputStream类的writeObject（Object obj）方法。默认会将obj的类、类的签名、以及类和其所有超类的非transient非static成员变量写入到输出流中，即实现了序列化。\nObjectInputStream类，继承了InputStream类，并且实现了ObjectInput接口，而ObjectInput接口又实现了DataInput接口。构造方法有ObjectInputStream（InputStream in），可接收一个输入字节流，也是一个过滤流，主要用于实现对象的反序列化。另外，由于实现了DataInput接口，所以类中包含了大量读取各种数据类型的方法。\n对象反序列化的方法：使用ObjectInputStream类的readObject（）方法，返回一个Object对象。由于对象在序列化的时候保存了对象的类信息，所以readObject方法无需参数，就能将当前游标所在位置后边的对象按该对象序列化时的类信息恢复出来。恢复的时候，并不会调用该对象类的任何构造方法，仅是根据保存的状态信息在内存中重新构建对象而已。又由于对象序列化的时候不会序列化transient修饰的成员变量，但保存的类信息中存在该成员的信息，所以反序列化后，被transient由于序列化时没有将值保存下来，其值只能是其数据类型的默认值。\n序列化和反序列化过程中，如果需要对对象进行特殊处理，不按照java提供的默认序列化和反序列化方法进行，可自定义序列化和反序列化的处理方法。方法为在需要被序列化和反序列化的类中实现两个方法： 1）序列化方法：private void writeObject（java.io.ObjectOutputStream stream）throws IOException{}；在方法体中写入自己的处理对象成员变量与写入ObjectOutputStream流的代码，当对该类对象进行序列化的时候便会调用这个方法进行序列化，不再使用默认序列化方法。 2）反序列化方法：private void readObject（java.io.ObjectInputStream stream）throws IOException，ClassNotFoundException{}；在方法体重写入自己处理对象成员变量与ObjectInputStream流的代码，当对该类对象进行反序列化的时候就会自动调用这个方法进行反序列化，不再使用默认的反序列化方法处理。\n进程：进程是一个运行中的程序，每一个程序运行的时候都需要在进程中执行代码，操作系统会为一个程序分配该程序进程所需要的资源，包括内存空间等。进程与进程之间的内部数据和状态都是完全独立的，所以进程与进程之间的切换代价比较高。\n线程：每个进程至少包含一个线程，一个进程可以包含多个线程，每个线程可独立完成进程中的一个工作，是程序内的一个顺序控制流，只能使用分配给程序的资源和环境。并且线程运行时只需要很少的资源，通常只有寄存器数据以及程序执行时的堆栈，所以线程与线程之间的切换代价比较小。同一个进程之间的线程共享一块内存空间和系统资源，它们有可能会互相影响。\n多任务处理包括基于进程和基于线程两种对任务处理，它们都是为最大限度使用CPU资源，以提高CPU效率。\nJava语言内置支持多线程变成，其他大多数编程语言都需要通过外部库链接来实现多线程编程。\nJava程序中，每当程序启动的时候都会自动启动一个线程，main方法就运行在这个自动启动的主线程上，因此这个线程也叫做main thread。每个Java程序至少都有一个线程，这个线程就main线程。\n","date":"June 4, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"装饰模式","url":"https://www.qinxiandiqi.sbs/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"title":"io","url":"https://www.qinxiandiqi.sbs/tags/io/"},{"title":"字符集","url":"https://www.qinxiandiqi.sbs/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"title":"序列化和反序列化","url":"https://www.qinxiandiqi.sbs/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"title":"JavaSE学习笔记 第十记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-29# Java的I/O系统主要由java.io包和java.nio包构成。\njava.io.File类对象表示了磁盘上的一个文件或者目录，在java的io系统中，文件和目录都统一使用File类对象表示，其父类是Object。File类只是对磁盘上的文件或目录的抽象表示，提供了与平台无关的对文件或目录的操作方法，比如获取路径或者文件及目录的相关信息，并对他们进行创建. 删除、改名等管理工作。然而File只是抽象描述了文件或目录的属性和操作方法，但并没有提供怎样从文件读取和向文件存储等方法。\n路径分隔符：由于java中反斜杠\\用作转义字符，所以路径中的反斜杠需要用双反斜杠\\转义表示。特别的，处理window系统中使用反斜杠做文件路径分隔符之外，其他系统都是使用正斜杠/做路径分隔符。因此，java中使用正斜杠/做抽象路径分隔符，无论什么系统使用正斜杠做路径分隔符，java都能自动转成系统适应的分隔符，所以推荐使用正斜杠/做java中的路径分隔符。\nFile的构造方法常用的有：File（String path）、File（File file，String str）、File(String str1,String str2)。值得注意的是，使用File构造方法构造一个File对象并不等于创建了这个File对象指向的文件或者目录，其中第二三个构造方法需要组合后能拼成一个正常的文件路径才不会影响到File对象对该文件或路径的操作。\nFile创建文件方法：createNewFile（）。只要File构造方法的参数路径存在，并且路径指向的文件不存在，就能够创建对应的文件。如果参数路径存在，且指向的文件也存在，则创建失败，返回false。如果参数路径不存在，则会抛出路径找不到的异常。\nFile创建目录的方法：mkdir（），该File指向的路径中，要创建的目录上一级路径不存在，则无法创建目录，返回false。mkdirs（），该File指向的路径中，要创建的目录上一级或上几级路径不存在，也能够正常创建目录，并把不存在的路径目录都创建出来。如果要创建的目录已经存在，则返回false。\nFile的isFile（）用于判断File是否指向一个文件；File的isDirectory（）用于判断File是否指向一个目录。\nFile的list（）用于将File指向目录内的所有内容的名字以字符串数组返回，包括文件和目录。File的listFiles（）方法用于将File对象指向的目录内所有File以File数组的形式返回。使用以上两个方法时，File对象必须时一个目录对象。\nFile的getName（）获取File对象指向文件的名字；File的getParent（）用于获取父目录名；File的getParnetFile（）用于获取父目录File对象；File的exists（）用于判断文件是否已经存在。File的delete（）用于删除File对象指向的文件（只有文件或者空目录才能删除，不为空的目录需要将目录内的所有文件都删除才能删除，一般是由递归算法）。\nFileNameFilter接口，常用作list（FileNameFilter filter）或listFiles（FileNameFilter filter）方法的参数，以返回目录下符合一定条件的文件名或文件File对象。一般是在参数列表中使用匿名内部类实现这个接口，该接口只包含一个方法accept（File dir，String name），筛选目录下文件的筛选方法就写在这个accept方法体中。\nFile.separator静态常量，用于表示与系统有关的默认名称分隔符，在路径中可以始终File.separator代替路径的分隔符以组成完整的路径字符串。单独的File.separator表示根目录，即盘符。\n递归：方法内部再调用自己，或者一个方法调用另一个方法，而另一个方法又调回原来的方法。递归的特点就是循环嵌套调用，并且使用递归的方法中必须提供一个结束递归的出口（一般是一个if条件判断）。递归的过程分为递进和回归，先一层一层调用到出口层，返回确定结果后再一层一层将结果返回到最顶层。\nJava的流（Stream）：Java的程序通过流来完成输入和输出，是生产或者消费信息的抽象，它通过java的输入和输出系统与物理设备连接，并且屏蔽掉设备之间的差异性，对于不同的物理设备，流都具有同样的行为方式。\n输入流和输出流：根据程序在使用数据时扮演的角色不同，流可以分为输入流和输出流。当程序从外部读取数据时，也就是程序是数据流的目的地，此时的数据流为输入流；当程序输入数据到外部时，也就是程序是数据流的源头，此时的数据流为输出流。总的来说，输出流和输入流是一种以程序为中心的相对概念。\n字节流和字符流：根据流结构上的不同，将流分为字节流和字符流。字节流以字节为处理单位，即八位二进制数据，一般用于读写图像或者声音等二进制数据。字符流以采用了统一编码标准的16位字符为单位，因此字符流可以国际化，在某些场合下，字符流具有比字节流更高的效率。\n综合输入输出流和字节字符流，可以将流再细分为：输入字节流（以InputStream抽象类为父类）、输出字节流（以OutputStream抽象类为父类）、输入字符流（以Reader抽象类为父类）、输出字符流（以Writer抽象类为父类）。\nJava 1.0只存在字节流，Java 1.1开始出现字符流。字符流的出现只是为了处理字符提供方便有效的办法，但是字符流的底层本质上还是以字节的形式处理。\n流读取数据的逻辑：\n打开一个输入流 循环判断是否还存在数据信息，如果还有数据信息，则读取一定单位的数据信息并继续循环，直到没有剩余数据信息为止。 关闭输入流 流存储数据的逻辑：\n打开一个输出流 循环判断是否还有需要存储的数据信息，如果还有数据信息，则存储一定单位的数据信息并继续循环，直到所有数据信息都存储完毕为止。 关闭输出流。 根据流是否与目标直接打交道，可以将流分为节点流和过滤流。节点流直接与需要从中读取数据或者需要从中输出数据的目标打交道，比如从硬盘上某文件读取数据的流、程序输出数据到硬盘某个文件的输出流。过滤流是与节点流或者其他过滤流打交道的流，也就是它不直接与数据目标打交道，它的作用在于将节点流或者过滤流再封装以增加更多的数据信息和处理方法，并且它是同步的。\n所有流的关闭方法都是close（）。\nInputStream的三个read方法：\nread()，三个read方法中唯一的一个抽象方法，规定从输入流中读取数据的下一个字节。因为不同子类read的具体需要不同，所以设计此read抽象方法以供子类实现时设计符合自己具体要求的read（）方法。 read（byte[] b，int off，int len），本质上是方法体内通过对read（）方法的调用，来实现从数据流中读取不超过len个字节到以off索引为起始位置的b字节数组中去，返回值为实际读取的字节个数，如果没有字节可读取则返回-1。因为每个子类的read（）实现方法不同，所以子类继承这个方法就能根据子类read（）的读取规则完成这个方法的逻辑。 read（byte[] b），本质上是调用read（b，0，b.length）。 String类具有一个将字节数组转换为字符串的构造方法：String（byte[] b，int off，int length），可以构造一个b数组中以off索引为其实位置，长度为length的字符串。String类也提供了getbyte（）方法将字符串转换为byte数组。\nOutputStream的三个write方法（类似于InputStream三个read的原理）：\nwrite(int b)，三个write方法中唯一的一个抽象方法，规定将b个字节写入到输出流中。因为不同子类write的具体需要不同，所以设计此read抽象方法以供子类实现时设计符合自己具体要求的write（int b）方法。 write（byte[] b，int off，int len），本质上是方法体内通过对write（int b）方法的调用，来实现将b字节数组中从off索引为起始位置的len个字节写入到输出流中，没有返回值。因为每个子类的write（int b）实现方法不同，所以子类继承这个方法就能根据子类write（int b）的写入规则完成这个方法的逻辑。 write（byte[] b），本质上是调用read（b，0，b.length）。 FileInputStream继承了InputStream，是关于File的字节输入流。构造方法有FileInputStream（String url）、FileInputStream（File file）等，用于获取file指向的文件或者url路径指向的文件的字节输入流。\nFileOutputSteam继承了OutputStream，是File的字节输出流。构造方法有FileOutputStream（File file，boolean append）和FileOutputStream（String url，boolean append），file或者url表示输出流要写入的file或者url指向的文件，如果文件不存在则会自动创建这个文件；append为true则当文件已经存在的情况下，使用write会将写入字节追加到文件尾，若为false则会删除文件的全部内容，然后写入。FileOutputStream（File file）和FileOutputStream（String url）的本质是对应前两个构造方法，append值为false的构造方法。\nByteArrayInputStream继承了InputStream，以byte数组为输入源的字节流，内部包含一个buf字节数组缓冲区（即要读取的数据）。构造方法有ByteArrayInputStream（byte[] buf，int off，int length），构造一个buf为缓冲区数组的字节数组输入流，并且将要读取的开始索引位置为off，读取的字节个数为length。另一个构造方法ByteArrayInputStream（byte[] buf）的本质为ByteArrayInputStream（buf，0，buf.length）。\nByteArrayOutputStream继承了OutputStream，以byte数组为输出对象的输出流，内部包含一个buf字节数组缓冲区（存放写出的数据）。构造方法有ByteArrayOutputStream（）和ByteArrayInputStream（int size）。使用它的write方法可以将一个byte数组写入到它的六种buf字节数组缓冲区，再使用它的toByArray（）方法创建一个新的byte数组存储流中的buf字节数组，也可以使用它的writeto（OutputStream out）方法将buf的全部内容写到输出流out中去。\nFilterInputStream是继承InputStream的输入字节过滤流抽象类，输入字节过滤流都必须继承这个类，java提供的子类有DataInputStream（常用）、BufferedInputStream（常用）、LineNumberInputStream、PushbackInputStream。\nFilterOutputStream是继承OutputStream的输出字节过滤流抽象类，所有输出字节过滤流都必须继承这个类，java提供的子类有DataOutputStream（常用）、BufferedOutputstream（常用）、PrintStream。\nDataInputStream：数据字节输入流，构造方法为DataInputStream（InputStream in），相当于将in输入流再进行包装成DataInputStream。内部提供了大量读取基本数据类型的方法，这些方法将按照对应数据类型的字节长度依次读取in中的数据。例如：readBoolean（）、readByte（）、readChar（）、readDouble（）等等。\nDataOutputStream：数据字节输出流，构造方法为DataOutputStream（OutputStream out），相当于将out输出流再进行包装称DataOutputStream。内部提供了大量写入基本数据类型的方法，这些方法会按照对应的基本类型占用的字节长度，以二进制的形式写入到out中。例如：writeBoolean、writeByte、writeBytes、writeChar、writeChars等。\nBufferedInputStream：字节缓冲输入流，内部具有buf字节数组缓冲区，构造方法有BufferedInputStream（InputStream in）和BufferedInputStream（InputStream in，int size），用于将in输入流包装称BufferedInputStream，带有size时可指定内部buf缓冲区数组长度为size。使用它的read读取in数据，并不会直接将读取的数据存入到接收数据的数组b中，而是先存到内部buf数组中，等到buf数组满了后再一次把数据读回，使用close关闭流之前会强制将buf中数据返回。\nBufferedOutputStream：字节缓冲输出流，内部具有buf字节数组缓冲区，构造方法有BufferedOutputStream（OutputStream out）和BufferedOutputStream（OutputStream out，int size），用于将out输出流包装称BufferedOutputStream，带有size时可指定内部buf缓冲区数组长度为size。使用它的write并不会直接将数据写出去，而是等到buf数组满了后再一次性写出去，或者调用flush（）时强制将buf中数据写出去，使用close关闭流时也会强制写出去。\n","date":"June 2, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B9%9D%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"io","url":"https://www.qinxiandiqi.sbs/tags/io/"},{"title":"文件系统","url":"https://www.qinxiandiqi.sbs/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}],"title":"JavaSE学习笔记 第九记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-27# AWT：Java第一代的GUI，是重量级的，将实际生成界面组件的操作委托给具体的操作系统GUI相关的API去完成，所以不同的操作系统生成的界面外观和感官是不同的。\nSwing：Sun推出的GUI组件，属于轻量级，可以屏蔽掉操作系统实现的细节。\nAWT中所有的容器类都继承与java.awt.Container，主要包含Window和Panel两个子类。Window主要包含Frame和Dialog框架类，是顶级窗口容器，相当于图形界面程序的最外层。Panel主要是包含各种组件面板容器（所有组件必须包含到一个容器中），并且Panel无法单独显示，必须添加到一个容器中。每个Panel都有自己的布局管理器，即使是添加到其他Panel中的Panel。\n布局管理器：能够根据相应布局管理器的规则自动管理容器中组件的大小和位置，通过setLayout（）设置容器的布局管理器。使用布局管理器后，容器中组件的setLocation（）、setSize（）、setBounds（）方法的设置都会被屏蔽。\nFrame必须设置setVisible（Boolean bool）方法为true，窗口程序才可见。Frame的pack（）方法调用后会以正常显示Frame内所有组件最佳的比例显示窗口。\nBorderLayout布局管理器：将组件分为东南西北中五个区域，是Frame默认的布局管理器。其中每个区域只能加入一个组件，如果加入过个组件，则后加入的组件会覆盖之前的组件。当容器发生大小变换的时候，南北区域只能在水平方向上缩放，东西区域只能在垂直方向上缩放，中间区域可再垂直方向和水平方向上一起缩放。当一个区域没有填充组件的时候，其他区域会自动延伸。\nFlowLayout布局管理器：流布局管理器，Panel默认的布局管理器，将组件按顺序排列，默认是按行排列，不会改变组件大小，但是当一行容不下所有组件时，会自动换行。\nGridLayout布局管理器：网格布局管理器，组件按行从左到右添加，行满换行继续添加。一个组件可以跨越多个网格。\nCardLayout布局管理器：将界面看做一系列卡片的布局，并且在一个时刻只能显示一个卡片的内容，使用show（）方法切换卡片。\n事件模型包括：事件（事件也是一个对象，集成了相关事件的信息，通过传递事件将事件信息给处理方法）、事件源、事件处理器（接收事件、解释事件并处理用户交互的方法）。\nJDK1.0的事件模型是层次模型，事件产生后会在产生事件的组件类处理，如果处理不了则会由包含组件的容器处理器，知道到Frame也无法处理的话，则不处理。这种模型的弊端是会造成事件处理方法的混乱，很难辨清事件到底会在哪里被处理，故从JDK1.1开始不再使用这种事件模型，而是委托模型，将事件处理委托给指定的监听器处理，一个组件的某个事件对应一个监听器，如果没有对应的监听器则不会由上层容器的监听器处理，即不会处理这个事件。\n典型的事件类型：MouseEvent（鼠标事件，包含了关于鼠标位置等鼠标操作信息）、WindowEvent（窗口事件，包含窗口关闭等窗口操作信息）、ActionEvent（动作事件，包含相应组件基本操作的信息）。\n委托模型的处理过程：当一个组件产生一个事件后，该组件对应这个事件所注册的监听器addXxxListener（XxxListener l)，即参数XxxListener e（一般XxxListener是一个接口，使用的时候需要使用该接口的实现类）的事件处理器方法处理事件。以Button为例，单击Button后产生一个ActionEvent事件，ActionEvent事件会传递给被其注册的所有ActionListener（Button的addActionEListener（）所注册）的actionPerformed（ActionEvent e）方法接收，并执行这个方法。\nActionEvent类的getActionCommand（）方法可放回与动作相关联的命令名称，比如Button返回的Button的标签名。另外，该类中还有方法getWhen（）返回发生该事件的事件。\n委托模型使用步骤： 1）编写监听器XxxListener中相关事件处理方法：一般AWT提供相应监听器XxxListener接口，事件的处理方法需要自定义监听器类实现这个接口，并重写这个接口中所有方法（可通过JDK帮助文档获得接口中所有的方法），把事件的处理代码放置到重写的方法中。特别的，JDK提供了适配器Adapter，Adapter适配器是实现了一个或多个接口的类，但是实现的接口方法体为空，什么事情也不做。JDK中提供了大量事件监听器接口的适配器XxxAdapter，因此，只要继承相应监听器适配器，就可以只重写监听器接口中需要用到的几个方法，以提升开发效率（如果自定义的监听器已经继承了其他类，那么只能实现接口这种方法）。 2）为组件注册相应的监听器：可通过查询JDK文档得知该组件能够注册的监听器类型的方法。一般注册方法的格式为addXxxListener（XxxListener l），只要将自定义的监听器实例引用作为该方法参数即可向该组件注册监听器。同一个组件可以注册多个XxxListener类型的监听器。 3）当组件接收到相应操作产生相应事件后，会根据该组件注册的监听器匹配处理该事件的监听器，并将事件对象发送给注册的处理这个事件类型的所有监听器，存在次事件的多个监听器时，它们都会接收到事件和执行处理。 4）特别的，经常将步骤1和2合并，使用内部类监听器作为addXxxListener（）的参数。\nInput is evil！\n观察者模式（Observer）：该模式定义了一种一对多的依赖关系，使多个观察者对象同时监听某一个主题对象。只要主题对象在状态上发生了变化，主题对象就会通知所有的观察者对象，让它们更新自己的状态。\n观察者模式的组成： 1）抽象主题角色：主题角色之所以能被观察者角色监听，原因在于主题角色中存在一个保存了该主题角色对所有观察者对象的应用的集合。抽象主题角色一般是一个抽象类或者接口，并且至少要提供增加或删除观察者角色对象应用的方法，以及通知观察者对象主题角色状态发生改变的方法。 2）具体主题角色：是抽象主题角色的子类或者实现对象，具体包含了一个或多个观察者类型的集合，并且实现了抽象主题角色中的方法，同时也具有具体自我特征的成员变量和方法。 3）抽象观察者角色：一般也是一个接口，定义了更新自己的方法以供主题角色的通知观察者方法调用。 4）具体观察者角色：实现抽象观察者角色接口的类，实现了具体供主题角色通知方法调用的更新自己状态的方法，以便与主题角色状态相协调。在需要的情况下，还可以保存一个指向具体主题角色的引用。\n观察者模式的基本使用步骤： 1）定义抽象主题角色和抽象观察者角色：一般都是接口。抽象主题角色添加或删除观察者角色方法的参数类型是观察者接口类型；它的通知观察者方法参数一般是一个对象（在事件处理机制中，一般是一个事件对象），并且会调用观察者接口中更改观察者状态的方法。抽象观察者角色更改自己状态方法的参数一般是抽象主题角色通知方法的参数类型。 2）定义具体主题角色和具体观察者角色：都是实现了抽象主题或观察者的类。具体主题角色类中要定义抽象观察者类型的集合，增加或删除观察者方法负责把参数观察者添加或删除到集合中；通知观察者的方法中要遍历每一个集合，调用每个集合中元素及观察者类的更改自己状态的方法。观察者类中要具体实现更改自己状态的方法。 3）new具体主题角色类和具体观察者类，使用主题角色的添加观察者方法添加观察者对象（也就是常说的注册观察者）。\n观察者模式运行过程：当部署好主题角色和观察者角色后，一旦主题角色触发通知观察者的方法（可以是主题角色对象显示调用，或者是主题角色上定义了某些操作可以调用这个方法），观察者的更改自己的状态方法就会被调用。由此，实现了多个观察者对主题角色对象的依赖关系。\nGUI程序的事件机制实质上就是观察者模式的运用，其中每个组件是一个具体主题对象，每个监听器是一个具体观察者对象。一旦某些操作触发了组件，底层实质是调用了通知观察者方法通知注册到组件上的每一个监听器，让它们调用更改自己状态的方法，而实现了事件处理。\n2012-07-28# Swing组件主要存放于Javax.swing和Javax.swing.event两个包中。\nSwing的三个顶层容器：JFrame、JDialog、JApplet。每一个顶层容器都默认包含一个content pane，用于包含顶层容器中所有的组件，但是不包括菜单。也就是说，顶层容器主要包括两个元素：content pane和菜单。\n菜单的三级元素：MenuBar、Menu、MenuItem。\nSwing提供的便捷关闭方法：Frame.setDefaultCloseOperation（JFrame.EXIT_ON_CLOSE）。\nJDK对观察者模式提供了内置的支持：JDK提供了java.util.Observable主题类和Observer抽象观察者接口。\nObservable主题类：该类提供了主题类应该具有的所有方法，类中存在保存Observer接口类型的观察者Vector集合。定义的主要方法有：addObserver（Observer o），当o与已有的观察者对象不同时，向集合中添加；deleteObserver（Observer o），向集合中删除观察者o；setChanged（），当主题类状态发生改变时，通过该方法记录已经发生了改变；notifyObservers（Object arg），通知所有观察者主题对象状态发生改变，会调用每个观察者对象中的update方法，并将参数arg传递过去。前提是Observable状态发生了改变，因为notifyObservers方法体中存在if语句判断状态改变常量changed是否为true，true的时候才会调用观察者中的update（如果changed为true，那么if的else最后会调用clearChange方法将changed改回false）。因此，在调用notifyObservers之前必须调用setchanged才会执行观察者中的update。\nObserver观察者接口：接口中只定义了一个方法update（Observable o，Object arg），具体的观察者需要实现这个接口。当主题类Observable的notifyObservers方法被调用时，会调用观察者这个update方法，其中o是观察者观察的主题对象，arg是被观察主题对象notifyObservers方法传递过来的参数。update实现对观察者自身状态的修改，以协调主题对象状态的改变。\n内部类：一般的类都是定义在package下，属于package级别类；而内部类是定义在类或方法内部的类。内部类分四种类型：静态内部类、成员内部类、局部内部类、匿名内部类。\n静态内部类：定义在类内部，并且被static修饰，可以访问外部类的静态成员变量和静态方法。\n静态内部类相当于外部类的一个静态成员变量，属于类的静态成员，只是这个成员是外部类内部自己定义的一个类。在外部类的内部使用静态内部类，可以直接像使用普通类的方法使用静态内部类即可。在外部类外部，由于静态内部类类似于外部类的静态成员，所以外部类外部使用静态内部类与使用外部类静态成员方法相同，格式为“外部类名.静态内部类名”，也可以看做静态内部类的实际类名为“外部类名.静态内部类名”。因此，在外部类外部构造静态内部类实例，使用“new 外部类名.静态内部类名()”格式构造（括号内参数由静态内部类的构造方法决定）。 对于静态内部类使用外部类静态成员变量和方法，只要外部类存在该静态成员和方法，在静态内部类中就可以直接调用。但如果静态内部类内部存在和外部类相同名字的静态成员变量和方法，则根据java的就近原则，静态内部类使用的是静态内部类的静态成员变量和方法。要是非得使用外部类的静态成员变量和方法，则需要在变量名和方法名前加“外部类名.”前缀来强制使用外部类的静态成员变量和方法。 含有静态内部类的类编译后，除了生成外部类的class文件之外，同样会生成静态内部类的class文件，文件名为“外部类名$静态内部类名.class”。 成员内部类：定义在类内部，与静态内部类的区别在于少了static修饰，可以访问外部类的任何成员变量和方法。\n成员内部类，相当于外部类的一个成员，只是这个成员是由外部类中自己定义的类。在外部类内部，可以像使用普通类的方法直接使用成员内部类（构造的时候，new 内部类名的new前默认存在“this.”)。在外部类外部，由于成员内部类相当于外部类的一个成员，而访问类的成员必须通过类对象访问。所以要先构造一个外部类对象才可以构造一个成员内部类的对象。成员内部类的类名依然可以看做是“外部类名.成员内部类类名”，构造成员内部类的方法本质是：外部类名.成员内部类类名 成员内部类引用变量名 = 外部类对象.new 内部类名（）。通常的做法是：外部类名.成员内部类类名 成员内部类引用变量名 = new 外部类名（）.new 内部类名（）。 对于成员内部类使用外部类成员变量和方法，只要外部类存在该成员变量和方法，成员内部类就可以直接使用。如果成员内部类定义了和外部类成员变量和方法相同名称的变量和方法，那么根据java就近原则，成员内部类将使用自己的变量和方法。但要是非得使用外部类的变量和方法，则需要在变量名和方法名之前加前缀“外部类名.this.”以表示使用的是外部类变量和方法。 含有成员内部类的类编译后，同样除了生成外部类的class文件之外，也会以“外部类名$内部类名.class”的形式生成成员内部类的class文件。 局部内部类：定义在方法内部的类，只能访问方法中final修饰的变量，外部类外部无法访问到局部内部类，局部内部类是给方法是用的，一般很少是用局部内部类。\n局部内部类，相当于类的局部成员，存在于方法中，只能被方法使用。在方法中可以像普通类使用方法一样使用。 对于局部内部类使用方法中局部变量的方法，只要是方法中存在的final修饰的局部变量，局部内部类就可以直接使用。如果方法中存在final修饰的局部变量与局部内部类中的成员变量同名，则根据就近原则，局部内部类将访问到局部内部类自己的变量，并且此时没有方法访问方法的局部变量。如果局部内部类要访问外部类的成员变量和方法，同样可以使用“外部类名.this.”前缀加外部类成员变量或者方法访问到。 包含局部内部类的类编译后，除了生成外部类的class文件之外，同样也生成“外部类名$1局部内部类名.class”的局部内部类class文件（相比前两种内部类class文件，文件名$之后多了“1”）。 匿名内部类：定义在方法内部，没有类名，没有构造方法，不需要class关键字定义，只能访问方法中final修饰的局部变量，可以说是局部类的变形，是一种比较常用的内部类，比如事件机制中的监听器常用匿名内部类定义。\n匿名内部类的使用：匿名内部类默认要继承一个类或者实现一个接口，使用“new + 默认要继承的类名或者接口名(参数由继承的类或实现的接口构造方法决定){匿名内部类代码}”的方式定义并构造一个匿名内部类对象。 同局部内部类一致，只能访问方法中final修饰的局部变量，如果局部变量名与匿名内部类变量名相同，根据就近原则使用匿名内部类变量。如果要使用外部类变量，同样加前缀“外部类名.this.”。 包含匿名内部类的类编译后，除了生成外部类的class文件之外，也同时也生成内部类“外部类名$+阿拉伯数字.class”的class文件，$后的阿拉伯数字由1向上递增。 ","date":"June 2, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%85%AB%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"AWT","url":"https://www.qinxiandiqi.sbs/tags/awt/"},{"title":"Swing","url":"https://www.qinxiandiqi.sbs/tags/swing/"},{"title":"Java内部类","url":"https://www.qinxiandiqi.sbs/tags/java%E5%86%85%E9%83%A8%E7%B1%BB/"}],"title":"JavaSE学习笔记 第八记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-25# 每一个动态代理类都对应一个动态调用处理器InvocationHandler，因为动态代理类不具备方法的实现，动态代理类的方法依赖于动态调用处理器InvocationHandler的invoke方法来实现。\n静态代理的真实类和代理类关系是：真实类和代理类都是抽象角色的子类或者实现，并且代理类含有真实类的引用，通过代理类操作真实类。而策略模式对抽象角色子类的使用都是通过抽象角色来使用，策略模式的子类之间不能互相使用，因为一个子类没有包含另一个子类的引用。\n动态代理的真实类和代理类关系与静态代理的真实类和代理类关系类似，区别在于动态类的定义和实现逻辑与静态代理类不同。静态代理每一个真实类都必须手动定义一个代理类，并且每一个静态代理类中都必须重写真实类中的每一个方法（即抽象角色中的方法），这么一来，一旦真实类的数量多起来，需要手动定义的类数量将急剧上升，造成类数量的臃肿。而动态代理类的实现是通过InvocationHandler动态调用管理器和Proxy类在运行时动态定义和构造，定义一个包含Object引用变量的InvocationHandler实现类，就可以动态定义和构造任意真实类的代理，并且由于动态代理类的方法实现是交付给InvocationHandler的invoke方法实现，而InvocationHandler的invoke方法又是由这个方法中接收的参数method的invoke实现，所以动态代理类不需要对应真实类的每一个方法重写，一律使用InvocationHandler的invoke动态实现真实类方法的重写和调用。如此一来，动态代理的好处就是不用手动定义每一个代理类和代理类中的方法，被代理的独享可以在运行时动态改变，动态代理类实现的接口也可以在运行时改变，从而实现了灵活的动态代理关系，降低了定义类的数量。\nJava Annotation：Java注解，JDK1.5新增的特性。\nJDK1.5提供的三个常用注解：\n@Override（位于java.lang.Override），只能注解方法，在方法定义前使用该注解表示这个方法必须重写一个父类或接口的方法，如果没有则编译不通过，该注解可达到在编译时检查有无重写方法的作用。 @Deprecated（位于java.lang.Deprecated），在方法定义前使用该注解表示该方法不建议被使用（一般是有更好的替代方法，或者该方法不够安全），注解后该方法名会被删除线划上，并且在调用该方法时会有不建议使用的警告。 @SuppressWarnings（String[]）（位于java.lang.SuppressWarning），可注解除了注解类型之外的其它所有类型，接收一个字符串数组，可注解一个类或者方法。注解的功能由接收的字符串数组决定，常用的参数有“unchecked”表示压制检查警告，“Deprecated”表示压制使用不建议使用方法警告等等。当一个类被一个@SuppressWranings注解后，类中每一个方法都默认被这个注解注解，当类中方法还被自己的注解注解时，这个方法同时被两个注解注解。 定义自己的注解类型：与定义接口类似，但是使用@Interface标志代替Interface，如public @Interface MyAnnotation{注解内容}。\n当自定义注解中包含定义属性时，要在属性名后加（），如“public String value（）；”，否则编译错误。如果要设定注解的默认值，要在属性名的()后使用“default + 属性值”的方式设置属性的默认值。\n使用带属性的自定义注解时，要在注解名后加（），并在括号内传递注解属性值，如@MyAnnotation（“myAnnotation”）。同时，若注解的属性名为value时，使用注解的括号内可直接写属性值，否则必须使用name=value的形式对应传递注解的属性参数，当属性有多个的时候，按照这个形式用逗号隔开就可以。\n自定义注解的方法只有使用@Interface一种，使用这个方法自定义的注解编译器默认会继承java.lang.annotation.Annotation接口。但是如果手动写一个接口继承这个java.lang.annotation.Annotation，这个接口也不是注解，就算是原来的这个java.lang.annotation.Annotation接口也不是一个注解。\n如果自定义的注解与使用注解的类不在同一个包中，那么同样需要把包含注解的包导入到使用注解的类中，导入方法与导入类包的方法相同。\n自定义的注解不能继承其它的Annotation类型（其它已定义的注解）或者接口，但是可以使用其它已定义的注解来注解自定义的注解。\n注解@Retention（位于java.lang.annotation.Retention):，只能用于注解注解类型，使用@Retention注解自定义注解类型可以告知编译器如何处理自定义的注解类型信息。\n枚举类型RetentionPolicy（位于java.lang.annotation.RetentionPolicy）：包含三个枚举常量SOURCE、CLASS、RUNTIME。SOURCE常量表示编译程序只在编译时使用注解信息，但不将注解信息保存到class文件中，所以不会在JVM中被读取；CLASS枚举常量表示编译器会在编译的时候使用注解信息，并且会将注解信息保存到class文件中，但是在VM加载class文件时不读取；RUNTIME枚举常量表示编译器在编译时会使用注解信息，并且会将注解信息保存到class文件中，在JVM运行时加载class文件会通过反射机制的API获取注解信息。\n@Retention注解中包含一个RetentionPolicy枚举类型的属性（属性名为value，所以使用这个注解时可以直接传递参数），并且属性值默认是CLASS枚举常量。通过使用@Retention注解并制定其枚举常量来注解自定义注解类型，以此达到控制编译器处理自定义注解类型信息方法的目的。\n通过实现反射机制的相关类获取@Retention（RetentionPolicy.RUNTIME）注解的注解类型信息：实现反射机制的相关类Class、Method、Constructor、Field、Package等都直接或间接实现了AnnotatedElement接口，AnnotatedElement接口中提供了四个与Annotation相关的方法。因此，使用反射机制的相关类调用实现了的AnnotatedElement接口方法，可以获得该反射相关类代表的部分上是否存在@Retention（RetentionPolicy.RUNTIME）注解的注解类型以及其注解信息。\nAnnotatedElement接口四个方法：\n\u0026lt;T extends Annotation\u0026gt; getAnnotation(Class\u0026lt;T\u0026gt; annotationClass\u0026gt;，如果存在annotationClass（该参数为注解的.class）注解类型的注解，则返回这个注解。 Annotation[] getAnnotations（），如果存在注解则以注解数组形式全部返回。 Annotation[] getDeclaredAnnotations()返回直接存在于此元素上的所有注释。 boolean isAnnotationPresent\u0026lt;Class\u0026lt;? extends Annotation\u0026raquo;，接收一个Annotation类型，如果该元素上存在这个Annotation注解类型，则返回true，否则返回false。 通过反射机制相关类获取注解引用变量后，可以利用这注解引用变量获取该注解中属性的值，获取方法为“注解引用变量.注解属性名()”，与对象获取属性值的方法后多加一个括号。\n注解@Target（ElementType[]），只能用于注解其它注解类型，接收一个ElementType枚举常量数组，表示被注解的注解类型能用于注解什么元素，由ElementType数组值决定。\nElementType枚举类型常量值：ANNOTATION_TYPE（只能注解注解类型）、CONSTRUCTOR（注解构造方法）、FIELD（注解属性）、LOCAL_VARIABLE（注解局部变量）、METHOD（注解方法）、PACKAGE（注解包）、PARAMETER（注解参数）、TYPE（注解类、接口、注解类型、枚举声明）。\n@Documented只能用于注解注解类型，被它注解的注解类型所注解的元素在生成JavaDoc帮助文档的时候，会在相应元素上显示这个注解类型。如果没有使用@Documented注解的注解类型在生成JavaDoc帮助文档的时候不会保存到文档上。\nEclipse生成JavaDoc方法：Project-Generation Javadoc\n@Inherited注解只能注解注解类型，当一个元素被它注解的注解类型注解后，继承该元素的元素能够被继承这个注解类型，反之则不会继承。\n2012-07-26# JUnit：Java单元测试，经典版本有JUnit3.8（完全基于反射机制设计）和JUnit4.x（基于反射机制和注解设计）\n使用JUnit需要导入JUnit库（JUnit.jar）。\n使用JUnit3.8的类需要导入包import junit.framework.TestCase，并且使用的类需要继承TestCase类，同时需要进行单元测试的方法名必须以test开头，如果不以test开头则进行JUnit测试的时候不会测试这个方法。\n使用JUnit4.x的类需要导入包org.junit.Test，并且在需要测试的方法前添加注解@Test，那么使用JUnit测试的时候就会测试这个方法，否则不会测试。\nJUnit原理（执行步骤）：\n先获得需要测试类的Class对象。 通过Class对象获取测试类中所有public类型方法的Method数组。 遍历Method数组，取出每一个Method对象。 如果是JUnit3.8，则判断Method对象对应的方法名是否是test开头，是则执行这个方法，否则不执行；如果是JUnit4，则会调用每一个Method对象的isAnnotationPresent（Test.class），判断方法是否被@Test注解，是则调用method.invoke（）执行该方法，否则什么都不做。 异常类：java.lang.Exception，java中所有的异常类都直接或间接的继承Exception。\n异常和错误：即Exception和java.lang.Error，它们都继承与java.lang.Throwable类，Exception异常是指可以处理的程序错误，而Error错误是不可处理的程序错误。\n运行时异常：也叫unchecked异常，java.lang.RuntimeException（直接继承Exception）或者直接及间接继承RuntimeException的异常，是运行期间抛出的异常，此类异常可以不必进行自行处理，JVM会自行处理，一般也不建议进行自行处理。\n非运行时异常：也叫checked异常，所有直接或间接继承Exception但非继承RuntimeException的异常都叫非运行时异常，此类异常必须自行进行异常处理，可以通过try-catch-finally处理，也可以使用throws处理。\n异常抛出的位置：\n当程序运行的代码行出现异常时，会自动生成相应的异常类并抛出。 new一个异常类，并使用throw关键字抛出。 处理异常的方法：\ntry{}catch（Exception e）{}finally{}： 将可能出现异常的代码放置到try后的{}代码块中，如果其中代码出现异常，则会在出现异常的代码行生成一个对应的异常对象并抛出和不再执行try中出现异常之后的代码。此时会按照catch排列顺序遍历try之后的catch（try之后可以跟多个catch，也可以将catch省略，但省略后必须跟finally），当其中一个catch参数异常类类型与抛出异常类类型符合时，则执行这个catch代码块中的方法。不存在抛出类型与所有catch不匹配的情况，因为若存在可能抛出的异常与所有catch不匹配时，程序在编译的时候根本不能编译通过。另外，匹配catch参数的时候也只会有一个catch匹配，因为每次最多只有一个异常抛出。特别的，由于匹配catch是按照前后顺序匹配，如果多个catch的异常参数类型中存在继承关系，那么必须要将父类异常类型参数的catch排在子类catch之后，否则子类catch异常将永远没有机会调用，编译时不能通过并会提示子类catch无法到达，而没有继承关系的catch则先后顺序没有关系。try-catch之后，无论异常是否处理，都会执行finally中的代码，即使是try代码块中存在return，也会在return语句调用之前先执行finally代码块。但是如果try代码块中存在System.exit（0）语句，则不会执行finally代码块，因为exit（0）是结束JVM的语句。整个try-catch-finally执行完毕后，会继续执行这个处理结构之后的代码（如果处理结构中没有catch则不会执行结构之后的代码）。注：一般不将声明变量的代码放置到try代码块中，如果在try代码快中声明变量，那么在try-catch-finally结构之外使用声明的变量将会出现编译错误。 定义类时使用throws抛出相应异常：如果定义一个类的时候，类中代码可能抛出异常，可以在定义类的参数列表括号后使用“throws+对应异常类[,对应异常类]”来将异常抛出但是不处理这个异常。处理异常的方法在于调用该类方法的方法中，要用try-catch-finally结构处理，如果调用该类方法的方法没有处理，继续使用throws将异常抛出到上一级调用方法。如果都没有提供处理方法，继续用throws抛出知道main方法都继续throws，那么这个异常会JVM处理。 try-catch-finally结构和throws组合：在catch代码块中再使用throw抛出一个异常，并用throws将异常抛到方法外。这种做法通常用于捕获代码自动生成的异常，并将这个异常重新包装成自定义的异常类，再以自定义的异常类抛出去处理，有利于形成具有特定处理信息的异常类。 常见的运行时异常：NullPointerException，空指针异常，由于调用了某个对象的方法，但是该对象引用的值为null所导致。\n自定义异常类需要继承一个异常类，一般是Exception，也有继承RuntimeException，但比较少。Exception中含有一个带参数的构造方法Exception（String str），str为异常的描述信息，使用Exception继承的printStackTrace（）方法可以打印出异常描述信息和异常出现位置（JVM处理异常一般也是调用这个方法）。\n使用自定义异常类的方法通常是利用一些判断结构，如if结构，在判断出出现自定义异常的地方使用new，构造一个自定义异常类，并用throw将其抛出，同时在该方法声明后面使用throws抛出。之后处理自定义的方法与其他异常类的处理方法一致。\n","date":"June 1, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%83%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"Java注解","url":"https://www.qinxiandiqi.sbs/tags/java%E6%B3%A8%E8%A7%A3/"},{"title":"Java异常","url":"https://www.qinxiandiqi.sbs/tags/java%E5%BC%82%E5%B8%B8/"},{"title":"JUnit","url":"https://www.qinxiandiqi.sbs/tags/junit/"}],"title":"JavaSE学习笔记 第七记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-23# 枚举类型(JDK1.5增加的新特性）：严格来说并不是类，但是具有跟类相同的级别。类似于类定义，使用与类class相同级别的关键字enum来定义枚举类型，例如：public enum Color{RED, BLUE}。可以单独用一个java源文件定义一个枚举类型。定义声明之后，使用枚举的方法都与类的使用方法一致。\n枚举类型提供了两个静态方法：values()和valueOf()。values()返回枚举类型的数据数组。valueOf()方法将一个与成员变量名称相同的字符串自动转换成对应的枚举成员。\n枚举类型的本质是一个继承java.lang.Enum的类，枚举类型的每一个枚举成员实质上就是一个枚举类，并且这个枚举成员是final和static以及public修饰的，所以枚举成员可以直接用“枚举类型.成员”使用。从本质上，在枚举类中照样可以定义普通类成员变量和方法，包括构造方法，一旦定义了构造方法，那么定义枚举成员的时候也要使用构造方法的形式（本质是构造枚举对象）。而且，枚举类型中的成员（类）不同于普通类，它们是在编译的时候直接生成，编译后在运行时不能再改变，也就是说在编译后枚举类型就已经完全确定下来了。\nJDK1.5增加了类似C语言的格式化输出，System.out.printf(\u0026quot;%d,%s\u0026quot;,a,b)。\n泛型EnumSet集合，只能接收Enum类或者其子类的类型参数，如：EnumSet\u0026lt;Color\u0026gt;。向EnumSet枚举集合添加元素可使用of(element)，of的参数列表element只能接收对应枚举类的枚举成员。EnumSet的complementOf(EnumSet enumset)方法返回接收的枚举类型中除了enumset包含的枚举成员之外的枚举成员集合。EnumSet的noneOf(Enum)方法创建一个空的Enum枚举类型的集合，使用add方法添加的时候只能添加Enum枚举类型的成员。\n普通的集合同样可以将枚举类型当成类型参数接收。\n静态导入（JDK1.5增加新特性）：使用import static导入其他包内的静态成员变量或者静态方法，路径要一直指定到具体的静态成员和静态方法上，那么在使用的时候可以直接使用不需要具体类名.成员。与普通import的区别在于普通导入的路径指定到具体类就可以了，静态导入要一直指定到成员和方法上，并且只能导入静态的成员变量和方法，另外静态导入使用时无需写具体类名。\njava的反射机制：使用new构造类实例和通过类调用类的方法等过程，在编译器编译的时候就已经知道会构造类或使用类的方法，但是反射机制不一样，反射机制强调是在运行时动态创建类对象和动态调用类方法，也就是说，编译时并不知道要创建什么类，调用什么类方法，直到运行时才能知道代码要创建类或调用类。通过反射机制，能够调用类的私有成员和方法。\n反射机制主要通过5个类来实现：\nClass\u0026lt;T\u0026gt;类，位于java.lang包中，代表了一个类，每一个类中都已有一个成员变量class保存该类所属的Class类，一个程序中的多个同类型对象都共享同一个Class。 Field类，位于java.lang.reflect包中，代表该类的成员变量，在反射机制中使用类的成员变量需要通过Field类使用。 Method类，位于java.lang.reflect包中，代表类的方法，在反射机制中使用类的方法需要通过Method类使用。 Constructor类，位于java.lang.reflect包中，代表类的构造方法，在反射机制中通过该类使用类的构造方法。 Array类，位于java.lang.reflect包中，提供了动态创建数组，以及访问数组元素的静态方法。 动态机制之所以能够在运行时实现，在于这五个类提供动态实现的方法，在运用动态机制的时候，必须通过以上五个类来间接操作。 反射机制的相关使用过程：\n首先要获取一个类的Class，Class类中提供了一个static方法forName（String）方法，参数为要获取具体的类完整类名，能够返回要获取具体类的Class，如Class classType = Class.forName(\u0026ldquo;java.lang.Object\u0026rdquo;)；另一种获取Class的方法是通过每一个类的都具有的成员变量class，直接从“类名.class”中获取；还有一种方法是利用从Object类继承下来的final方法getClass()方法返回调用该方法对象的Class，此方法需要用对象调用。 反射机制创建类实例，Class类中提供了方法newInstance()借用该Class对应类中不带参数的构造方法创建类实例，并返回对象引用。如果要使用带参数列表的构造方法，则需要借助Constructor的newInstance（Object\u0026hellip;）方法——首先利用Class的getConstructor(Class\u0026hellip;)方法获取带相应参数构造方法的Constructor（通常用Class[]数组做参数，如果是使用不带参数构造方法，要传递Class[]{}空数组），再利用该Constructor的newInstance（Object\u0026lt;T\u0026gt;\u0026hellip;）构造新实例（通常newInstance参数为Object数组，即使是不带参数也要使用空Object[]{}数组表示空），需要注意的是可变参数数组的元素要前后对应。 反射机制使用类成员变量，通过Field获取。Class提供了getDeclaredFields()返回代表所有成员变量的Field[]数组，或者通过getDeclaredField(String）返回指定变量名的Field对象。Field的方法getName()可以返回该Field代表成员变量的名称。 反射机制使用类方法，通过获取Method操作，Class类中提供了getDeclaredMethod()方法获取该类中所有方法的数组，即返回值为Method[]；Class提供的getMethod(String，Class\u0026hellip;)接收一个方法名字符串和可变参数Class（可变参数接收多个Class，通常用Class[]数组传递），可以返回一个方法名为String，参数为Class\u0026hellip;的Method。获取Method对象后，Method类中提供了方法invoke(String，Object\u0026hellip;)，String表示调用的是哪个对象，Object\u0026hellip;可变参数接收一个或多个Object类型参数（通常以Object数组传递），返回值是一个Object类型（具体使用返回值时可再强制转换）。 反射机制构造数组，通过Array的newInstance()方法。Array重载了两个newInstance静态方法，其中newInstance(Class\u0026lt;T\u0026gt; componentType,int length)构造一个一维数组，长度为length，元素类型为Class\u0026lt;T\u0026gt; componentType关联的类。如果创建的是多维数组，要使用newInstance(Class\u0026hellip; componeneType,int\u0026hellip; dimensions)，componentType表示数组的比较类型对应的Class（已知数组可通过Class的getComponentType()返回该数组的比较类型，实际也就是数组的元素类型，三维数组的比较类型是二维数组，二维数组的比较类型是一维数组，不是数组的比较类型为null），dimensions使用散列int或者int数组表示多维数组各维度的长度（从左到右为高维度到低维度）。Array的get(array，int\u0026hellip;)方法可获取数组array对应维度的值。 Class对象在构造该类的实例之前就已经存在，一个Class对象是JVM在加载一个类的时候自动创建的，里面包含了该类的所有信息，包括成员变量和方法，是java语言至关重要的类。\n原生数据类型的包装类.TYPE返回的是包装类对应的原生数据类型，.class返回的是class+包装类的完整类名。\n2012-07-24# Class中getDeclaredXxx与getXxx的区别：getXxx只能返回public修饰的成员变量和方法，getDeclaredXxx可以返回任意修饰符修饰的变量和方法。反射机制可以破坏类的封装性，使用类的私有成员和私有方法，此时要使用getDeclaredXxx获取相应的Method、Field、Constructor才有可能。\nMethod、Field、Constructor都继承于AccessibleObject，该类中提供了一个方法setAccessible（boolean），当boolean为true时，表示强制取消检查访问限制，当boolean为false时，则正常检查访问限制。只有通过setAccessible()设置为true取消访问检查，才有可能破坏类的封装性，使用类的私有成员和私有方法。\n类中定义的set和get方法，本质上也是使用反射机制才有可能实现。\nField中的set（Object obj，Object value）可以设置对象obj中该Field关联的成员变量值为value。如果是私有成员，也需要先用setAccessible（true）强制取消访问权限检查才可实现。\nnative修饰的方法表示本地方法，即不是使用java来实现，而是由C或C++来实现。\nClass的构造方法为private修饰，所以Class不能手动创建。\n类调用类对象的getSuperclass可以获取父类的Class。\n代理模式：为其它对象提供一个代理以控制这个对象的访问，代理相当于客户端与目标对象之间的中介，并带有自己附加的一些功能。\n代理模式设计的角色：\n抽象角色：声明真实对象和代理对象的共同接口或抽象类。 真实角色：即真实对象，是代理角色所代表的对象，是客户端最终要 引用的对象。 代理角色：代理角色内部包含对真实对象的引用，从而能够操作真实对象。同时，代理对象提供与真实对象相同的接口以便能够在任何时刻代替真实对象和使用真实对象。并且，代理对象可以在执行真实对象操作的时候附加自己的操作，相当于代理对象是对真实对象的封装。 静态代理设计过程：\n定义抽象角色，一个真实对象和代理对象共同要实现的抽象类或者接口。 定义真实角色，也就是要被代理的类，此类要继承或实现抽象角色的抽象类或者接口，实现里面的抽象方法。 定义代理角色，也就代理类。此类也要继承或实现抽象角色的抽象类或接口，并且实现里面的抽象方法。同时，代理类中还要声明一个真实类的引用变量，并通过相关方法从外部传递一个真实类对象引用进来，或者代理类内部new一个真实类对象。另外，代理类中实现抽象类或者接口中的方法体中，利用代理类中的这个真实类对象引用调用真实类中相应的方法，也就是代理类的方法最终实现是由它代理的真实类的方法类实现，但是此时，在调用真实类的方法前后可以插入代理类自己的一些方法，完成捆绑代理类的一些操作。 客户端使用代理类操作真实类，可以使用抽象角色引用变量接收代理类对象引用，使用抽象角色中方法时，根据多态会调用代理类中的方法，而代理类中的方法由是对真实类中相应方法的封装，由此间接操纵了真实类。 动态代理需要java.lang.reflect包下的接口InvocationHandler和类Proxy来实现。\n动态代理实际过程：\n定义抽象角色，动态代理的抽象角色只能是一个接口，不能是抽象类。 定义真实角色，也就是被代理的类，要实现抽象角色接口中的方法。 定义实现InvocationHandler接口的类。动态代理中不再需要手动定义代理角色（代理类由运行过程中生成），但是将代理类需要包含的一个真实类对象引用变量转移到实现InvocationHandler的类中，所以这个实现InvocationHandler类要定义一个可以接收真实类对象引用的引用变量（一般是Object引用变量，这样就可以代理任意类型的真实类，动态代理的特点也就在于此，可以动态生成代理类，不需要每使用一个代理类就要定义一个代理类），并在构造方法或者定义其他方法给这个变量赋真实类对象引用值。其次，这个类中最重要的是实现InvocationHandler接口中的方法public Object invoke（Object obj，Method method，Object[] args），其中第一个参数一般是指调用该方法的代理类对象（一般情况下用不到），method是被代理的方法，args是被代理的方法的参数列表。动态代理的客户端运行代理类方法的时候，实际上使用的是这个类的invoke方法，invoke方法中接收的method参数是动态代理底层利用反射机制自动生成的被调用方法对应的Method对象，args参数是动态代理将被调用方法传递的参数组合起来的数组。因此，实现InvocationHandler接口的类中invoke方法要根据传回来的Method对象使用Method对象的invoke方法，所以Method的invoke方法要接收被调用对象（一般是本类InvocationHandler中接收真实类引用的成员变量，它通过它才能调用真实类的对应方法达到通过代理控制真实类的目的）和被调用方法的参数（本类invoke方法接收到的args参数），并且代理类方法中要附加自己的代码要插入到调用Method的invoke方法前后。 客户端动态生成代理类和构造代理类对象。动态代理的客户端要构造真实类对象和实现InvocationHandler接口的类对象，然后使用Proxy.newProxyInstance（ClassLoader loader，Class[] interfaces，InvocationHandler h）动态生成代理类（类名为“$Proxy+阿拉伯数字”）和代理类对象，并将生成的代理类对象返回（Object类型，使用时可以强制转换）。该方法中loader参数接收实现InvocationHandler类的类加载器ClassLoader，可以通过Class类的getClassLoader方法获得，可以使用真实类的ClassLoader或者实现InvocationHandler类的ClassLoader，一个类的ClassLoader可以装载很多类；第二个参数interfaces接收一个接口数组，自动生成的代理类会实现interfaces数组中所有的接口，一般要接收真实类实现的接口，因为代理类要实现与真实类的共同接口；第三个参数要接收InvocationHandler，也就是实现InvocationHandler接口的类，使用生成的代理类方法时，动态代理底层会传递参数h中的invoke方法所需要的参数，将代理类的方法实现转移给h中的invoke方法。 Proxy.newProxyInstance返回的代理类对象Object可以强制转换成接收的参数interfaces数组中的任意一种接口类型（多态特性，代理类是interfaces数组中所有接口的实现类），便可以调用强制转换后的接口中拥有的每一个方法，代理都会自动包装调用过程中的方法参数传递给InvocationHandler中的invoke，让invoke实现代理方法。 ","date":"October 14, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%85%AD%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"枚举","url":"https://www.qinxiandiqi.sbs/tags/%E6%9E%9A%E4%B8%BE/"},{"title":"反射","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%8D%E5%B0%84/"},{"title":"代理模式","url":"https://www.qinxiandiqi.sbs/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}],"title":"JavaSE学习笔记 第六记 —— 代理模式"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-21# Vector与ArrayList基本类似，不同的是Vector是同步的。HaseTable与HaseMap类似，只是HaseTable是同步的，不常用HaseTable，但常用HaseTable的子类Properties。\nProperties的键值通常为String，用于Java的属性配置。System.getProperties()可以发返回一个系统配置的Properties对象。\n泛型（JDK1.5新添加的特性，之前版本的编译器无法识别泛型）：将数据类型参数化，通常使用T作为数据类型的参数，可接受多个参数，编写泛型类的时候把T当成具体数据类型来使用就可以了。泛型适用于逻辑结构完全相同，只是数据类型不相同的情况，相当于泛型提供了一个逻辑结构模板，接收不同的数据类型后模板会转换为具体数据类型的逻辑结构。例如：class Test\u0026lt;T\u0026gt;，使用类Test的时候接收一个数据类型参数T，Test类内部将T当成一个具体的数据类型使用，此时Test就是一个处理T类型的类。泛型的好处是在编译的时候就能知道调用泛型类的接收类型，不使用泛型则编译的时候无法知道具体接收的是什么数据类型，只能在运行赋值的时候才能知道使用的具体类型。由此，泛型可以在编写代码的时候明确知道调用泛型类的具体类型，从而降低抛出类型转换错误的异常。\n所有的集合都使用泛型，构造集合的时候如果不传递泛型集合类要接收的具体数据类型，则默认接收的具体类型为Object，同时编译器会提出需要具体指定接收类型的警告，但能通过编译。传递了具体制定类型的泛型类只能接收制定类型的对象，否则编译不通过，所以当给集合类传递具体数据类型后，集合类只能接收和处理这种数据类型的对象。Java提倡使用集合类的时候传递具体的数据类型，默认的Object类型虽然可以接收各种类型对象，但是带来的问题是没法直接从集合中取出一个元素，要想做关于该元素的相关操作必须强制转换为该元素原有的数据类型，也就是说使用Object的时候必须知道集合中每一个元素的数据类型，一旦数据类型指派错误，就会抛出类型转换错误的异常。\n默认泛型类的类参数T可以接收各种数据类型，如果要限制T接收的数据类型，可以在T后面\u0026lt;\u0026gt;内部使用extends +只能接收的数据类型或者接口（无论限制的是类还是接口，规定一律使用extends），那么T只能接收extends该类型或接口，以及其子类，除此之外的其他类型都不能接收。默认情况下是T extends Object，所以使用泛型类的时候没有传递具体数据类型，则会默认接收Object类型。\n2012-07-22# 使用泛型的时候，一旦明确在声明泛型引用变量时的类型参数，那么声明的引用变量类型也就确定，不能指向其他类型参数的泛型。然而，可以只用通配符?声明可以指向多种类型参数的泛型引用变量。具体实现方法：在声明引用变量的时候，使用代替具体参数类型即可，则声明后的泛型引用变量可以指向任何泛型类型参数的对象。如果要限制引用变量指向的类型参数范围，可以使用实际是引用变量可以指向任何类型对象。特别的，一旦使用通配符定义的引用变量在赋予具体对象地址后，只能使用读取或者删除对象的数据而不能修改该对象。原因在于从java设计者的角度出发，一旦可以修改，那么程序运行时在使用该引用变量的数据时，必须知道该数据的具体类型然后强制转换过来，这种做法不符合泛型的思想，失去了泛型的意思，因此java规定使用通配符的泛型引用变量只能读取或删除对象数据，而不能修改。\n泛型同样可以被继承或用于接口，但是在继承泛型类或实现接口的时候必须同时继承类型参数，也就是说在子类或者实现类中必须也有父类或接口的类型参数，因为根据继承和实现的顺序原理，实现子类或接口时传递给父类或接口的类型参数只能从子类或实现类传入。\n遍历for循环（JDK1.5新增加特性），用于遍历数组或集合中的元素，for(type element：array){}。多维数组的遍历for循环需要使用多个遍历for循环嵌套使用，内嵌for中array使用上层element表示。\n自动装箱和自动拆箱：JDK1.5针对八种原生数据类型和包装类之间的自动转换提供的新特性，因此，在JDK1.5以后的版本中，可以直接将原生数据类型直接赋值给对应包装类，或者在需要原生数据类型的地方直接使用对应包装类的对象，JAVA会自动使用相应的valueOf方法转换后再使用。\nInteger包装类中存在一个长度为255的Cache数组，其中包含了数值在-128~127这255个Integer对象作为缓冲数组。当使用valueOf()方法时，如果数值在-128到127之间时，不会生成新的Integer对象，而是直接返回Cache数组中对应值对象的引用，所以，自动装箱形成的Integer对象数值只要在这个缓冲范围内，使用==比较的结果是true。另外，如果Integer对象是使用new构造的话，那么无论数值是否在缓冲范围内都将重新构造新的对象，与构造普通对象的过程一样，不受缓冲数组的影响。\n可变参数（JDK1.5新增加的特性）：方法的参数可以不明确指定有多少个，在调用的时候才能知道究竟有多少个参数。可变参数只能是同种类型的多个参数，并且可变参数只能出现方法参数列表的最后一个，使用时在参数类型后边加3个点，例如：void method（String str,int\u0026hellip; arr）{}。可变参数的实质是一个数组，调用带可变参数方法时，运行时会自动将参数转换为相关数组再传入方法中，所以调用带可变参数方法时的参数可使用离散参数，也可用数组参数，但是如果定义方法的时候使用数组做参数，调用方法时的参数也只能是数组。基于这个原因，为了能够知道调用方法时那些参数是要形成可变参数数组，所以决定了可变参数的位置只能在参数列表的最末尾，并且一个方法中最多只能有一个可变参数。\n","date":"October 10, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%94%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"泛型","url":"https://www.qinxiandiqi.sbs/tags/%E6%B3%9B%E5%9E%8B/"},{"title":"包装类","url":"https://www.qinxiandiqi.sbs/tags/%E5%8C%85%E8%A3%85%E7%B1%BB/"},{"title":"可变参数","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"}],"title":"Java SE 学习笔记 第五记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-19# java中的链表节点使用封装的类，节点类包括节点数据和前驱后继节点的引用，java中没有指针的概念，所以使用链表只能使用引用，也就是引用类型变量做“指针”。\nLinkedList链表的底层实现实质上是由数据类型为Object和前驱后继Entry引用变量组成的Entry节点类的双向链表，所以LinkedList链表可以添加任意类元素（Object的子类）。添加新元素的时候，LinkedList会将对象封装成Entry类实例后插入到LinkedList链表中。基于链表的特性，LinkedList无长度限制，添加删除链表节点会关系到节点上下引用值的改变。\nclass Entry{ Entry previous; Object element; Entry next; } JDK提供了Stack类和Queue接口，可以通过LinkedList类的方法构造Queue类。\nJava中的Set集合与数学意义上的集合是一致的，集合中不能有相同的元素。\nHaseSet中的元素没有顺序性，符合数学集合的无序性。使用add向HaseSet添加已存在元素会返回false，表明添加不成功。\nObject类的equals()方法的特点：\n自反性，x.equals(x)的值为true，x不为null； 对称性，x.equals(y)与y.equals(x)的值一致； 传递性，x.equals(y)的值为true，且y.equals(z)的值为true，则有x.equals(z)的值也为true； 一致性，只要x和y没有改变，无论调用多少次x.equals(y)，结果都不会改变； 对于非空引用x.equals(null)的结果必定为false。 Object类的haseCode()方法特点：\n在java引用的一次执行过程中，同一个对象只要没有修改，无论调用多少次haseCode()，返回值都相同； 如果两个对象用equals比较的结果为true，那么这两个对象的haseCode()返回值一致； 如果两个对象用equals比较的结果是false，那么这两个对象的haseCode()返回值可以相同，也可以不同，Java推荐使用不同值可以提高程序的性能； Object默认的haseCode()返回值是对象的地址，所以Object的haseCode()对于不同对象的返回值是不同的。 HaseSet集合不允许存在相同的元素是通过以下机制实现：当向HaseSet添加新元素的时候，HaseSet会首先调用要添加对象的hashCode()方法，并与HaseSet已存在元素的HaseCode进行比较，如果都不相同，则直接添加新元素进集合；如果HaseCode的比较结果存在相同的元素，则进一步调用equals比较要添加的元素和HaseCode相同的元素，equals的结果为true的话，则拒绝添加新的元素，若为false，则将新元素添加进HaseSet集合。因此，如果使用Object的hashCode()和equals()，添加内容相同的对象时，由于HaseCode值相同，所以即使对象内容相同也能一起添加进去。而对于重写了hashCode()和equals()方法的子类要根据具体重写的方法决定是否能添加进内容相同的对象，比如String类的hashCode()返回采用字符串的内容进行计算获得，所以内容相同的String对象的HaseCode值也相同，自然不能添加进HaseSet。\n一般重写equals()方法的时候，最好也重写hashCode()方法。在Eclipse里可以通过Source-Generate hashCode()和 equals()命令选择一定类属性自动重写hashCode()和equals()方法。\nHaseSet没有get方法，要想从HaseSet中取出元素，需要使用迭代器来使用。利用HaseSet的iterator()可以返回一个该HaseSet的迭代器，再使用循环结构配合iterator的hasNext()方法判断是否存在下一个元素和next()返回下一个元素，返回后hasNext位置会自动指向下一个元素。当然，由于HaseSet元素是无序的，所以返回的结果顺序不一定就是元素添加进HaseSet的顺序。\nSortedSet接口继承了Set接口，同样不能存在相同的元素，但是增加了排序功能，主要的实现类由TreeSet。\n向TreeSet添加元素的时候，TreeSet会根据元素自动升序排序添加，如果添加的元素无法与已存在元素进行比较，则会抛出类型转换异常。此时的解决方法可以是在构造TreeSet的时候使用带Comparator参数的构造方法，指定一个Comparator实现类，这个类里提供了元素之间比较的方法compara()。\n指定自定义Comparator的TreeSet构造方法为TreeSet（Comparator comparator），所以实现自定义排序方法，需要自定义实现Comparator接口的类，类中必须实现方法int comparator（Object arg0，Object arg1）（默认是arg0\u0026gt;arg1时返回整数，小于时返回负数，相等时返回0）。利用自定义的比较类，在TreeSet构造方法参数中new一个自定义的Comparator实现类实例就能创建按照自定义比较规则排序的TreeSet。默认的TreeSet使用升序排序，要修改为降序也要通过以上方法重新定义降序的Comparator实现类来完成。\n类似于Arrays类为数组提供了大量static操作方法，Collections类为集合提供了大量static操作方法，例如：reverseOrder()为目标集合返回一个与目标集合排序相反的Comparator；sort（Collection，Comparator）为集合Collection进行Comparator规则的排序；shuffle（List list）为列表List打算元素顺序；min()和max()获取集合中的最小和最大值。。。。方法详见JDK开发文档Collection类。\n2012-07-20# 映射Map是一个接口，元素是一对Key和Value对象，且不能存在相同的Key，一个Key最多映射到一个值上。\nHaseMap是Map接口常用的实现类，同样HaseMap中元素是无序的，用put向HaseMap添加元素，如果先后添加的元素Key值相同，则会修改原Key的Value，不会再添加一个元素。使用get(Key)获取HaseMap中Key的值。使用KeySet()方法可以获得HaseMap中Key的集合，并且返回的Set集合是由HaseMap维护的，即当HaseMap中Key发生变化会关联到Set中元素的变化，反过来也一样；使用value()可以返回HaseMap的Value集合Collection，同样返回的Collection也是由HaseMap维护的，值的改变会互相影响。之所以返回的Key集合用Set和Value用Collection，是因为Key在HaseMap中是唯一的，使用Set则不存在相同的元素，但是value却不一定是唯一，所以使用Collection。\nHaseMap每一对映射的实质在底层上就是一个HaseMap内部类Entry实例，Entry类封装了一对Key和Value，并提供了get和set方法。使用HaseMap的entry()方法可以返回HaseMap的Entry的Set集合，利用Set和Set的迭代器iterator可以遍历整个HaseMap。\nTreeMap类似于TreeSet，可以实现元素自动排序，默认的排序方法是根据Key进行升序排序。添加自定义排序方法的TreeMap与TreeSet类似。\n策略模式（Strategy Pattern）:策略模式的实现根据是多态。\n策略模式的组成有三大部分抽象策略角色（通常是接口或者抽象类）、具体策略角色（具体的实现接口或抽象类的实现类）、环境角色（即环境类，具有接口或者抽象类的引用作为环境类的成员变量，并且提供set和get设置接口或抽象类的方法，以及其他封装接口或者抽象类的方法，以供客户类使用）。\n策略模式的实现步骤分3步：1）编写抽象策略角色，一般是公共接口，设定接口的方法；2）编写具体策略角色，即策略类，封装相关算法和行为的接口实现方法；3）在环境角色即环境类中，保存一个接口的引用，并完成环境类的set和get或者构造方法，以对接口引用的赋值。\n策略模式的使用过程：定义了公共接口和相关接口的实现类，整个策略模式的关键在于环境类中保存的成员变量是接口的引用，而不是接口实现类的引用，并且环境类中所有需要接口做参数的方法，参数类型和方法中调用接口的方法都是依据接口的引用，而不是接口具体实现类的引用。由此，只要在客户类使用环境类的时候，为环境类的接口成员赋予具体的实现类引用，在环境类中，依据多态的特征，环境类就能知道将调用哪个具体实现类对接口的实现方法。也就是说，在客户类中，传入环境类中的具体实现类不同，环境类使用的方法过程不同，虽然方法名相同（实现接口的类中必须实现接口的方法）。\n策略模式的优点：策略模式中各个组成部分是弱连接的，只要接口类型不改变，各个组成部分中实现代码可以改变而不会影响其他部分。各个策略类实现接口的代码不同，环境类中使用的是接口的方法，而非具体实现类的方法，只要客户端传入具体实现类的引用，环境类就能根据多态知道使用的是哪个实现类的方法。好处是：环境类只需要根据接口引用和接口的方法名就能编写相应的业务逻辑方法，而只要传入的实现类引用不同，环境类的方法自然就变成了另一种业务逻辑，从而提升了软件的可重用性。\nHaseSet底层实质上是一个HaseMap，HaseSet中的元素实质上是HaseMap中的Key，而每一个Key的Value都是同一个Object，所以使用add向HaseSet中添加元素本质上是向HaseMap中put一个Key为HaseSet元素，值为一个final的Object元素。\nHase负载因子：表明达到负载因子比例的时候就认为哈希数组将近满，另外开辟一个更大的数组以满足要求。\nHaseMap的在底层上的实质是一个HaseMap内部类Entry的数组，HaseMap类内部有一个成员变量table就是一个HaseMap的Entry数组，使用默认HaseMap构造方法构造的HaseMapEntry数组长度为16，hase负载因子为0.75。并且，由于Entry类内部有一个成员变量next，可以指向一个Entry对象，所以table数组每个Entry元素实际上也是一个Entry链表。根据这个本质和Hase的特点，HaseMap就是一个封装了Entry数组的类，并且具有Hase数组元素添加方式的特征。\nHaseMap添加put新元素（一对键值，实质是一个Entry类对象）的过程本质：HaseMap根据新键值的Key的HaseCode和table数组的长度，通过Hase算法计算出新键值要添加进table数组的索引号。此时，HaseMap会判断该索引号位置上是否已经存在HaseMap元素，如果不存在，则直接将新键值（Entry）添加进table数组。如果该位置已经存在一个Entry，则HaseMap会遍历这个Entry链表，将添加的新Entry与链表上的每一个Entry进行equals比较。当链表上存在一个Entry比较后的返回值是true时，说明这个Entry的Key与将要添加的Entry的Key相同，根据HaseMap规则，HaseMap会取出原有Entry的Value返回，并将新添加的Entry的Value替换这个旧的Value。当遍历整个Entry链表后无true返回值，HaseMap则会为要添加的Entry调用addEntry方法，该方法会new一个新的Entry对象存放要添加的键值，并将这个新Entry的next指向原本该table数组位置上的Entry对象，再将这个新建的Entry对象插入到table数组这位置上，形成该位置上新的Entry链表，新的Entry对象为该链表的表头（之所以要将新Entry对象作为链表的表头，是因为操作系统认为刚使用的数据在不久的将来有很大的概率会再次使用，所以将新Entry对象作为表头可以提高效率）。 注：由于put新键值的数组位置是由Key根据Hase算法计算获得，所以Key值相同的键值获得的插入位置一定在同一个位置，因此只要遍历该位置上的Entry对象就能知道HaseMap中是否已经存在相同Key的键值。另外，同一个位置上的Entry链中可能存在不同的Key值，因为不同的Key值也可能得出相同的位置。\n","date":"October 9, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"Set","url":"https://www.qinxiandiqi.sbs/tags/set/"},{"title":"List","url":"https://www.qinxiandiqi.sbs/tags/list/"},{"title":"Map","url":"https://www.qinxiandiqi.sbs/tags/map/"},{"title":"Tree","url":"https://www.qinxiandiqi.sbs/tags/tree/"},{"title":"策略模式","url":"https://www.qinxiandiqi.sbs/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}],"title":"Java SE 学习笔记 第四记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-17# java.lang包在编译的时候会自动导入，无需显示导入。此包内包含object类还有一些常用类。\nObject的equals方法实质是判断两个引用值是否一致，相当于==，即两个对象是否是同一个对象。String的equals方法是比较两个字符串的每个字符是否一样，而不是两个字符串对象的引用值。\n“==”比较的是值，无论是原生数据类型还是对象引用都是比较值，只是对象引用的值是引用地址，因此比较的结果是同一个对象才会返回true。\nString是一种特殊的对象，除了可以用new创建新对象之外，还可以使用字面值直接创建新对象，字面值就是类似于原生数据类型一样赋值，如String string=\u0026ldquo;abc\u0026rdquo;，只有String可以使用字面值创建对象。并且，String字面量对象是一种常量对象，java通过字符串池来管理这些常量。当使用字面值创建对象后，字符串池内会创建相应的String对象，而且创建后的String内容不能再改变。因此，字符串池类会有很多不能再改变的字符串对象，如“abc”是不能再改变的，所以，当使用字面值创建String的时候，会先在字符串池内搜索是否存在要创建的字符串对象，如果存在则不用再创建，直接返回该对象的引用。也就是说，字符串池内的字符串对象只创建一次，并且创建后不能再改变值，可以供多个字符串引用使用。基于这个原理，当使用字面值创建相同内容的字符串对象时，用==比较这些对象的结果是true，因为它们的值都是字符串池中同个字符串对象的引用地址。而使用new创建的字符串对象不同，因为new是在堆中创建新对象，字符串池存在于栈中，new无论怎样都会在堆中创建新的对象，并返回对象的引用。如果字符串池中已经存在要创建的字符串，则new直接在堆中创建新对象；如果字符串池中不存在要创建的对象，则java会先在字符串池中创建要创建的字符创对象后，堆中也会创建这个要创建的对象，并返回堆中这个对象的引用。因此，即使String内容相同，但是不同对象引用地址不同，==比较的结果也是false。\nString的intern()方法，如“abc”.intern()，该方法会在字符串池中查询abc是否存在，如果不存在，则会在字符串池中创建abc对象，并返回字符串池中这个对象的引用，如果字符串池中已存在，则直接返回字符串池中这个对象的引用。因此，s.intern()==q.inern()为true的必要条件是s.equals(q)为true。\nString和StringBuffer的区别：String对象是常量，定义后值不能再改变；StringBuffer是变量对象，值可以修改，修改后StringBuffer引用变量还是指向原来的StringBuffer对象（String修改的实质是String引用变量指向一个新的String对象），常用append()方法追加字符，可以用toString()方法返回当前字符串内容。\n+号不能直接用于布尔值的拼接。\n字符串字面量的拼接，返回值也是字符串池中字面量的引用，如“abc”+“def”，返回的结果是字符串池中的“abcdef”引用；而字符串字面量和字符串引用变量的拼接，其过程是在堆中创建新的对象，返回值是堆中该对象的引用。\njava中对应8个原生数据类型，有8个包装类：Boolean、Integer、Short、Long、Byte、Float、Double、Character。\n数组是一种由相同类型的变量组成的集合的特殊类，类名为数组元素类型+[]（一个或多个），如int[]。创建数组相当于创建对象，用new创建，需指明数组的长度，特别的，可以{}指定数组元素的同时创建数组，此时不用指明数组的长度。每一个数组元素相当于数组对象的成员变量，而且数组含有一个final类型的public成员变量length，表示数组的长度。\n对于二维数组type[][]（行列），实质上相当于数组的数组，可以分隔为\u0026rsquo;type[]\u0026rsquo;[]：以type[]数组作为一维数组元素类型，type类型作为二维数组元素类型，分成两层形成最终复合二维数组，所以type表示的整个二维数组（值为地址，二维数值也是对象，其length值是二维数组中一维数组的个数），type[i]表示的是第i个一维数组（值为地址，因为数组是对象，其length值是第i个一维数组的长度）。二维数组每一行的列数可以不相同，也正是因为这个原因。类比二维数组，高维数组也遵循同样的道理。\n数组声明的元素的类型可以是interface，因为数组创建后的元素interface是引用类型，但是具体每个元素赋值时使用new的必须是interface的实现子类。\njava的java.util.Arrays类提供了各种静态数组辅助操作方法，包括数组比较，排序等，详见jdk文档。\n2012-07-18# java.lang.System类包含许多辅助方法，如数组拷贝方法arraycopy()。\n冒泡排序是交换排序的一种。\njava中约定常量命名规则：全部由大写字母组成，多个单词之间用下划线隔开。\n修饰常量成员常用final与static并用，因为final不允许修改，static为类常量，节省内存。\nEclipse中快捷键Alt+/，自动补充相关代码。Ctrl+/，自动注释掉光标所在行。Ctrl+D，删除光标所在行。将鼠标放置在一个类名上，再按Ctrl，类名将变成一个超链接指向定义该类的代码。\njava提供了集合的概念，集合也就是一堆元素的集合体。集合在java以接口的形式定义为Collection，但是JDK并没有提供Collection的实现类，而是提供了向下继承了Collection的另外两个接口Set和List，并且提供了Set和List的一系列实现类。\n实现List接口的一个实现类ArrayList（数组列表），类似于数组，但是元素可以是各种类（只要是Object的继承类）（数组是同一类类型的集合），定义的时候也不用指定数组列表的长度，使用add()向数组列表添加元素，使用get()向数组列表获取指定索引值的元素（索引顺序与数组一样，从0计数），使用clean()清除数组列表所有元素，使用remove()以元素索引或元素值删除指定元素。详细方法查询JDK文档。\n使用get获取ArrayList数组列表元素后，需要将元素强制转换为该元素的类型，如果强制转换的类型不符合元素类型，编译的时候不会报错，在运行时会把抛出类型转换错误异常。\n使用ArrayList的toArray()方法，将ArrayList数组类表元素转换为数组，返回的数组类型是Object[]，Object[]不能强制转换为具体类型数组，原因在于具体数组类型并不是Object[]的子类。\nArrayList的toString()方法是按照ArrayList元素的顺序分别调用各个元素类型的toString（）方法，并将返回结果使用[]括起来，元素之间的返回结果用，号隔开。\n集合的元素依然是对象的引用，不是对象本身。\nArrayList的底层实际是一个Object[]数组，所以数组列表元素可以是任意类型的对象，因为任何类都继承Object类。使用ArrayList默认构造方法会实际会在ArrayList底层生成一个长度为10的Object[]数组。当使用add方法向ArrayList添加新元素的时候，add方法会先判断Object数组长度够不够，如果够则直接将新元素添加进Object数组；如果长度不够，则会创建新的Object数组，长度为原来数组长度的1.5倍+1，然后将原数组的内容复制到新数组当中。如此循环，直到数组长度不够的时候，再按照以上方法增加数组长度。\n","date":"October 8, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"String","url":"https://www.qinxiandiqi.sbs/tags/string/"},{"title":"集合","url":"https://www.qinxiandiqi.sbs/tags/%E9%9B%86%E5%90%88/"},{"title":"List","url":"https://www.qinxiandiqi.sbs/tags/list/"},{"title":"数组","url":"https://www.qinxiandiqi.sbs/tags/%E6%95%B0%E7%BB%84/"}],"title":"Java SE 学习笔记 第三记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-15# 同一个类中的多个重载构造方法的互相调用，要用this(params)调用，不能直接显示调用构造方法，并且调用的时候this()必须放在构造方法中的首行，也就是this()之前不能存在其他代码。params为重载构造方法的参数列表。\n创建子类实例的时候，new子类的构造方法，实际默认的构造方法的调用顺序为调用父类不带参数的构造方法，若不存在不带参数的父类构造方法则编译出错，若存在则调用该父类构造方法，之后再调用带相应参数的子类构造方法。也就是说，创建子类实例的时候永远都是要先调用父类的构造方法再调用子类的构造方法。如果需要指定调用的具体父类构造方法，需要在子类构造方法使用super（params）来表明调用父类中带有相应参数列表的构造方法，并且super之前不能出现任何可执行的代码。\n对于内存来说，创建子类实例的时候，先调用父类构造方法，说明在内存中创建了一个父类实例（包括该父类实例的属性和父类方法引用，注：方法不创建，因为一个类的所有实例共享所有类方法），之后再调用子类的构造方法，这个时候并不像创建普通类一样从头到尾在内存中完完整整的创建一个单独的类实例，而是在该父类实例连续下来的内存空间里再创建子类增加的属性和方法引用，如果子类重写了父类相关属性和方法，则在连续下来的内存中创建重写的属性和重写的方法引用。换句话说，创建子类实例的时候，子类实例和父类实例共用一块连续的内存空间，并且子类实例内存空间包含父类实例内存空间，所以父类引用变量可以指向子类实例，使用多态的父类实例引用可以强制转换为子类引用。\n重载方法和重写方法的区别：重载方法是方法名一样，参数列表不一样，返回类型可以一样也可以不一样，重载方法出现在同一个类中；重写方法是方法名、参数类表、返回类型都完全一样，是子类重新定义父类中相应的方法，重写方法不能出现在同一个类中。\n多态就是父类对象引用可以指向子类对象引用。\n父类的构造方法不能被子类继承。\n当使用多态方式调用方法时，也就是父类引用变量指向子类实例，此时，java会先查询父类中是否存在需要调用的方法，如果不存在则编译错误，如果存在则再检查子类是否重写了这个方法，如果重写则调用子类的该方法，如果没有重写则直接调用父类的这个方法。而多态的父类引用，如果使用重写的属性值，则使用的属性值是父类的属性值，因为此时是父类实例引用，指向的是父类实例内存中的属性。\n可以通过强制转换的方式将使用多态方式的父类引用变量转换为子类引用变量。\n2012-07-16# 确定引用类型是否是多态是在运行时确定的，编译的时候只能确定引用类型引用的是什么类，也就是说多态是在编译后进行的，是晚绑定的。\n抽象类定义： abstract class 类名；抽象方法定义：修饰符 abstract 返回类型 方法名（params）;（没有花括号）。抽象方法必须定义在抽象类中。抽象类中可以包含具体方法，也可以不包含具体方法，抽象方法也可包含或者不包含。\n继承抽象类的子类必须实现父类中所有的抽象方法，如果没有全部实现，则该子类还是一个抽象类，需要使用abstract关键字，同样不能实例化。\n接口定义：关键字 interface 接口名{}；接口中所有方法都是抽象方法，所以在接口中的方法不能出现方法体，并且方法的abstract抽象关键字可以省略，因为默认都是抽象的。接口可以看成是特殊的抽象类，但是一个子类只能继承一个父类，而对于接口，一个类可以实现多个接口。实现接口用关键字implements，继承类用关键字extents。接口中所有方法也都是public关键字修饰的，所以public关键字在接口中省略。\n实现一个接口必须同时实现接口中所有的方法，否则要将类定义为抽象类。\n接口多态：接口类型引用指向实现接口类的实例，具有多态特征。\n静态关键字static，当用于修饰类属性时，表明该属性为静态类属性，所有的实例都共享一份静态属性，如果一个实例修改了静态属性，那么其他实例使用的静态属性值也会改变，使用静态属性可以用实例名.属性名，但是推荐使用类名.属性名；当用于修饰方法时，可以使用类名.方法名来调用。\n静态方法只能继承，但不具备多态特征，也就是不能被子类重写，只能被隐藏。即，只能使用静态方法隐藏静态方法，不能使用静态方法覆盖非静态方法，也不能使用非静态方法覆盖静态方法。被隐藏后调用的是父类还是子类的静态方法，取决于是使用什么类型的引用。\nfinal修饰的类不能被继承，final修饰的方法不能被子类重写，final修饰的属性不能被修改（属性为原生数据类型时，则数值不能改变；属性为引用类型时，则引用指向的对象不能改变，但对象属性可以改变）。\nfinal属性定义时必须显式赋予初值，如果定义时没有赋初值则只能在构造方法中赋初值，并且所有构造方法都必须赋初值，否则编译不通过，因为此时不赋初值将没有其他机会再定义值。\nfinal{}静态代码块，是在编译器编译后的class类文件加载进虚拟机时执行的代码，一个类中的静态代码只运行一次，在加载进虚拟机的时候。所有静态代码块在构造方法之前执行，构造方法是在生成新实例的时候才执行的，此时class文件已加载进虚拟机。对于继承的静态代码跟构造方法差不多，也是父类的先执行，再执行子类的静态代码，所有静态代码执行完毕后有创建实例才按构造方法顺序调用构造方法。\nclass类文件在类被使用的时候才会加载进JVM，而且只加载一次。\nstatic静态方法中只能调用静态属性，原因在于静态方法可以通过类名调用，如果调用的是非静态属性，那么每个实例的非静态属性都不同，静态方法会无法辨认使用的是哪个实例的属性，因此编译的时候不允许。反过来，非静态方法可以调用静态属性，因为静态属性时唯一，方法知道调用的是哪个属性。\n不能在静态方法中使用关键字this，同使用非静态属性的道理一样，this只当前的实例对象，在静态方法中使用this，java会无法辨认是哪个实例对象，因此编译不通过。\n接口中的成员变量都是public、final、static关键字修饰的，可以省略。因此，接口中的成员变量必须在定义的时候赋初值。\nfinal和abstract关键字不能同时使用，因为abstract抽象定义要求继承实现，而final是终止继承，互相矛盾。\n单例模式：一个类只有唯一的一个实例，即无论创建多少个类实例，它们实际上都是同一个实例。实现的方法是：首先，将类的构造方法关键字设为private，这么一来构造方法只能在类内部调用，在类外无法调用也就无法在类外创建类实例；其次，将创建类实例转移到类内部创建，并且使用static关键字修饰创建的类实例；最后，创建static的返回类内创建类实例引用的方法，使用static的原因是无法在类外创建类实例也就无法在类外调用类的任何一个非静态方法，只能通过静态方法来获取类内创建的类实例，类实例也用static修饰也是因为它要被static方法调用。由此三个步骤决定一个类由始至终只能创建一个类实例。\n包相当于目录，用于分类管理类文件，包名推荐使用反顺序的域名，并且全部小写。\n当java源文件中使用package引入包名，则表明此源文件中的类全名为：包名.类名，调用类的时候时候必须使用类的全名，即必须将类的class文件放置到包名指示的文件路径下，虚拟机才能找到相应的类执行，否则运行出错。\n当java源文件没有使用package引入包名，则使用默认的包default，调用的时候无需包名，即无包名。\n编译java源文件使用命令时，javac -verbose 文件名，可以追踪编译器的运行情况；javac -d 路径 文件名，可以将class生成到指定路径下。\n导入包和类的时候使用import关键字，导入类要使用类的全名，即指定到类名下，导入包则在包名后加“.*”，*号是通配符的意思，即该包下所有的类文件都导入，但是没有包含子包，如果需要导入子包则要将子包当成另外一个包，按导入包的方法导入。\n源文件中，必须遵循package、import、class的顺序声明。\n同个包内的类在关键字允许下，可以直接调用。\n访问修饰符：public，所有包的类都可访问，可以被所有包的类继承；private，只有在定义为private的类内部才可访问，不能被继承；不带访问修饰符即默认访问修饰符，可以被该类内部和该类所在包内的类可以访问，可以被所在包的其他类继承，不能被其他包的类访问和继承；protected，可以被类内部、相同包内其他类访问，可以被其他包的类继承，但不能被其他包的类访问。\n包和类的导入跟访问修饰符没有直接联系，导入是关于能不能找到类，访问修饰符是关于找到的类有没有权限访问。\n关键字instanceof用于判断某实例是不是某类或其子类的实例，引用名 instanceof 类名或接口名，返回一个布尔值。\n","date":"October 7, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"面向对象","url":"https://www.qinxiandiqi.sbs/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"多态","url":"https://www.qinxiandiqi.sbs/tags/%E5%A4%9A%E6%80%81/"},{"title":"单例模式","url":"https://www.qinxiandiqi.sbs/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}],"title":"Java SE 学习笔记 第二记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-12# bin目录：binary二进制缩写 windows环境变量：用户变量只对当前用户起作用，系统变量对所有用户都起作用。 javac的c是compile缩写，编译的意思，所以javac是编译命令程序。 java.exe是java运行字节码class命令程序。 java编译后的class文件名为java源文件的类名，并非java源文件名。 java是跨平台语言在于真正执行的不是二进制代码而是字节码，并且字节码由JVM执行，也就是说java程序可以不考虑程序将在什么操作系统上运行，因为运行java程序是的JVM虚拟机，只要有虚拟机就可以执行java程序。但是JVM虚拟机不是跨平台的，它是由c语言编写的，不同平台下的JVM虚拟机不一样。 java包含8中原生数据类型：整型int（32位）、字节型byte（范围-128-127，是整型的一个子集）、短整型short（16位）、长整型long（64位）、单精度浮点型float、双精度浮点型double、字符型char、布尔型boolean（true\u0026amp;false）。 java变量名可以包含下划线、字母、美元符号、数字，但是变量名不能以数字开头。 java中有三种注释方式：单行注释，//；多行注释，/* /；java doc帮助文档注释，/* */。 java中的布尔型只允许true和false两个值，不同于c语言和C++可以将数值当做布尔型。 java中所有浮点型默认情况下都是double类型，所以将任意一个浮点值赋给float变量将会抛出损失精度错误，所以将浮点值赋给float需要将浮点值强制转换为float（加括号和类型名），或者借助java语言的支持性在浮点值后加F（大写或小写），如：float a=1.2F。 赋值准则：赋值等号左右两边类型一致或者左边类型范围大于右边类型范围，并且值大小不溢出该类型。 变量在使用之前必须声明类型和赋值，并且只能声明定义一次。 2012-07-13# 若干个数据类型参与运算，运算结果类型为参与运算类型中表值范围最大的类型。 当运算结果为int时，java舍弃结果的所有小数部分，只保留整数部分。 强制转换，如a为int，“（double）a”整个部分的结果为double类型，但是a本身还是int类型。 取模运算（%）的结果正负与被除数的符号一致。 逻辑运算与\u0026amp;\u0026amp;：当左边的值为false时，java得出结果为false，不再执行\u0026amp;\u0026amp;右边的表达式。 逻辑运算或||：当左边的值为true时，java得出结果为true，不再运行右边的表达式。 条件运算符（三目运算符）：type d=布尔表达式？a：b switch的变量类型只允许short、byte、int、char四种类型和枚举类型。 继承 inheritance；封装encapsulation；多态polymoruphism 定义类：修饰符 class 类名字 定义方法：修饰符 返回类型 方法名称（参数） java类中的方法不能嵌套定义，也就是不能在一个方法中定义另一个方法，并且java中的方法只能定义在类中，即方法是属于类的。 类的命名约定：首字母大写，如果由多个单词组成则每个单词首字母都大写并且直接拼接在一起形成类名。 方法的命名约定：首字母小写，如果由多个单词组成则第一单词首字母小写，其余单词首字母都大写，然后直接拼接在一起。 属性的命名约定：命名约定与方法的命名约定方式相同。 成员变量和局部变量在使用前都需要定义，成员变量在使用前可以不初始化，但是局部变量在使用前必须初始化，否则程序出错。成员变量使用前未初始化，则会使用java默认值：byte、short、int、long默认值为0；boolean默认值为false；float、double默认值为0.0；char默认值为\u0026rsquo;\\u0000\u0026rsquo;。 引用类型是专门使用在对象上的，相当于一个指向对象的指针变量。一个对象可以被多个引用变量引用，但是同一个时刻一个引用变量只能引用一个对象。 用new实例化一个类创建对象的实质是在内存类堆上开辟一块空间创新对象，此时若有引用类型赋值，则会返回对象地址给引用类型（引用类型存在于内存栈中）。 方法的参数是对象，实际上是对象的引用类型，因为java中对对象的操作都是通过引用类型来实现，所以当实参（引用类型）传递给形参的值实际上只是对象的引用变量，并没有生成一个新的对象，也就是说，此时实参和形参两个引用类型都指向同一个对象。 同一个类的多个对象都拥有自己的属性，但是同一个类的多个对象共同拥有类的方法。 方法参数为原生数据类型，则参数传递的是值，方法中形参值的改变不影响实参的值。方法参数参数传递都是值传递，引用类型传递的是引用类型值，即地址。 什么类型的引用只能指向什么类型的对象或者对象的父类。 构造方法的名字必须与类名完全一致，因此构造方法以大写字母开头；构造方法没有返回值，因此构造方法没有返回类型，连void也不能出现；如果没有定义构造方法，类会自动添加默认不带任何参数且方法体为空的构造方法，如果定义了构造方法，则不会自动生成默认构造方法；类的构造方法不能显示调用，由new隐式调用。 new关键字生成对象时完成三件事：为对象在内存堆内开辟内存空间；调用类的构造方法；返回对象的地址。new关键字后类名小括号内容为响应构造方法的参数列表。 2012-07-14# 一个java源文件中最多只有一个public类。且main存在的话，只能存在于这个public类中。换句话说，一个java源文件中可以存在多个不是public的类。 一个java源文件中含有多少个类，编译后就生成多少个class文件，并且文件名为相应类名。 方法重载：两个多或多个方法的名字相同，参数列表不同，包括参数个数不同和参数类型不同。不能根据方法的返回值类型来重载方法，即不能有参数列表相同，唯独返回类型不同的方法重载。 ","date":"October 6, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"float","url":"https://www.qinxiandiqi.sbs/tags/float/"},{"title":"虚拟机","url":"https://www.qinxiandiqi.sbs/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"title":"Java SE 学习笔记 第一记"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/en/contact/","series":[],"smallImg":"","tags":[],"title":"Contact Me"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/en/offline/","series":[],"smallImg":"","tags":[],"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/offline/","series":[],"smallImg":"","tags":[],"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/contact/","series":[],"smallImg":"","tags":[],"title":"联系我"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/search/","series":[],"smallImg":"","tags":[],"title":"搜索"}],"series":["Java学习笔记"],"tags":["SSH","Java","装饰模式","io","字符集","序列化和反序列化","文件系统","AWT","Swing","Java内部类","Java注解","Java异常","JUnit","枚举","反射","代理模式","泛型","包装类","可变参数","Set","List","Map","Tree","策略模式","String","集合","数组","面向对象","多态","单例模式","float","虚拟机"]}