---
# type: posts 
title: "XML学习笔记 第一记"
date: 2014-06-18T11:07:26+0800
authors: ["Jianan"]
summary: "2012-08-05

1、XML：eXtensible Markup Language，可扩展元标记语言。

2、DTD：Document Type Definition，文档类型定义，用于规范XML的语法要求，XML常通过DTD文档来验证XML的语法是否符合对应DTD的要求。

3、XML描述的是结构和语义，注重的是内容，而不是单纯的强调格式化（如HTML），不决定文档的内容应该怎"
series: ["XML学习笔记"]
categories: ["XML学习笔记"]
tags: ["xml"]
images: []
featured: false
comment: true
toc: true
reward: true
pinned: false
carousel: false
draft: false
read_num: 1373
comment_num: 0
---

2012-08-05  
  
1、XML：eXtensible Markup Language，可扩展元标记语言。  
  
2、DTD：Document Type
Definition，文档类型定义，用于规范XML的语法要求，XML常通过DTD文档来验证XML的语法是否符合对应DTD的要求。  
  
3、XML描述的是结构和语义，注重的是内容，而不是单纯的强调格式化（如HTML），不决定文档的内容应该怎样显示。  
  
4、XML中每一个元素都是成对出现的，开始元素标签和结束元素标签的区别在于结束元素标签名前多了一个正斜杠“/”，如果不成对则出现基本的语法错误。元素的开始和结束标签之间为元素值，元素值可以是其他元素集合（即元素的嵌套），也可以是具体类型值。  
  
5、XML元素嵌套的时候，必须遵循嵌套顺序，内部元素必须先结束之后，才能结束外部元素。  
  
6、一个XML文档有且只有一个顶层元素，即根元素，一个XML中除了根元素之外，其它元素都必须被嵌套在根元素中。  
  
7、嵌套其它元素的元素叫做父元素，被嵌套的元素元素叫做子元素，同一个父元素下并列的子元素叫做兄弟元素。  
  
8、目前浏览器都很好的支持XML文档，使用浏览器打开XML文档，浏览器会在XML文档的每个元素前添加“+或-”标签，用于打开或收缩元素的具体内容。  
  
9、目前XML的标准为1.0。  
  
——————————————————————————————————————————  
  
2012-08-06  
  
1、XML的树形结构：一个XML文档根据文档中元素的嵌套关系可以形成一颗关系树，这种树形结构可以支持面向对象编程。XML元素的树形结构信息通常保存在DTD文档中，作为XML的规范。  
  
2、XML与HTML比较：  
    1）可扩展性：HTML不具有扩展性，只有固定的几个标签；而XML是元标记语言，可以定义新的标记语言。  
    2）侧重点：HTML侧重于如何变现信息，即显示信息的格式；而XML侧重于如何结构化地描述信息。  
    3）语法要求：HTML不要求标记的嵌套、配对等，不要求标记之间具有一定的顺序；而XML严格要求嵌套、配对，和遵循DTD的树形结构。  
    4）可读性和可维护性：HTML难于阅读和维护；而XML结构清晰，便于阅读、维护。  
    5）数据和显示关系：HTML的内容描述与显示方式整合为一体；而XML内容描述和显示方式向分离，XML只注重结构化的描述信息，如何显示这些信息需要通过外部部件来确定。  
    6）保值性：HTML不具有保值性；而XML具有保值性。  
  
3、XML提供了将不同来源的结构化数据集成的强大功能，通过XML可以实现数据在不同软件、不同数据库、异构语言和异构平台上进行交互。比如一个C++程序需要调用以一个Java程序的方法，C++程序可以通过XML文档将要调用的方法名和参数等信息发送给Java程序，Java程序收到XML文档后从中提取信息执行方法，并将结果再以XML发送回去。基本每一种语言都提供了对XML支持的组件，每一种语言都提供了对XML文档解析的机制。Java中提供了DOM和SAX两种接口用于XML编程。  
  
4、XML解放了一些只能在服务器端运行的高端软件：服务器将XML格式的数据发送给客户端，并允许客户端通过使用XML文档对象DOM用脚本语言或其它编程语言处理，从而数据不需要返回服务器就能在本地进行计算处理。  
  
5、由于XML支持的显示模式和数据内容分开，所以只要客户的显示配置不同就可以产生不同的显示方式，从而实现同一个XML文档的个性化显示。  
  
6、XML在web上传递可以像HTML一样发送数据，所以传递XML文档不需要对现有网络做任何变化。  
  
7、XML可以根据需求定义一套适合的标准在适合的范围里使用。  
  
8、XML文档的第一行是XML声明，用XML的处理指令进行声明。XML的处理指令放置在<?
?>之中，“<?”问号之后接指令名（如xml），指令名后空格接指令对应的参数值。XML对指令的语法要求很严格，每条指令必须顶格写，即“<”之前不允许有任何空白和其它字符，并且指令中“<”之后的“?”前后也不允许有空格，否则语法错误。XML的所有处理指令都放在文档首，处理指令写完后才能写XML文档元素。  
  
9、xml指令<?xml version="1.0" encoding="UTF-8"
standalone="yes"?>：version指定XML版本（目前只有1.0版本）。encoding指定XML的编码方式，该属性必须放置在standalone之前，否则语法错误；当XML文档中的字符不能完全转换为指定的编码方式时也会产生语法错误，推荐使用UTF-8编码方式可以涵盖所有语言的字符，并且不指定encoding属性时默认也为UTF-8编码方式。standalone属性当值为yes时表示不需要外部文档支持，当为no时表示需要外部文档支持，比如DTD。没有添加standalone属性时默认其值为yes。需要外部文档DTD时，XML解析器会先分析XML文档语法是否符合XML指定版本规范，除此之外还要分析XML文档是否也符合指定DTD文档规范，如DTD文档中树形结构包含的元素必须有，没有包含的元素不能出现等。  
  
10、XML元素可以具有属性，跟在元素标签名后，用空格隔开，属性采用“属性名=属性值”的格式，属性值用双引号或者单引号包围（当属性值中有单引号时属性值用双引号，当属性值中有双引号时属性值用单引号），多个属性使用一个或多个空格隔开，同一个属性在同一个元素中最多只能出现一次，并且属性值不能包括<,>,&等符号。  
  
11、XML中的元素名严格区分大小写！！  
  
12、类似于css样式表可以定义HTML标签的显示样式，同样css样式表也能够定义XML元素的显示样式，编写css的时候将XML的元素当做HTML标签一样定义就可以了。另外，还要将css样式表文件关联到XML文档上，在XML文档添加处理指令<?xml-
stylesheet type="text/css" href="..."?>。其中，xml-
stylesheet为指令名，type为指定关联样式文件的类型（text/css，表示样式文件类型为css文件类型），href为关联的样式文件地址。使用了CSS样式表的XML文档，浏览器显示的时候将以CSS定义的样式显示，因为此时浏览器已经知道每个元素的显示方式，由此可见XML的显示格式与XML内容是分离的。  
  
13、另一种定义XML显示样式的方法是使用XSL文档，XSL即eXtendable style
language，是专为显示XML开发的样式语言。使用时同样需要处理指令声明<?xml-styleshell type="text/xsl"
href="..."?>。  
  
14、XML只有一种注释<?--  \-->，注释不能写在元素尖括号中，注释也不能嵌套。  
  
15、当XML的元素没有内容的时候，可以将起始标签与结束标签合并为一个标签表示一个空元素，方法是在起始标签名后加“/”。  
  
16、实体：XML中的变量。XML中定义了5个常用实体，&lt;表示符号<，&gt;表示符号>，&amp;表示符号&，&quot;表示符号"，&apos;表示符号'，在XML中不能使用以上符号的地方可以使用它们的实体代替。  
  
17、定义实体的方法：  
<!DOCTYPE 根元素[  
    <!ENTITY 实体名 实体值>  
    <!ENTITY 实体名 实体值>  
    ...  
]>  
  
18、调用实体的方法：在根元素内调用实体，只要使用“&实体名;”的格式就能调用相应实体的值，在显示的时候会使用实体值代替。  
  
19、CDATA节：即使用<![CDATA[ 数据
]]>，XML会把CDATA节中的数据都当做纯文本字符处理，也就是对于任意字符都能能在CDATA节中出现而不会出现语法错误（除了]]之外），该标记对于大量使用<>%等字符特别方便。另外CDATA节也不能互相嵌套。  
  
20、DOCTYPE：文档类型声明，紧跟在XML声明之后，包含了所有实体的声明，语法间实体的定义。  
  
21、格式正规（wellformed）的XML文档，即符合以下规则的XML文档：  
    1）必须由XML声明语句<?xml version="1.0"?>  
    2）必须只有一个根元素  
    3）标记必须大小写敏感  
    4）属性值使用引号  
    5）标记成对出现  
    6）空标记关闭  
    7）元素正确嵌套  
  
22、格式正规的XML文档不一定是符合逻辑的文档，也就是文档的实现逻辑不一定就是用户需要的逻辑。  
  
23、XML的元素命名：元素名可以由字母、数字或者其它字符组成，但是不能用数字和XML/xml/Xml/等开头，并且名称中也不能有空格和冒号（冒号是给命名空间使用的）。  
  
24、有效的XML文档：满足对应DTD要求的格式正规的XML文档。  
  
25、DTD与XML的关系类似于面向对象语言的类与对象的关系，XML是堆DTD的一个具体实现。  
  
26、DTD文档的声明与使用：  
    1）内部DTD文档：在XML文档内部使用<!DOCTYPE 根元素[定义内容]>  
    2）外部DTD文档：<!DOCTYPE 根元素 SYSTEM "DTD文件路径">  
    3）内外部DTD文档结合（用的很少）：<!DOCTYPE 根元素 SYSTEM "DTD文件路径"[定义内容]>  
  
27、无论是使用内部还是外部还是内外部结合的DTD文档，它们在本质上都是一样的，完成DTD声明的语法都是一样，区别只是声明语句的位置不一样而已（其中，内外部就是内部和外部的声明进行组合，但根元素的声明在内外部都必须有）。  
  
28、外部DTD文档格式：同样需要<?xml version="1.0"
encoring="utf-8"?>语句的声明，声明自后写入符合DTD声明语法的语句就可以了。  
  
29、DTD声明元素语法：<!ELEMENT 元素名 元素类型>。  
  
30、ELEMENT的元素类型有：EMPTY表示一个空元素，即元素不能包含内容，但可以有属性；ANY表示可以包含任何在DTD中定义的元素类型，使用ANY类型的元素包含的子元素数量和类型都不受限制，一般不常用，使用了跟不定义DTD没什么区别；#PCDATA表示字符串类型，使用此类型的元素不能再包含其它子元素，即此元素的内容只能是一个字符串，不能再嵌套其它元素；纯元素类型，表示内容只有元素，除了元素之外没有其它文本；混合类型，表示既包含子元素和文本数据。  
  
31、DTD声明中可用的修饰符号：“()”，用于给元素分组，如括号将(apple,pear),banana分成了两组；“|”，使用它分隔的多个对象中必须并且只能出现其中的一个，如(man|woman)中只能出现man或者woman；“+”，表示修饰的对象至少要出现一次，可以出现一次到多次，如(member+)中member至少需要出现一次；“*”，表示修饰的对象可以出现零到任意多次，爱出现多少次就出现多少次，如(爱好*)中爱好可以出现任意次；“?”，表示修饰的对象要么不出现，要么只能出现一次，也就是最多只能出现一次，如(id?)中id最多只能出现一次；“,”，用将对象分隔并且要求对象必须按照指定的顺序出现，如(apple,pear,banana)中出现的顺序只能是apple然后pear然后banana。  
  
32、ELEMENT声明举例：  
    <!ELEMENT poem (author,title,context)>  
    <!ELEMENT author (#PCDATA)>  
    <!ELEMENT title (#PCDATA)>  
    <!ELEMENT context (#PCDATA)>  
    以上定义了一个poem元素，元素中包含三个子元素author、title、context，每个子元素都是一个包含字符串的元素。XML文档中定义poem元素的时候必须定义它的三个子元素，而且子元素的定义顺序只能是author、title、context。  
  
33、DTD声明元素属性语法：<!ATTLIST 元素名 属性名 属性类型 属性特点 属性名 属性类型 属性特点 属性名...>。  
  
34、DTD属性语法-元素名：元素名指定该属性是哪个元素的属性。  
  
35、DTD属性语法-属性名：属性名指定元素某属性的名称。  
  
36、DTD属性语法-属性类型：指定该属性对应的数据类型。主要有：  
    1）CDATA，任意字符串类型（与#PCDATA不同，它是修饰元素的）；  
    2）NMTOKEN是CDATA的一个子集，表示属性值必须是由英文字母、数字、句号、破折号、下划线或冒号组成，并且不能出现空格；  
    3）NMTOKENS，与NMTOKEN一样，区别在于可以包含由多个空格分隔的字符；  
    4）ID，表示该属性值在XML文档中相同的元素中取值必须是唯一的；  
    5）IDREF，表示该属性值必须是文档中其它元素已经定义的ID属性值；  
    6）IDREFS，表示该属性是可以具有由空格分隔开的多规格文档中其它元素已经定义的ID属性值；  
    7）Enumerated枚举类型，表示属性值必须在实现定义好的一些值范围内，使用格式为：<!ATTLIST 元素名 属性名 (属性值1|属性值2|属性值3|...) 属性特点>。  
  
37、DTD属性语法-属性特点：指定该属性是必须出现还是可省略等一些特性。主要有：    1）#REQUIRED，指定该属性必须出现；  
    2）#IMPLIED，指定该属性可以出现也可以不出现；  
    3）#FIXED value，指定该属性的值必须时value；  
    4）value，指定该属性的默认值为value，如果该属性出现但不提供值，则默认值为value。 

