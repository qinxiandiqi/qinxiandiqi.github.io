+++
title = "Java SE 学习笔记 第五记"
date = 2012-10-10T08:32:08+08:00
draft = false
summary = "Java的泛型和包装类。"
description = "Java的泛型和包装类。"
tags = [
    "Java",
    "泛型",
    "包装类",
    "可变参数"
]
read = 1195
+++

## 2012-07-21

1. Vector与ArrayList基本类似，不同的是Vector是同步的。HaseTable与HaseMap类似，只是HaseTable是同步的，不常用HaseTable，但常用HaseTable的子类Properties。

2. Properties的键值通常为String，用于Java的属性配置。System.getProperties()可以发返回一个系统配置的Properties对象。

3. 泛型（JDK1.5新添加的特性，之前版本的编译器无法识别泛型）：将数据类型参数化，通常使用T作为数据类型的参数，可接受多个参数，编写泛型类的时候把T当成具体数据类型来使用就可以了。泛型适用于逻辑结构完全相同，只是数据类型不相同的情况，相当于泛型提供了一个逻辑结构模板，接收不同的数据类型后模板会转换为具体数据类型的逻辑结构。例如：class Test\<T>，使用类Test的时候接收一个数据类型参数T，Test类内部将T当成一个具体的数据类型使用，此时Test就是一个处理T类型的类。泛型的好处是在编译的时候就能知道调用泛型类的接收类型，不使用泛型则编译的时候无法知道具体接收的是什么数据类型，只能在运行赋值的时候才能知道使用的具体类型。由此，泛型可以在编写代码的时候明确知道调用泛型类的具体类型，从而降低抛出类型转换错误的异常。

4. 所有的集合都使用泛型，构造集合的时候如果不传递泛型集合类要接收的具体数据类型，则默认接收的具体类型为Object，同时编译器会提出需要具体指定接收类型的警告，但能通过编译。传递了具体制定类型的泛型类只能接收制定类型的对象，否则编译不通过，所以当给集合类传递具体数据类型后，集合类只能接收和处理这种数据类型的对象。Java提倡使用集合类的时候传递具体的数据类型，默认的Object类型虽然可以接收各种类型对象，但是带来的问题是没法直接从集合中取出一个元素，要想做关于该元素的相关操作必须强制转换为该元素原有的数据类型，也就是说使用Object的时候必须知道集合中每一个元素的数据类型，一旦数据类型指派错误，就会抛出类型转换错误的异常。

5. 默认泛型类的类参数T可以接收各种数据类型，如果要限制T接收的数据类型，可以在T后面<>内部使用extends +只能接收的数据类型或者接口（无论限制的是类还是接口，规定一律使用extends），那么T只能接收extends该类型或接口，以及其子类，除此之外的其他类型都不能接收。默认情况下是T extends Object，所以使用泛型类的时候没有传递具体数据类型，则会默认接收Object类型。

---

## 2012-07-22

1. 使用泛型的时候，一旦明确在声明泛型引用变量时的类型参数，那么声明的引用变量类型也就确定，不能指向其他类型参数的泛型。然而，可以只用通配符?声明可以指向多种类型参数的泛型引用变量。具体实现方法：在声明引用变量的时候，使用<?>代替具体参数类型即可，则声明后的泛型引用变量可以指向任何泛型类型参数的对象。如果要限制引用变量指向的类型参数范围，可以使用<? extends type>限制引用变量只能指向type类型或者其子类对象，使用<? super type>限制引用变量只能指向type类型及其父类对象，<?>实际是<? extends Object>，所以<?>引用变量可以指向任何类型对象。特别的，一旦使用通配符定义的引用变量在赋予具体对象地址后，只能使用读取或者删除对象的数据而不能修改该对象。原因在于从java设计者的角度出发，一旦可以修改，那么程序运行时在使用该引用变量的数据时，必须知道该数据的具体类型然后强制转换过来，这种做法不符合泛型的思想，失去了泛型的意思，因此java规定使用通配符的泛型引用变量只能读取或删除对象数据，而不能修改。

2. 泛型同样可以被继承或用于接口，但是在继承泛型类或实现接口的时候必须同时继承类型参数，也就是说在子类或者实现类中必须也有父类或接口的类型参数，因为根据继承和实现的顺序原理，实现子类或接口时传递给父类或接口的类型参数只能从子类或实现类传入。

3. 遍历for循环（JDK1.5新增加特性），用于遍历数组或集合中的元素，for(type element：array){}。多维数组的遍历for循环需要使用多个遍历for循环嵌套使用，内嵌for中array使用上层element表示。

4. 自动装箱和自动拆箱：JDK1.5针对八种原生数据类型和包装类之间的自动转换提供的新特性，因此，在JDK1.5以后的版本中，可以直接将原生数据类型直接赋值给对应包装类，或者在需要原生数据类型的地方直接使用对应包装类的对象，JAVA会自动使用相应的valueOf方法转换后再使用。

5. Integer包装类中存在一个长度为255的Cache数组，其中包含了数值在-128~127这255个Integer对象作为缓冲数组。当使用valueOf()方法时，如果数值在-128到127之间时，不会生成新的Integer对象，而是直接返回Cache数组中对应值对象的引用，所以，自动装箱形成的Integer对象数值只要在这个缓冲范围内，使用==比较的结果是true。另外，如果Integer对象是使用new构造的话，那么无论数值是否在缓冲范围内都将重新构造新的对象，与构造普通对象的过程一样，不受缓冲数组的影响。

6. 可变参数（JDK1.5新增加的特性）：方法的参数可以不明确指定有多少个，在调用的时候才能知道究竟有多少个参数。可变参数只能是同种类型的多个参数，并且可变参数只能出现方法参数列表的最后一个，使用时在参数类型后边加3个点，例如：void method（String str,int... arr）{}。可变参数的实质是一个数组，调用带可变参数方法时，运行时会自动将参数转换为相关数组再传入方法中，所以调用带可变参数方法时的参数可使用离散参数，也可用数组参数，但是如果定义方法的时候使用数组做参数，调用方法时的参数也只能是数组。基于这个原因，为了能够知道调用方法时那些参数是要形成可变参数数组，所以决定了可变参数的位置只能在参数列表的最末尾，并且一个方法中最多只能有一个可变参数。
