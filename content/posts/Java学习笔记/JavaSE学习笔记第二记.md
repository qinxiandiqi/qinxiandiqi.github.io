+++
title = "Java SE 学习笔记 第二记"
date = 2012-10-07T08:49:06+08:00
draft = false
summary = "Java对象的构造过程，Java类的多态。设计模式的单例模式。"
description = "Java对象的构造过程，Java类的多态。设计模式的单例模式。"
tags = [
    "Java",
    "面向对象",
    "多态",
    "单例模式",
]
series = ["Java学习笔记"]
read = 1232
+++

## 2012-07-15

1. 同一个类中的多个重载构造方法的互相调用，要用this(params)调用，不能直接显示调用构造方法，并且调用的时候this()必须放在构造方法中的首行，也就是this()之前不能存在其他代码。params为重载构造方法的参数列表。

2. 创建子类实例的时候，new子类的构造方法，实际默认的构造方法的调用顺序为调用父类不带参数的构造方法，若不存在不带参数的父类构造方法则编译出错，若存在则调用该父类构造方法，之后再调用带相应参数的子类构造方法。也就是说，创建子类实例的时候永远都是要先调用父类的构造方法再调用子类的构造方法。如果需要指定调用的具体父类构造方法，需要在子类构造方法使用super（params）来表明调用父类中带有相应参数列表的构造方法，并且super之前不能出现任何可执行的代码。

3. 对于内存来说，创建子类实例的时候，先调用父类构造方法，说明在内存中创建了一个父类实例（包括该父类实例的属性和父类方法引用，注：方法不创建，因为一个类的所有实例共享所有类方法），之后再调用子类的构造方法，这个时候并不像创建普通类一样从头到尾在内存中完完整整的创建一个单独的类实例，而是在该父类实例连续下来的内存空间里再创建子类增加的属性和方法引用，如果子类重写了父类相关属性和方法，则在连续下来的内存中创建重写的属性和重写的方法引用。换句话说，创建子类实例的时候，子类实例和父类实例共用一块连续的内存空间，并且子类实例内存空间包含父类实例内存空间，所以父类引用变量可以指向子类实例，使用多态的父类实例引用可以强制转换为子类引用。

4. 重载方法和重写方法的区别：重载方法是方法名一样，参数列表不一样，返回类型可以一样也可以不一样，重载方法出现在同一个类中；重写方法是方法名、参数类表、返回类型都完全一样，是子类重新定义父类中相应的方法，重写方法不能出现在同一个类中。

5. 多态就是父类对象引用可以指向子类对象引用。

6. 父类的构造方法不能被子类继承。

7. 当使用多态方式调用方法时，也就是父类引用变量指向子类实例，此时，java会先查询父类中是否存在需要调用的方法，如果不存在则编译错误，如果存在则再检查子类是否重写了这个方法，如果重写则调用子类的该方法，如果没有重写则直接调用父类的这个方法。而多态的父类引用，如果使用重写的属性值，则使用的属性值是父类的属性值，因为此时是父类实例引用，指向的是父类实例内存中的属性。

8. 可以通过强制转换的方式将使用多态方式的父类引用变量转换为子类引用变量。

--- 

## 2012-07-16

1. 确定引用类型是否是多态是在运行时确定的，编译的时候只能确定引用类型引用的是什么类，也就是说多态是在编译后进行的，是晚绑定的。

2. 抽象类定义： abstract class 类名；抽象方法定义：修饰符 abstract 返回类型 方法名（params）;（没有花括号）。抽象方法必须定义在抽象类中。抽象类中可以包含具体方法，也可以不包含具体方法，抽象方法也可包含或者不包含。

3. 继承抽象类的子类必须实现父类中所有的抽象方法，如果没有全部实现，则该子类还是一个抽象类，需要使用abstract关键字，同样不能实例化。

4. 接口定义：关键字 interface 接口名{}；接口中所有方法都是抽象方法，所以在接口中的方法不能出现方法体，并且方法的abstract抽象关键字可以省略，因为默认都是抽象的。接口可以看成是特殊的抽象类，但是一个子类只能继承一个父类，而对于接口，一个类可以实现多个接口。实现接口用关键字implements，继承类用关键字extents。接口中所有方法也都是public关键字修饰的，所以public关键字在接口中省略。

5. 实现一个接口必须同时实现接口中所有的方法，否则要将类定义为抽象类。

6. 接口多态：接口类型引用指向实现接口类的实例，具有多态特征。

7. 静态关键字static，当用于修饰类属性时，表明该属性为静态类属性，所有的实例都共享一份静态属性，如果一个实例修改了静态属性，那么其他实例使用的静态属性值也会改变，使用静态属性可以用实例名.属性名，但是推荐使用类名.属性名；当用于修饰方法时，可以使用类名.方法名来调用。

8. 静态方法只能继承，但不具备多态特征，也就是不能被子类重写，只能被隐藏。即，只能使用静态方法隐藏静态方法，不能使用静态方法覆盖非静态方法，也不能使用非静态方法覆盖静态方法。被隐藏后调用的是父类还是子类的静态方法，取决于是使用什么类型的引用。

9. final修饰的类不能被继承，final修饰的方法不能被子类重写，final修饰的属性不能被修改（属性为原生数据类型时，则数值不能改变；属性为引用类型时，则引用指向的对象不能改变，但对象属性可以改变）。

10. final属性定义时必须显式赋予初值，如果定义时没有赋初值则只能在构造方法中赋初值，并且所有构造方法都必须赋初值，否则编译不通过，因为此时不赋初值将没有其他机会再定义值。

11. final{}静态代码块，是在编译器编译后的class类文件加载进虚拟机时执行的代码，一个类中的静态代码只运行一次，在加载进虚拟机的时候。所有静态代码块在构造方法之前执行，构造方法是在生成新实例的时候才执行的，此时class文件已加载进虚拟机。对于继承的静态代码跟构造方法差不多，也是父类的先执行，再执行子类的静态代码，所有静态代码执行完毕后有创建实例才按构造方法顺序调用构造方法。

12. class类文件在类被使用的时候才会加载进JVM，而且只加载一次。

13. static静态方法中只能调用静态属性，原因在于静态方法可以通过类名调用，如果调用的是非静态属性，那么每个实例的非静态属性都不同，静态方法会无法辨认使用的是哪个实例的属性，因此编译的时候不允许。反过来，非静态方法可以调用静态属性，因为静态属性时唯一，方法知道调用的是哪个属性。

14. 不能在静态方法中使用关键字this，同使用非静态属性的道理一样，this只当前的实例对象，在静态方法中使用this，java会无法辨认是哪个实例对象，因此编译不通过。

15. 接口中的成员变量都是public、final、static关键字修饰的，可以省略。因此，接口中的成员变量必须在定义的时候赋初值。

16. final和abstract关键字不能同时使用，因为abstract抽象定义要求继承实现，而final是终止继承，互相矛盾。

17. 单例模式：一个类只有唯一的一个实例，即无论创建多少个类实例，它们实际上都是同一个实例。实现的方法是：首先，将类的构造方法关键字设为private，这么一来构造方法只能在类内部调用，在类外无法调用也就无法在类外创建类实例；其次，将创建类实例转移到类内部创建，并且使用static关键字修饰创建的类实例；最后，创建static的返回类内创建类实例引用的方法，使用static的原因是无法在类外创建类实例也就无法在类外调用类的任何一个非静态方法，只能通过静态方法来获取类内创建的类实例，类实例也用static修饰也是因为它要被static方法调用。由此三个步骤决定一个类由始至终只能创建一个类实例。

18. 包相当于目录，用于分类管理类文件，包名推荐使用反顺序的域名，并且全部小写。

19. 当java源文件中使用package引入包名，则表明此源文件中的类全名为：包名.类名，调用类的时候时候必须使用类的全名，即必须将类的class文件放置到包名指示的文件路径下，虚拟机才能找到相应的类执行，否则运行出错。

20. 当java源文件没有使用package引入包名，则使用默认的包default，调用的时候无需包名，即无包名。

21. 编译java源文件使用命令时，javac -verbose 文件名，可以追踪编译器的运行情况；javac -d 路径 文件名，可以将class生成到指定路径下。

22. 导入包和类的时候使用import关键字，导入类要使用类的全名，即指定到类名下，导入包则在包名后加“.*”，*号是通配符的意思，即该包下所有的类文件都导入，但是没有包含子包，如果需要导入子包则要将子包当成另外一个包，按导入包的方法导入。

23. 源文件中，必须遵循package、import、class的顺序声明。

24. 同个包内的类在关键字允许下，可以直接调用。

25. 访问修饰符：public，所有包的类都可访问，可以被所有包的类继承；private，只有在定义为private的类内部才可访问，不能被继承；不带访问修饰符即默认访问修饰符，可以被该类内部和该类所在包内的类可以访问，可以被所在包的其他类继承，不能被其他包的类访问和继承；protected，可以被类内部、相同包内其他类访问，可以被其他包的类继承，但不能被其他包的类访问。

26. 包和类的导入跟访问修饰符没有直接联系，导入是关于能不能找到类，访问修饰符是关于找到的类有没有权限访问。

27. 关键字instanceof用于判断某实例是不是某类或其子类的实例，引用名 instanceof 类名或接口名，返回一个布尔值。