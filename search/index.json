{"authors":["Jianan"],"categories":["python","opengl","Git","Kotlin","Linux","Java","翻译","libGDX","libGDX手册","Android Tips","Android","IDE","go","OS","spring","RaspBerry","路由器","MySQL","Gson","Beacon","Android Gradle","Android Wear","Ant","JavaScript学习笔记","JavaWeb学习笔记","JUnit学习笔记","XML学习笔记","Java学习笔记"],"pages":[{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"python","url":"https://www.qinxiandiqi.sbs/categories/python/"}],"content":"一、逃离CSDN？# 在CSDN上面断断续续写了十年的文章，回想CSDN的名声这十几年从金字招牌演变到令人唾弃，如今我也决定逃离，不免令人遗憾。你要说CSDN做错了什么？可能也没什么大错，只不过是没跟上时代而已。在自媒体浪潮中，抓不住自己的定位，服务没跟上又想割韭菜，结果作者和读者双头得罪。随着越来越多的人出走CSDN，劣币又驱逐良币，再加上CSDN自己不断作死的一些骚操作，整体社区氛围越来越恶化并且恶性循环。一个品牌一旦臭了，无论做什么事情都事倍功半，要想再挽回可是非常艰难的事情了。\n实际上，我对CSDN还是很感激的，十年前的CSDN可是个大佬云集的地方。我曾经为了追逐大佬，也为了博客排名而奋笔疾书。也正因为在CSDN上坚持写了很多文章，不断逼迫自己研究了很多东西，从建立了自己在IT行业立足的自信。技术人的自信是很重要的，很多时候是自信决定了你在技术这条道上能走多远。从这点出发，我还是很感激CSDN的。\n二、怎么逃离，CSDN搬家是个问题# 既然决定逃离了，那么CSDN博客搬家是个问题。CSDN并没有提供文章批量导出之类的工具，放弃这么多年的文章很可惜，得想个办法把文章打包迁移出来。\n结合在网上找到的一些文章，还有分析CSDN的网络请求，于是写了个python工具blog_packaging_tools。因为我是用hugo来部署自己的网站，所以这个工具的主要目的就是把CSDN上自己的文章下载下来，转换为markdown文件格式（包括下载文章中的图片），并按hugo文件组织的结构保存。\n目前项目已经开源，有需要的可以自取。项目中抽象了博客的类型和打包流程，不满足自己要求的话，也可以按自己的要求实现下Blog、Post、Packer等几个类，适当改造一下来满足自己的要求。\n项目地址：https://github.com/qinxiandiqi/blog_packaging_tools\n三、blog_packaging_tools使用方式# clone项目到本地： git clone https://github.com/qinxiandiqi/blog_packaging_tools.git 确认本地已经安装python3环境，进入clone下来的blog_packaging_tools项目目录，使用pip/pip3安装项目以来python模块： pip install -r requirements.txt 复制项目根目录下config.ini.sample文件到根目录下，重命名为config.ini文件。 填写config.ini配置文件下csdn相关参数。 blog_id: csdn博客的id author：csdn博客作者名 cookie：csdn博客的cookie。cookie的获取方式：\n使用chrome相关浏览器登录csdn后，按F12打开开发者工具。刷新自己的csdn博客主页，在开发者工具中找到自己博客主页的网络请求，在header头参数中找到cookie字段，右键菜单选择复制值，复制到config.ini配置文件的cookie字段（注意保留配置文件中的单引号） start_page: 扫描csdn文章开始分页页码，默认1，从第1页开始扫描 end_page: 扫描csdn文章结束分页页码，默认100。当没有下一页或到达指定结束分页时停止扫描。 blogs/packer/hugo/template.md文件为导出hugo markdown文章模板，需要修改导出文章模板的话可以修改这个文件，具体支持的参数可查看默认模板文件中的参数。 执行打包： python3 main.py 结果输出到根目录下的output目录 ","date":"October 31, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/python/%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/","series":[],"smallImg":"","tags":[{"title":"python","url":"https://www.qinxiandiqi.sbs/tags/python/"},{"title":"博客搬家","url":"https://www.qinxiandiqi.sbs/tags/%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6/"}],"title":"逃离CSDN，一键打包CSDN博客"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"opengl","url":"https://www.qinxiandiqi.sbs/categories/opengl/"}],"content":"在opengl的着色器中，如果定义的uniform全局变量只是定义但并没有使用，或者使用了该uniform变量的代码不可触达或对着色器结果不产生影响，那么opengl在编译链接着色器程序之后，会自动将着色器中的这些uniform变量删除。\n这个优化可能会导致在业务代码中查询使用该uniform变量时，发生变量不能存在的错误，不了解这个自动优化机制容易让人费解。 例如：\nuniform vec4 u_color; 或者\nuniform vec4 u_color; if (u_color.a \u0026gt;= 0.0) {} 以上的u_color变量将会被自动删除。\n","date":"September 26, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/opengl/glsl/glsl%E7%9A%84uniform%E5%8F%98%E9%87%8F%E8%87%AA%E5%8A%A8%E4%BC%98%E5%8C%96/","series":[{"title":"opengl","url":"https://www.qinxiandiqi.sbs/series/opengl/"}],"smallImg":"","tags":[{"title":"glsl","url":"https://www.qinxiandiqi.sbs/tags/glsl/"},{"title":"opengl","url":"https://www.qinxiandiqi.sbs/tags/opengl/"}],"title":"GLSL的uniform变量自动优化"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Git","url":"https://www.qinxiandiqi.sbs/categories/git/"}],"content":"在Windows平台下进行git操作可能会出现Filename too long错误，这是因为操作的文件路径或文件名超长，配置git支持长文件名可解决问题：\ngit config --global core.longpaths true ","date":"September 18, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/git/filenametoolongbygitofwindows/","series":[],"smallImg":"","tags":[{"title":"git","url":"https://www.qinxiandiqi.sbs/tags/git/"},{"title":"Windows","url":"https://www.qinxiandiqi.sbs/tags/windows/"}],"title":"Windows平台下git报错Filename Too Long"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"一、Window系统# 1.1 新建ssh密钥# 打开Terminal（Power Shell终端），使用ssh-keygen生成新密钥： $ ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 提示新密钥保存位置，直接回车保存到默认位置：%USERPROFILE%/.ssh/id_ed25519 \u0026gt; Enter a file in which to save the key (/c/Users/you/.ssh/id_algorithm):[Press enter] 提示键入安全密码，直接回车不使用密码： \u0026gt; Enter passphrase (empty for no passphrase): [Type a passphrase] \u0026gt; Enter same passphrase again: [Type passphrase again] 查看新密钥指纹： $ cat ~/.ssh/id_ed25519 1.2 添加新密钥到ssh-agent# Window系统ssh-agent服务默认禁用，先把ssh-agent服务启动方式改为自启动。以管理员身份打开Terminal（Power Shell终端），输入： Set-Service -Name ssh-agent -StartupType automatic 添加新密钥到ssh-agent： $ ssh-add ~/.ssh/id_ed25519 二、Linux或Mac系统# 2.1 新建ssh密钥# 打开终端，使用ssh-keygen生成新密钥： $ ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 提示新密钥保存位置，直接回车保存到默认位置：%USERPROFILE%/.ssh/id_ed25519 \u0026gt; \u0026gt; Enter a file in which to save the key (/home/you/.ssh/algorithm): [Press enter] 提示键入安全密码，直接回车不使用密码： \u0026gt; Enter passphrase (empty for no passphrase): [Type a passphrase] \u0026gt; Enter same passphrase again: [Type passphrase again] 查看新密钥指纹： $ cat ~/.ssh/id_ed25519 2.2 添加新秘钥到ssh-agent# 启动ssh-agent服务： $ eval \u0026#34;$(ssh-agent -s)\u0026#34; 添加新密钥到ssh-agent： $ ssh-add ~/.ssh/id_ed25519 ","date":"September 11, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/system/%E7%94%9F%E6%88%90%E6%96%B0ssh%E5%AF%86%E9%92%A5%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0ssh-agent/","series":[],"smallImg":"","tags":[{"title":"ssh","url":"https://www.qinxiandiqi.sbs/tags/ssh/"}],"title":"生成新SSH密钥并添加到ssh-Agent"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Kotlin","url":"https://www.qinxiandiqi.sbs/categories/kotlin/"}],"content":"一、完整的Kotlin属性声明# var|val \u0026lt;propertyName\u0026gt;[: \u0026lt;PropertyType\u0026gt;] [= \u0026lt;property_initializer\u0026gt;] [\u0026lt;getter\u0026gt;] [\u0026lt;setter\u0026gt;] 一个kotlin属性声明可分为必选部分：属性关键字、属性名、属性类型；以及可选部分：属性初始器（property_initializer）、Getter、Setter。 注意：val没有Setter。\n二、问题：在属性初始器中为属性赋值会使用属性的Setter吗？# 答案：不会。\n例如以下代码：\npackage com.molidt.kotlin.demo fun main() { val obj = Obj() println(\u0026#34;obj.x = ${obj.x}\u0026#34;) obj.x = 2F println(\u0026#34;obj.x = ${obj.x}\u0026#34;) obj.x = 3F println(\u0026#34;obj.x = ${obj.x}\u0026#34;) } class Obj { var x: Float = 1F set(value) { field = value println(\u0026#34;set value:$value\u0026#34;) } } 结果输出：\nobj.x = 1.0 set value:2.0 obj.x = 2.0 set value:3.0 obj.x = 3.0\n三、需要注意的使用场景# 1）使用类构造器参数作为属性初始器不会使用属性Setter# 例如：\npackage com.molidt.kotlin.demo fun main() { val obj = Obj(1F) println(\u0026#34;obj.x = ${obj.x}\u0026#34;) obj.x = 2F println(\u0026#34;obj.x = ${obj.x}\u0026#34;) obj.x = 3F println(\u0026#34;obj.x = ${obj.x}\u0026#34;) } class Obj(x: Float) { var x: Float = x set(value) { field = value println(\u0026#34;set value:$value\u0026#34;) } } 结果输出：\nobj.x = 1.0 set value:2.0 obj.x = 2.0 set value:3.0 obj.x = 3.0\n2）在类构造器中为属性赋值会使用属性的Setter# 例如：\npackage com.molidt.kotlin.demo fun main() { val obj = Obj(1F) println(\u0026#34;obj.x = ${obj.x}\u0026#34;) obj.x = 2F println(\u0026#34;obj.x = ${obj.x}\u0026#34;) obj.x = 3F println(\u0026#34;obj.x = ${obj.x}\u0026#34;) } class Obj { constructor(x: Float) { this.x = x } var x: Float set(value) { field = value println(\u0026#34;set value:$value\u0026#34;) } } 结果输入：\nset value:1.0 obj.x = 1.0 set value:2.0 obj.x = 2.0 set value:3.0 obj.x = 3.0\n特别要注意：方式2的写法，IDE会提示将constructor简化成方式1的写法，实际上两者的执行过程并不完全相同。\n","date":"July 18, 2021","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/kotlin/kotlin%E7%9A%84%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%99%A8%E4%B8%8E%E5%B1%9E%E6%80%A7setter/","series":[{"title":"Kotlin","url":"https://www.qinxiandiqi.sbs/series/kotlin/"}],"smallImg":"","tags":[{"title":"kotlin","url":"https://www.qinxiandiqi.sbs/tags/kotlin/"},{"title":"Setter","url":"https://www.qinxiandiqi.sbs/tags/setter/"},{"title":"属性初始器","url":"https://www.qinxiandiqi.sbs/tags/%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%99%A8/"}],"title":"Kotlin的属性初始器与属性Setter"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Linux","url":"https://www.qinxiandiqi.sbs/categories/linux/"}],"content":"最近将闲置的PC安装了Deepin，作为内网的一台服务器。一般使用场景都是通过ssh远程登录，但是发现设备通电开机后，如果没有登录账号，wifi是不会自动连接的。这就有点尴尬了，每次通电开机后都要手动去机器上登录下账号，进入了桌面环境后再连接个wifi，然后才能在内网用ssh远程登录操作，非常不方便。\n期望机器能在通电进入系统后，即使没有登录账号也能自动连接wifi。可以使用Linux的网络管理工具的命令：\nnmctl device wifi connect [ssid wifi名字] password [wifi密码] 只要上面的命令成功连接wifi后，以后每次通电启动系统，不必登录账号进入桌面环境也能自动重连wifi，这样就再也不用去手动登录下桌面环境啦。\n","date":"December 29, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/system/linux/%E8%AE%BE%E7%BD%AElinux%E5%9C%A8%E6%9C%AA%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7%E6%83%85%E5%86%B5%E4%B8%8B%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5wifi/","series":[{"title":"Linux","url":"https://www.qinxiandiqi.sbs/series/linux/"}],"smallImg":"","tags":[{"title":"linux","url":"https://www.qinxiandiqi.sbs/tags/linux/"},{"title":"wifi","url":"https://www.qinxiandiqi.sbs/tags/wifi/"},{"title":"ssh","url":"https://www.qinxiandiqi.sbs/tags/ssh/"}],"title":"设置Linux在未登录账号情况下自动连接wifi"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/categories/java/"}],"content":"1. transient关键字的用途# 用于在实现Serializable接口的类中标记成员变量，使该类对象在序列化和反序列化过程中忽略该成员变量的处理。\n2. transient序列化和反序列化过程中的处理方式# 在序列化过程中，transient关键字修饰的成员变量默认处理方式使直接忽略 在反序列化过程中，transient关键字修饰的成员变量默认赋值该成员变量类型的默认值，例如int型为0，boolean为false，对象类型为null。 3. transient默认处理方式引发的问题# 反序列化过程中，transient修饰的成员变量赋值可能不是期望的默认值，例如：\nimport java.io.*; public class JavaSerializableObj { public static void main(String[] args) { Obj obj = new Obj(); System.out.println(\u0026#34;Obj.member = \u0026#34; + obj.getMember() + \u0026#34;; Obj.ignore = \u0026#34; + obj.getIgnore()); try { FileOutputStream fos = new FileOutputStream(\u0026#34;obj\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(obj); oos.close(); System.out.println(\u0026#34;write obj to file success\u0026#34;); } catch (Exception ex) { ex.printStackTrace(); } try { FileInputStream fis = new FileInputStream(\u0026#34;obj\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); obj = (Obj) ois.readObject(); ois.close(); System.out.println(\u0026#34;read obj from file success\u0026#34;); } catch (Exception ex) { ex.printStackTrace(); } System.out.println(\u0026#34;Obj.member = \u0026#34; + obj.getMember() + \u0026#34;; Obj.ignore = \u0026#34; + obj.getIgnore()); } public static class Obj implements Serializable { private final String member = \u0026#34;Member\u0026#34;; private final transient String ignore = new String(\u0026#34;Ignore\u0026#34;); public String getMember() { return member; } public String getIgnore() { return ignore; } } } 以上输出的结果为：\nObj.member = Member; Obj.ignore = Ignore write obj to file success read obj from file success Obj.member = Member; Obj.ignore = null Obj类中transient修饰的成员变量ignore为final类型，并且默认值为new String(\u0026ldquo;Ignore\u0026rdquo;)，但反序列化后缺为null，因为在反序列化过程中对象类型的值默认处理为null，这可能就不是业务逻辑所期望的。 注意：如果这里ignore的初始值改为ignore = \u0026ldquo;ignore\u0026rdquo;（非new出来的对象），反序列化却可以正常恢复ignore默认值，原因是final String字符串对象以字符串字面量赋值，java编译器编译的时候其实把该对象编译优化为常量，反序列化自然就没有问题了。\n4. 自定义序列化和反序列化过程# 为了解决transient关键字在序列化和反序列化过程中带来的问题，对有特殊业务要求的场景可以通过自定义序列化和反序列化过程来解决这些问题。 Serializable接口提供了三个自定义序列化过程的方法：\n/** * 处理对象序列化过程，默认应该调用out.defaultWriteObject()方法序列化 * 非static和transient修饰的成员变量 */ private void writeObject(java.io.ObjectOutputStream out) throws IOException /** * 处理对象反序列化过程，默认应该调用in.defaultReadObject()方法反序列化 * 非station和transient修饰的成员变量 */ private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException; /** * 用于反序列化过程中识别到未定义成员变量时的回调处理，常见于同个类在反序列化时修改了继承关系， * 或远程传输过来的序列化数据版本与当前类的序列化版本不一致。 */ private void readObjectNoData() throws ObjectStreamException; 针对上面的问题可以将Obj类处理为：\npublic static class Obj implements Serializable { private final String member = \u0026#34;Member\u0026#34;; private final transient String ignore = new String(\u0026#34;Ignore\u0026#34;); public String getMember() { return member; } public String getIgnore() { return ignore; } private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ in.defaultReadObject(); //final变量需要通过反射来赋值 try { Field ignoreField = getClass().getDeclaredField(\u0026#34;ignore\u0026#34;); ignoreField.setAccessible(true); ignoreField.set(this, new String(\u0026#34;Read Ignore\u0026#34;)); ignoreField.setAccessible(false); } catch (NoSuchFieldException | IllegalAccessException e) { e.printStackTrace(); } } } 输出结果为：\nObj.member = Member; Obj.ignore = Ignore write obj to file success read obj from file success Obj.member = Member; Obj.ignore = Read Ignore ","date":"December 21, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/transient%E4%BF%AE%E9%A5%B0%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%BAnull/","series":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/series/java/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"transient","url":"https://www.qinxiandiqi.sbs/tags/transient/"},{"title":"serializable","url":"https://www.qinxiandiqi.sbs/tags/serializable/"}],"title":"Transient修饰对象成员变量反序列化为null"},{"authors":[],"categories":[],"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremely fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","date":"February 28, 2019","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/about/","series":[],"smallImg":"","tags":[],"title":"关于我"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/categories/libgdx/"},{"title":"libGDX手册","url":"https://www.qinxiandiqi.sbs/categories/libgdx%E6%89%8B%E5%86%8C/"}],"content":" 原文作者：libGDX\n原文地址：https://github.com/libgdx/libgdx/wiki/Threading\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2018-08-26版本翻译\n译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接。\n所有ApplicationListener接口中的方法都会在同个OpenGL的渲染线程中被调用。对于大多数游戏来说，一般在ApplicationListener.render()方法中实现游戏的更新逻辑，这个方法会在渲染线程中执行。\n任何涉及OpenGL的图形操作都需要在渲染线程上执行。如果在其它线程上执行会导致一些无法预测的结果，这是因为OpenGL Context只有在渲染线程中才处于激活状态，\u0008对于大多数Android设备而言，在其它线程中创建OpenGL Context会导致一些问题，因此不支持这种操作。\n要从其它线程传递数据到渲染线程，我们建议使用Application.postRunnable()。渲染线程在渲染下一帧，并且在ApplicationListener.render()方法回调之前会执行Runnable中的代码。\nnew Thread(new Runnable() { @Override public void run() { // do something important here, asynchronously to the rendering thread final Result result = createResult(); // post a Runnable to the rendering thread that processes the result Gdx.app.postRunnable(new Runnable() { @Override public void run() { // process the result, e.g. add it to an Array\u0026lt;Result\u0026gt; field of the ApplicationListener. results.add(result); } }); } }).start(); libGDX有哪些类是线程安全的？# 除非在类文档中明确标记为线程安全，否则libgdx中的类都不是线程安全的。\n假如要操作图形或音频相关的内容，你永远不应该对这些操作进行多线程处理，例如，在多个线程中处理scene2D组件。\n","date":"August 26, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/libgdx/libgdx%E7%9A%84%E7%BA%BF%E7%A8%8B/","series":[{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/series/libgdx/"},{"title":"libGDX手册","url":"https://www.qinxiandiqi.sbs/series/libgdx%E6%89%8B%E5%86%8C/"}],"smallImg":"","tags":[{"title":"libgdx","url":"https://www.qinxiandiqi.sbs/tags/libgdx/"},{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"游戏引擎","url":"https://www.qinxiandiqi.sbs/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"title":"线程","url":"https://www.qinxiandiqi.sbs/tags/%E7%BA%BF%E7%A8%8B/"},{"title":"线程安全","url":"https://www.qinxiandiqi.sbs/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"}],"title":"LibGDX的线程"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/categories/libgdx/"},{"title":"libGDX手册","url":"https://www.qinxiandiqi.sbs/categories/libgdx%E6%89%8B%E5%86%8C/"}],"content":" 原文作者：libGDX\n原文地址：https://github.com/libgdx/libgdx/wiki/Logging\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2018-08-05版本翻译\n译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接。\n日志消息可以输出为普通信息，或者是带可选异常的错误消息，也可以是调试信息：\nGdx.app.log(\u0026#34;MyTag\u0026#34;, \u0026#34;my informative message\u0026#34;); Gdx.app.error(\u0026#34;MyTag\u0026#34;, \u0026#34;my error message\u0026#34;, exception); Gdx.app.debug(\u0026#34;MyTag\u0026#34;, \u0026#34;my debug message\u0026#34;); 依赖于具体的底层平台，日志会被打印到控制台（桌面平台），或者是LogCat（Android平台）。在Html框架下，可以是GwtApplicationConfiguration提供的GWTTextArea，\u0008也可能是由html5自动控制。\n日志可以指定特定的输出级别：\nGdx.app.setLogLevel(logLevel); 这里的 logLevel可以是以下的值：\nApplication.LOG_NONE: 屏蔽所有日志。 Application.LOG_DEBUG: 打印所有日志。 Application.LOG_ERROR: 只打印错误日志。 Application.LOG_INFO: 打印错误或普通日志。 ","date":"August 5, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/libgdx/libgdx%E7%9A%84%E6%97%A5%E5%BF%97/","series":[{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/series/libgdx/"},{"title":"libGDX手册","url":"https://www.qinxiandiqi.sbs/series/libgdx%E6%89%8B%E5%86%8C/"}],"smallImg":"","tags":[{"title":"libgdx","url":"https://www.qinxiandiqi.sbs/tags/libgdx/"},{"title":"游戏引擎","url":"https://www.qinxiandiqi.sbs/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"日志","url":"https://www.qinxiandiqi.sbs/tags/%E6%97%A5%E5%BF%97/"}],"title":"LibGDX的日志"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/categories/libgdx/"},{"title":"libGDX手册","url":"https://www.qinxiandiqi.sbs/categories/libgdx%E6%89%8B%E5%86%8C/"}],"content":" 原文作者：libGDX\n原文地址：https://github.com/libgdx/libgdx/wiki/Querying\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2018-08-05版本翻译\n译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接。\n有时候需要获取应用程序运行时所依赖的底层平台类型。Application.getType() 方法会返回应用程序实际运行时的底层平台类型：\nswitch (Gdx.app.getType()) { case Android: // android specific code break; case Desktop: // desktop specific code break; case WebGl: // HTML5 specific code break; default: // Other platforms specific code } 在Android平台上甚至可以查询应用程序运行时的Android系统版本号：\nint androidVersion = Gdx.app.getVersion(); 这个方法将会返回当前设备的Android SDK level，例如，Android 1.5会返回3。\n有时候为了调试或者分析应用程序，需要知道运行时的内存消耗情况。可以通过下面方法获取Java堆和native堆内存的消耗情况：\nlong javaHeap = Gdx.app.getJavaHeap(); long nativeHeap = Gdx.app.getNativeHeap(); 这两个方法都会以bytes为单位返回当前对应堆内存的消耗情况。\n","date":"August 5, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/libgdx/%E6%9F%A5%E8%AF%A2libgdx%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/","series":[{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/series/libgdx/"},{"title":"libGDX手册","url":"https://www.qinxiandiqi.sbs/series/libgdx%E6%89%8B%E5%86%8C/"}],"smallImg":"","tags":[{"title":"libgdx","url":"https://www.qinxiandiqi.sbs/tags/libgdx/"},{"title":"查询","url":"https://www.qinxiandiqi.sbs/tags/%E6%9F%A5%E8%AF%A2/"},{"title":"运行时环境","url":"https://www.qinxiandiqi.sbs/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83/"}],"title":"查询libGDX运行时环境的相关信息"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/categories/libgdx/"},{"title":"libGDX手册","url":"https://www.qinxiandiqi.sbs/categories/libgdx%E6%89%8B%E5%86%8C/"}],"content":" 原文作者：libGDX\n原文地址：https://github.com/libgdx/libgdx/wiki/Starter-classes-and-configuration\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2018-07-22版本翻译\n译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接。\n本文假设你已按照libGDX的项目设置、运行和调试一文中的说明进行操作，并已将生成的Core、桌面、Android和HTML5项目代码导入到Eclipse。（译注：该创建libGDX项目文章已经过时，新项目创建方法请参考使用gradle创建libGDX项目）\n打开my-gdx-game项目中的Main.java类，你会看到以下代码：\npackage com.me.mygdxgame; import com.badlogic.gdx.backends.lwjgl.LwjglApplication; import com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration; public class Main { public static void main(String[] args) { LwjglApplicationConfiguration cfg = new LwjglApplicationConfiguration(); cfg.title = \u0026#34;my-gdx-game\u0026#34;; cfg.useGL30 = false; cfg.width = 480; cfg.height = 320; new LwjglApplication(new MyGdxGame(), cfg); } } 上面的代码首先实例化了LwjglApplicationConfiguration。此类允许设置各种配置，例如初始屏幕分辨率，是否使用OpenGL ES 2.0或3.0（当前还处于实验阶段）等。有关更多信息，请参阅此类的Javadocs。\n设置好这个配置对象之后，下一步开始实例化LwjglApplication。它的构造方法包含一个MyGdxGame()类对象，这个MyGdxGame类实际上是实现了游戏逻辑的ApplicationListener接口实例。\n在这之后就会有一个窗口被创建出来，并开始执行ApplicationListener接口中的相关生命周期方法，详情请参考libGDX的生命周期。\n等待补充……\nAndroid应用程序不使用main()方法作为启动类入口点，而是需要一个Activity。打开my-gdx-game-android项目中的MainActivity.java类：\npackage com.me.mygdxgame; import android.os.Bundle; import com.badlogic.gdx.backends.android.AndroidApplication; import com.badlogic.gdx.backends.android.AndroidApplicationConfiguration; public class MainActivity extends AndroidApplication { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); AndroidApplicationConfiguration cfg = new AndroidApplicationConfiguration(); initialize(new MyGdxGame(), cfg); } } Android的主要入口是Activity的onCreate()方法。请注意，上面代码中的MainActivity继承了AndroidApplication类，而AndroidApplication又继承类Activity。类似桌面平台的启动类，首先要创建配置实例AndroidApplicationConfiguration。配置完成后，调用AndroidApplication.initialize()方法，与ApplicationListener实例（本例中是MyGdxGame）一起传入。有关配置类可用的设置参数，请参阅AndroidApplicationConfiguration Javadocs。\nAndroid应用程序可以有多个Activity，但Libgdx游戏通常只应包含一个Activity。如果游戏需要显示多个分屏，应通过libgdx来实现，而不是使用多个Activity。这样做的原因是创建一个新的Activity意味着创建一个新的OpenGL Context，这是非常耗时的，而且也意味着必须重新加载所有图形资源。\nAndroid SDK引入了一个API，可以为屏幕的特定区域创建控制器，甚至可以在多个屏幕上轻松重复使用。此API称为Fragments API。Libgdx现在也可以以Fragment的形式引入，做为更大屏幕的一部分。要创建包含Libgdx的Fragment，fragment必须继承AndroidFragmentApplication，并使用下面方式重写onCreateView()方法：\n@Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return initializeForView(new MyGdxGame()); } 使用fragment引入libGDX的代码与上面使用Activity引入libGDX的步骤和代码有些许区别：\n添加Android V4支持库。如果你的Android项目还没有添加这个支持库，那你必须添加这个依赖库以便后面使用FragmentActivity。 修改AndroidLauncher继承FragmentActivity，而不是继承AndroidApplication。 AndroidLauncher这个activity需要实现AndroidFragmentApplication.Callbacks接口。 创建继承AndroidFragmentApplication类的Fragment，这个fragment是libGDX的实现。 添加上面提到的initializeForView()代码到Fragment的onCreateView方法中。 最后，将AndroidLauncher Activity的content替换为这个libGDX fragment。 例如:\n// 2. 修改AndroidLauncher继承FragmentActivity，而不是继承AndroidApplication。 // 3. AndroidLauncher activity实现AndroidFragmentApplication.Callbacks接口 public class AndroidLauncher extends FragmentActivity implements AndroidFragmentApplication.Callbacks { @Override protected void onCreate (Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 6. 最后，将AndroidLauncher Activity的content替换为这个libGDX fragment。 GameFragment fragment = new GameFragment(); FragmentTransaction trans = getSupportFragmentManager().beginTransaction(); trans.replace(android.R.id.content, fragment); trans.commit(); } // 4. 创建继承AndroidFragmentApplication类的Fragment，这个fragment是libGDX的实现。 public static class GameFragment extends AndroidFragmentApplication { // 5. 添加initializeForView()到Fragment的onCreateView方法中。 @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return initializeForView(new MyGdxGame()); } } @Override public void exit() {} } AndroidManifest.xml文件# 除了AndroidApplicationConfiguration，Android应用程序还要对AndroidManifest.xml文件进行配置，该文件位于Android项目的根目录中。你大概需要进行以下的配置：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; package=\u0026#34;com.me.mygdxgame\u0026#34; android:versionCode=\u0026#34;1\u0026#34; android:versionName=\u0026#34;1.0\u0026#34; \u0026gt; \u0026lt;uses-sdk android:minSdkVersion=\u0026#34;8\u0026#34; android:targetSdkVersion=\u0026#34;15\u0026#34; /\u0026gt; \u0026lt;application android:icon=\u0026#34;@drawable/ic_launcher\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; \u0026gt; \u0026lt;activity android:name=\u0026#34;.AndroidLauncher\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:screenOrientation=\u0026#34;landscape\u0026#34; android:configChanges=\u0026#34;keyboard|keyboardHidden|orientation\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 目标Sdk版本# 将targetSDKVersion设置为你要的目标Android版本。\n屏幕方向和设备配置更改# 除了targetSdkVersion，activity的screenOrientation和configChanges属性通常也要设置。\nscreenOrientation属性指定应用程序屏幕的固定方向。如果应用程序可以同时使用横向和纵向模式，则可以省略此项。\nconfigChanges属性至关重要，它应始终设置为上面显示的值。省略此属性意味着每次物理键盘滑出/插入或设备方向发生变化时，应用程序都将重新启动（译注：忽略这个属性，默认设备这些属性发生修改时会重新启动该Activity，由于libGDX基于Activity注入，Activity重启也意味着libGDX实例重启）。如果是screenOrientation属性被省略，libgdx应用程序将回调ApplicationListener.resize()方法以指示方向更改。然后，API客户端可以相应地重新调整应用程序的布局。\n权限# 如果应用程序需要能够写入设备的外部存储器（例如SD卡），或者需要访问互联网，又或者需要使用振动器或想要录制音频，则需要将以下权限添加到AndroidManifest.xml文件中：\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.RECORD_AUDIO\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.VIBRATE\u0026#34;/\u0026gt; 用户通常对申请许多权限的应用程序感到疑惑，因此请明智地选择申请这些权限。\n为使唤醒锁定起作用，AndroidApplicationConfiguration.useWakeLock需要将其设置为true。\n如果游戏不需要加速计或指南针访问，建议通过将AndroidApplicationConfiguration.useAccelerometer和AndroidApplicationConfiguration.useCompass字段设置false来禁用它们 。\n如果你的游戏需要陀螺仪传感器，则必须设置AndroidApplicationConfiguration.useGyroscope为true（默认情况下它是被禁用，这样可以节省电量）。\n有关如何为应用程序设置图标等其他属性的详细信息，请参阅Android开发人员指南。\nLibgdx提供了一种简单易用的方法来为Android创建动态壁纸。动态壁纸的启动类是AndroidLiveWallpaperService，下面是一个例子：\npackage com.mypackage; // imports snipped for brevity public class LiveWallpaper extends AndroidLiveWallpaperService { @Override public ApplicationListener createListener () { return new MyApplicationListener(); } @Override public AndroidApplicationConfiguration createConfig () { return new AndroidApplicationConfiguration(); } @Override public void offsetChange (ApplicationListener listener, float xOffset, float yOffset, float xOffsetStep, float yOffsetStep, int xPixelOffset, int yPixelOffset) { Gdx.app.log(\u0026#34;LiveWallpaper\u0026#34;, \u0026#34;offset changed: \u0026#34; + xOffset + \u0026#34;, \u0026#34; + yOffset); } } 当你的动态壁纸在选择器中显示或创建后在主屏幕上显示时，createListener()和createConfig()方法会被回调。\n当用户在主屏幕上滑动屏幕时，offsetChange() 方法会被调用，并且告诉你当前屏幕偏离中心屏幕多少。这个方法会在渲染线程上执行，因此你不必同步任何内容。\n除了启动类之外，你还必须创建一个描述壁纸的XML文件，我们暂且称之为livewallpaper.xml。在Android项目的res/资源文件夹下创建一个xml/文件夹，并将文件放在这个文件夹里面（res/xml/livewallpaper.xml）。下面是xml文件的内容：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;wallpaper xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:thumbnail=\u0026#34;@drawable/ic_launcher\u0026#34; android:description=\u0026#34;@string/description\u0026#34; android:settingsActivity=\u0026#34;com.mypackage.LivewallpaperSettings\u0026#34;/\u0026gt; 文件中的thumbnail定义了你的动态壁纸在选择器中P显示的缩略图，description和settingsActivity定义了当用户点击动态壁纸选择器中的“设置”时将显示的描述和Activity。这Activity应该只是一个标准的Activity，它有一些小组件可以更改动态壁纸的一些设置，例如背景颜色和类似的东西。你可以将这些设置存储在SharedPreferences中，稍后就可以在动态壁纸的ApplicationListener中通过Gdx.app.getPreferences()加载它们。\n最后，你需要在AndroidManifest.xml文件中添加内容。以下是包含简单设置Activity的动态壁纸的示例：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; package=\u0026#34;com.mypackage\u0026#34; android:versionCode=\u0026#34;1\u0026#34; android:versionName=\u0026#34;1.0\u0026#34; android:installLocation=\u0026#34;preferExternal\u0026#34;\u0026gt; \u0026lt;uses-sdk android:minSdkVersion=\u0026#34;7\u0026#34; android:targetSdkVersion=\u0026#34;14\u0026#34;/\u0026gt;\t\u0026lt;uses-feature android:name=\u0026#34;android.software.live_wallpaper\u0026#34; /\u0026gt; \u0026lt;application android:icon=\u0026#34;@drawable/icon\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34;\u0026gt; \u0026lt;activity android:name=\u0026#34;.LivewallpaperSettings\u0026#34; android:label=\u0026#34;Livewallpaper Settings\u0026#34;/\u0026gt; \u0026lt;service android:name=\u0026#34;.LiveWallpaper\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:icon=\u0026#34;@drawable/icon\u0026#34; android:permission=\u0026#34;android.permission.BIND_WALLPAPER\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.service.wallpaper.WallpaperService\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;meta-data android:name=\u0026#34;android.service.wallpaper\u0026#34; android:resource=\u0026#34;@xml/livewallpaper\u0026#34; /\u0026gt; \u0026lt;/service\u0026gt;\t\u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 这个manifest定义了：\n它要使用动态壁纸功能，请参阅\u0026lt;uses-feature\u0026gt;标签。 允许绑定壁纸的权限，请参阅android:permission属性。 指定壁纸设置的Activity 指定livewallpaper的service，它指向livewallpaper.xml文件，请参阅meta-data。 注意动态壁纸从Android 2.1 (SDK level 7)之后才开始支持。\n动态壁纸在触摸输入方面有一些限制。通常只会报告点击/拖放事件。如果你想要接收全部触摸事件，你可以将AndroidApplicationConfiguration#getTouchEventsForLiveWallpaper标志设为true以接收完整的多点触控事件。\n从Android 4.2开始，当设备处于空闲或停靠状态时，用户可以设置Daydreams（译注：Google在Android上引入的VR平台）显示出来。这些Daydreams类似于屏保，可以用来显示相册等内容。Libgdx可以让你轻松写出这样的Daydreams应用。\nDaydream的启动类是AndroidDaydream。下面是一个例子：\npackage com.badlogic.gdx.tests.android; import android.annotation.TargetApi; import android.util.Log; import com.badlogic.gdx.ApplicationListener; import com.badlogic.gdx.backends.android.AndroidApplicationConfiguration; import com.badlogic.gdx.backends.android.AndroidDaydream; import com.badlogic.gdx.tests.MeshShaderTest; @TargetApi(17) public class Daydream extends AndroidDaydream { @Override public void onAttachedToWindow() { super.onAttachedToWindow(); setInteractive(false); AndroidApplicationConfiguration cfg = new AndroidApplicationConfiguration(); ApplicationListener app = new MeshShaderTest(); initialize(app, cfg); } } 只需要继承AndroidDaydream，重写onAttachedToWindow方法，添加配置和ApplicationListener就可以初始化你的Daydream。\n除了Daydream本身，你还可以提供配置用的Activity，让用户配置你的Daydream。这可以是普通的Activity，也可以是libgdx的AndroidApplication。以空Activity为例：\npackage com.badlogic.gdx.tests.android; import android.app.Activity; public class DaydreamSettings extends Activity { } 必须将此配置Activity指定为Daydream服务的metadata。在Android项目的res/xml文件夹中创建一个xml文件，并指定如下activity：\n\u0026lt;dream xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:settingsActivity=\u0026#34;com.badlogic.gdx.tests.android/.DaydreamSettings\u0026#34; /\u0026gt; 最后，像往常一样在AndroidManifest.xml中添加配置activity的部分，以及daydream的service描述，如下所示：\n\u0026lt;service android:name=\u0026#34;.Daydream\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:icon=\u0026#34;@drawable/icon\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.service.dreams.DreamService\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;meta-data android:name=\u0026#34;android.service.dream\u0026#34; android:resource=\u0026#34;@xml/daydream\u0026#34; /\u0026gt; \u0026lt;/service\u0026gt; 等待补充……\nHTML5/GWT应用程序的主要启动类是GwtApplication。打开my-gdx-game-html5项目中的GwtLauncher.java类：\npackage com.me.mygdxgame.client; import com.me.mygdxgame.MyGdxGame; import com.badlogic.gdx.ApplicationListener; import com.badlogic.gdx.backends.gwt.GwtApplication; import com.badlogic.gdx.backends.gwt.GwtApplicationConfiguration; public class GwtLauncher extends GwtApplication { @Override public GwtApplicationConfiguration getConfig () { GwtApplicationConfiguration cfg = new GwtApplicationConfiguration(480, 320); return cfg; } @Override public ApplicationListener createApplicationListener () { return new MyGdxGame(); } } 启动类主要由两个方法组成，GwtApplication.getConfig()和GwtApplication.createApplicationListener()。 前者必须返回一个GwtApplicationConfiguration实例， 这个实例指定HTML5应用程序的各种配置。GwtApplication.createApplicatonListener()方法为程序运行提供 ApplicationListener实例.\n模块文件# GWT需要引用每个jars/projects目录下的Java代码。此外，每个jars/projects都需要有一个模块定义文件，后缀为gwt.xml。\n在示例项目的设置中，html5项目的模块文件如下所示：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE module PUBLIC \u0026#34;-//Google Inc.//DTD Google Web Toolkit trunk//EN\u0026#34; \u0026#34;http://google-web-toolkit.googlecode.com/svn/trunk/distro-source/core/src/gwt-module.dtd\u0026#34;\u0026gt; \u0026lt;module\u0026gt; \u0026lt;inherits name=\u0026#39;com.badlogic.gdx.backends.gdx_backends_gwt\u0026#39; /\u0026gt; \u0026lt;inherits name=\u0026#39;MyGdxGame\u0026#39; /\u0026gt; \u0026lt;entry-point class=\u0026#39;com.me.mygdxgame.client.GwtLauncher\u0026#39; /\u0026gt; \u0026lt;set-configuration-property name=\u0026#34;gdx.assetpath\u0026#34; value=\u0026#34;../my-gdx-game-android/assets\u0026#34; /\u0026gt; \u0026lt;/module\u0026gt; 上面指定了另外两个继承的模块（gdx-backends-gwt模块和Core项目模块），指明启动类（GwtLauncher），以及相对于HTML5项目根目录的assets资源目录。\n注意，gdx-backend-gwt模块和Core项目都有一个类似的模块定义文件，里面可能指定了其他依赖项。你不能使用不包含模块文件和源文件的jars/projects模块！\n有关模块和依赖关系的更多信息，请参阅GWT开发人员指南。\n反射支持# 由于各种原因，GWT不支持Java反射。Libgdx有一个内部仿真层，它将为少数几个内部类生成反射信息。这意味着如果你使用libgdx的Json序列化功能，你将遇到问题。你可以通过指定要为哪些包和类生成反射信息来解决此问题。为此，你可以将配置属性放在GWT项目的gwt.xml文件中，如下所示：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;module\u0026gt; ... other elements ... \u0026lt;extend-configuration-property name=\u0026#34;gdx.reflect.include\u0026#34; value=\u0026#34;org.softmotion.explorers.model\u0026#34; /\u0026gt; \u0026lt;extend-configuration-property name=\u0026#34;gdx.reflect.exclude\u0026#34; value=\u0026#34;org.softmotion.explorers.model.HexMap\u0026#34; /\u0026gt; \u0026lt;/module\u0026gt; 你可以通过添加更多extend-configuration-property元素来添加多个包和类。\n此功能目前属于实验性使用，使用风险自负。\n载入画面# libgdx HTML5应用程序会预加载所有能在gdx.assetpath中找到的资源。在此加载过程中，将显示一个加载画面，该加载画面通过GWT小部件实现。如果要自定义此加载画面，只需覆盖该GwtApplication.getPreloaderCallback()方法（在上例中，该方法在GwtLauncher类中）。以下示例使用Canvas绘制一个非常简单，丑陋的加载画面：\nlong loadStart = TimeUtils.nanoTime(); public PreloaderCallback getPreloaderCallback () { final Canvas canvas = Canvas.createIfSupported(); canvas.setWidth(\u0026#34;\u0026#34; + (int)(config.width * 0.7f) + \u0026#34;px\u0026#34;); canvas.setHeight(\u0026#34;70px\u0026#34;); getRootPanel().add(canvas); final Context2d context = canvas.getContext2d(); context.setTextAlign(TextAlign.CENTER); context.setTextBaseline(TextBaseline.MIDDLE); context.setFont(\u0026#34;18pt Calibri\u0026#34;); return new PreloaderCallback() { @Override public void done () { context.fillRect(0, 0, 300, 40); } @Override public void loaded (String file, int loaded, int total) { System.out.println(\u0026#34;loaded \u0026#34; + file + \u0026#34;,\u0026#34; + loaded + \u0026#34;/\u0026#34; + total); String color = Pixmap.make(30, 30, 30, 1); context.setFillStyle(color); context.setStrokeStyle(color); context.fillRect(0, 0, 300, 70); color = Pixmap.make(200, 200, 200, (((TimeUtils.nanoTime() - loadStart) % 1000000000) / 1000000000f)); context.setFillStyle(color); context.setStrokeStyle(color); context.fillRect(0, 0, 300 * (loaded / (float)total) * 0.97f, 70); context.setFillStyle(Pixmap.make(50, 50, 50, 1)); context.fillText(\u0026#34;loading\u0026#34;, 300 / 2, 70 / 2); } @Override public void error (String file) { System.out.println(\u0026#34;error: \u0026#34; + file); } }; } 请注意，你只能使用纯GWT工具来显示加载画面，libgdx相关的API要在预加载完成后才可用。\n上一章|libGDX的模块\n下一章|查询libGDX运行环境相关信息\n","date":"July 22, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/libgdx/libgdx%E7%9A%84%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%92%8C%E9%85%8D%E7%BD%AE/","series":[{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/series/libgdx/"},{"title":"libGDX手册","url":"https://www.qinxiandiqi.sbs/series/libgdx%E6%89%8B%E5%86%8C/"}],"smallImg":"","tags":[{"title":"libgdx","url":"https://www.qinxiandiqi.sbs/tags/libgdx/"},{"title":"游戏引擎","url":"https://www.qinxiandiqi.sbs/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"title":"跨平台","url":"https://www.qinxiandiqi.sbs/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"title":"启动类","url":"https://www.qinxiandiqi.sbs/tags/%E5%90%AF%E5%8A%A8%E7%B1%BB/"},{"title":"初始化","url":"https://www.qinxiandiqi.sbs/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"}],"title":"LibGDX的启动类和配置"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/categories/libgdx/"},{"title":"libGDX手册","url":"https://www.qinxiandiqi.sbs/categories/libgdx%E6%89%8B%E5%86%8C/"}],"content":" 原文作者：libGDX\n原文地址：https://github.com/libgdx/libgdx/wiki/Modules-overview\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2018-07-15版本翻译\n译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接。\nLibGDX，对应典型游戏设计架构的每个步骤，它都提供了一系列模块来提供相应服务。\nInput输入模块 - 为所有平台提供了统一的输入和处理模型。它支持键盘、触屏、加速度计和鼠标等可用输入设备。 Graphics图形模块 - 它通过OpenGL ES API的方式使用硬件，将图形绘制到屏幕上。 Files文件模块 - 它不关心具体操作的媒体文件类型，它为所有平台统一提供了抽象化的，简易的方法来进行媒体文件的读写操作。 Audio音频模块 - 提供了有助于在所有平台上录制和播放音频的功能。 Networking网络模块 - 提供执行网络操作的相关方法，例如简单的HTTP GET和POST请求，TCP server/client socket连接等等。 下图是一个简单游戏架构中libGDX各个模块的结构：\n下面章节将简单描述各个模块的一些常用例子。\nInput模块# Input输入模块能够在所有平台上轮询不同输入源的状态，它能够轮询每一个键盘的键、触屏设备和加速度计的状态。在桌面平台上，触屏设备会使用鼠标来替代，但加速度计一般不支持。\n它同时也支持注册输入处理器来消耗基于Input模块产生的特定事件。\n下面的代码片段在触摸事件（或者是桌面平台上的鼠标点击事件）产生时，捕获这个事件并获取它的坐标：\nif (Gdx.input.isTouched()) { System.out.println(\u0026#34;Input occurred at x=\u0026#34; + Gdx.input.getX() + \u0026#34;, y=\u0026#34; + Gdx.input.getY()); } 只要使用以上类似的方法就可以轮询和处理所有支持的事件类型。\nGraphics图形模块将和GPU的通讯交互进行抽象化，并提供了简单的方法来获取OpenGL ES的包装实例。它的内部会管理好所有用来获取和持有OpenGL实例的标准化代码，并处理好设备生产商实现的所有细节。\n取决于底层的硬件，（OpenGL ES的）包装实例可能可用也可能不可用（译注：如果硬件设备不支持，该模块功能就不能用了）。\n另外，Graphics模块同时也提供了一些方法来生成Pixmap和Texture。\n例如，为了获取OpenGL API 2.0版本的实例，可以使用以下代码：\nGL20 gl = Gdx.graphics.getGL20 (); 这个方法会返回一个实例，用来绘制图形到屏幕上。在这段代码中，如果硬件不支持OpenGL ES v2.0的话，这个方法会返回null。\n下面的代码会擦除屏幕内容，并填充红色：\ngl.glClearColor(1f, 0.0f, 0.0f, 1); gl.glClear(GL20.GL_COLOR_BUFFER_BIT); 这些方法始终会返回\u0008OpenGL API在特定平台（lwjgl，jogl或Android）的具体实现，因此游戏主程序不需要知道具体的实现细节，它可以在所有libGDX支持的平台上运行。\nlibGDX支持以下OpenGL API版本：\nGL版本 访问方法 2.0 Gdx.graphics.getGL20(); 3.0 Gdx.graphics.getGL30(); 更多关于Graphics图形模块的内容请参考这个文档。\nFiles文件模块提供了一种通用的方法来访问文件，使得使用文件的时候不需要考虑游戏具体运行在什么平台上，它让文件的读写变得更简单。不过，\u0008由于不同平台的安全限制，在文件写入方面会有一点限制。\n使用Files文件模块最常见的场景是从应用程序的同一个子目录中为所有平台加载游戏资源（纹理、音频文件等）。它同样也常被用来将游戏玩家的高分记录或游戏状态写入到文件里面。\n下面的例子加载并创建了位于$APP_DIR/assets/textures目录下的brick.png纹理\u0008：\nTexture myTexture = new Texture(Gdx.files.internal(\u0026#34;assets/textures/brick.png\u0026#34;)); 这是一个非常强大的抽象层，它使得相同的代码能够适用于Android和桌面端。\nAudio音频模块使得创建和播放音频文件变得非常简单。它同样也允许直接访问音频硬件。\n它能够处理两种类型的音频文件：Music(音乐)和Sound(声音)。两种类型都支持WAV、MP3和OGG格式。\nSound声音是直接被加载到内存中，所以能够随时播放。\u0008它非常适用于游戏中可能会被播放多次的音效，例如爆炸声和枪击声等。\nMusic音乐采用另一种加载方式，它是将硬盘（或者SD卡）上的文件以数据流的方式进行加载。每次播放一个音频文件，它都会以数据流的方式将文件加载到音频设备上。\n下面的代码会从硬盘上加载并循环播放音频文件\u0008myMusicFile.mps，同时将音量调低到一半：\nMusic music = Gdx.audio.newMusic(Gdx.files.getFileHandle(\u0026#34;data/myMusicFile.mp3\u0026#34;, FileType.Internal)); music.setVolume(0.5f); music.play(); music.setLooping(true); Networking网络模块为游戏的网络操作提供了一些有用的功能，它能被用于添加多人游戏，发送玩家数据到你的网站，或者执行其它一些网络操作。这些功能能够跨平台使用，虽然有些平台可能需要添加一些额外的设置或者缺少一些功能。\nNetworking模块提供了可配置化的TCP client和server socket，可以通过配置来进行优化以达到低延迟。\n另外，它也提供了一些方法和工具来发起HTTP请求。其中一个工具就是Request Builder，它采用链式调用的方式来简单创建一个HTTP请求。\nRequest Builder通过类似以下代码来创建一个HTTP请求：\nHttpRequestBuilder requestBuilder = new HttpRequestBuilder(); HttpRequest httpRequest = requestBuilder.newRequest() .method(HttpMethods.GET) .url(\u0026#34;http://www.google.de\u0026#34;) .build(); Gdx.net.sendHttpRequest(httpRequest, httpResponseListener); 它同样也可以在创建HTTP请求的时候添加参数：\nHttpRequestBuilder requestBuilder = new HttpRequestBuilder(); HttpRequest httpRequest = requestBuilder.newRequest() .method(HttpMethods.GET) .url(\u0026#34;http://www.google.de\u0026#34;) .content(\u0026#34;q=libgdx\u0026amp;example=example\u0026#34;) .build(); Gdx.net.sendHttpRequest(httpRequest, httpResponseListener); 上一章|libGDX的生命周期\n下一章|libGDX的启动类和配置\n","date":"July 15, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/libgdx/libgdx%E7%9A%84%E6%A8%A1%E5%9D%97/","series":[{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/series/libgdx/"},{"title":"libGDX手册","url":"https://www.qinxiandiqi.sbs/series/libgdx%E6%89%8B%E5%86%8C/"}],"smallImg":"","tags":[{"title":"libgdx","url":"https://www.qinxiandiqi.sbs/tags/libgdx/"},{"title":"游戏引擎","url":"https://www.qinxiandiqi.sbs/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"title":"模块","url":"https://www.qinxiandiqi.sbs/tags/%E6%A8%A1%E5%9D%97/"},{"title":"跨平台","url":"https://www.qinxiandiqi.sbs/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"}],"title":"LibGDX的模块"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/categories/libgdx/"},{"title":"libGDX手册","url":"https://www.qinxiandiqi.sbs/categories/libgdx%E6%89%8B%E5%86%8C/"}],"content":" 原文作者：libGDX\n原文地址：https://github.com/libgdx/libgdx/wiki/The-life-cycle\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2018-07-01版本翻译\n译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途。\n应用程序的开发者通过实现ApplicationListener接口来接管\u0008libGDX应用程序的生命周期事件。ApplicationListener的实例需要传递给底层平台的Application实例（参考libGDX的应用框架）。之后\u0008，\u0008每当有应用程序级别的生命周期事件发生时，Application都会回调ApplicationListener。\u0008一个简单的ApplicationListener空实现大致如下：\npublic class MyGame implements ApplicationListener { public void create () { } public void render () { } public void resize (int width, int height) { } public void pause () { } public void resume () { } public void dispose () { } } 如果不需要关注所有的生命周期事件，也可以选择继承ApplicationAdapter类\u0008，然后有选择的重写需要的生命周期方法。\n一旦ApplicationListener被传递到Application，它的方法将会在以下情况被回调：\n方法签名 描述 create () 创建应用程序的时候会被回调，它只会被回调一次。 resize(int width, int height) 只要\u0008\u0008游戏不在Pause停止生命周期状态下，每次游戏的屏幕窗口尺寸发生变化都会回调这个方法。另外，create()方法被回调之后，它也会被回调一次。这个方法的参数是屏幕变化之后\u0008新的\u0008屏幕宽高，单位是像素。 render () 每次应用程序\u0008循环游戏的\u0008渲染过程都会执行这个方法。游戏的刷新逻辑通常也会放在这个方法里面执行。 pause () 在Android平台上，当按了Home键或者有电话拨入等情况时，这个方法都会被回调。如果是在桌面平台上，只有在退出应用程序时，它会在dispose()被回调之前执行一次。 如果要\u0008保存游戏的状态，这个方法是个很合适的地方。 resume () 这个方法只会在Android平台上被调用，它只会在应用程序从Pause停止状态恢复运行的时候被调用。 dispose () 当应用程序被销毁的时候会调用这个方法。在它被调用之前会先回调pause()方法。 \u0008下面的图可以直观的看出整个生命周期：\nLibgdx属于事件驱动模型，因为这也是Android和\u0008Javascript的工作模式，它没有明确的主循环。如果非要\u0008扯的话，ApplicationListener.render()方法也可以考虑看作是主循环方法。\nLibGDX和Android的生命周期\n如果你的目标平台是Android的话，这篇文章会跟你解释清楚为什么不要使用静态变量。\n","date":"July 1, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/libgdx/libgdx%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","series":[{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/series/libgdx/"},{"title":"libGDX手册","url":"https://www.qinxiandiqi.sbs/series/libgdx%E6%89%8B%E5%86%8C/"}],"smallImg":"","tags":[{"title":"libgdx","url":"https://www.qinxiandiqi.sbs/tags/libgdx/"},{"title":"游戏引擎","url":"https://www.qinxiandiqi.sbs/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"title":"生命周期","url":"https://www.qinxiandiqi.sbs/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"跨平台","url":"https://www.qinxiandiqi.sbs/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"}],"title":"LibGDX的生命周期"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/categories/libgdx/"},{"title":"libGDX手册","url":"https://www.qinxiandiqi.sbs/categories/libgdx%E6%89%8B%E5%86%8C/"}],"content":" 原文作者：libGDX\n原文地址：https://github.com/libgdx/libgdx/wiki/The-application-framework\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2018-06-30版本翻译\n译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途。\n作为libGDX的核心（译注：也是\u0008libGDX实现跨平台的基础），\u0008libGDX提供了6个通用接口来与具体的操作系统进行交互，不同的操作系统对这6个接口有不同的具体实现。\nApplication接口：运行的应用程序并负责通知API终端（译注：实现相关API，接收libGDX提供服务的处理终端程序，例如你的游戏\u0008实现程序）与应用程序级别相关的事件，例如窗口尺寸变化事件。它也提供了一些日志工具和查询方法，例如内存使用情况等。 Files接口：暴露具体平台\u0008底层文件系统的接口。它提供了一些抽象方法，用于获取在libGDX自定义的文件系统中不同路径来源的文件，需要注意的是这些文件不是直接使用Java的File类。（译注：简单来说，libGDX自己定义了一套处理文件的文件系统和接口，这个文件系统在不同的平台上进行不同的实现，以屏蔽不同平台的文件系统细节，\u0008从而实现跨平台）。 Input接口：负责将用户的输入通知API终端的接口，例如鼠标、键盘、触屏或者加速度计事件。它支持轮询和事件驱动处理模式。 Net接口：提供通过HTTP/HTTPS\u0008跨平台访问资源方式的接口，它也包括创建TCP\u0008服务和\u0008socket客户端方式。 Audio接口：提供播放音效和音乐\u0008流的接口，通过这些接口就好像\u0008你可以直接访问PCM音频输入/输出设备一样。 Graphics接口：\u0008暴露OpenGL ES 2.0(如果可用的话)的接口，它允许查询或者设置\u0008视频的模式或者其它类似的操作。 针对特定平台需要编写特定的代码，这段代码也叫做程序的启动类。对于每一个特定的平台都需要一段特定的代码来创建一个实现Application接口的类实例（这个Application接口实现类具体如何实现\u0008是由运行时依赖的平台决定的）。例如桌面平台的这段启动类代码可能如下，它的底层使用Lwjgl作为依赖平台：\npublic class DesktopStarter { public static void main(String[] argv) { LwjglApplicationConfiguration config = new LwjglApplicationConfiguration(); new LwjglApplication(new MyGame(), config); } } 对于Android平台，相应的启动类代码可能如下：\npublic class AndroidStarter extends AndroidApplication { public void onCreate(Bundle bundle) { super.onCreate(bundle); AndroidApplicationConfiguration config = new AndroidApplicationConfiguration(); initialize(new MyGame(), config); } } 这两个类的代码通常放在不同的project里面，例如一个桌面project和一个Android project。在Project的设置，运行和调试章节会介绍在Eclipse工程项目里面这些project文件的布局。\n应用程序的实际逻辑代码是放在ApplicationListener接口的实现类里面（在上面的例子里，这个实现类是MyGame）。这个类的实例会被传递到\u0008\u0008底层平台的Application接口实现类的初始化方法。Application会在适当的时机回调ApplicationListener的相关方法（具体参考libGDX的生命周期）。\n参考libGDX的启动类和配置章节查看具体的入口类细节。\n上面提到的libGDX模块可以通过Gdx类的静态变量访问。这实际上是一些全局变量，\u0008以便能够简单访问到libGDX的各个模块。虽然这一般被认为是一种很糟糕的代码实现，但我们仍然决定使用这种机制来缓解在各个代码库中传递和管理各种环境引用而引发的痛苦。\n要访问\u0008模块，例如访问audio音频模块的代码简单如下：\n// 使用audio音频模块创建一个16位PCM采样率的AudioDevice AudioDevice audioDevice = Gdx.audio.newAudioDevice(44100, false); Gdx.audio是一个底层\u0008（平台）实例的引用，它是在Application实例初始化应用程序的时候创建的。其它的模块也是通过类似的方法来访问，例如：Gdx.app可以获取Application实例，Gdx.files可以访问Files模块的实例等等。\n下一章|libGDX的生命周期\n","date":"July 1, 2018","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/libgdx/libgdx%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/","series":[{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/series/libgdx/"},{"title":"libGDX手册","url":"https://www.qinxiandiqi.sbs/series/libgdx%E6%89%8B%E5%86%8C/"}],"smallImg":"","tags":[{"title":"libgdx","url":"https://www.qinxiandiqi.sbs/tags/libgdx/"},{"title":"open GL","url":"https://www.qinxiandiqi.sbs/tags/open-gl/"},{"title":"游戏引擎","url":"https://www.qinxiandiqi.sbs/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"跨平台","url":"https://www.qinxiandiqi.sbs/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"}],"title":"LibGDX的应用框架"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/categories/libgdx/"}],"content":" 原文作者：Jianan - qinxiandiqi@foxmail.com\n原文地址：http://blog.csdn.net/qinxiandiqi\n版本信息：2017-11-18\n版权声明：本文采用CC BY-NC-ND 4.0共享协议。允许复制和转载，但必须在文首显眼位置保留原文作者、原文链接、版本信息、版权声明等信息。不允许演绎和用于商业用途。\nlibGDX本身已经提供了截屏功能，先看下libGDX的wiki提供的方法：\nbyte[] pixels = ScreenUtils.getFrameBufferPixels(0, 0, Gdx.graphics.getBackBufferWidth(), Gdx.graphics.getBackBufferHeight(), true); Pixmap pixmap = new Pixmap(Gdx.graphics.getBackBufferWidth(), Gdx.graphics.getBackBufferHeight(), Pixmap.Format.RGBA8888); BufferUtils.copy(pixels, 0, pixmap.getPixels(), pixels.length); PixmapIO.writePNG(Gdx.files.external(\u0026#34;mypixmap.png\u0026#34;), pixmap); pixmap.dispose(); 简单解释下上面这段代码，整个截屏的过程分两步走：\n获取将要截屏出来的图片像素数据。libGDX提供了ScreenUtils这个工具类，使用这个工具类的getFrameBufferPixels()方法，再设定相关参数获取当前帧缓存中指定位置的像素数据（byte字节数组）。 将获取的图片像素数据输出到Pixmap对象（Pixmap是libGDX提供的用于处理图片的类），再由pixmap将图片像素处理为最终的图片数据并输出到文件，完成截屏图片输出。 总结一下，libGDX截屏的过程，实际上就是读取帧缓冲区的一帧像素数据后封装成图片数据，再输出到图片文件。\n那么问题来了，截屏出来的图片最大能有多大，绘制在屏幕外边的内容是否也能截图出来？ 可以换一种方式来思考一下。既然截屏的过程实际上就是保存帧缓冲区中的一帧像素数据，截屏出来的图片能有多大自然受限于帧缓冲区的大小。那么libGDX的帧缓冲区到底有多大呢？\nlibGDX游戏引擎的优点就是开源，所有源码都可以查看。libGDX在android平台上底层使用的是OpenGL，初始化OpenGL的代码被放在AndroidGraphics类中。这个类实现了android.opengl.GLSurfaceView.Renderer接口，在onSurfaceCreated()方法中有这么一段设置OpenGL viewport的代码：\n@Override public void onSurfaceCreated (javax.microedition.khronos.opengles.GL10 gl, EGLConfig config) { ... Display display = app.getWindowManager().getDefaultDisplay(); this.width = display.getWidth(); this.height = display.getHeight(); ... gl.glViewport(0, 0, this.width, this.height); } 可以看到OpenGL viewport的宽高使用了当前设备屏幕的宽高，也就是说，libGDX默认的帧缓冲区大小就是设备屏幕的尺寸，截屏最大也就是截取屏幕上显示的内容，超出帧缓冲区的内容由于没有记录像素数据，保存下来就变成黑色区域。\n在某些需求下，期望可以将逻辑上绘制在屏幕范围之外的内容也能够截屏保存下来，怎么办呢？改变帧缓冲区的大小，调整帧缓冲区的大小超出屏幕，渲染绘制之后，屏幕范围之外的帧缓冲区也就有数据了。\nlibGDX提供了FrameBuffer这个工具可以创建一个帧缓冲区，在FrameBuffer.begin()和FrameBuffer.end()方法之间绘制的内容都会输入到FrameBuffer缓冲区中。截屏的流程调整如下：\n//创建一个帧缓冲区，指定帧缓冲区的像素格式类型、帧宽高等属性 FrameBuffer frameBuffer = new FrameBuffer(Pixmap.Format.RGBA8888, bufferWidth, bufferHeight, false); //开始绘制，从这里开始绘制的数据都会输出到frameBuffer缓冲区，输入的才可以截屏出来 frameBuffer.begin(); ... //开始截屏，还是上文提到的截屏方法，不过这里帧缓冲区已经变成我们创建的FrameBuffer缓冲区 //captureWidth和captureHeight为最终截图的尺寸，不得大于设定的缓冲区尺寸大小 byte[] pixels = ScreenUtils.getFrameBufferPixels(0, 0, captureWidth, captureHeight, true); Pixmap pixmap = new Pixmap(captureWidth, captureHeight, Pixmap.Format.RGBA8888); BufferUtils.copy(pixels, 0, pixmap.getPixels(), pixels.length); PixmapIO.writePNG(Gdx.files.external(\u0026#34;mypixmap.png\u0026#34;), pixmap); pixmap.dispose(); //截屏结束，关闭缓冲区 frameBuffer.end();\t//不再使用的frameBuffer需要销毁 frameBuffer.dispose();\t需要注意，不再使用FrameBuffer需要dispose销毁。\n","date":"November 18, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/libgdx/libgdx%E6%88%AA%E5%8F%96%E8%B6%85%E5%87%BA%E5%B1%8F%E5%B9%95%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%9B%BE%E7%89%87/","series":[{"title":"libGDX","url":"https://www.qinxiandiqi.sbs/series/libgdx/"}],"smallImg":"","tags":[{"title":"libgdx","url":"https://www.qinxiandiqi.sbs/tags/libgdx/"},{"title":"截屏","url":"https://www.qinxiandiqi.sbs/tags/%E6%88%AA%E5%B1%8F/"},{"title":"尺寸","url":"https://www.qinxiandiqi.sbs/tags/%E5%B0%BA%E5%AF%B8/"},{"title":"帧缓冲区","url":"https://www.qinxiandiqi.sbs/tags/%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA/"}],"title":"LibGDX截取超出屏幕大小的图片"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Android Tips","url":"https://www.qinxiandiqi.sbs/categories/android-tips/"}],"content":" 原文作者：Jianan - qinxiandiqi@foxmail.com\n原文地址：http://blog.csdn.net/qinxiandiqi/article/details/73556668\n版本信息：2017-06-21\n版权声明：本文采用CC BY-NC-ND 4.0共享协议。允许复制和转载，但必须在文首显眼位置保留原文作者、原文链接、版本信息、版权声明等信息。不允许演绎和用于商业用途。\nDrawerLayout抽屉菜单常用来做简单的左右侧滑菜单，默认效果是侧滑菜单覆盖在主内容区域上：\n可以改变DrawerLayout的默认侧滑效果，比如实现常见的主内容区域跟随侧滑菜单滑动而滑动，甚至如QQ侧滑菜单等复杂效果。实现的关键在于利用**DrawerLayout.addDrawerListener(DrawerLayout.DrawerListener)**方法，给DrawerLayout添加DrawerListener监听。\nDrawerLayout.DrawerListener是监听DrawerLayout状态变化的一个内部类。实现DrawerListener.onDrawerSlide(View drawerView, float slideOffset)方法，第一个drawerView参数为作为侧滑菜单的View，第二个参数slideOffset为侧滑菜单滑动过程中移动的距离比例，范围从0到1。当侧滑菜单在滑动的过程中会回调这个方法，借助这个方法可以知道侧滑菜单当前的滑动距离从而调整其它View的属性，这样就可以实现多种多样的侧滑效果。\n例如简单实现主内容区跟随侧滑菜单滑动而滑动的效果：\ndrawerLayout.addDrawerListener(new DrawerLayout.DrawerListener() { @Override public void onDrawerSlide(View drawerView, float slideOffset) { vMain.setX(drawerView.getWidth() * slideOffset); } ... }); 其中vMain为主内容区的View，看下效果：\n","date":"June 22, 2017","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/drawerlayout%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%A0%B7%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95%E6%95%88%E6%9E%9C/","series":[{"title":"Android Tips","url":"https://www.qinxiandiqi.sbs/series/android-tips/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"抽屉式菜单","url":"https://www.qinxiandiqi.sbs/tags/%E6%8A%BD%E5%B1%89%E5%BC%8F%E8%8F%9C%E5%8D%95/"},{"title":"滑动效果","url":"https://www.qinxiandiqi.sbs/tags/%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C/"},{"title":"侧滑菜单","url":"https://www.qinxiandiqi.sbs/tags/%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95/"}],"title":"DrawerLayout实现多样侧滑菜单效果"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Android Tips","url":"https://www.qinxiandiqi.sbs/categories/android-tips/"}],"content":" 原文作者：Jianan - qinxiandiqi@foxmail.com\n原文地址：http://blog.csdn.net/qinxiandiqi/article/details/53783402\n版本信息：2016-12-21\n版权声明：本文采用CC BY-NC-ND 4.0共享协议。允许复制和转载，但必须在文首显眼位置保留原文作者、原文链接、版本信息、版权声明等信息。不允许演绎和用于商业用途。\n在Android的string.xml文件中，如果定义的字符串资源包含两个或两个以上的格式化占位符，比如：\n\u0026lt;string name=\u0026#34;version_format\u0026#34;\u0026gt;v%d - %s\u0026lt;/string\u0026gt; 那么你在编译的时候可能会遇到以下的错误：\n出现这个错误的原因在于aapt在编译时对字符串资源中的格式化占位符进行比较严格的校验，解决方案有两种：\n使用完整的格式化占位符形式：%[index]$[type]，其中index表示该占位符在字符串所有占位符的序号，type表示该占位符的数据类型，比如上面的例子改成： \u0026lt;string name=\u0026#34;version_format\u0026#34;\u0026gt;v%1$d - %2$s\u0026lt;/string\u0026gt; 在string.xml中添加formatted属性为false表明对应的字符串资源为非格式化字符串，比如上面的例子改成： \u0026lt;string name=\u0026#34;version_format\u0026#34; formatted=\u0026#34;false\u0026#34;\u0026gt;v%d - %s\u0026lt;/string\u0026gt; 建议使用第一种完整格式化占位符形式的方法解决这个问题。\n","date":"December 21, 2016","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/android%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/","series":[{"title":"Android Tips","url":"https://www.qinxiandiqi.sbs/series/android-tips/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"格式化","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96/"}],"title":"Android字符串资源使用格式化占位符的正确姿势"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":" 原文作者：Jianan - qinxiandiqi@foxmail.com\n原文地址：http://blog.csdn.net/qinxiandiqi/article/details/51744782\n版本信息：2016-06-23\n版权声明：本文采用CC BY-NC-ND 4.0共享协议。允许复制和转载，但必须在文首显眼位置保留原文作者、原文链接、版本信息、版权声明等信息。不允许演绎和用于商业用途。\nandroid对于所有进程的处理态度都是尽可能不杀死。然而，资源总共就那么多，要是对所有进程都保持宽容的话，资源总会有消耗殆尽的时候。因此，在内存不足的情况，android系统需要根据一定的策略，选择性的杀死部分进程。这个策略就是对所有的进程标记优先级，优先级低的先杀死。\nandroid将进程的优先级分为5个层次，按照优先级由高到低排列如下：\n前台进程（Foreground process）。它表明用户正在与该进程进行交互操作，android系统依据下面的条件来将一个进程标记为前台进程：\n该进程持有一个用户正在与其交互的Activity（也就是这个activity的生命周期方法走到了onResume()方法）。 该进程持有一个Service，并且这个Service与一个用户正在交互中的Activity进行绑定。 该进程持有一个前台运行模式的Service（也就是这个Service调用了startForegroud()方法）。 该进程持有一个正在执行生命周期方法（onCreate()、onStart()、onDestroy()等）的Service。 该进程持有一个正在执行onReceive()方法的BroadcastReceiver。 一般情况下，不会有太多的前台进程。杀死前台进程是操作系统最后无可奈何的做法。当内存严重不足的时候，前台进程一样会被杀死。\n可见进程（Visible process）。它表明虽然该进程没有持有任何前台组件，但是它还是能够影响到用户看得到的界面。android系统依据下面的条件将一个进程标记为可见进程：\n该进程持有一个非前台Activity，但这个Activity依然能被用户看到（也就是这个Activity调用了onPause()方法）。例如，当一个activity启动了一个对话框，这个activity就被对话框挡在后面。 该进程持有一个与可见（或者前台）Activity绑定的Service。 服务进程（Service process）。除了符合前台进程和可见进程条件的Service，其它的Service都会被归类为服务进程。\n后台进程（Background process）。持有不可见Activity（调用了onStop()方法）的进程即为后台进程。通常情况下都会有很多后台进程，当内存不足的时候，在所有的后台进程里面，会按照LRU（最近使用）规则，优先回收最长时间没有使用过的进程。\n空进程（Empty process）。不持有任何活动组件的进程。保持这种进程只有一个目的，就是为了缓存，以便下一次启动该进程中的组件时能够更快响应。当资源紧张的时候，系统会平衡进程缓存和底层的内核缓存情况进行回收。\n如果一个进程同时满足上述5种优先级中的多个等级条件，android系统会优先选取其中最高的等级作为该进程的优先级。例如，一个进程持有一个Service（服务进程等级）和一个前台Activity（前台进程等级），那么操作系统会将这个进程标记为前台进程。\n另外需要注意的是，如果一个进程为另外一个进程提供服务，那么这个进程的优先级不会低于享受服务的进程。例如，假设进程A中的content provider为进程B提供服务，或者进程A中有一个Service与进程B中的组件进程绑定，那么进程A的优先级至少要与进程B一致，或者高于进程B。\n参考：https://developer.android.com/guide/components/processes-and-threads.html\n","date":"June 23, 2016","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/android%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"进程","url":"https://www.qinxiandiqi.sbs/tags/%E8%BF%9B%E7%A8%8B/"},{"title":"优先级","url":"https://www.qinxiandiqi.sbs/tags/%E4%BC%98%E5%85%88%E7%BA%A7/"}],"title":"Android的进程优先级"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":" 原文作者：Google 原文地址：https://developer.android.com/guide/topics/graphics/prop-animation.html\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2016-06-17版本翻译\n译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n属性动画（Property Animation）系统是一个更加强大的框架，它几乎允许你为任何东西设置动画。不管一个对象是否需要绘制到屏幕上面，你都可以定义一个动画让这个对象的属性随着时间推移而改变。一个属性动画可以在规定的时间内改变一个属性值（对象的一个成员变量）。设定动画，你需要指定对象中需要设定动画的属性，例如对象在屏幕上的坐标，动画需要执行的时间，以及动画过程中属性的变化值。\n属性动画系统允许你为一个动画设定以下属性：\n时长：你可以指定动画的时长。默认的动画时长是300毫秒。 时间插值器：你可以设定一个根据当前动画已经执行的时间计算出对应属性值的方法（它被称为时间插值器）。 重复次数和行为：你可以设定当动画结束之后是否需要自动重复执行，以及可以重复执行多少次。你同样也可以设定动画是否需要反向回放，设定动画来回反复反向回放，直到完成动画设定的重复次数。 动画组：你可以在一个动画组里面逻辑嵌套多个动画，让这些动画同时播放，或者顺序播放，或者延迟一定的时间后播放。 延迟帧刷新：你可以设定动画帧与帧之间的刷新频率。默认设定是每10毫秒刷新一次，但你的应用程序实际刷新的帧频率最终还是要取决于整体系统的繁忙程度，以及系统底层能够支持的定时器有多快。 首先，我们通过一个简单的示例来了解下动画的工作过程。图1假设了一个对象需要对它的x属性设定动画，这个x属性代表这个对象在屏幕上面的横坐标。这个动画的时间设定为40毫秒，以及需要移动的距离是40个像素。每过10毫秒（默认的帧频率），这个对象就会在水平方向上移动10个像素。等到40毫秒之后，这个动画停止，对象在水平方向上总共移动了40个像素。这个例子中的动画使用了一个线性插值器，意味着这个对象以匀速移动。\n图1：线性动画示例\n你也可以设定动画使用一个非线性插值器。图2演示了一个假设的对象在动画的一开始进行加速，等动画快结束的时候进行减速。这个对象一样在40毫秒中总共移动40个像素点，但移动是非线性的。在一开始，动画加速移动到中间点，然后从中间点一直减速到动画结束。正如图2所示，一开始和将近结束的时候移动的距离比中间时段移动的距离要小。\n图2：非线性动画示例\n让我们来仔细看一下属性动画系统的重要组成部分是如何像上面的插图一样计算动画的。图3描述了属性动画系统中一些主要类之间的相互关系。\n图3：动画如何计算\nValueAnimator对象负责跟踪动画的时序，比如这个动画已经运行了多久，以及当前的动画属性值是多少。\nValueAnimator对象中包含了一个TimeInterpolator对象，用来定义动画的插值器；另外还包含了一个TypeEvaluator对象，这个对象定义了如何根据动画的执行程度计算出对应的属性值。例如，在图2中，TimeInterpolator使用的是AccelerateDecelerateInterpolator，TypeEvaluator使用的是IntEvaluator。\n启动一个动画，需要创建一个ValueAnimator对象，并给它设定动画开始和结束时的属性值，以及动画的执行时间。当你调用**start()**方法启动动画，在整个动画执行期间，ValueAnimator会基于整个动画需要执行的时间以及当前已经执行的动画时间，计算出一个从0到1的值，表示已消耗的时间比例。这个已消耗的时间比例代表了动画已完成的百分比，0表示0%，1就表示100%。例如，在图1中，当t=10ms的时候，这个已消耗的时间比例就是0.25，因为整个动画时长为40ms。\n当ValueAnimator完成了一次已消耗的时间比例计算，它就会调用当前设定的TimeInterpolator去计算对应的（属性）插值比例。插值比例根据所设定的时间插值器将已消耗的时间比例映射到一个新的比例值上。例如，在图2中，由于动画缓慢加速，在t=10ms的时候，它的插值比例大概是0.15，显然比已消耗的时间比例0.25要小，因此在这个时间点上，属性值将会是0.15 * （40-0），也就是6个像素点。\n在API Demo的com.example.android.apis.animation 包中提供了一些关于如何使用属性动画系统的实例代码。\n视图动画（View Animation）系统只提供了给View对象设置动画的功能，如果你要给非View对象设置动画，你只能完全依靠自己来实现相关的逻辑代码。实际上，视图动画还受限于只能对View对象的一部分属性设置动画，例如它可以缩放和旋转一个View，但是无法改变view的背景颜色等等。\n视图动画系统还有一个缺点就是它实际上只修改了View对象的绘制位置，而不是View的本身。举个例子，使用视图动画你可以将一个按钮从屏幕上移动过去，这个按钮能够正确的绘制到目标位置上，但这个按钮的点击位置实际上没有随着按钮移动而移动，因此你需要自己实现对应的代码响应逻辑来处理这个问题。\n使用属性动画系统就完全没有这样的限制，你可以给一个对象（View对象或者非View对象）的任意属性设定动画，随着动画的执行，对象的属性也会跟着一起改变。属性动画系统同样提供了更强大的功能来实现动画协作。在更高的等级上，你可以为多个属性添加多个动画（例如颜色、坐标、大小），然后定义动画的各个方面（例如插值器和多个动画同步运作）。\n视图动画系统，相对的，配置起来需要花费的时间会少一点，需要的代码量也会少一点。如果视图动画已经能够满足你所有的要求，或者你现有的代码中已经使用了视图动画，那么你也不是非得使用属性动画系统才可以。在某些特别的情况下，为不同的情景使用不同的动画系统也是合情合理的。\n你可以在android.animation 包中找到大部分属性动画系统的API。由于视图动画系统已经在android.view.animation 包中定义了很多插值器，你也可以在属性动画系统中直接使用这些插值器。下面的表格中列举了属性动画系统的主要组件。\nAnimator 类中提供了创建动画的基本结构。一般情况下你不需要直接使用这个类，继承这个类只能够提供满足属性动画的最少方法。一般使用的是下面这些Animator的子类：\n表1：Animator\n类名 描述 ValueAnimator 属性动画主要的时序引擎，它还要计算动画过程中的属性值。它包含了全部计算动画值的核心功能，还包含了每一个动画的时序细节、关于动画重复的信息、接收更新事件的监听器、以及设定自定义类型来计算的功能。执行属性动画包含两个部分：计算变化的属性值以及给对象设定计算出来的属性值，属性动画就是这么执行的。ValueAnimator不负责第二部分，因此你需要监听ValueAnimator计算出来的属性值更新，并使用自己的代码逻辑把这些属性值赋值给你想要执行动画的属性。更多细节请参考下面的使用ValueAnimator执行动画章节。 ObjectAnimator 这是ValueAnimator的一个子类，它允许你设定一个目标对象和目标对象中需要执行动画的属性。这个类会在计算出新的属性值时自动更新对象的属性。大多数情况下，你都会使用ObjectAnimator，因为这个类能让设定目标对象的属性动画更加容易。然而，也有一些情况下需要直接使用ValueAnimator，因为ObjectAnimator有一些限制，例如它需要在目标对象上指定特定的计算方法。 AnimatorSet 这个类提供了一个机制来组合多个动画，让动画与动画之间关联起来。你可以设定多个动画同时执行，或者顺序执行，或者延迟一段时间后执行。更多细节请参考下面使用AnimatorSet编排多个动画章节。 计算器（Evaluator）用于告知属性动画系统如何计算属性值。它们持有Animator类提供的时序数据，动画的初始值和结束值。动画执行过程中的属性值都依赖于这些时序数据。属性动画系统提供了下列计算器： 表2：计算器\n类名/接口 描述 IntEvaluator 默认的用于计算int类型属性的计算器。 FloatEvaluator 默认的用于计算float类型属性的计算器。 ArgbEvaluator 默认的用于计算16进制颜色值属性的计算器。 TypeEvaluator 用于创建自定义计算器的接口。如果你需要设定动画的属性类型不是int、float或者颜色值，那么你就必须实现这个TypeEvaluator接口来定义如何计算动画执行期间的属性值。如果你想要改变int、float或者颜色值类型计算器的默认计算行为，你也可以自定义一个TypeEvaluator实现类来计算这些类型。参考下面使用TypeEvaluator章节来获取关于如何自定义计算器的内容。 时间插值器中定义了一个动画执行过程中针对指定值的时间函数。例如，你可以设定动画在整个过程中线性变化，也就是在整个动画过程中动画会一直均匀的移动。同样的，你也可以设定动画使用非线性的时间过渡，例如，动画在一开始的时候加速，在结尾的时候减速。表3中列举了android.view.animation包中的插值器。如果没有找到适合你的插值器，你可以实现TimeInterpolator接口自定义一个插值器。参考下面使用插值器章节获取更多如何自动以插值器的内容。 表3：插值器\n类/接口 描述 AccelerateDecelerateInterpolator 这个插值器的速率在动画开始和结束的时候变慢，但是在动画的中间会加速。 AccelerateInterpolator 这个插值器的速率会在动画开始的时候缓慢，然后慢慢加速。 AnticipateInterpolator 这个插值器会在动画开始的时候向反方向运动，然后再甩回前进方向。 AnticipateOvershootInterpolator 这个插值器会在动画开始的时候向反方向运动再甩回前进方向，达到动画结束值之后会继续超过结束值再降回结束值。 BounceInterpolator 这个插值器会在动画结束的时候反弹跳动。 CycleInterpolator 这个插值器会让动画按照指定的次数反复执行。 DeceleraterInterpolator 这个插值器的速率会在动画开始的时候很快，然后不停减速。 LinearInterpolator 这个插值器的速率会保持匀速。 OvershootInterpolator 这个插值器会让动画在一开始向前甩出去直到超出设定的结束值后再返回到结束值。 TimeInterpolator 实现自定义的插值器的接口。 ValueAnimator类让你通过设定一些类型值，比如一组int、float或者颜色值，在动画执行期间进行动画过渡。你可以调用ValueAnimator的任意一个工厂方法来获取一个ValueAnimator实例：ofInt()，ofFloat()，或者ofObject()。例如：\nValueAnimator animation = ValueAnimator.ofFloat(0f, 1f); animation.setDuration(1000); animation.start(); 在这段代码中，ValueAnimator调用start()方法后，开始在1000毫秒的时间里面从0到1计算动画过程中对应的数值。\n你也可以使用下面的代码指定一个自定义的动画值类型：\nValueAnimator animation = ValueAnimator.ofObject(new MyTypeEvaluator(), startPropertyValue, endPropertyValue); animation.setDuration(1000); animation.start(); 在这段代码中，ValueAnimator调用start()方法之后，开始使用MyTypeEvaluator提供的计算逻辑，在1000毫秒里面从startPropertyValue到endPropertyValue计算动画过程中对应的数值。\n在上面的代码片段中，其实，并不会对任何对象产生影响，因为ValueAnimator不负责直接操作对象或者属性。你可能想要做的事是根据这些计算值修改需要设定动画的对象。为了实现这个功能，你需要实现一个ValueAnimator中的listener，通过listener在动画的生命周期中适当处理一些重要的事件，例如帧更新。当实现这些listener的时候，你可以通过getAnimatedValue() 方法获取特定帧刷新时的动画值。更多详细内容，请参考下面的动画监听器章节。\nObjectAnimator是ValueAnimator的一个子类（前面章节已经提过了），它集成了时序引擎和ValueAnimator的计算值能力，能够直接操作目标对象中指定的属性。这就让设定任意对象的动画变得更加容易，因为你不再需要去实现ValueAnimator.AnimatorUpdateListener接口，动画属性会自己自动更新。\n实例化一个ObjectAnimator对象跟ValueAnimator很类似，但除了设定动画起始值之外，还需要指定一个对象，并以字符串的形式传入这个对象中需要设定动画的属性名称：\nObjectAnimator anim = ObjectAnimator.ofFloat(foo, \u0026#34;alpha\u0026#34;, 0f, 1f); anim.setDuration(1000); anim.start(); 为了让ObjectAnimator能够正确更新属性，你必须按照下面步骤操作：\n需要设定动画的对象属性必须按照set\u0026lt;PropertyName\u0026gt;() 的形式生成它的setter方法（驼峰风格）。因为ObjectAnimator要在动画执行过程中自动更新属性，它就必须能够通过setter方法访问到这个属性。举个例子，如果属性名是“foo”，你就必须有一个setFoo()方法。如果setter方法真的不存在，你可以有三种选择： 如果你有修改这个类的权限，你可以给这个类添加上对应的setter方法。 使用一个你有权限控制的包装类，在类中使用一个有效的setter方法接收包装值后发送给原对象。 使用ValueAnimator代替 如果你在ObjectAnimator的工厂方法中给values\u0026hellip;参数只设定了一个值，那么这个值会作为动画的结束值使用。因此，你要设定动画的属性还必须提供一个getter方法，用来获取动画开始的属性初始值。这个getter方法必须按照get\u0026lt;PropertyName\u0026gt;() 格式书写。例如，如果这个属性名是“foo”，那么他的getter方法就应该是getFoo()。 需要设定动画的属性getter（如果需要的话）和setter方法操作的数据类型应该与你在ObjectAnimator中指定的数据类型保持一致。例如，如果你使用下面的方法来构造一个ObjectAnimator对象，你就必须持有targetObject.setPropName(float)和targetObject.getPropName(float)方法： ObjectAnimator.ofFloat(targetObject, \u0026#34;propName\u0026#34;, 1f) 取决于你设定动画的属性或者对象，你可能需要调用View的invalidate() 方法来强制屏幕重新绘制属性值有更新的目标对象。你可以在onAnimationUpdate()回调方法中执行这些操作。例如，要执行一个Drawable对象的颜色属性动画，它只会在屏幕重新绘制这个对象后才能看到颜色动画效果。View对象每一个属性的setter方法，例如setAlpha()和setTranslationX()方法都会自动调用invalidate()来刷新View的属性，因此，当调用这些方法给View设定新的属性值时，不需要调用invalidate()方法。更多关于监听器的细节，请参考下面动画监听器章节。 在一些情况下，你需要在一个动画启动或者结束的同时启动另一个动画。android系统允许你使用一个AnimatorSet捆绑多个动画，这样你就可以设定多个动画是否同时执行，还是顺序或者延迟一段时间后再执行。你甚至可以在AnimatorSet对象中嵌套另一个AnimatorSet对象。\n下面的示例代码取自Bouncing Balls示例项目（为修改方便起见），它按照下面的顺序执行动画：\n执行bounceAnim动画。 同时执行squashAnim1、squashAnim2、stretchAnim1和stretchAnim2四个动画。 执行bounceBackAnim动画。 执行fadeAnim动画。 AnimatorSet bouncer = new AnimatorSet(); bouncer.play(bounceAnim).before(squashAnim1); bouncer.play(squashAnim1).with(squashAnim2); bouncer.play(squashAnim1).with(stretchAnim1); bouncer.play(squashAnim1).with(stretchAnim2); bouncer.play(bounceBackAnim).after(stretchAnim2); ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, \u0026#34;alpha\u0026#34;, 1f, 0f); fadeAnim.setDuration(250); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.play(bouncer).before(fadeAnim); animatorSet.start(); 更多如何使用动画套件的复杂示例，请查看Bouncing Balls示例项目。\n你可以使用下面列举的listener（监听器）监听动画执行过程中的重要事件：\nAnimator.AnimatorListener onAnimationStart() - 当动画开始执行时回调。 onAnimationEnd() - 当动画结束的时候回调。 onAnimationRepeat() - 当动画重复的时候回调。 onAnimationCancel() - 当动画被取消的时候回调。无论动画是怎么被结束，即使是被取消的动画，同时也会回调onAnimationEnd()方法。 ValueAnimator.AnimatorUpdateListener onAnimationUpdate() - 动画的每一次帧刷新都会回调。监听这个事件是为了在动画执行过程中使用ValueAnimator计算出来的值。为了使用这些值，需要借用这个回调方法带过来的参数——ValueAnimator实例对象，使用ValueAnimator.getAnimatedValue()方法获取当前动画状态对应的动画值。如果你是直接使用ValueAnimator来实现属性动画，那么你就需要实现这个方法。取决于你设定动画的属性或者对象，你可能需要调用View的invalidate() 方法来强制屏幕重新绘制属性值有更新的目标对象。你可以在onAnimationUpdate()回调方法中执行这些操作。例如，要执行一个Drawable对象的颜色属性动画，它只会在屏幕重新绘制这个对象后才能看到颜色动画效果。View对象每一个属性的setter方法，例如setAlpha()和setTranslationX()方法都会自动调用invalidate()来刷新View的属性，因此，当调用这些方法给View设定新的属性值时，不需要调用invalidate()方法。更多关于监听器的细节，请参考下面动画监听器章节。 如果你不想实现Animator.AnimatorListener接口中的每一个方法，那么你可以选择继承AnimatorListenerAdapter类来取代直接实现Animator.AnimatorListener接口。AnimatorListenerAdapter类提供了Animator.AnimatorListener接口中每一个方法的空实现，你可以有选择的重写其中几个。\n例如，在Bouncing Balls示例项目中创建了一个仅仅重写onAnimationEnd()回调方法的AnimatorListenerAdapter:\nValueAnimatorAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, \u0026#34;alpha\u0026#34;, 1f, 0f); fadeAnim.setDuration(250); fadeAnim.addListener(new AnimatorListenerAdapter() { public void onAnimationEnd(Animator animation) { balls.remove(((ObjectAnimator)animation).getTarget()); } 属性动画系统提供了为ViewGroup对象设定布局动画的功能，这些功能使用起来的效果就像直接为布局中的子View设定动画一样。\n你可以使用LayoutTransition类来为ViewGroup内部对象的改变过程设定动画。当你在一个ViewGroup中添加或移除一个子View，又或者是使用View.setVisibility()给子view设定VISIBLE、INVISIBLE和GONE值，这个子view变化的过程都可以添加显示和消失动画。当你添加或者移除子view的时候，剩余的子view一样也可以使用动画移动到新的位置上。你可以在LayoutTransition对象的**setAnimator()**方法中设定这些动画，这个方法需要传入一个Animator对象和下面列举的一个LayoutTransition常量作为参数值：\nAPPEARING - 这个标识表明设定的动画要在子view从视图容器中显示出来的过程中执行。 CHANGE_APPEARING - 这个标识表明设定的动画要在视图容器中原有的子View由于要显示其它子View而引起自身布局变化时执行。 DISAPPEARING - 这个标识表明设定的动画要在子View从视图容器中消失的时候执行。 CHANGE_DISAPPEARING - 这个标识表明设定的动画要在视图容器中的子view由于其它子view的小时而引起自身布局变化的时候执行。 你可以为你的布局过渡定义上面四种事件类型的自定义动画，也可以让动画系统直接使用默认的动画。\nLayoutAnimations示例项目中介绍了如何为布局过渡定义动画，以及如何把动画设定到View对象上面。\nLayoutAnimationsByDefault示例项目和它的layout_animations_by_default.xml布局文件介绍了如何在xml文件中为ViewGroup开启默认的布局动画。你唯一需要做的事情就是讲ViewGroup的android:animationLayoutChanges属性设置为true。例如：\n\u0026lt;LinearLayout android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:id=\u0026#34;@+id/verticalContainer\u0026#34; android:animateLayoutChanges=\u0026#34;true\u0026#34; /\u0026gt; 将这个属性设置为true之后，ViewGroup中的添加或者移除子View都会有动画效果，同时仍然保留在ViewGroup中的View在这个过程中也会有动画过度效果。\n如果你要给一个android系统未支持的类型添加动画，你可以通过实现TypeEvaluator接口来创建一个自定义计算器。android系统已支持的类型包括int、float、颜色值，它们分别通过IntEvaluator、FloatEvaluator和ArgbEvaluator计算器来实现动画支持。\nTypeEvaluator接口中只包含了一个方法evaluate()。这个方法允许你根据动画当前的执行进度点返回一个合适的属性值。FloatEvaluator实现这个过程的代码如下：\npublic class FloatEvaluator implements TypeEvaluator { public Object evaluate(float fraction, Object startValue, Object endValue) { float startFloat = ((Number) startValue).floatValue(); return startFloat + fraction * (((Number) endValue).floatValue() - startFloat); } } 注意：当ValueAnimator（或者ObjectAnimator）运行的过程中，它会计算当前动画已消耗的时间比例（一个0到1之间的值），然后再根据你使用的插值器计算出一个插值比例。这个插值比例就是就是你在TypeEvaluator.evaluate()方法中接收到的fraction参数，因此你不需要在计算动画属性值的时候关心如何计算插值。\n插值器定义了动画在运行过程中属性值的时间函数。例如，你可以让动画在整个执行过程中线性过度，这意味着动画在整段时间里面都做匀速运动。你也可以设定动画非线性过度，例如，在动画开始的时候加速，在动画结束的时候减速。\n在动画系统中，插值器会从Animator接收到一个代表从动画开始到目前已花费的时间比例值。插值器会整合动画的类型去修改这个比例值。android在android.view.animation包中提供了一系列通用的插值器。如果你在里面没有找到你想要的插值器，你可以实现TimeInterpolator接口来自定义一个插值器。\n作为例子，下面比较了默认的AccelerateDecelerateInterpolator和LinearInterpolator插值器是如何计算插值比例的。LinearInterpolator插值器没有对已消耗的时间比例进行修改。AccelerateDecelerateInterpolator插值器在开始的时候调整加大已消耗的时间比例，在结束的时候降低已消耗的时间比例。下面的代码列举了这些插值器的逻辑：\nAccelerateDecelerateInterpolator\npublic float getInterpolation(float input) { return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; } LinearInterpolator\npublic float getInterpolation(float input) { return input; } 下面的表格列举了一个耗时1000毫秒的动画在执行过程中使用这些插值器计算出来的大概值：\n已消耗的时间（ms） 已消耗的时间比例/线性插值比例 （加速/减速）插值比例 0 0 0 200 0.2 0.1 400 0.4 0.345 600 0.6 0.8 800 0.8 0.9 100 1 1 正如表格所描述的，LinearInterpolator在每个时间段里面修改的插值都是一样，即每过200毫秒增加0.2。AccelerateDecelerateInterpolator从200毫秒到600毫秒之间修改的插值比LinearInterpolator快，在600毫秒到1000毫秒之间又比LinearInterpolator慢。 Keyframe对象中包含了一对时间与属性值的键值对，它定义了一个动画在指定的时间点上要呈现出特定的状态。每一个Keyframe都可以设定自己的插值器，用来控制动画从上一个Keyframe到当前这个Keyframe这段时间间隔里面的行为。\n获取一个Keyframe实例对象，你必须选择一个Keyframe的ofInt()、ofFloat()，或者ofObject()工厂方法来构造一个合适的Keyframe对象。然后，再调用ofKeyframe()方法生成一个PropertyValuesHolder对象。一旦你生成了而这个对象，你就可以将这个PropertyValuesHolder对象以及需要设定动画的对象作为参数生成一个Animator。下面的代码片段演示了这个过程：\nKeyframe kf0 = Keyframe.ofFloat(0f, 0f); Keyframe kf1 = Keyframe.ofFloat(.5f, 360f); Keyframe kf2 = Keyframe.ofFloat(1f, 0f); PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(\u0026#34;rotation\u0026#34;, kf0, kf1, kf2); ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation) rotationAnim.setDuration(5000ms); 更多关于使用关键帧的复杂示例，请查看MultiPropertyAnimation示例项目。\n属性动画系统允许为View对象设定流线型的动画，并且提供了一些比视图动画系统更加高级的功能。视图动画系统是通过修改View的绘制位置来改变View对象。这些操作是在每个View的容器中进行处理的，因为View本身并没有可以执行这类操作的属性。这就会导致View已经开始动画了，但是View对象本身并没有任何变化。整个过程看起来就像是View对象已经被绘制到屏幕上面的另一个位置，但它实际上还是在原来的位置上。从android 3.0开始，View类添加了新的属性以及对应的getter和setter方法，以解决这个缺陷。\n属性动画系统可以通过直接修改View对象的实际属性来完成它在屏幕上的动画效果。另外，当View的属性有变化的时候，它也会自动调用**invalidate()**方法刷新屏幕。View类中支持属性动画的新属性如下：\ntranslationX和translationY：这两个属性以布局容器给View的left和top坐标值为基准，控制View在横竖方向上需要移动位置的增量值。 rotation、rotationX和rotationY：这三个属性以View的中心点为基准，控制view在2D视觉（rotation属性）和3D视觉上的旋转。 scaleX和scaleY：这两个属性以View中心点为基准，控制View在2D视觉上的大小缩放。 pivotX和pivotY：这两个属性控制View对象的中心点，当View进行旋转或者缩放的时候需要依赖这个中心点的位置。默认情况下，中心点的位置在View对象的中心。 x和y：这两个属性描述了View在它所在的视图容器中的最终位置，可以看做是left或者top和translationX或者translationY值的和。 alpha：代表View的透明度。默认值为1，表示不透明，当值为0时即为完全透明（不显示）。 给View对象的属性设定动画，例如它的颜色或者旋转值，你需要做的只是创建一个属性的Animator，然后指定需要设定动画的属性。例如：\nObjectAnimator.ofFloat(myView, \u0026#34;rotation\u0026#34;, 0f, 360f); 更多关于创建动画的细节，请参考上面使用ValueAnimator设定动画和使用ObjectAnimator设定动画章节。\nViewPropertyAnimator底层封装了一个Animator对象，提供了一种简单的途径来给View的多个属性值同时设置动画。它的操作与ObjectAnimator很类似，因为它也是直接修改view的属性值，不同的是它能够一次操作多个属性值。此外，使用ViewPropertyAnimator的代码会更加简洁和易读。下面的代码片段比较了同时给view的x和y属性设定动画时，使用多个ObjectAnimator对象、使用一个ObjectAnimator对象，以及使用ViewPropertyAnimator对象之间的区别。\n多个ObjectAnimator对象\nObjectAnimator animX = ObjectAnimator.ofFloat(myView, \u0026#34;x\u0026#34;, 50f); ObjectAnimator animY = ObjectAnimator.ofFloat(myView, \u0026#34;y\u0026#34;, 100f); AnimatorSet animSetXY = new AnimatorSet(); animSetXY.playTogether(animX, animY); animSetXY.start(); 一个ObjectAnimator对象\nPropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(\u0026#34;x\u0026#34;, 50f); PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(\u0026#34;y\u0026#34;, 100f); ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start(); ViewPropertyAnimator\nmyView.animate().x(50f).y(100f); 更多关于ViewPropertyAnimator的信息，请参考Android Developers的博客.\n属性动画系统允许你不直接写代码而使用xml来声明定义属性动画。通过在xml文件中定义动画，可以让动画更容易在多个activity中重复使用，也能让编辑动画序列更加容易。\n为了区分使用了新属性动画API的动画文件和旧视图动画框架的动画文件，从android 3.1开始，你必须将使用属性动画的xml文件保存在__res/animator/__文件夹下。\n下面列举了属性动画类对应的xml标签：\nValueAnimator - \u0026lt;animator\u0026gt; ObjectAnimator - \u0026lt;objectAnimator\u0026gt; AnimatorSet - \u0026lt;set\u0026gt; 下面的示例顺序顺序执行两个动画组，第一个内嵌的动画组同时执行两个ObjectAnimator动画：\n\u0026lt;set android:ordering=\u0026#34;sequentially\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;objectAnimator android:propertyName=\u0026#34;x\u0026#34; android:duration=\u0026#34;500\u0026#34; android:valueTo=\u0026#34;400\u0026#34; android:valueType=\u0026#34;intType\u0026#34;/\u0026gt; \u0026lt;objectAnimator android:propertyName=\u0026#34;y\u0026#34; android:duration=\u0026#34;500\u0026#34; android:valueTo=\u0026#34;300\u0026#34; android:valueType=\u0026#34;intType\u0026#34;/\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;objectAnimator android:propertyName=\u0026#34;alpha\u0026#34; android:duration=\u0026#34;500\u0026#34; android:valueTo=\u0026#34;1f\u0026#34;/\u0026gt; \u0026lt;/set\u0026gt; 为了执行这个动画，你需要在你的代码中把xml动画资源实例化为AnimatorSet对象，然后在开始动画之前设定动画的目标对象。可以简单的调用**setTarget()**方法给一个目标对象设定AnimatorSet中的全部子动画。代码如下：\nAnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext, R.anim.property_animator); set.setTarget(myObject); set.start(); 更多关于定义属性动画的xml语法，请参考Animation Resources。\n","date":"June 20, 2016","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/android%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"属性动画","url":"https://www.qinxiandiqi.sbs/tags/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/"},{"title":"动画","url":"https://www.qinxiandiqi.sbs/tags/%E5%8A%A8%E7%94%BB/"}],"title":"Android的属性动画"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":" 原文作者：Google 原文地址：https://developer.android.com/guide/topics/location/strategies.html\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2016-06-17版本翻译\n译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\nNote: 本文中的策略适用于Android平台上android.location包中的定位API。不同于Google Location Services API，Google Location Services API是Google Play Services中的一部分，能够提供更强大更高级别的框架来自动处理定位数据源、用户移动和定位精度问题，还能够根据你提供的能源消耗参数调整定位的刷新方式。通过使用Google Location Services API，在大多数情况下，你都能够获得更好的电池性能，同时，还能得到更好的定位精度。更多关于这部分定位服务API的内容，请参考Google Location Services for Android。\n获取用户的地理位置信息能够让你的应用程序显得更加智能，借此能够分发更合适的信息给用户。为android开发地理位置相关的应用程序，你可以利用GPS或者android的网络定位数据源来获取用户的地理位置。尽管GPS的定位更加精准，但它只适用于户外，并且还会更快的消耗电量，它也不能按用户所期待的及时返回地理位置信息。android的网络定位数据源是通过使用手机信号塔和WiFi信号来获取用户的地理位置信息，不管是在室内还是室外都能够以统一的方式提供地理位置信息，网络定位的响应也会更快，消耗的电量也更好。在你的应用程序中获取用户的地理位置，你可以同时使用GPS或者网络定位，也可以只使用其中一种。\n从移动设备上获取用户的地理位置信息是很复杂的。有多种原因能够导致地理位置信息的获取（不管使用的是哪一种数据源）发生错误或者精度不准。一些用户地理位置信息获取可能导致的数据源错误如下：\n多种定位数据源\nGPS、手机信号塔ID和WiFi，每一种数据源都包含了一种用户地理位置定位的规则。选择和信任哪一种数据源的数据是一个权衡定位精度、定位速度，以及电量消耗的问题。 用户位置移动 由于用户的位置在不停变化，你必须每隔一段时间重新更新用户的地理位置信息来应对用户位置不停变化问题。 不同的精度 不同定位数据源的地理位置信息精度是不同的。10秒钟前从一个定位数据源获取的地理位置信息精度可能比另外一个甚至是同一个定位数据源刚刚获取的地理位置信息还要准确。 上面的这些问题让获取一个可靠的用户地理位置信息变得很困难。本文档提供一些解决方案来帮助你面对这些挑战，获取相对可靠的地理位置信息。同时，也提供一些建议，帮助你在应用程序中为用户提供一个精确的响应及时的定位体验。\n在解决上面提到的一些定位错误问题之前，这里要先介绍如何在android设备上获取定位数据。\n在android上获取用户的地理位置信息是通过回调来实现的。你通过调用LocationManager类（Location Manager）的requestLocationUpdates() 方法，传递一个LocationListener监听器来向系统表明你需要接收地理位置数据刷新信息。你的LocationListener 必须实现一些回调方法。这些方法在用户的地理位置信息有变化，或者地理位置服务状态有变化时，Location Manager就会回调它们。\n例如，下面的代码片段定义了一个LocationListener并且请求定位更新：\n// 获取系统的LocationManager服务 LocationManager locationManager = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE); // 定义一个LocationListener来响应定位更新 LocationListener locationListener = new LocationListener() { public void onLocationChanged(Location location) { // 当地理位置信息有变化的时候回调 makeUseOfNewLocation(location); } public void onStatusChanged(String provider, int status, Bundle extras) {} public void onProviderEnabled(String provider) {} public void onProviderDisabled(String provider) {} }; // 向Location Manager注册LocationListener监听定位更新 locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0, locationListener); requestLocationUpdates() 方法中第一个参数指明使用的定位数据源类型（这个例子中，使用的依据手机信号塔和WiFi信号来定位的网络数据源）。你可以通过第二和第三个参数来控制你的监听器接收定位数据信息的频率——第二个参数指定两次数据更新通知之间的最小时间间隔，第三个参数指定触发下一次定位数据更新通知的最小距离——两个参数都设置为0则表示要尽可能快的更新。最后一个参数就是你的LocationListener监听器啦，它的回调方法会在有定位更新的时候得到回调。\n请求根据GPS数据源来更新定位信息，只需要将第一个参数NETWORK_PROVIDER替换为GPS_PROVIDER就可以了。你也可以同时请求GPS和网络定位数据源更新定位信息，但你需要调用requestLocationUpdates()方法两次，一次使用NETWORK_PROVIDER，一次使用GPS_PROVIDER。\n为了能够从NETWORK_PROVIDER或者GPS_PROVIDER定位数据源接收到定位更新数据，你必须在android的manifest文件中分别声明ACCESS_COARSE_LOCATION和ACCESS_FINE_LOCATION权限。例如：\n\u0026lt;manifest ... \u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_FINE_LOCATION\u0026#34; /\u0026gt; ... \u0026lt;/manifest\u0026gt; 如果没有这些权限，你的应用程序在运行过程中请求定位更新将会失败。\n注意：如果你同时使用NETWORK_PROVIDER和GPS_PROVIDER定位数据源，那么你只需要申请ACCESS_FINE_LOCATION权限，因为它已经包含了这两个数据源需要的权限（ACCESS_COARSE_LOCATION只包含了NETWORK_PROVIDER数据源所需要的权限）。\n基于定位的应用程序现在很常见，但由于稍差的定位精度、用户不停移动、获取定位信息的方法多种多样、以及需要减少电量消耗，导致获取用户定位信息变得很复杂。为了解决获取精确的定位信息与节省电量消耗之间的矛盾，你必须确定一个统一的模型来指定你的应用程序如何获取用户的定位信息。这个模型应该包含什么时候你应该启动或者停止定位更新监听，以及什么时候可以使用缓存的定位数据。\n获取用户定位信息的步骤# 下面是获取用户定位信息的典型流程：\n启动应用程序 稍等一段时间后，启动对目标定位数据源更新的监听器 过滤新的，但是精度不准确的定位信息，以保持当前的地理位置测量数据是最佳的。 停止监听定位信息的更新 获取最后最佳的定位测量数据 下面图1通过一条时间线形象地展示了一个应用程序在监听地理位置信息更新的过程中每一个阶段发生的事件。\n图1：一条代表应用程序监听定位刷新的时间线\n上面的模型中，在地理位置信息更新和接收的阶段，你会接收到多次地理位置信息，你需要根据你添加的地理位置服务进行判断过滤。\n确定什么时候启动地理位置更新监听# 你可能想要在应用程序一启动的时候就开启地理位置信息更新监听，也有可能当用户触发了相关功能模块的时候才进行启动监听。但要知道，长时间进行定位监听来修复当前地理位置信息会消耗掉大量电量，而如果监听时间过短又可能导致定位不够精确。\n正如上面章节所描述的，你可以通过调用requestLocationUpdates() 方法来启动定位更新监听：\nString locationProvider = LocationManager.NETWORK_PROVIDER; // Or, use GPS location data: // String locationProvider = LocationManager.GPS_PROVIDER; locationManager.requestLocationUpdates(locationProvider, 0, 0, locationListener); 获取最后快速调整修复的定位信息# 你的定位监听器第一次获取到修复的定位信息所花费的时间常常要让用户等很久。直到你的定位监听器获取到更多精确的地理位置信息时，你才能调用getLastKnownLocation(String) 方法来获取缓存的地理位置信息：\nString locationProvider = LocationManager.NETWORK_PROVIDER; // Or use LocationManager.GPS_PROVIDER Location lastKnownLocation = locationManager.getLastKnownLocation(locationProvider); 确定何时停止定位更新监听# 决定什么时候不再需要新的地位位置修正信息取决于你的应用程序逻辑，它可能很简单，也可能很复杂。当获取的地理位置信息到使用这个地址位置信息的时间间隔越短，这个定位信息的测量精确度就越高。要始终注意监听定位更新的时间越长，消耗的电量就更多。因此，一旦给你获得你所需要的定位信息之后，你就应该马上调用removeUpdates(PendingIntent) 方法停止监听定位更新。\n// Remove the listener you previously added locationManager.removeUpdates(locationListener); 维护一个当前最精确的定位信息# 你可能认为最近获取的定位修正信息就是最准确的，然而，由于地理位置修正值变化的精度问题，最近获取的修正定位信息不一定就是最精确的。你应该在应用程序中添加基于几个标准来选择定位信息修正值的逻辑。这些标准同样也会由于应用程序的用户和实际测量值的不同而变化。\n下面有几个你可以用来检验定位修正值精确度的步骤：\n检查定位修正值是否明显比上次的测量值要新很多。 检查定位信息的精度要求是否比上次的测量值要好还是差。 检查新的定位测量值是哪个定位数据源提供的，你是否信任这个定位数据源。 综合上面所描述的逻辑，类似的处理代码如下：\nprivate static final int TWO_MINUTES = 1000 * 60 * 2; /** 判断是一个新的定位测量值是否比当前的定位修正值更好 * @param location 需要评估的新定位测量值 * @param currentBestLocation 当前的定位修正值，也就是你想要用来跟新定位测量值比较的定位数据 */ protected boolean isBetterLocation(Location location, Location currentBestLocation) { if (currentBestLocation == null) { // 如果当前没有定位修正值，那么新的定位测量值肯定是更好的 return true; } // 检查新的定位测量值是更新的数据还是更旧的数据 long timeDelta = location.getTime() - currentBestLocation.getTime(); boolean isSignificantlyNewer = timeDelta \u0026gt; TWO_MINUTES; boolean isSignificantlyOlder = timeDelta \u0026lt; -TWO_MINUTES; boolean isNewer = timeDelta \u0026gt; 0; // 如果新的定位测量值晚于当前的定位修正值两分钟，那么使用新的定位测量值，因为用户可能已经移动了 if (isSignificantlyNewer) { return true; // 如果新的定位测量值早于当前定位修正值两分钟，那么新的定位测量值应该是过时的 } else if (isSignificantlyOlder) { return false; } // 检查新的定位测量值精度是否更加精确 int accuracyDelta = (int) (location.getAccuracy() - currentBestLocation.getAccuracy()); boolean isLessAccurate = accuracyDelta \u0026gt; 0; boolean isMoreAccurate = accuracyDelta \u0026lt; 0; boolean isSignificantlyLessAccurate = accuracyDelta \u0026gt; 200; // 检查两个定位测量值是否来源于同一个定位数据源 boolean isFromSameProvider = isSameProvider(location.getProvider(), currentBestLocation.getProvider()); // 组合定位的及时性和准确度来评估定位的质量 if (isMoreAccurate) { return true; } else if (isNewer \u0026amp;\u0026amp; !isLessAccurate) { return true; } else if (isNewer \u0026amp;\u0026amp; !isSignificantlyLessAccurate \u0026amp;\u0026amp; isFromSameProvider) { return true; } return false; } /** 检查两个定位数据源是否是同一个数据源 */ private boolean isSameProvider(String provider1, String provider2) { if (provider1 == null) { return provider2 == null; } return provider1.equals(provider2); } 调整模式以节省电量和数据交换# 当你测试你的应用程序的时候，你可能会发现你为了提供更好的定位和更好的性能而设计的定位模式可能需要一些调整。为了更好的在两者之间取得平衡，下面提到的一些东西你可能需要进行调整。\n减少监听时间# 更少的监听定位刷新时间意味着与GPS和网络定位服务更少的交互操作，因此，也就延长了电池的使用时间。而且，这种策略也允许从少数定位信息中挑选最佳的测量值。\n为定位数据源设定更低的刷新频率# 在监听定位刷新期间，降低新更新信息出现的频率同样可以提升电池的效率，但需要考虑精度损耗的成本。刷新频率值需要根据你的应用程序用途来权衡。你可以通过增加requestLocationUpdates() 的参数来指定刷新间隔时间和最小的距离变化条件。\n限制多个定位数据源的使用# 取决于你的应用程序使用场景以及要求的精确度等级，你可能只需要选择网络定位数据源或者GPS定位数据源就够了，不用两种数据源同时使用。在可预见能够接受的精度范围内置选择与一种定位数据源交互能够降低电量的消耗。\n有很多种原因你需要获取用户的地理位置信息。下面是一组你可以使用用户的地理位置信息来丰富你的应用程序的场景。每一种场景都描述了为获取好的定位信息并且在节省电量消耗的情况下，应该什么时候启动或者停止监听定位刷新的做法。\n用地理位置信息标记用户创建的内容# 你可能想要创建一个应用程序，使用地理位置信息标志用户创建的内容。例如用户可能想要分享他所在地的风俗，发表对一家餐厅的评论，或者记录一些能通过他们当前地理位置信息来增强的内容。图2形象的描述了这个过程中与定位服务的交互模型：\n图2：一条包含用户定位获取，以及消耗掉当前获取的地理位置后停止定位监听的时间线\n这条时间线基于前面如何在代码中获取用户定位信息的模型（图一）。为了更好的定位精确度，你可能需要在用户开始创建内容甚至是应用程序启动的时候就开始监听定位信息的刷新，然后在内容发表或者保存之后挺尸定位刷新的监听。你可能需要考虑创建一个内容的典型任务需要花费多长的时间，然后判断这个时间间隔是否足够高效采集一个定位测量值。\n帮助用户决定应该走去哪里# 你可能想要创建一个应用程序来尝试给用户提供一系列关于去哪里的选项。例如，你要查询提供一个附近餐厅、商店和公寓的列表，并且这个建议列表会根据用户的地理位置变化而变化。\n为了适应这个流程，你可以选择：\n当获取的更新更准确的定位测量值时，刷新建议列表 当建议列表排序相对稳定的时候停止监听定位刷新 图3形象的表述了这个模型：\n图3：一条每一次用户定位刷新都要动态更新一系列数据的时间线\n当你在开发应用程序，你当然需要测试你的获取用户地理位置信息模型是否足够满足要求。使用一台android设备很容易进行这种测试。然而，即使你没有一台真机设备，你同样可以在android模拟器中通过假定位数据来测试你的定位模块功能。下面有三种向你的应用程序发送假定位数据的方法：使用android studio，DDMS，或者在模拟器控制台上使用“geo”命令。\n注意：提供假定位信息是以GPS定位信息的方式注入的，因此你必须从GPS定位数据源获取定位刷新数据才能使假定位信息正常使用。\n使用Android Studio# 选择Tool \u0026gt; Andorid \u0026gt; AVD Manager.在android虚拟机管理器窗口中选择你的AVD，并且通过点击操作列表中的绿色播放按钮启动这个模拟器。\n之后，选择Tool \u0026gt; Android \u0026gt; Android Device Monitor.在Android Device Monitor窗口中选择Emulator Control（模拟器控制）标签页，然后在Location Controls里面输入GPS坐标作为用户的经纬度坐标，或者使用GPX文件指定路线规划，或者使用KML文件标识多个地点。\n使用DDMS# 使用DDMS工具，你可以通过几种不同的方式模拟位置：\n手动发送个人经纬度坐标到设备上 使用一个GPX文件来描述一条回放的路线 使用一个KML文件来描述用于测量回放的个体标识地点 更多关于使用DDMS模拟地理位置的内容，请参考使用DDMS.\n在模拟器控制台上使用“geo”命令# 从终端命令行上发送假地理位置数据：\n在android模拟器中启动你的应用程序，同时打开你的SDK中**/tools**目录下的terminal/console。 连接模拟器的控制台： telnet localhost \u0026lt;console-port\u0026gt; 发送地理位置数据： geo fix命令发送一个修正的地理位置。\n这个命令接受一对十进制的经纬度参数，还有一个可选的以米为单位的海拔高度参数。例如 geo fix -121.45356 46.51119 4392 geo nmea命令发送一个NMEA 0183句子 这个命令接受一个单一的\u0026rsquo;$GPGGA\u0026rsquo;(稳定数据)类型或者\u0026rsquo;$GPRMC\u0026rsquo;(过渡数据)类型的句子。例如： geo nmea $GPRMC,081836,A,3751.65,S,14507.36,E,000.0,360.0,130998,011.3,E*62 更多关于如何连接到模拟器控制台的内容，请参考使用模拟机控制台。\n","date":"June 17, 2016","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/android%E7%9A%84%E5%AE%9A%E4%BD%8D%E7%AD%96%E7%95%A5/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"定位","url":"https://www.qinxiandiqi.sbs/tags/%E5%AE%9A%E4%BD%8D/"},{"title":"策略","url":"https://www.qinxiandiqi.sbs/tags/%E7%AD%96%E7%95%A5/"},{"title":"地理位置","url":"https://www.qinxiandiqi.sbs/tags/%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE/"}],"title":"Android的定位策略"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":" 原文作者：Google 原文地址：http://developer.android.com/intl/zh-cn/training/permissions/best-practices.html\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2016-05-04版本翻译\n译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\napp的权限请求很容易让用户反感。当用户觉得一个app用起来很麻烦，或者觉得这个app不知道要拿用户的信息去做什么事情时，用户可能会避免使用甚至是完全卸载掉这个app。下面的权限最佳运用方式能够帮助你避免这些糟糕的用户体验。\n在很多情况下，app执行一个任务都会有两种可供选择的方式。你可以让你的app亲自请求系统权限来执行一个操作，你也可以让你的app发送一个Intent给其它app来代替执行这个操作。\n举个例子，假设你的app需要使用设备的摄像头拍一张照片。你的app可以申请CAMERA权限，这个权限允许你的app直接访问摄像头。请求这个权限之后，你的app才能使用摄像头的API来控制摄像头并拍摄一张照片。这种方式能够使你完全控制整个拍照的过程，还能够将拍照界面UI整合到你的app里面。\n然而，如果你不需要像这样完全控制整个拍照流程，那么你可以使用一个ACTION_IMAGE_CAPTURE Intent来请求获取一张图片。当你发送这个Intent请求之后，系统会提示用户选择一个拍照app（如果系统还没有设定默认拍照app的情况下）。之后，用户可以使用选择的拍照app拍摄一张照片，这个拍照app会通过onActivityResult() 方法返回一张图片。\n同样的，如果你需要打电话、访问用户通讯录等等，你都可以创建一个合适的Intent来完成这件事情。当然，你都可以直接申请系统权限后直接访问响应的对象进行处理。下面是这两种方式的的优缺点。\n如果你申请权限：\n当你在执行目标操作的时候，你能够完全控制整个过程中的用户体验。但是，这样全面的控制你的任务流程势必会增加实现的复杂程度，例如你需要设计一个合适的UI。 （基于用户的android设备版本）不管是在app运行的过程中还是在安装app的时候，用户会被提示授权至少一次。在这之后，你的app才能直接执行相应的操作，不再需要用户的授权互动。但是，如果用户拒绝授权（或者在过后撤销了授权），那么你的app将完全无法执行对应的操作。 如果你使用Intent：\n你不需要为对应的操作设计UI，接收Intent请求的app会提供相应的UI。这意味着你无法控制整个过程的用户体验。用户可能会与你从来没有见过的app进行交互操作。 如果用户没有设定处理该操作的默认app，系统将会提供用户选择一个app。也就是，如果用户没有指定一个默认的操作处理app，每次用户执行响应的操作都会弹出一个额外的对话框。 每一次你请求一个权限，你都是在强制用户做出一个决定。你应该尽量减少这些请求的次数。如果用户的android设备系统版本是6.0（API Level 23）或者更高，每次用户尝试一个需要申请权限的新功能时，app都必须中断用户的操作要求授权。如果用户的android设备系统是更早的版本，用户就需要在安装app的时候授权每一个app需要的权限。这种情况下，如果权限列表过长或者看起来不合理，用户可能就选择不安装你的app了。基于这些原因，你都应该尽量减少你的app需要申请的权限。\n通常情况下，你都可以替代使用Intent来避免申请权限。如果一个功能对于你的app来说并不是非常核心的模块，你就应该考虑让其它的app来完成这个功能，详情请参考上面考虑使用Intent章节。\n如果用户的设备运行着android 6.0（API level 23）或者更高的系统版本，在运行app的过程中，用户就必须对每一个需要的权限进行授权。如果你一次向用户申请过多的权限，你就可能骚扰到用户，导致他们放弃你的app。因此，你应该只申请你需要的权限。\n在一些情况下，有些权限对于你的app来说是必须的，那么在app一启动的时候就申请这些权限是比较合理的。例如，如果你写了一个拍照app，这个app需要访问设备摄像头。当用户第一次启动这个app的时候，他们就不会惊讶这个app为什么需要申请摄像头权限。但如果这个app还有一个功能是分享照片给用户的通讯录联系人，那你就不应该在第一次启动的时候申请READ_CONTACTS权限。相反的，你应该等到用户使用“分享”功能的时候再申请联系人权限。\n如果你的app能提供一个教程，那么最好在教程的结尾解释app需要的必要权限。\n当你调用requestPermission() 方法后系统弹出的授权对话框会说明你的app需要什么权限，但是不会解释为什么需要权限。在一些情况下，用户可能会对这些权限申请感到疑惑。因此，在调用requestPermission() 方法之前向用户解释你的app为什么需要这个权限是一种很好的做法。\n例如，一个拍照app可能需要使用地理位置服务来标识拍摄的照片。一般用户可能不知道一张图片里面可以包含地理位置信息，他们可能就会对拍照app需要获取地理位置信息感到疑惑。类似这样的情况，在app调用requestPermission() 方法之前向用户解释这个功能就很有意义了。\n通知用户的一种途径可以是在app的教程指南中列举所有需要的权限解释。在这个教程指南中可以轮流展示app的每一个功能，在展示的过程中解释每一个功能需要的权限。例如，拍照app的教程指南可以演示它的“分享图片给联系人”功能，在演示过程中告诉用户app需要权限来查看用户的联系人。之后，app可以调用requestPermission() 方法来请求用户授权访问对应的功能。当然，不是每一个用户都会查看教程指南，所以你在app的正常操作过程中一样要时时检查权限是否已经授权。\n从android 6.0（API level 23）开始，用户可以在运行过程中授权或者撤销权限，而不是在安装app的时候就要求这么做。这就导致了一个结果，你必须测试你的app在多种多样的权限授权组合模式下的运行情况。在android 6.0之前的版本上，你可以合理的断定你的app如果安装运行起来了，那么app的manifest文件声明的所有权限都已经授权。但在新的权限管理模式下，你不能再这么简单的下结论。\n下面的小提示可以帮助你确认在API level 23或者更高版本设备上出现的权限相关的代码问题：\n确认你的app当前的权限，以及相关代码的位置。 测试用户经权限保护的服务和数据。 测试已授权或者已被撤权的各种权限组合。例如，一个拍照app可能在manifest文件中列举了CAMERA、READ_CONTACTS、ACCESS_FINE_LOCATION权限。你就必须测试每一种权限的开启或者关闭，确保app能够优雅的处理所有权限的授权或拒绝组合模式。需要注意的是，从android 6.0开始，用户能够授权或者禁止任意app的权限，不管这个app的target API level是22还是更低的版本。 在终端上使用adb工具管理权限： 分组列举权限和状态： $ adb shell pm list permissions -d -g 授权或者取消一个或多个权限： $ adb shell pm [grant|revoke] \u0026lt;permission-name\u0026gt; ... 分析你的app那些使用权限的service。 ","date":"June 16, 2016","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/android%E6%9D%83%E9%99%90%E7%9A%84%E6%9C%80%E4%BD%B3%E8%BF%90%E7%94%A8/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"permission","url":"https://www.qinxiandiqi.sbs/tags/permission/"},{"title":"权限","url":"https://www.qinxiandiqi.sbs/tags/%E6%9D%83%E9%99%90/"},{"title":"使用技巧","url":"https://www.qinxiandiqi.sbs/tags/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"title":"Android权限的最佳运用"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":" 原文作者：Google 原文地址：http://developer.android.com/intl/zh-cn/training/permissions/requesting.html\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2016-04-27版本翻译\n译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n从android 6.0（API 23）开始，安装app时不需要对app的权限申请进行授权，而是在app运行的时候，用户才需要对app进行授权。这种流程精简了app的安装过程，用户不需要在安装或者升级app的时候进行授权操作。这同样也给了用户更多对app功能的控制能力；例如，用户可以选择给一个照相app访问摄像头的权限，但不给它访问设备地理位置的权限。用户也可以通过app的设置界面，随时撤销对app授予的权限。\n系统权限可以被分为两大类，普通权限和危险权限：\n普通权限不会引起用户隐私泄露的风险。如果你的app在manifest文件中列举了一个普通权限，系统会自动对申请的普通权限直接授权。 危险权限允许app访问用户的机密信息。如果的你app在它的manifest中列举了一个普通权限，系统会自动授权。但如果你列举的是一个危险权限，用户就必须明确处理是否授权给你的app。 更多相关信息，请参考普通权限和危险权限。\n无论是哪个android版本，你的app都必须在它的manifest文件上声明它需要的所有普通权限和危险权限，详情请参考声明权限。只不过，声明权限的结果因系统版本和app的target SDK不同而不同：\n如果设备运行在android 5.1或者更低版本的系统上，或者app的target SDK是22或者更低：如果你的app在它的manifest文件中声明了一个危险权限，那么用户在安装app的时候就必须授权这个危险权限给你的app；如果用户不同意授予这个权限，系统就拒绝安装这个app。 如果设备运行在android 6.0或者更高的系统版本上，并且app的target SDK是23或者更高：app必须在manifest文件中声明所有需要的权限，并且在app运行的过程中必须请求用户对每个使用到的危险权限进行授权。用户可以选择授权或者拒绝每一个权限，如果用户拒绝了授权，app同样可以继续运行，只是对应的功能无法使用。 注意： 从android 6.0（API 23)开始，不管app的target SDK是不是低版本的SDK，用户都可以随时取消任意app已经授权过的权限。不管你的app是什么target SDK版本，当你的app缺少一个需要的权限时，你都应该测试的app功能是否正常。\n本章节内容将探讨如何使用android support library来检查和请求权限。android的framework在android 6.0（API 23）版本上提供了类似的方法。不过，相对来说使用support library的方法会比较简单，因为这样你的app在调用这些方法之前就不需要检查当前运行的android系统版本是多少。\n如果你的app需要一个危险权限，那么你每次执行需要这个危险权限的操作时，你都必须检查是否已经申请到这个权限。用户随时都可以撤销授予过的权限，因此，尽管一个app昨天可以正常使用摄像头，但不代表今天仍然拥有使用摄像头的权限。\n检查你的app是否拥有过一个权限，需要调用ContextCompat.checkSelfPermission()方法。例如，下面的代码片段检查了activity是否拥有写日历的权限：\n// Assume thisActivity is the current activity int permissionCheck = ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.WRITE_CALENDAR); 如果app拥有这个权限，方法会返回PackageManager.PERMISSION_GRANTED，app可以继续执行相关操作。如果app不具备该权限，方法会返回PERMISSION_DENIED，app需要明确请求用户授予该权限。\n如果你的app需要使用一个在它的manifest文件中声明的危险权限，那么在使用之前它必须请求用户授予该权限。android提供了一系列方法供你申请权限。请求这些方法会唤起一个标准的android对话框，这个对话框你不能自定义。\n解释app为什么需要权限# 在一些情况下，你可能想要帮助用户理解为什么你的app需要一个权限。例如，如果用户启动一个摄影app，用户应该对app请求使用摄像头的权限不会感到惊讶，但是用户可能无法理解为什么app还要求访问设备的地理位置和通讯录。在你申请一个权限之前，你应该考虑给用户提供一个解释。但是要注意不要用解释过多骚扰用户；如果你提供了太多的解释，用户可能会厌烦你的app并且卸载掉。\n只有在用户已经拒绝了权限请求的情况下，你才有可能需要向用户提供一个解释。如果用户继续尝试使用需要申请权限的功能，但是这个权限之前已经被用户拒绝，这就说明用户可能不清楚为什么app的这个功能需要申请权限。类似这样的情况，那么显示一个权限申请解释就是一种很好的解决方法。\n为了帮助判断用户在什么情况下需要一个权限解释，android提供了一个工具方法，ActivityCompat.shouldShowRequestPermissionRationale()。如果app之前申请过一个权限，但这个权限被用户拒绝了，这个方法就会返回true。\n注意： 如果用户在过去拒绝权限申请的同时还勾选了系统权限申请对话框中的不再询问选项，这个方法也会返回false。如果是在设备权限设置中禁止了app使用的权限，用这个方法判断这些权限同样也会返回false。\n申请你需要的权限# 如果你的app目前不具备它所需要的权限，app必须调用requestPermissions()多个重载方法中的一个来申请适当的权限。这些方法中，你的app除了将所需要的权限作为参数传递进去之外，还需要传递一个整型值作为本次权限请求的标识码。这些方法都是异步的：方法会直接返回，等到用户响应对话框之后，系统才会回调app的回调方法把结果传递回来，结果中包括app调用requestPermissions()方法时传递进来的请求码。\n下面的代码检查app是否拥有读取用户联系人的权限，如果没有，在需要的时候会申请权限：\n// Here, thisActivity is the current activity if (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) { // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) { // Show an expanation to the user *asynchronously* -- don\u0026#39;t block // this thread waiting for the user\u0026#39;s response! After the user // sees the explanation, try again to request the permission. } else { // No explanation needed, we can request the permission. ActivityCompat.requestPermissions(thisActivity, new String[]{Manifest.permission.READ_CONTACTS}, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant. The callback method gets the // result of the request. } } 注意： 当你的app调用requestPermissions()方法时，系统会弹出一个标准的对话框给用户。你的app无法配置或者修改这个对话框。如果你需要向用户提供一些的信息或者解释，你应该在调用requestPermissions()方法之前进行这些操作，请参考上面小节解释app为什么需要权限。\n处理权限请求的响应# 当你的app申请权限之后，系统会显示一个对话框给用户。当用户响应之后，系统会回调你的app的**onRequestPermissionsResulet()方法，将响应结果传递过来。你的app必须重写这个方法来判断申请的权限是否被授予了。回调方法会接收到与你传递到requestPermissions()**方法中相同的请求码。例如，如果一个app请求READ_CONTACTS访问权限，它可能需要以下的响应代码：\n@Override public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) { switch (requestCode) { case MY_PERMISSIONS_REQUEST_READ_CONTACTS: { // If request is cancelled, the result arrays are empty. if (grantResults.length \u0026gt; 0 \u0026amp;\u0026amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { // permission was granted, yay! Do the // contacts-related task you need to do. } else { // permission denied, boo! Disable the // functionality that depends on this permission. } return; } // other \u0026#39;case\u0026#39; lines to check for other // permissions this app might request } } 这个系统显示的对话框会描述你的app需要访问的权限组，它不会列举具体使用到的哪一个权限。例如，如果你请求READ_CONTACTS权限，系统对话框只会描述你的app需要访问设备的通讯录。用户只需要对每一个权限组授权一次。一旦对一个权限组授权之后，如果你的app请求同一个权限组中的其它权限（同样也要在app的manifest文件声明），系统会自动授予这些权限。当你请求这些同个权限组中的其它权限时，系统也会回调你的onRequestPermissionsResult()方法并传递PERMISSION_GRANTED参数，回调的结果就跟用户已经通过系统对话框明确同意你的权限申请一样。\n注意： 你的app仍然需要明确请求每一个它需要的权限，不过用户是否已经同意授权同个权限组中的其它权限。此外，每个权限组包含的权限在未来android的发布版中也有可能会变化。你的代码逻辑不应该建立在使用到的几个权限是否被包含在同一个权限组中的假设之上。\n例如，假设你在app的manifest中声明了READ_CONTACTS和WRITE_CONTACTS权限。如果你已经请求过READ_CONTACTS权限并且用户通过授权申请，当你再请求WRITE_CONTACTS权限时，系统会立即把这个权限也授权给app，不需要再与用户进行授权交互。\n如果用户拒绝了你的权限申请，你的app应该采取适当的响应操作。例如，你的app可能需要显示一个对话框来解释为什么你的app无法继续执行下去的原因是需要被用户拒绝的权限。\n当系统请求用户授权时，用户可以选择告诉系统需要再次请求这个权限。在这种情况下，无论app调用多少次requestPermissions()方法来申请权限，系统都会直接决绝申请。系统会回调你的onRequestPermissionsResult()回调方法并且传递PERMISSION_DENIED参数值，整个回调过程就跟用户已经直接明确拒绝你的权限申请一样。这意味着当你调用requestPermissions()方法时，你不能假设与用户直接交互的操作一定会发生。\n","date":"May 4, 2016","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/app%E5%9C%A8android6.0%E6%88%96%E4%BB%A5%E4%B8%8A%E5%B9%B3%E5%8F%B0%E7%89%88%E6%9C%AC%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%AF%B7%E6%B1%82%E6%9D%83%E9%99%90/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"权限","url":"https://www.qinxiandiqi.sbs/tags/%E6%9D%83%E9%99%90/"},{"title":"动态申请","url":"https://www.qinxiandiqi.sbs/tags/%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7/"}],"title":"App在android 6.0或以上平台版本运行过程中请求权限"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":" 原文作者：Google 原文地址：http://developer.android.com/intl/zh-cn/training/permissions/declaring.html\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2016-04-27版本翻译\n译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n每一个android app都运行在一个限制访问的沙盒中。如果一个app需要访问它所在沙盒之外的资源和信息，那么这个app就需要声明适当的权限。这个权限声明要求将你的app需要的权限全部列举在App的manifest文件中。 根据权限不同的隐私敏感程度级别，系统可能会自动授予该权限，也有可能需要请求设备用户授权才能获取该权限。例如，如果你的app请求授予打开设备闪光灯的权限，系统将会自动授予这个权限。但是，如果你的app需要读取用户的通讯录联系人，系统就会请求用户是否授予读取联系人的权限。根据android不同的系统版本，请求用户授予app权限的时机可能是在安装app的时候（在android 5.1或者更早的系统版本上），也有可能是在app运行的过程中（在android 6.0或者更高的系统版本上）。\n当你在开发app的时候，你应该注意使用那些需要申请权限的功能。通常情况下，一个app需要使用非它自己本身创建的信息或者资源，以及执行会影响设备或者其它app的操作时，它就需要申请权限。例如，如果一个app需要访问网络，使用设备摄像头，或者打开关闭wifi，那么这个app就需要对应的权限。系统的权限列表，请查看普通等级和危险等级的权限。\n你的app只需要申请app直接执行的操作所需要的权限。如果你的app只是请求其它app来执行任务或者提供信息，那么你的app不需要申请这些任务或者信息所需要的权限。例如，如果你的app需要读取用户的地址簿，那么你需要申请READ_CONTACT权限。但是，如果你的app使用一个Intent来请求用户的通讯录app获取信息，你的app就不需要任何相关的权限，不过，通讯录的app就需要申请相关的权限。更多的详情，请参考考虑使用Intent。\n声明app需要的权限，必须使用**\u0026lt;uses-permission\u0026gt;标签在app的manifest文件中作为\u0026lt;manifest\u0026gt;**元素的子标签进行声明。例如，一个需要发送短信的app在manifest文件中的声明大致如下：\n\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; package=\u0026#34;com.example.snazzyapp\u0026#34;\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.SEND_SMS\u0026#34;/\u0026gt; \u0026lt;application ...\u0026gt; ... \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 当你声明一个权限之后，系统的行为根据权限的隐私程度来决定。如果声明的权限不涉及用户的隐私，那么系统会自动授予这个权限。如果这个权限可能会涉及到用户的隐私信息，系统就会咨询用户是否要授予该权限的申请。更多关于不同权限类型的信息，请参考普通等级和危险等级的权限。\n","date":"April 28, 2016","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/android%E7%9A%84%E6%9D%83%E9%99%90%E5%A3%B0%E6%98%8E/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"permission","url":"https://www.qinxiandiqi.sbs/tags/permission/"},{"title":"权限","url":"https://www.qinxiandiqi.sbs/tags/%E6%9D%83%E9%99%90/"}],"title":"Android的权限声明"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"IDE","url":"https://www.qinxiandiqi.sbs/categories/ide/"},{"title":"go","url":"https://www.qinxiandiqi.sbs/categories/go/"}],"content":" 原文作者：Jianan - qinxiandiqi@foxmail.com\n原文地址：http://blog.csdn.net/qinxiandiqi/article/details/50319953\n版本信息：2015-12-15\n版权声明：本文采用CC BY-NC-ND 4.0共享协议。允许复制和转载，但必须在文首显眼位置保留原文作者、原文链接、版本信息、版权声明等信息。不允许演绎和用于商业用途。\n支持golang开发的IDE现在已经很多了，如果要讨论出哪一个IDE才是最好的golang IDE，这绝对可以让一群程序猿撕逼上百楼，这里就不讨论了。选择什么样的IDE，主要就是个人喜好的问题而已。我习惯了Android Studio和Intellij IDEA的UI风格，所以这里只讨论IDEA的golang插件配置，别的IDE就不讨论了，因为我很懒。\nIDEA的golang插件是开源的，项目托管在github上面。如果你技术很屌的话，可以参与到这个插件的开发中，留个大名，比去某风景区的石头上刻某某某到此一游屌多了。\n在IDEA上安装golang插件需要手动添加golang插件的仓库，目前golang插件有两个仓库：\nAlpha：https://plugins.jetbrains.com/plugins/alpha/5047 Nightly：https://plugins.jetbrains.com/plugins/nightly/5047 两个仓库的在于Alpha仓库的golang插件每个星期更新一次版本，而Nightly仓库的golang插件版本每天更新一次版本。根据自己更新频率的需要添加合适的仓库到自己的IDEA里面，添加方法如下：\nSetting菜单里面选择Plugin，点击Browse repositories：\nBrowse repositories窗口中选择Manage repositories：\n出现Custom Plugin Repositories窗口，点击“+”按钮，输入golang插件仓库地址后点确定：\n回到Browse Repositories窗口，顶部选择刚添加的golang插件仓库，过滤出golang插件，选择并点击Install plugin按钮安装插件：\n安装golang插件后重启IDEA。安装成功够进入File-\u0026gt;Other Settings-\u0026gt;Default Project Structure\u0026hellip;，选择SDKs选项，添加golang的sdk和指定sdk路径：\ngolang插件配置完毕，创建新项目的时候可以看到go项目和golang的sdk。\n","date":"December 15, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/golang/intellijidea%E5%AE%89%E8%A3%85golang%E6%8F%92%E4%BB%B6/","series":[{"title":"IDE","url":"https://www.qinxiandiqi.sbs/series/ide/"},{"title":"go","url":"https://www.qinxiandiqi.sbs/series/go/"}],"smallImg":"","tags":[{"title":"golang","url":"https://www.qinxiandiqi.sbs/tags/golang/"},{"title":"intellij idea","url":"https://www.qinxiandiqi.sbs/tags/intellij-idea/"},{"title":"ide","url":"https://www.qinxiandiqi.sbs/tags/ide/"},{"title":"插件","url":"https://www.qinxiandiqi.sbs/tags/%E6%8F%92%E4%BB%B6/"}],"title":"Intellij IDEA安装golang插件"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"OS","url":"https://www.qinxiandiqi.sbs/categories/os/"}],"content":" 原文作者：Jianan - qinxiandiqi@foxmail.com\n原文地址：http://blog.csdn.net/qinxiandiqi/article/details/50194811\n版本信息：2015-12-06\n版权声明：本文采用CC BY-NC-ND 4.0共享协议。允许复制和转载，但必须在文首显眼位置保留原文作者、原文链接、版本信息、版权声明等信息。不允许演绎和用于商业用途。\nGoogle旗下两个重量级操作系统：Android和ChromiumOS。Android就不用说了，ChromiumOS目前主要用于ChromeBook设备上。整个系统基本上就是个Chrome浏览器，可以安装各种Chrome扩展和Chrome App Store上面的各种app。虽然ChromeBook设备很便宜，然而并没什么卵用，因为国内根本没有销售啊！我个人的看法是因为国内大环境所致，ChromeBook如果使用不了google的服务，基本上就半身瘫痪了。这种情况下就算ChromeBook很便宜，买来了也没多少使用价值，商家自然也不会投入大陆市场。\n虽然国内没有销售，但是还可以海淘什么的。不过，像我这种精打细算过日子的人，当然不能这么冲动啦。于是决定将ChromiumOS烧录到U盘上先体验下这个系统，再决定入不入手一台ChromeBook。\n然而，Google官方并没有提供将ChromiumOS烧录到U盘的方法，好在ChromiumOS是开源的，网络上的大牛也很多。于是就有人将ChromiumOS进行移植，做了个img系统映像，可以直接烧录到U盘上来体验这个系统。\n在制作ChromiumOS的U盘启动盘之前，需要做下面准备工作：\nChromiumOS系统映像，可以到这里下载。下载到的是个7z压缩包，解压后就是ChromiumOS的img系统映像。 Win32diskManger，用于在window平台上将ChromiumOS系统映像烧录到U盘的软件，可以在这里下载。 U盘一个，容量至少要8G，因为ChromiumOS的系统映像已经7个G了。。。 制作U盘启动盘的方法很简单，打开Win32diskManager，Image File 选项选择ChromiumOS的img系统映像文件路径，Device 选项选择自己电脑上U盘的盘符。之后点击Write按钮，会有确认是否烧录到U盘的信息弹框，重点检查下盘符是不是你的U盘。确认无误后继续往下执行，等烧录完成后就完成了。如下图：\n重启电脑系统，不同的主板需要在开机的时候按不同的键进入启动菜单，根据实际情况进入启动菜单后选择从U盘启动，然后进入ChromiumOS系统。进入系统后会有一些设置网络代理之类的系统初始化的步骤，此处应该有系统截图……但是没有……是事为什么呢？因为手太快点下一步下一步不小心就点过去了啊！另外ChromiumOS下截图不方便。最后要求使用google账号登录或者匿名账号登录系统。有门路就自己设置网络代理翻墙登录google账号，没有的就只能匿名账号登录。然后你会发现除了使用浏览器看看网页，啥都干不了，因为连接不上google的服务，连上google Chrome store在线安装个app都没办法，只能通过离线包安装，略麻烦。。。现已放弃购买ChromeBook的想法。\n有兴趣的小伙伴就玩玩吧。哦~对了，ChromiumOS是基于Linux开发的，烧录到U盘之后，U盘会被切割成五六七八块linux的ext类型分区，所以你的U盘就别想在window上使用了。要想恢复U盘需要使用磁盘工具擦除U盘上所有分区重新格式化，so。。。生命在于折腾，祝玩的开心:)\n","date":"December 6, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/system/%E5%9C%A8u%E7%9B%98%E4%B8%8A%E5%AE%89%E8%A3%85chromiumos/","series":[{"title":"OS","url":"https://www.qinxiandiqi.sbs/series/os/"}],"smallImg":"","tags":[{"title":"ChromiumOS","url":"https://www.qinxiandiqi.sbs/tags/chromiumos/"},{"title":"ChromeBook","url":"https://www.qinxiandiqi.sbs/tags/chromebook/"},{"title":"u盘","url":"https://www.qinxiandiqi.sbs/tags/u%E7%9B%98/"},{"title":"操作系统","url":"https://www.qinxiandiqi.sbs/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"title":"在U盘上安装ChromiumOS"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Java","url":"https://www.qinxiandiqi.sbs/categories/java/"}],"content":" 原文作者：deors\n原文地址：https://deors.wordpress.com/2011/10/31/annotation-generators/\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2015-10-12版本进行翻译\n版权声明：本文经原文作者许可进行翻译，保留所有权利，未经允许不得复制和转载\n本文是我的“使用Java语言注解处理器生成代码”系列第三部分，也是最后一部分。在第一部分中（请阅读这里），我们介绍了什么是Java语言的注解，以及一些常用的方法。在第二部分中（请阅读这里），我们介绍了注解处理器，以及注解处理器如何创建和运行。\n现在，在第三部分中，我们要学习如何使用注解处理器来生成源代码。\n幸运的是从去年开始，MDE[1]（Model-Driven Engineering，也就是模型驱动工程设计，有时候也称为模型驱动开发或者模型驱动架构）已经有助于实践这个目标。这种设计更多的是倾向于艺术层面而不是科学——它针对的是经验丰富的程序员（译注：原文此句为task for ninja coders，国外有把经验丰富的程序员比作忍者的习惯）——是基于经过验证的流程和工具所提取出来的成熟方法论。\n尽管我们可以认为生成源代码是MDE方法论的一个天然切入点，但是MDE涵盖的范围远远不止这些。\n注解处理器只是众多我们用来生成源代码工具中的其中一种而已。\nMDE的一个重要支柱就是它抽象的结构。我们将想要创建的软件系统在不同的细节层面使用不同的方法进行建模。当对一个抽象层建模之后，我们就可以对下一个和再下一个层面继续建模，直到一个可部署的产品被完整地建立起来。\n从这个角度来看，无论我们使用的是哪一个细节层面，一个模型（覆盖的范围）都不会超过对应用来代表系统的抽象层。\n元模型（meta-model），就是我们用来定义模型的规则。你可以认为它是模型的schema或者语法。\n我们可以利用模型来生成配置文件或者从一个已存在的源文件中派生出一个新的源文件。例如，创建一个远程代理，或者为被注解的bean创建一个可访问内部数据的入口对象。\n这种方法的核心在于注解处理器。一个处理器能够读取源代码中的所有注解——也就是提取模型，并且通过它能够做任何我们想要做的事情——打开文件并添加内容等。Java编译器会处理好模型验证的问题（注解必须匹配在注解处理器中注册的类型）。\n在javax.annotation.processing.Filer[2]接口中定义了一些创建源文件、class文件或者生成资源的方法。通过使用Filer，我们可以确保使用了正确的文件目录，以避免丢失文件系统中生成的一些重要数据。\n（另外，）我们需要关注的重点：一方面是考虑是否要写一个在javac上附加-d或者-s选项的生成器，另一方面就是Maven POM中定义文件夹。\n下面是一个如何在注解处理器中创建Java源文件的例子。正如我们创建了一个Bean信息类，生成的类名与被注解的类名相同，只是在它后面添加上了“BeanInfo”后缀：\nif (e.getKind() == ElementKind.CLASS) { TypeElement classElement = (TypeElement) e; PackageElement packageElement = (PackageElement) classElement.getEnclosingElement(); JavaFileObject jfo = processingEnv.getFiler().createSourceFile( classElement.getQualifiedName() + \u0026#34;BeanInfo\u0026#34;); BufferedWriter bw = new BufferedWriter(jfo.openWriter()); bw.append(\u0026#34;package \u0026#34;); bw.append(packageElement.getQualifiedName()); bw.append(\u0026#34;;\u0026#34;); bw.newLine(); bw.newLine(); // rest of generated class contents } 我们将从注解中获取所需信息（代表模型）的逻辑与生成文件（代表视图，译注：指的是MVC设计模式中的V层）的逻辑混合在一起。\n使用这种方法很难写出一个像样的生成器。如果我们需要在这个过程加入更复杂的东西，那么这个过程就会变得非常繁杂，并且容易出错，也很难维护。\n因此，我们需要一种更加优雅的方式：\n将模型从视图中清晰的分离出来。 使用模板来减轻生成文件的任务压力。 让我们来看一个使用这种方式的例子：如何利用Apache Velocity来生成我们想要的生成器。\nVelocity经常在当下流行的MVC模式中被用来渲染视图，或者在XML文件中作为XSLT的替代品进行数据转换。\nVelocity拥有自己的语言，也就是Velocity Template Language（VLT），它是生成简单易读模板的关键。使用VLT，我们可以简单且直观地定义变量，控制流程和迭代，以及访问Java对象中包含的信息。\n下面是一段Velocity模板片段：\n#foreach($field in $fields) /** * Returns the ${field.simpleName} property descriptor. * * @return the property descriptor */ public PropertyDescriptor ${field.simpleName}PropertyDescriptor() { PropertyDescriptor theDescriptor = null; return theDescriptor; } #end #foreach($method in $methods) /** * Returns the ${method.simpleName}() method descriptor. * * @return the method descriptor */ public MethodDescriptor ${method.simpleName}MethodDescriptor() { MethodDescriptor descriptor = null; return descriptor; } #end 写一个用来生成代码的模板。 注解处理器从每一轮的environment中读取被注解的元素并将它们保存到容易访问的Java对象中——包括一个保存field的map对象，一个保存method的map对象，类名和包名等等。 注解处理器实例化Velocity的context。 注解处理器加载Velocity的模板。 注解处理器创建源文件（通过使用Filer），并且连同Velocity Context将一个写入器（writer）传递给Velocity的模板。 Velocity引擎生成源代码。 通过使用这种方法，你会发现处理器/生成器的代码非常清晰，结构良好，并且易于理解和维护。\n下面让我们一步一步来实现：\n步骤1：写模板# 为了简单起见，我们不会列出完整的BeanInfo生成器代码，只是列出部分与注解处理器一块编译时需要的field（成员变量）和method（方法）。\n接下来让我们创建一个名为beaninfo.vm的（模板）文件，并把它放到包含注解处理器的Maven artifact项目的src/main/resources目录下。模板内容的示例如下：\npackage ${packageName}; import java.beans.MethodDescriptor; import java.beans.ParameterDescriptor; import java.beans.PropertyDescriptor; import java.lang.reflect.Method; public class ${className}BeanInfo extends java.beans.SimpleBeanInfo { /** * Gets the bean class object. * * @return the bean class */ public static Class getBeanClass() { return ${packageName}.${className}.class; } /** * Gets the bean class name. * * @return the bean class name */ public static String getBeanClassName() { return \u0026#34;${packageName}.${className}\u0026#34;; } /** * Finds the right method by comparing name \u0026amp; number of parameters in the class * method list. * * @param classObject the class object * @param methodName the method name * @param parameterCount the number of parameters * * @return the method if found, \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt; otherwise */ public static Method findMethod(Class classObject, String methodName, int parameterCount) { try { // since this method attempts to find a method by getting all // methods from the class, this method should only be called if // getMethod cannot find the method Method[] methods = classObject.getMethods(); for (Method method : methods) { if (method.getParameterTypes().length == parameterCount \u0026amp;\u0026amp; method.getName().equals(methodName)) { return method; } } } catch (Throwable t) { return null; } return null; } #foreach($field in $fields) /** * Returns the ${field.simpleName} property descriptor. * * @return the property descriptor */ public PropertyDescriptor ${field.simpleName}PropertyDescriptor() { PropertyDescriptor theDescriptor = null; return theDescriptor; } #end #foreach($method in $methods) /** * Returns the ${method.simpleName}() method descriptor. * * @return the method descriptor */ public MethodDescriptor ${method.simpleName}MethodDescriptor() { MethodDescriptor descriptor = null; Method method = null; try { // finds the method using getMethod with parameter types // TODO parameterize parameter types Class[] parameterTypes = {java.beans.PropertyChangeListener.class}; method = getBeanClass().getMethod(\u0026#34;${method.simpleName}\u0026#34;, parameterTypes); } catch (Throwable t) { // alternative: use findMethod // TODO parameterize number of parameters method = findMethod(getBeanClass(), \u0026#34;${method.simpleName}\u0026#34;, 1); } try { // creates the method descriptor with parameter descriptors // TODO parameterize parameter descriptors ParameterDescriptor parameterDescriptor1 = new ParameterDescriptor(); parameterDescriptor1.setName(\u0026#34;listener\u0026#34;); parameterDescriptor1.setDisplayName(\u0026#34;listener\u0026#34;); ParameterDescriptor[] parameterDescriptors = {parameterDescriptor1}; descriptor = new MethodDescriptor(method, parameterDescriptors); } catch (Throwable t) { // alternative: create a plain method descriptor descriptor = new MethodDescriptor(method); } // TODO parameterize descriptor properties descriptor.setDisplayName(\u0026#34;${method.simpleName}(java.beans.PropertyChangeListener)\u0026#34;); descriptor.setShortDescription(\u0026#34;Adds a property change listener.\u0026#34;); descriptor.setExpert(false); descriptor.setHidden(false); descriptor.setValue(\u0026#34;preferred\u0026#34;, false); return descriptor; } #end } 注意在这个模板运作之前，我们需要将以下信息传递给Velocity：\npackageName：生成类的完整包名。 className：生成类的类名。 fields：源类中包含的filed的集合。我们需要从每个field中获取以下信息： simpleName：filed的变量名。 type：filed的类型。 description：filed的自我描述（在本例中没有使用） …… methods：源类中包含的method的集合。我们需要从每个method中获取以下信息： simpleName：method的方法名。 arguments：method的参数（在本例中没有使用） returnType：method的返回类型（在本例中没有使用） description：method的自我描述（在本例中没有使用） …… 所有的这些信息（也就是模型）都需要从源类里面匹配的注解中提取，并保存到JavaBean后传递给Velocity。\n步骤2：注解处理器读取Model# 下面让我们创建一个注解处理器。正如本系列第二部分中所提到的，不要忘记给处理器添加注解，好让它能够处理BeanInfo注解类型：\n@SupportedAnnotationTypes(\u0026#34;example.annotations.beaninfo.BeanInfo\u0026#34;) @SupportedSourceVersion(SourceVersion.RELEASE_6) public class BeanInfoProcessor extends AbstractProcessor { ... } 注解处理器的方法需要从注解和源类本身中提取构建模型所需要的信息。你可以将全部需要的信息都保存到JavaBean里面，不过在这个示例中我们使用的是javax.lang.model.element类型，因为我们不打算传递太多细节给Velocity（当然，需要的数据还是会传递过去的，在这个例子中我们要创建的是一个完整的BeanInfo生成器）：\nString fqClassName = null; String className = null; String packageName = null; Map\u0026lt;String, VariableElement\u0026gt; fields = new HashMap\u0026lt;String, VariableElement\u0026gt;(); Map\u0026lt;String, ExecutableElement\u0026gt; methods = new HashMap\u0026lt;String, ExecutableElement\u0026gt;(); for (Element e : roundEnv.getElementsAnnotatedWith(BeanInfo.class)) { if (e.getKind() == ElementKind.CLASS) { TypeElement classElement = (TypeElement) e; PackageElement packageElement = (PackageElement) classElement.getEnclosingElement(); processingEnv.getMessager().printMessage( Diagnostic.Kind.NOTE, \u0026#34;annotated class: \u0026#34; + classElement.getQualifiedName(), e); fqClassName = classElement.getQualifiedName().toString(); className = classElement.getSimpleName().toString(); packageName = packageElement.getQualifiedName().toString(); } else if (e.getKind() == ElementKind.FIELD) { VariableElement varElement = (VariableElement) e; processingEnv.getMessager().printMessage( Diagnostic.Kind.NOTE, \u0026#34;annotated field: \u0026#34; + varElement.getSimpleName(), e); fields.put(varElement.getSimpleName().toString(), varElement); } else if (e.getKind() == ElementKind.METHOD) { ExecutableElement exeElement = (ExecutableElement) e; processingEnv.getMessager().printMessage( Diagnostic.Kind.NOTE, \u0026#34;annotated method: \u0026#34; + exeElement.getSimpleName(), e); methods.put(exeElement.getSimpleName().toString(), exeElement); } } 步骤3：初始化Velocity Context并加载模板# 下面的代码片段展示了如何初始化Velocity Context并加载模板：\nif (fqClassName != null) { Properties props = new Properties(); URL url = this.getClass().getClassLoader().getResource(\u0026#34;velocity.properties\u0026#34;); props.load(url.openStream()); VelocityEngine ve = new VelocityEngine(props); ve.init(); VelocityContext vc = new VelocityContext(); vc.put(\u0026#34;className\u0026#34;, className); vc.put(\u0026#34;packageName\u0026#34;, packageName); vc.put(\u0026#34;fields\u0026#34;, fields); vc.put(\u0026#34;methods\u0026#34;, methods); Template vt = ve.getTemplate(\u0026#34;beaninfo.vm\u0026#34;); ... } Velocity配置文件，在本示例中名为velocity.properties，它应该被放置到src/main/resources目录下。下面是它的内容示例：\nruntime.log.logsystem.class = org.apache.velocity.runtime.log.SystemLogChute resource.loader = classpath classpath.resource.loader.class = org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader 这组属性配置了Velocity的日志，以及一个用于查找模板的基本资源加载路径。\n步骤4：创建新的源文件并生成源代码# 紧接着，让我们创建新的源文件，并将这个新文件作为模板的目标来运行模板。下面的代码片段展示了如何操作：\nJavaFileObject jfo = processingEnv.getFiler().createSourceFile( fqClassName + \u0026#34;BeanInfo\u0026#34;); processingEnv.getMessager().printMessage( Diagnostic.Kind.NOTE, \u0026#34;creating source file: \u0026#34; + jfo.toUri()); Writer writer = jfo.openWriter(); processingEnv.getMessager().printMessage( Diagnostic.Kind.NOTE, \u0026#34;applying velocity template: \u0026#34; + vt.getName()); vt.merge(vc, writer); writer.close(); 步骤5：打包并运行# 最后，注册注解处理器（记得添加本系列第二部分中提到过的service配置文件），然后打包。再通过终端命令行，Eclipse或者Maven工具在client（客户）项目中进行调用和编译。\n假设client项目中的client类如下：\npackage example.velocity.client; import example.annotations.beaninfo.BeanInfo; @BeanInfo public class Article { @BeanInfo private String id; @BeanInfo private int department; @BeanInfo private String status; public Article() { super(); } public String getId() { return id; } public void setId(String id) { this.id = id; } public int getDepartment() { return department; } public void setDepartment(int department) { this.department = department; } public String getStatus() { return status; } public void setStatus(String status) { this.status = status; } @BeanInfo public void activate() { setStatus(\u0026#34;active\u0026#34;); } @BeanInfo public void deactivate() { setStatus(\u0026#34;inactive\u0026#34;); } } 当我们在终端上执行javac命令后，我们可以在控制台上看到找到的被注解元素，以及生成的BeanInfo类：\nArticle.java:6: Note: annotated class: example.annotations.velocity.client.Article public class Article { ^ Article.java:9: Note: annotated field: id private String id; ^ Article.java:12: Note: annotated field: department private int department; ^ Article.java:15: Note: annotated field: status private String status; ^ Article.java:53: Note: annotated method: activate public void activate() { ^ Article.java:59: Note: annotated method: deactivate public void deactivate() { ^ Note: creating source file: file:/c:/projects/example.annotations.velocity.client/src/main/java/example/annotations/velocity/client/ArticleBeanInfo.java Note: applying velocity template: beaninfo.vm Note: example\\annotations\\velocity\\client\\ArticleBeanInfo.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. 如果我们检查下源代码目录，我们将会找到我们生成的BeanInfo类。任务完成！\n我们学习了什么是注解和注解类型，以及它们的常用方式。 我们学习了什么是注解处理器，如何写注解处理器，以及如何使用不同的工具运行注解处理器——Java编译器、Eclipse或者Maven。 我们讨论了一点关于模型驱动设计与代码生成的技术。 我们介绍了如何使用注解处理器创建能够与Java编译器完全交互的源代码生成器。 我们介绍了如何利用现有的生成框架（像Apache Velocity）基于注解处理器来创建优雅强大且易于维护的源代码生成器。 现在，是时候将这些内容应用到你的项目中了。思考一下生成技术！\n[1]：如果你想要了解更多关于MDE的内容，请参考维基百科的这篇文章以及它的参考文献。\n[2]：Filer的API文档可以在这里在线查看。\n","date":"October 24, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/java%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E7%94%9F%E6%88%90%E6%BA%90%E4%BB%A3%E7%A0%81/","series":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/series/java/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"注解处理器","url":"https://www.qinxiandiqi.sbs/tags/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/"},{"title":"源代码","url":"https://www.qinxiandiqi.sbs/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/"},{"title":"自动生成","url":"https://www.qinxiandiqi.sbs/tags/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90/"}],"title":"Java语言使用注解处理器生成代码——第三部分：生成源代码"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":" 原文作者：Google\n原文地址：http://developer.android.com/guide/practices/screens_support.html\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2015-10-20版本翻译\n译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n尽管系统能够自动将你的应用程序UI通过缩放或重置大小来适配不同的屏幕，但你仍然需要为你的应用程序适配不同尺寸和密度的屏幕做一点优化工作。这样，你才能够最大程度优化不同设备上的用户体验，让你的用户相信你的应用就是为他们的设备设计的，而不是通过简单的UI拉伸来填充他们的设备屏幕。\n通过本文介绍的方法，你能够创建一个显示正确的应用程序，并且签名打包出一个在其所有支持的设备屏幕上都能获得优越用户体验的apk文件。\n注意： 本文所有内容都假定你的应用程序只支持Android 1.6（API Level 4）或者更高的Android版本。如果你的应用程序需要支持Android 1.5或者更低的版本，请先阅读Strategies for Android 1.5.\n另外，要知道从Android 3.2开始引入了很多新的API，这些API能够让你为不同屏幕尺寸更好的调整应用程序所使用的layout资源。如果你开发的应用需要针对平板进行优化，这些新特性就更加重要。更多的细节可以参考下面Declaring Table Layouts for Android 3.2章节。\n2.1 术语及概念（Terms and concepts）# 2.1.1 Screen size（屏幕尺寸）# 实际的物理尺寸，根据屏幕的对角线来测量。\n为了简单起见，Android将全部屏幕尺寸归类成4种通用尺寸：small、normal、large、extra-large。\n2.1.2 Screen density（屏幕密度）# 指的是屏幕上一个物理单位区域中的像素数量，通常使用dpi（每英寸多少点）为单位。例如，相对于“normal”或者“high”密度的屏幕，在相同物理区域上“low”密度的屏幕拥有的像素要更少。\n为了简单起见，Android将全部屏幕密度归类成6中通用密度：low、medium、high、extra-hight、extra-extra-high、extra-extra-extra-high。\n2.1.3 Orientation（屏幕方向）# 屏幕的方向是从用户的视觉角度来说的。屏幕方向不是landscape（横向）就是portrait（竖向），分别意味着屏幕的宽高比更宽或者更高。注意不单要做不同屏幕的适配，还要做同一个屏幕不同方向情况下的适配，因为如果用户在应用程序运行的过程中旋转设备可能会引起屏幕方向的改变。\n2.1.4 Resolution（分辨率）# 表示一块屏幕上总的物理像素数量。当支持多样屏幕适配的时候，应用程序不直接使用分辨率，应用程序应当使用上文所说的系统通用尺寸和通用密度类别，只需关心屏幕尺寸和密度就可以了。\n2.1.5 Density-independent pixel（dp，密度无关的像素）# 一种虚拟的像素单位。当你在UI的layout资源中定义layout的尺寸或位置的时候，你应当使用这种虚拟像素单位。\n1个单位的虚拟像素等于160dpi屏幕上的一个物理像素点，这也是系统将“medium”屏幕密度作为基准密度的原因。在运行的时候，如果有需要，系统会基于实际屏幕的密度对dp单位进行缩放。dp单位和实际屏幕px像素单位的转换很简单：px = dp * (dpi/160)。例如，在240dpi的屏幕上，1dp等于1.5px。当你定义应用程序UI的时候，你应当使用dp来保证你的UI能够正确显示在不同的屏幕上。\n2.2 屏幕支持的范围（Range of screens supported）# 从Android 1.6（API Level 4）开始，Android提供了多种屏幕尺寸和密度的支持，以对应不同的设备屏幕配置。你可以使用系统提供的这些功能针对每一种屏幕配置优化你的应用程序界面，确保你的应用程序能够在每一种屏幕上提供最好的用户体验，而不单单只是基本正常显示。\n为了简化你为不同屏幕适配用户界面的工作，Android将实际的屏幕尺寸和密度归类为如下：\n4种通用的尺寸：small，normal，large，xlarge 注意： 从Android 3.2（API Level 13）开始，这些尺寸分类已经被弃用，以便于基于可用屏幕宽度来管理屏幕尺寸这种新技术的实现。如果你是为Android 3.2或更高版本的系统开发，请参考下面 Declaring Tablet Layouts for Android 3.2 章节获取更多信息。\n6种通用密度： ldpi(low) ~ 120dpi mdpi(medium) ~ 160dpi hdpi(high) ~ 240dpi xhdpi(extra-hight) ~ 320dpi xxhdpi(extra-extra-high) ~ 480dpi xxxhdpi(extra-extra-extra-high) ~ 640dpi 这些通用尺寸和通用密度全部都是以normal尺寸和mdpi密度作为基准来调整的。之所以使用这个基准是因为这是第一部Android设备T-Mobile G1的屏幕配置，也就是HVGA屏幕（直到Android 1.6之前，这都是Android唯一支持的屏幕配置）。\n每一套通用尺寸和通用密度都会覆盖一定范围的真实屏幕尺寸和密度。例如，两台设备都要求使用normal尺寸，但实际上手动测量两台设备屏幕的真实尺寸和纵横比会稍稍不同。同样的，两个设备都要求使用hdpi密度，但实际上两台设备的像素密度稍稍不同。Android系统会将这些差异抽象化，因此你可以直接提供通用尺寸或者通用密度的UI，让系统在有需要的时候自动进行校准。下图粗略的展示了不同的尺寸和密度与通用尺寸和通用密度的对应关系：\n图1 真实尺寸与密度和通用尺寸通用密度对应的大致范围（注意图中数字是不太准确的）\n当你为不同的屏幕尺寸设计UI的时候，你会发现每一种都有最小的空间值限制。因此，系统对上面提到的每一种通用屏幕尺寸都定义了相关联的最小解析度。最小的尺寸为1dp，dp是你定义layout的时候应该使用的单位，使用这个单位才能让系统处理UI因屏幕密度不同引起的变化。\nxlarge屏幕最小解析度为960dp*720dp large屏幕最小解析度为640dp*480dp normal屏幕最小解析度为470dp*320dp small屏幕最小解析度为426dp*320dp 注意： 这些最小屏幕解析度在Android 3.0之前的版本上并没有明确定义，因此，你可能会发现一些设备的屏幕尺寸在normal和large之间被错误归类了。另外，这些解析度也基于屏幕的物理解析度，所以每台设备都各不相同——例如一部1024*720的平板使用了系统栏后留给应用程序的可用空间会更少，因为部分空间被系统栏占用了。\n为不同的屏幕尺寸和屏幕密度优化你的应用程序UI，你可以为一些通用尺寸和通用密度提供替换的资源。通常情况下，你应该为不同尺寸的屏幕提供可替换的layout资源，以及为不同密度的屏幕提供可替换的图片资源。在运行的时候，系统会将当前设备的屏幕与通用尺寸或通用密度进行对比，自动为你的应用程序选择合适的资源。\n你不需要为每一种通用屏幕尺寸和通用屏幕密度的组合都提供一套可替换的资源。系统提供了强大的兼容功能，能够将你的应用程序渲染到不同设备屏幕上并处理大部分的问题。但前提是你在实现你的UI时已经使用了相关的技术，这样才能使系统优雅的调整UI大小（详细请查看下面独立密度章节）。\n注意： 一台设备的通用屏幕尺寸和通用屏幕密度的特性之间是相互独立的。例如，一块WVGA的high密度屏幕将会使用normal屏幕尺寸，因为它的物理尺寸与T-Mobile G1一样（第一部Android设备，也是屏幕配置分类的基准）。另一方面，一块WVGA的medium密度屏幕将会使用large屏幕尺寸。尽管它们的解析度是相同的（总像素相同），但是这块WVGA medium密度的屏幕密度比较低，这意味着它的像素点物理尺寸更大，因此才会使整块屏幕比基准屏幕（normal尺寸的屏幕）更大。\n2.3 独立的密度（Density independence）# 当你的应用程序实现“密度独立”时，即使是在不同密度的屏幕上，你的UI元素也将保留同样的物理尺寸（从用户的角度来看）。\n保持密度独立是一件重要的事情，因为如果没有保持密度独立，一个UI元素（例如一个按钮）将会在低密度屏幕上显示的很大，而在高密度屏幕上显示的很小。像这样密度相关的尺寸如果一改变，就会导致你的应用程序产生布局或者可用性的问题。图2和图3分别显示了一个应用程序如果没有保持密度独立和保持密度独立的显示效果。\n图2 没有支持不同屏幕密度的应用程序示例，分别是low、medium和high密度的屏幕效果。\n图3 很好支持不同屏幕密度的应用程序示例（也就是密度独立），分别是low、medium和high密度的屏幕效果。\nAndroid系统通过两种方式来帮助你的应用程序实现密度独立：\n系统根据当前屏幕的实际密度自动缩放dp单位到合适的大小 在需要的情况下，系统根据当前屏幕的实际密度自动缩放图片资源到合适的尺寸 在图2中，TextView和ImageView的尺寸通过像素（px单位）来指定，因此这些View的物理尺寸在low密度屏幕上显示会变得很大，在high密度屏幕上显示的很小。这是因为尽管它们的屏幕实际物理尺寸大小一样，但是high密度的屏幕上每英寸拥有的像素点更多（反过来也就是同样数量的像素点在high密度屏幕上能够填充的范围更少）。由于密度无关像素的基准是medium密度的屏幕，所以在上面两张图片中medium密度的屏幕显示效果是一样的。对于low密度和high密度的屏幕，系统会自动分别为dp值的实际尺寸缩小或放大到合适尺寸。\n大多数情况下，确保你的应用程序与密度无关，你只需要简单的将所有layout中的尺寸值使用dp单位或者“wrap_content”属性值声明。这样系统也才能够根据当前屏幕的密度选择合适的缩放因子将图片资源缩放到合适的尺寸。\n然而，从上面的截图中，你可能已经发现图片的缩放会导致图片模糊或者产生齿距。为了避免这种情况，你需要为不同的密度提供可替换的图片资源。例如，你应该为high密度的屏幕提供高分辨率的图片，系统会在high密度屏幕上使用高分辨率的图片来缩放，而不是直接使用medium密度的图片。下面的章节会详细说明如何为不同配置的屏幕提供可替换掉的资源。\n在manifest中明确声明你的应用程序所支持的屏幕尺寸\n通过声明你的应用程序所支持的屏幕尺寸，你可以确保只有符合屏幕配置条件的设备才能下载你的应用程序。声明所支持的不同屏幕尺寸也会影响系统如何在更大的屏幕上绘制你的应用程序——无论你的应用程序是否运行在屏幕兼容模式下。\n声明你的应用程序所支持的屏幕尺寸，你需要在manifest文件中声明\u0026lt;supports-screens\u0026gt;标签。\n为不同的屏幕尺寸提供不同的layout\n默认情况下，Android会调整应用程序的layout大小来适配当前设备屏幕。在大多数情况下，这么做没什么问题。然而，在有些情况下，你的UI可能看起来没那么好，需要针对不同屏幕尺寸做一定的调整。例如，在大屏幕上面，你可能想要调整一些元素的位置和尺寸来利用大屏幕多出来的屏幕空间，或者在小屏幕上你可能需要调整下尺寸才能让全部元素都能正确显示在屏幕上。\n提供特定尺寸资源，你可以使用的配置修饰符有small、noraml、large、xlarge。例如，为extra-large屏幕提供的layout资源应该放在layout-xlarge/资源文件夹下。\n从Android 3.2（API level 13）开始，上面所说的尺寸类别已经被弃用，你应该使用sw\u0026lt;N\u0026gt;dp配置修饰符作为替代品来定义你的layout资源要求的最小可用宽度。例如，如果你的多窗口平板布局要求最少600dp的屏幕宽度，你就应该使用layout-sw600dp/资源文件夹。更多关于这种声明layout资源的新技术，请参考下面Declaring Table Layouts for Android 3.2章节。\n为不同的屏幕密度提供不同的图片资源\n默认情况下，Android会自动缩放你的bitmap图片（.png，.jpg，和.gif文件）和Nine-Patch图片（.9.png文件），这样它们才能在每一台设备上渲染出合适的物理尺寸。例如，如果你的应用程序只为基准密度，也就是medium屏幕密度（mdpi）提供了图片资源，那么系统将会在high密度屏幕上放大这些图片，在low密度屏幕上缩小这些图片。这些缩放可会到引起图片显示问题。为了确保你的图片看起来显示效果最好，你应该为不同密度的屏幕提供不同分辨率的图片进行替换。\n提供特定密度的资源，你可以使用的配置修饰符（下面章节详细介绍）有ldpi（low）、mdpi（medium）、hdpi（high）、xhdpi（extra-high）、xxhdpi（extra-extra-high）、xxxhdpi（extra-extra-extra-high）。例如，想要为high屏幕密度提供的图片应该放在drawable-hdpi/资源文件夹下。\n注意： mipmap-xxxhdpi修饰符只有在需要为xxdpi屏幕密度的设备提供比通常更大的启动图标时才必须使用的。你不需要为所有图片都提供xxxdpi规格的版本。\n有些设备会将启动图标放大多达25%。例如，如果你的最高启动图标密度已经是extra-extra-hight密度，缩放程序将会使启动图标的显示效果变得模糊。因此，你应该在mipmap-xxxhdpi资源文件夹中提供更高密度的启动图标，系统会直接使用这个图标，而不是去放大低密度版本的图片。\n参考提供xxx-high密度启动图标章节获取更多详细信息。除了启动图标，你不应该为其它UI元素提供xxxhdpi类型的图片。\n注意： 将你的启动图标放在res/mipmap-[density]资源文件夹下，而不是res/drawable-[density]资源文件夹。因为，不管你的应用程序实际安装的设备屏幕分辨率是多少，Android系统都会保留这类密度修饰符的资源文件夹，例如mipmap-xxxhdpi。这样启动器才能够选择你的应用程序最佳分辨率的图标显示在home上面。更多关于mipmap文件夹的信息，请参考Managing Projects Overview\n所有的这些尺寸和密度的配置修饰符一一对应上面屏幕支持的范围（Range of screens supported） 章节所提到的通用尺寸和通用密度。\n注意： 如果你不熟悉这些配置修饰符，以及系统如何使用它们来适配替换资源，请参考Providing Alternative Resources。\n在运行的过程中，系统通过以下几个步骤来确保UI在当前屏幕上能有最好的显示效果：\n系统使用适当的可替换资源\n根据当前屏幕的尺寸和密度，系统将使用应用程序提供的对应尺寸和密度修饰符资源文件夹中的资源。例如，一台high密度的设备要使用应用程序的一张图片资源，系统将会在应用程序的全部资源文件夹中挑选最匹配当前设备配置的资源文件夹。取决于可用的替代资源，使用hdpi修饰符的资源文件夹（例如drawable-hdpi）可能是最佳的匹配，系统就会使用这个文件夹中的图片资源。\n如果没有找到匹配的可用资源，系统将会使用默认的资源加以放大或缩小来适配当前屏幕尺寸和密度\n所谓的默认资源文件夹就是那些不带任何配置修饰符的资源文件夹。例如，drawable/资源文件夹中的资源就是默认的图片资源。系统会假设默认的资源是根据屏幕尺寸和密度的基准来设计的，也就是normal尺寸和medium密度。因此，系统将会为高密度的屏幕放大默认图片，为低密度屏幕缩小默认图片。\n然而，当系统查找对应当前屏幕的密度修饰符资源但又找不到匹配的资源时，系统不一定就会使用默认的资源。系统也有可能会使用其它密度修饰符的资源来作替代，以便放大缩小后能够取得最好的效果。例如，当系统寻找low密度的资源但是又找不到的时候，系统会优先用high密度的资源进行缩小，因为相对于使用0.75缩放因子将medium密度资源缩小成low密度资源，系统使用0.5的缩放因子将high密度资源缩小成low密度的资源会更加容易和节省开销。\n更多关于Android系统如何选取带配置修饰符的可替代资源来适应设备配置信息，请参考How Android Finds the Best-matching Resource。\n3.1 使用配置修饰符（Using configuration qualifiers）# Android支持一系列配置修饰符，通过这些修饰符，你可以控制系统如何基于当前设备屏幕的特性选择对应的替代资源。所谓的配置修饰符就是一串字符串，用于附加到你的Android项目资源文件夹后面，以指明该资源文件夹所针对的配置。\n配置修饰符的使用方式：\n在你的项目res/文件夹下创建一个新的文件夹，并以\u0026lt;resources_name\u0026gt;-\u0026lt;qualifiter\u0026gt;格式命名 \u0026lt;resources_name\u0026gt;指的是标准的资源名称（例如drawable或者layout）。 \u0026lt;qualifier\u0026gt;指的是下面表1中的配置修饰符，用于指明文件夹中的资源对应的屏幕配置（例如hdpi或xlarge） 将适当的配置资源放到对应的资源文件夹中。这些资源的名称必须与默认的资源文件一模一样。 例如，xlarge是针对extra-large屏幕的配置修饰符。当你将这个修饰符添加到资源文件夹后面时（例如layout-xlarge），它向系统指明这些资源应该用于extra-large屏幕的设备。\n表1 允许你为不同屏幕配置指定资源的配置修饰符\n更多关于这些修饰符如何匹配当前屏幕实际尺寸和密度的内容，请参考前面屏幕支持范围（Range of Screens Support） 章节。\n例如，下面的应用程序的资源目录为不同的屏幕尺寸提供了不同的layout资源，为不同的屏幕密度提供了不同的图片，并使用mipmap/资源文件夹提供启动图标：\nres/layout/my_layout.xml // layout for normal screen size (\u0026quot;default\u0026quot;) res/layout-large/my_layout.xml // layout for large screen size res/layout-xlarge/my_layout.xml // layout for extra-large screen size res/layout-xlarge-land/my_layout.xml // layout for extra-large in landscape orientation res/drawable-mdpi/graphic.png // bitmap for medium-density res/drawable-hdpi/graphic.png // bitmap for high-density res/drawable-xhdpi/graphic.png // bitmap for extra-high-density res/drawable-xxhdpi/graphic.png // bitmap for extra-extra-high-density res/mipmap-mdpi/my_icon.png // launcher icon for medium-density res/mipmap-hdpi/my_icon.png // launcher icon for high-density res/mipmap-xhdpi/my_icon.png // launcher icon for extra-high-density res/mipmap-xxhdpi/my_icon.png // launcher icon for extra-extra-high-density res/mipmap-xxxhdpi/my_icon.png // launcher icon for extra-extra-extra-high-density 更多关于如何使用可替代资源，以及完整的配置修饰符列表（不单只是屏幕配置修饰符），请参考Providing Alternative Resource.\n要注意，系统在运行的时候会选择哪一种资源作为“最合适”的资源是根据一定的逻辑规则来决定的。也就是，无论在哪种屏幕下，你所使用的修饰符都不一定要跟当前屏幕配置完全匹配，以便系统能够自己选择。具体来讲，当基于尺寸修饰符选择资源的时候，如果没有更匹配的资源，系统会选择为比当前屏幕更小的屏幕所提供的资源（例如，在需要的时候large尺寸的屏幕可能会使用normal尺寸的资源）。另外，如果唯一能够使用的资源是为比当前设备屏幕更大的屏幕所提供的，那么系统将不会使用这些资源，并且应用程序会崩溃（例如，所有的layout资源都添加了xlarge修饰符，但是当前设备屏幕是normal尺寸屏幕）。更多关于系统选择资源的信息，请参考How Android Finds the Best-matching Resource.\n小贴士： 如果你有一些图片资源希望系统永远不进行缩放（可能你想要在程序运行时由自己来控制和调整），那么你应该把这些资源放到nodpi配置修饰符的资源文件夹中。在这个配置修饰符文件夹中的资源是密度无关的资源，系统永远不会对它们进行缩放。\n3.2 设计可替代的布局和图片资源（Designing alternative layouts and drawables）# 需要提供哪些可替代资源是根据你的应用程序需求来决定的。通常情况下，你需要使用尺寸和方向类的修饰符来提供可替代的layout资源，以及使用密度类的修饰符提供可替代的图片资源。\n下面章节将分别总结为什么你要使用尺寸类或密度类修饰符提供可替代的layout资源或者图片资源。\n3.2.1 可替代布局资源（Alternative layouts）# 通常情况下，只要你在不同配置的屏幕上测试你的应用程序，你就能知道是否需要为不同的屏幕尺寸提供可替换的layout资源了。例如：\n当你在small屏幕上测试的时候，你可能会发现你的layout不能很好的填充在屏幕上。例如，在small屏幕上，屏幕的宽度内不能填满多个按钮。这种情况下，你需要为small屏幕提供可替代的layout资源来调整按钮的尺寸和位置。\n当你在extra-large屏幕上测试的时候，你可能会发现你的layout不能高效利用大屏幕的优势，并且整个布局都被拉伸来填满屏幕。这种情况下，你需要为extra-large屏幕提供可替代的layout资源，重新提供为大屏幕（例如平板）优化的UI。\n尽管你的应用程序不为大屏幕提供可替代layout资源也能够正常运行，但对用户来说，提供可替代资源能让用户感觉这个应用程序就是为了他的设备所设计的。如果UI都被拉伸了，用户对应用程序的用户体验可能很反感。\n另外，当测试横向屏幕与竖向屏幕时，你可能会发现竖向屏幕底部的UI元素在横向屏幕上显示在屏幕右边。\n总结，你应该确认你的应用程序布局是存在以下几点：\n需要适配小屏幕（这样用户才能正常使用你的应用程序） 是否有对大屏幕进行优化以充分利用大屏幕带来的额外空间 是否有对横向和竖向屏幕进行优化 如果你的UI所使用的图片即使在被系统缩放layout之后也要填充整个view（例如按钮的背景图片），那么你应该使用Nine-Patch图片文件。Nine-Patch（点九图）文件实际上就是在png图片文件的基础上指定了两个维度上的可拉伸区域。当系统拉伸使用点九图的的view时，所使用的点九图也会被拉伸，只不过拉伸的只是点九图上指定的可拉伸区域。因此，如果使用点九图的话就不需要为不同的屏幕尺寸提供不同的图片，因为点九图能够自动调整到任何尺寸。然而，你还是要为不同的屏幕密度提供可替代的点九图资源。\n3.2.2 可替代图片资源（Alternative drawables）# 几乎每一个应用程序都需要为不同的屏幕密度提供可替代的图片资源，因为每一个应用程序都有一个启动图标，至少要保证这个启动图标在每一块屏幕上都有良好的显示效果。同样，如果你的应用程序中还有其它的图片（例如菜单图标或者其它图形），你都应该为不同的屏幕密度给每一张图片都提供可替换的版本。\n注意： 你只需要为图片文件（.png，.jpg或.git）和Nine-Patch文件提供密度相关的资源。如果你使用XML文件来定义图形、颜色或者其它drawable resources，那么你只需要在默认的图片文件夹（drawable/）中保留一份代码就可以了。\n要为不同的屏幕密度创建可替代的图片资源，你应该遵循六种通用屏幕密度图片的缩放比例3:4:6:8:12:16。例如，如果你有一张为medium屏幕密度设计的图片尺寸是48x48像素，那么其它尺寸应该为：\n36x36（0.75x），low屏幕密度 48x48（1.0x 基准），medium屏幕密度 72x72（1.5x），high屏幕密度 96x96（2.0x），extra-high屏幕密度 180x180（3.0x），extra-extra-high屏幕密度 192x192（4.0x），extra-extra-extra-high屏幕密度（只需要启动图标，参考上面章节） 图4 每一种屏幕密度之间图片的尺寸关系\n更多关于设计图标的信息，请参考Icon Design Guidelines。里面包含了各种图片资源的尺寸信息，包括启动图标、菜单图标，状态栏图标、标签图标等等。\n这么设计的原因是当使用通用尺寸为7英寸平板做适配时，事情会变得非常棘手，因为7英寸平板在通用尺寸归类技术上与5英寸手机都划分为同一组（large类型）。尽管这种设备从尺寸上来看非常相近，但是对应用程序的UI占用的空间大小来说是显著不同的，同样用户交互习惯也不同。因此，7英寸和5英寸屏幕不应该使用相同的layout资源。为了实现为这两种不同的屏幕尺寸提供不同的layout资源，Android现在允许你根据应用程序layout实际需要的尺寸来声明layout资源的类型，并且要使用dp单位。\n例如，你在为平板设备特别设计好layout资源之后，应该在小于600dp宽度的屏幕上检查这些layout是否能使用。因为使用这些平板layout资源的条件就是屏幕的最小尺寸是否满足你声明的尺寸。因此，现在你可以为你的应用程序UI指定一些只有在可用宽度最少为600dp时才能使用的layout资源。\n你应该在指定一个宽度的同时，以这个宽度作为最小尺寸来进行设计。否则，你需要在完成layout资源后测试你的layout能够支持的最小宽度。\n注意： 所有使用新API指定的数值都是密度无关的值（dp），所以你的layout尺寸也应该使用dp单位来定义，因为你应该关心的只是系统计算屏幕密度后得出来的可用屏幕空间总值（强烈反对使用物理像素单位）。更多关于密度无关像素的内容，请参考上面术语与概念（Terms and concepts） 章节。\n4.1 使用新的尺寸修饰符（Using new size qualifiers）# 表2总结了能够根据屏幕可用空间大小来指定资源的配置修饰符。相比较于传统的通用屏幕尺寸类型（small、normal、large、xlarge），新的修饰符能基于你的应用程序支持的屏幕尺寸给你提供更多的控制。\n注意： 你使用这些修饰符指定的尺寸不是实际上的屏幕尺寸。实际上，这些尺寸是你的Activity窗口可用宽度或者高度的dp值。Android系统可能会占用一些屏幕空间来显示系统UI（例如屏幕底部的系统栏或者顶部的状态栏），因此一些屏幕可能无法使用你的layout资源。也就是说，你声明的尺寸应该是你的Activity需要的尺寸——系统会统计系统UI占用的空间后决定给你的layout提供多大的空间。另外也要注意Action Bar也是你的应用程序组成部分，尽管你的layout资源没有声明它，但是它同样要占用你的layout可用空间的一部分，你在设计的时候也要把这部分给计算进去。\n表2 新的屏幕尺寸配置修饰符（Android 3.2引入）\n屏幕配置 修饰符 说明 最小宽度 （smallestWidth） sw\u0026lt;N\u0026gt;dp例如：sw600dp、sw720dp 屏幕的基本尺寸，由屏幕可用区域的最短尺寸所决定。准确的说，设备的最小宽度就是屏幕最短的可用高度和宽度（你也可以认为是屏幕有可能呈现的最短宽度）。你可以使用这个修饰符来确保无论当前屏幕的方向如何，你的应用程序UI最少可用的宽度都有**\u0026lt;N\u0026gt;** dp。例如，你的应用程序无论任何时候都要求屏幕宽度最少要600dp，那么你就可以使用这个修饰符创建一个layout资源并放到**res/layout-sw600dp/**的资源文件夹中。系统只会在当前屏幕可用最小尺寸为600dp时才会使用这个资源，并且不管这个600dp是用户认为的高度还是宽度。最小宽度是一个固定的屏幕尺寸，是屏幕的一个属性。无论当前屏幕的方向如何，设备的最小宽度都是不会变的。设备的最小宽度要考虑到屏幕的装饰空间和系统UI。例如，如果设备屏幕有一些持久性的UI沿着最小宽度的轴心占据一定的空间，那么系统声明的最小宽度值将会比实际屏幕的尺寸小，因为被占据的这部分屏幕空间你的UI永远无法使用。这是相对于传统通用尺寸修饰符（small、normal、large、xlarge）的替代方案，它允许你根据你的UI实际需要的可用尺寸定义离散的数值。使用最小宽度来定义通用尺寸是非常有用的，因为宽度通常是设计一个layout的关键因素。一个UI通常可以上下滑动，但是却在横向空间上无法扩展。可用宽度同时也是决定是否在手机上显示单窗口layout或者平板上显示多窗口layout的关键因素。因此，你应该更加关注每一种设备上可能的最小宽度值是多少。 可用屏幕宽度 （Available screen width） w\u0026lt;N\u0026gt;dp例如：w720dp、w1024dp 通过**\u0026lt;N\u0026gt;**值指定该资源文件夹中资源最小可用宽度的dp值。当屏幕在横向和竖向之间切换的时候，系统相应的宽度值会改变，以实时更新你的UI当前可用的实际宽度。这通常对判断是否使用多窗口layout非常有用，因为尽管是在平板设备上，你通常也不希望竖向多窗口布局与横向的相同。因此，你可以使用这个修饰符来声明layout所需要的最小宽度，而不是同时使用屏幕尺寸和方向的修饰符来联合声明。 可用屏幕高度 （Available screen high） h\u0026lt;N\u0026gt;dp例如：h720dp、h1024dp 通过**\u0026lt;N\u0026gt;值指定该资源文件夹中资源最小可用高度的dp值。当屏幕在横向和竖向之间切换的时候，系统相应的高度值会改变，以实时更新你的UI当前可用的实际高度。与使用w\u0026lt;N\u0026gt;dp来定义layout所需宽度一样，使用h\u0026lt;N\u0026gt;dp**来定义你的layout所需要的高度也是非常有用的，它可以避免使用屏幕尺寸和方向两种修饰符来进行组合定义。然而，大多数app不需要这个修饰符。因为UI在需要的时候一般都能够上下滑动，在可用高度的控制上本身就比较灵活，不像可用宽度无法扩展。 尽管看起来使用这些修饰符要比使用通用屏幕尺寸类修饰符更复杂，但是一旦你确定了你的UI需求，使用这些修饰符实际上要简单得多。当你在设计UI的时候，你所关心的最主要问题应该是你的应用程序在手机风格的UI和平板风格的UI（使用多窗口）之间切换时，你所能使用的实际尺寸。这个UI风格切换的关键点取决于你特定的设计——可能你的平板layout需要720dp的宽度，也有可能600dp或者480dp就够了，还有可能是介于两者之间的某个值。使用表二中的修饰符，你就能精确的控制你的layout切换临界值。 更多关于这些尺寸配置修饰符的资料，请参考Providing Resource文档。\n4.2 配置实例（Configuration examples）# 为了帮助你针对不同类型的设备进行设计，下面是一些典型屏幕宽度的数值：\n320dp：一种典型的手机屏幕（240x320 ldpi、320x480 mdpi、480x800 hdpi等等） 480dp：像是平板设备的过渡线（480x800 mdpi） 600dp：一种7英寸平板（600x1024 mdpi） 720dp：一种10英寸平板（720x1028 mdpi、800x1280 mdpi等等） 使用表2中的尺寸修饰符，你的应用程序可以根据你想要的宽度（或高度）来设定准确的数值去促使手机和平板分别使用不同的layout资源。例如，如果600dp是你的平板layout能够支持的最小可用宽度值，你就可以提供下面两套layout资源：\nres/layout/main_activity.xml # 手机使用 res/layout-sw600dp/main_activity.xml # 平板使用 在这个例子中，只有当前屏幕空间的最小可用宽度值为600dp时，你的平板layout才能够被使用。\n如果你还想进一步自定义你的UI，例如分别为7英寸和10英寸平板设计不同的layout，那么你可以再补充额外的最小宽度值layout：\nres/layout/main_activity.xml # 手机使用 (小于600dp的可用宽度) res/layout-sw600dp/main_activity.xml # 7英寸平板使用(600dp或者更大的屏幕宽度) res/layout-sw720dp/main_activity.xml # 10英寸平板使用(720dp或者更大的屏幕宽度) 注意上面两个例子中的资源所使用的最小宽度修饰符sw\u0026lt;N\u0026gt;dp，它所指的是不管当前设备的方向怎样，屏幕宽高两条边中的最小宽度。因此，使用sw\u0026lt;N\u0026gt;dp从总体上忽略了屏幕的方向并为你的layout指定屏幕的可用尺寸是一种比较方便的方法。\n然而，在一些情况下，分辨当前可用宽度或者高度对你的UI非常重要。例如，如果你有一个内置两个窗口的layout要显示两个边靠边的fragment，你可能就需要根据当前屏幕的宽度是否大于等于600dp，以及是否横向还是竖向才能决定是否使用这个layout。这种情况下，你的资源文件应该类似下面：\nres/layout/main_activity.xml # 手机使用(可用宽度小于600dp) res/layout-w600dp/main_activity.xml # 多窗口 (任何可用宽度大于等于600dp的屏幕) 注意第二套资源使用的可用宽度修饰符是w\u0026lt;N\u0026gt;dp。使用这种方法，有些设备由于屏幕方向的改变导致两种layout都会使用到（例如屏幕在一个方向上可用宽度至少有600dp，而在另一个方向可用宽度小于600dp）。\n如果可用高度才是你需要关注的点的话，你同样也可以与上面一样使用h\u0026lt;N\u0026gt;dp修饰符。甚至，你还可以联合w\u0026lt;N\u0026gt;dp和h\u0026lt;N\u0026gt;dp两种修饰符一块使用，如果你真的需要的话。。。\n4.3 声明支持的屏幕尺寸（Declaring screen size support）# 一旦你为不同的屏幕尺寸实现了对应的layout后，在你的manifest文件中声明你的应用程序所支持的屏幕也是同样重要的。\n相对于新的屏幕配置修饰符，Android 3.2也为manifest的**\u0026lt;support-screens\u0026gt;** 元素引入了新的属性。\nandroid:requiresSmallesWidthDp\n声明支持的最小屏幕宽度。最小宽度指的是屏幕空间（dp单位）上最短的边能够给你的应用程序最小的可用宽度，换句话说就是在屏幕两条边上最短的可用边。因此，为了能让设备兼容你的应用程序，设备的最小宽度应该等于或者大于声明的这个值。（通常声明的这个“最小宽度”值指的是你的layout所支持的值，并且不管当前屏幕是什么方向。）\n例如，如果你的应用程序只支持最小可用宽度为600dp的平板设备： \u0026lt;manifest ... \u0026gt; \u0026lt;supports-screens android:requiresSmallestWidthDp=\u0026#34;600\u0026#34; /\u0026gt; ... \u0026lt;/manifest\u0026gt; 然而，如果你的应用程序支持Android所支持的所有屏幕（比如小到426dpx320dp），那么你可以不用声明这个属性，因为你的应用程序支持的最小宽度已经覆盖了可能遇到的最小设备了。\n慎重： Android系统并不会注意这个属性，因此在运行的过程中这个属性并不会对应用程序的行为产生任何影响。它的作用是在像Google Paly这样的服务中过滤你的应用程序。不过，Google Play当前并不支持这个属性过滤（在Android 3.2版本上）。因此如果你的应用程序不支持小屏幕，你还需要继续使用其它关于尺寸的属性。\nandroid:compatibleWidthLimitDp\n这个属性允许你通过指定你的应用程序所支持的最大的“最小宽度”值来启用屏幕兼容模式作为一个可选的功能。如果设备屏幕的最小边可用宽度值大于你声明的值，用户依然能够安装你的应用程序，不过会在屏幕兼容模式下运行。默认情况下，屏幕兼容模式是关闭的，你的layout通常会被拉伸来填充屏幕。不过在系统栏会有一个按钮允许用户开启或者关闭屏幕兼容模式。 注意： 如果你的layout能够在大屏幕上正确的调整大小，那么你不需要使用这个属性。我们建议你避免使用这个属性，你应该遵从本文档提到的其它方法来确保你的layout尺寸能够适配大屏幕。\nandroid:largestWidthLimitDp\n这个属性允许你通过指定你的应用程序支持的最大的“最小宽度”值来强制启用屏幕兼容模式。如果设备可用屏幕的最小边大于你声明的值，你的应用程序将会在屏幕兼容模式下运行，并且没有任何途径关闭兼容模式。 注意： 如果你的应用程序layout能够在大屏幕上正确调整大小，那么你不需要使用这个属性。我们建议你避免使用这个属性，你应该遵从本文档提到的其它方法来确保你的layout尺寸能够适配大屏幕。\n慎重： 当为Android 3.2或者更高版本系统开发应用程序时，你不应该使用旧的屏幕尺寸属性与上面列出的属性组合使用。同时组合使用新的属性和旧的尺寸属性可能会导致无法预料到到结果。\n更多关于这些属性的信息，请参考上面列出的相关链接。\n下面是确保你的应用程序能够在不同屏幕上良好显示的快速检查列表：\n在XML layout文件中指定尺寸时要使用wrap_content、fill_parent或者dp单位。\n不要在你的应用程序代码中使用固定的像素值。\n不要使用AbsoluteLayout（已经被废弃）\n为不同的屏幕密度提供可替代的图片资源。\n下面的章节提供更多的细节。\n5.1 为layout的尺寸使用wrap_content、fill_content或者dp单位# 当在XML layout文件中定义view的android:layout_width和android:layout_height时，使用wrap_content、fill_parent或者dp单位来确保view在当前设备屏幕上能够分配到一个合适的尺寸。\n例如，一个view定义了layout_width=\u0026quot;100dp\u0026quot;，那么它在medium密度屏幕上将有100像素宽，而在high密度的屏幕上系统会将它放大到150像素宽，这样view就在屏幕上占据大约相等物理尺寸。\n同样的，你应该使用sp（独立尺度像素）单位来定义字体的尺寸。sp的缩放因子由用户设定，系统会像处理dp一样缩放这些尺寸。\n5.2 不要在应用程序的代码中写死像素值# 出于性能原因以及为了保持代码的简单性，Android系统使用像素作为尺寸和坐标值的标准单位。这意味着一个view的尺寸在代码中都是用像素单位来表示，并且基于当前屏幕密度而变化。例如，如果myView.getWidth()返回值为10，这表示在当前屏幕上myView宽度为10像素，但是在更高密度的屏幕上，这个返回值可能为15像素。如果你在应用程序的代码中使用像素值来定义图片的尺寸，这会导致图片无法根据当前屏幕密度进行预缩放处理，你可能需要在自己的代码中自行缩放这些像素值来适配未经缩放的原图。\n如果你的应用程序需要在运行时操作图片或者处理像素值，请参考下面Additional Density Consideration章节。\n5.3 不要使用AbsoluteLayout# 不像其它的layout控件，AbsoluteLayout强制使用固定的值来给子view布局，这样就导致在不同屏幕上很容易出现布局问题。因此，AbsoluteLayout在Android 1.5（API Level 3）就给废弃了。\n你应该替换使用RelativeLayout，它能够根据相对位置给子view布局。例如，你可以指定一个按钮应该显示在一个TextView的右边。\n5.4 使用尺寸和密度相关的资源# 尽管系统会根据当前屏幕配置自动缩放你的layout和图片资源，但你可能需要调整UI在不同屏幕上的尺寸，以及为不同的屏幕密度提供对应的图片资源。这其实是重申上面章节讲的内容。\n如果你需要控制你的应用程序在各个屏幕上的显示效果，你需要在特定资源文件夹中调整你的layout和图片资源。例如，考虑到一个图标需要在medium和high屏幕密度上显示，你可以简单的创建两个不同尺寸的图标（例如medium密度为100x100尺寸，high密度为150x150尺寸），然后分别将这个两个图标放到特定修饰符的资源文件夹中：\nres/drawable-mdpi/icon.png //for medium-density screens res/drawable-hdpi/icon.png //for high-density screens 注意： 如果一个资源文件夹的名字没有定义密度修饰符，那么系统会认为这个资源文件夹中的资源是为medium这个密度基准而设计的，并且在需要的情况下会为其它密度缩放这些资源。\n更多关于有效配置修饰符的内容，请参考上面**使用配置修饰符（Using configuration qualifiers）**章节。\n为了更好的理解在运行过程中是如何操作图形来支持多种密度屏幕，你应该先理解系统用于确保正确缩放图片的途径：\n预缩放资源（例如图片资源）\n基于当前屏幕的密度，系统使用你的应用程序提供的指定尺寸或密度修饰符的资源直接显示。如果提供的资源与当前屏幕密度不符合，系统将会加载默认的资源并放大或缩小这些资源来适配当前的屏幕密度。系统会假设默认的资源（就是那些保存在没有添加任何配置修饰符资源文件夹中的资源）是为屏幕密度的基准（mdpi）而设计的，除非系统加载的资源是从其它密度修饰符资源文件中加载的。所谓的预缩放就是系统将图片大小调整到适合当前屏幕尺寸时做的处理。 如果你需要获取预缩放资源的尺寸，系统返回的将是缩放之后的资源尺寸。例如，一张为mdpi屏幕设计的图片为50x50像素，它将会在hdpi屏幕上放大到75x75像素（如果没有对应的hdpi资源替换的话），并且系统返回的尺寸也将是放大后的这个值。\n在一些情况下，你可能不希望Android系统进行预缩放资源处理。避免预缩放处理最简单的方法就是把资源放到nodpi配置修饰符的资源文件夹下。例如：\nres/drawable-nodpi/icon.png\n当系统从这个文件夹中获取icon.png资源时，系统会不根据当前设备密度对这张图片进行缩放。\n自动缩放像素尺寸和位置\n应用程序可以通过在manifest文件中设置android:anyDensity属性为false，或者在程序代码中把一张图片的Bitmap对象的inScaled属性设置为false来禁用预缩放处理。在这种情况下，系统将会在绘制过程中自动缩放绝对像素位置和像素尺寸。系统通过这么处理来保证使用像素定义的屏幕元素与在基准屏幕密度（mdpi）上显示的物理尺寸保持大致相同。系统所做的这些缩放处理对于应用程序来说是透明，应用程序获取到的也是缩放后的尺寸，而不是实际的物理像素尺寸。\n例如，假设一台设备是WVGA high密度的屏幕，它的分辨率为480x800并且与传统的HVGA屏幕的大小一样，现在它运行一个禁用预缩放处理的程序。在这种情况下，当应用程序请求屏幕尺寸时，系统将会“欺骗”应用程序，返回320x533尺寸（近似mdpi的屏幕密度）。之后，当应用程序执行绘画操作时，例如废除一个位于(10,10)到(100,100)的矩形，系统将会适当转换这个位置的值，实际上废除的区域为(15,15)到(150,150)。如果你的应用程序需要直接操作图片的缩放，这个误差可能会导致意想不到的结果，不过这是尽可能考虑应用程序的性能后得出的一个合理的方案。如果你遇到这种情况，请参考下面将dp单位转换为像素单位（Converting dp units to pixel units） 。\n通常情况下，你不应该禁用预缩放处理。支持多样屏幕的最好方法是遵从上面如何支持多屏幕（How to Support Multiple Screens) 章节提及的基本技术。\n如果你的应用程序需要操作图片或者需要通过其它方式在屏幕上直接与像素进行交互，那你可能需要采取额外的步骤来支持不同的屏幕密度。例如，如果你需要根据手指在屏幕上划过的像素点来识别触摸手势并进行响应，你就需要采用适当的密度无关像素值来取代实际像素值。\n6.1 缩放运行过程中创建的Bitmap对象（Scaling Bitmap objects created at runtime）# 如果你的应用程序在内存中创建一张图片（一个Bitmap对象），默认情况下系统会假设这张图片是为medium这个基准屏幕密度而设计的，并且在渲染的时候会自动缩放。当Bitmap没有指定密度属性时，系统会添加“自动缩放”属性给Bitmap。如果你没有正确计算当前设备的屏幕密度并且为Bitmap对象指定相应的密度属性，自动缩放会跟你没有提供可替换资源的处理方法一样缩放这些Bitmap图片。\n为了控制运行过程中创建的Bitmap对象是否缩放，你可以通过Bitmap的setDensity()为其指定密度类型，该方法可选参数值为DisplayMetrics类中定义的常量，例如DENSITY_HIGH或者DENSITY_LOW。\n如果你是通过BitmapFactory从文件或者数据流这些数据源创建了Bitmap对象，那么你可以当做这个Bitmap对象已经存在一样，使用BitmapFactory.Options来设置bipmap对象的属性，系统通过这些属性来决定如何对它进行缩放。例如，你可以设置inDensity属性来设置bitmap对象对应的屏幕密度，以及inScaled属性来设置bitmap是否要通过缩放来适配当前设备屏幕密度。\n如果你设置inScaled属性为false，那么你就禁用了系统可能会对bitmap进行的预缩放处理，系统在每次绘制的时候才对bitmap自动缩放处理。使用自动缩放来取代预处理会消耗更多的CPU，不过可以节省内存。\n图5： 对比预缩放和自动缩放的bitmap\n图5显示了在high密度屏幕上分别加载low（120）、medium（160）、high（240）密度的bitmap时，预处理缩放和自动缩放机制的区别。可以看出其中的差异是很小的，因为所有的bitmap都被缩放到适配当前屏幕密度的大小，尽管被缩放的bitmap由于预缩放处理还是绘制时自动缩放处理而有小小的显示差异。\n注意： 在Android 3.0或更高的系统版本中，由于改进了图形框架，预缩放或者自动缩放的bitmap显示效果将看不出区别。\n6.2 将dp单位转换为像素单位（Converting dp units to pixel units）# 在一些情况，你需要使用dp单位表达尺寸后再转换为对应的像素单位。试想一下一个应用程序识别一个滑动或者划动手势的要求是手指至少移动16像素。在基准屏幕上要识别出这个手势，用户至少要滑动16 pixels/160dpi，相当于一英寸的十分之一（2.5mm）。如果是在high密度的设备屏幕上，用户至少要滑动16 pixels/240dpi，相当于一英寸的十五分之一（1.7mm）。这个距离必须足够短，这样用户才能感觉这个应用程序很灵敏。\n为了解决这个问题，手势的触发距离必须在代码中用dp表示，并转换为对应的实际像素尺寸。例如：\n// 用dp单位表示的手势触发距离 private static final float GESTURE_THRESHOLD_DP = 16.0f; // 获取屏幕密度 final float scale = getResources().getDisplayMetrics().density; // 基于\u0008屏幕密度将dp尺寸转换为px尺寸 mGestureThreshold = (int) (GESTURE_THRESHOLD_DP * scale + 0.5f); // 使用mGestureThreshold作为手势距离判定尺寸... 其中DisplayMetrics.density属性是根据当前屏幕密度得出的缩放因子，你必须使用这个因子转换dp单位和像素单位。在medium密度的屏幕上，DisplayMetrics.density等于1.0；在high密度的屏幕上等于1.5；在extra-high密度的屏幕上等于2.0；在low密度的屏幕上等于0.75。你必须使用这个因子的数值乘以dp单位值得出在当前屏幕上对应的实际像素尺寸（额外增加0.5f是为了在强制转换为整数时得到较大的整数值）。更多信息，请参考DisplayMetrics类。\n另外，与其随意为这类事件定义一个触发值，你应该使用ViewConfiguration类中的可用方法获取预缩放的配置值。\n6.3 使用预缩放配置值（Using pre-scaled configuration values)# 你可以使用ViewConfiguration类来获取Android系统使用的距离值、速度值、时间值等等。例如，系统框架识别滑动操作的像素距离值可以使用getScaledTouchSlop()方法获取：\nprivate static final int GESTURE_THRESHOLD_DP = ViewConfiguration.get(myContext).getScaledTouchSlop(); 使用ViewConfiguration类中以getScaled开头的方法返回的像素值，不管当前是什么屏幕密度，都保证能正确显示。\n配置应用程序多样屏幕支持性测试环境，你需要创建一系列AVD（Android虚拟机），可以使用默认的仿真模拟器或者创建符合你的应用程序能够支持的屏幕尺寸密度的屏幕配置。为此，你可以使用AVD管理器来创建这些AVD，并通过图形界面启动它们。\n图6： 为测试屏幕支持个的系列AVD\n启动Android SDK管理器，在window平台下你可以执行Android SDK文件夹下的SDK Manager.exe文件，在其它平台上可以执行\u0026lt;sdk\u0026gt;/tools/目录下的android可执行文件。图6展示了选中一个AVD的AVD管理器，用于测试各种各样的屏幕配置。\n表3展示了Android SDK提供的各种各样仿真模拟器，你可以使用这些模拟器来模拟一些常见的屏幕配置。\n表3： Android SDK提供的仿真器及各种屏幕配置（粗体显示）,还有其它一些典型分辨率。\nLow密度(120),ldpi Medium密度(160),mdpi High密度(240),hdpi Extra-high密度(320),xhdpi Small屏幕 QVGA(240x320) 480x640 Normal屏幕 WQVGA400(240x400)WQVGA432(240x432) HVGA(320x480) WVGA800(480x800)WVGA854(480x854)600x1024 640x960 Large屏幕 WVGA800(480x800)[1]WVGA854(480x854)[1] WVGA800(480x800)[2]WVGA854(480x854)[2] Extra-Large屏幕 1024x600 WXGA(1280x800)[3]1024x7681280x768 1536x11521920x11521920x1200 2048x15362560x15362560x1600 [1] 模拟这个配置，在创建AVD的时候要自定义120的密度，并且选择WVGA800或者WVGA854的皮肤 [2] 模拟这个配置，在创建AVD的时候要自定义160的密度，并且选择WVGA800或者WVGA854的皮肤 [3] Android 3.0平台上才支持这个皮肤 更多关于创建和使用AVD测试应用程序的内容情况请参考Managing AVDs with AVD Manager。\n查看所有支持的屏幕配置激活设备比例，请参考Screen Sizes and Densities。\n\u0008我们同样建议你将模拟器的物理尺寸配置成与真实设备尺寸相近后再测试你的应用程序。这样更容易将模拟结果与各个尺寸和密度比较。为此，你需要知道你的计算机显示器大致的dpi密度（例如，一个30英寸的戴尔显示器密度大概96dpi）。当你从AVD管理器中启动AVD的时候，你可以在启动选项中指定模拟器的屏幕尺寸和显示器的dpi，如图7：\n图7 从AVD管理器中启动AVD时，你可以设置的尺寸和密度选项\n如果你想要在内建模拟器皮肤支持的分辨率或密度之外的屏幕上测试你的应用程序，你可以通过自定义分辨率和密度来创建一个AVD。当使用AVD管理器创建AVD的时候不要选择内建的皮肤，自己指定分辨率。\n如果你使用命令行启动你的AVD，你可以通过-scale选项为模拟器指定缩放因子，例如：\nemulator -avd \u0026lt;avd_name\u0026gt; -scale 96dpi 为了精简模拟器的尺寸，你也可以为-scale选项传递一个0.1到3之间的数值，它代表期望的缩放因子。\n更多关于从命令行创建AVD模拟器的内容，请参考Managing AVDs from the Command Line。\n","date":"October 20, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/android%E7%9A%84%E5%B1%8F%E5%B9%95%E5%A4%9A%E6%A0%B7%E6%80%A7%E6%94%AF%E6%8C%81/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"屏幕","url":"https://www.qinxiandiqi.sbs/tags/%E5%B1%8F%E5%B9%95/"},{"title":"碎片化","url":"https://www.qinxiandiqi.sbs/tags/%E7%A2%8E%E7%89%87%E5%8C%96/"},{"title":"兼容","url":"https://www.qinxiandiqi.sbs/tags/%E5%85%BC%E5%AE%B9/"},{"title":"布局","url":"https://www.qinxiandiqi.sbs/tags/%E5%B8%83%E5%B1%80/"}],"title":"Android的屏幕多样性支持"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"OS","url":"https://www.qinxiandiqi.sbs/categories/os/"}],"content":"升级win10之后，有时会莫名其妙发现任务栏上面包括开始菜单、小娜、日历、系统通知等系统图标都无法点击，并且重启系统之后并没有自动修复。发生这种情况可以尝试以下解决方法：\n方法一：卸载冲突软件# 这种情况有可能是存在冲突软件引起的。如果你确定这种情况是在安装某个软件之后出现了，那么可以尝试进入安全模式中把这个软件卸载：\n按window+R键，弹出运行窗口，输入msconfig调出系统配置窗口： 选择引导标签页，勾选安全引导选项 点击确定后重启系统 系统进入安全模式，在安全模式中卸载最近安装后导致任务栏系统图标无法点击的软件 卸载软件之后，同样按照上面的方法调出系统配置窗口，并把安全引导选项勾除。 再次重启系统，看看是否问题解决。 方法二：重启window资源管理器# 如果你排除是因为软件冲突引起的问题，那么你可以简单尝试下重启window资源管理器。\n按Ctrl+Alt+Delete键或者右键任务栏菜单调出任务管理器 在任务管理器中找到Widnwo资源管理器，右键菜单选择重启，或者点击右下角重新启动按钮\n查看情况是否解决。 方法三：PowerShell中执行修复脚本# 任务管理器中点击文件菜单，选择运行新任务，弹出新建任务小窗口 在新建任务小窗口中输入PowerShell，并勾选以系统管理权限创建此任务，点击确定弹出PowerShell终端。\n在PowerShell终端中，输入一下命令并执行： Get-AppXPackage -AllUsers | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register \u0026#34;$($_.InstallLocation)\\AppXManifest.xml\u0026#34;} 等待命令执行完成，过程种可能会弹出一些错误信息，直接忽略它们。命令执行完成之后，查看问题是否已经修复。 方法四：cmd中执行修复命令# 运行管理员权限的cmd终端。在开始菜单图标右键菜单选择命令提示符（管理员），或者跟上面PowerShell一样的方式，只不过将新建任务小窗口中输入的“PowerShell”改为“cmd”。 在cmd终端中执行下面命令： ren %windir%\\System32\\AppLocker\\Plugin*.* *.bak 重启系统，查看问题是否解决。 方法五：修复系统服务# 按照上面打开PowerShell一样的方法，新建任务小窗口中输入services.msc,打开服务窗口。 查找其中的Application Identity服务，右键菜单选择启动。 查看问题是否已经解决。 方法六：还原系统# 如果你有做系统备份，尝试将系统还原到最近正常的时间点。\n参考：https://www.xtremerain.com/fix-windows-10-start-menu-cortana-not-working/\n","date":"October 19, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/system/%E4%BF%AE%E5%A4%8Dwin10%E4%BB%BB%E5%8A%A1%E6%A0%8F%E5%BC%80%E5%A7%8B%E8%8F%9C%E5%8D%95%E7%AD%89%E7%B3%BB%E7%BB%9F%E5%9B%BE%E6%A0%87%E6%97%A0%E6%B3%95%E7%82%B9%E5%87%BB%E9%97%AE%E9%A2%98/","series":[{"title":"OS","url":"https://www.qinxiandiqi.sbs/series/os/"}],"smallImg":"","tags":[{"title":"win10","url":"https://www.qinxiandiqi.sbs/tags/win10/"},{"title":"开始菜单","url":"https://www.qinxiandiqi.sbs/tags/%E5%BC%80%E5%A7%8B%E8%8F%9C%E5%8D%95/"},{"title":"任务栏","url":"https://www.qinxiandiqi.sbs/tags/%E4%BB%BB%E5%8A%A1%E6%A0%8F/"},{"title":"无法点击","url":"https://www.qinxiandiqi.sbs/tags/%E6%97%A0%E6%B3%95%E7%82%B9%E5%87%BB/"},{"title":"修复","url":"https://www.qinxiandiqi.sbs/tags/%E4%BF%AE%E5%A4%8D/"}],"title":"修复Win10任务栏开始菜单等系统图标无法点击问题"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Java","url":"https://www.qinxiandiqi.sbs/categories/java/"}],"content":" 原文作者：deors\n原文地址：https://deors.wordpress.com/2011/10/08/annotation-processors/\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2015-10-16版本进行翻译\n版权声明：本文经原文作者许可进行翻译，保留所有权利，未经允许不得复制和转载\n现在，在这第二部分中，我们将介绍注解处理器。包括如何创建注解处理器，以及如何运行它们。\n直到目前为止，我们所看到的是注解相比于Javadoc有很多优点，但是还不足够证明它们集成到Java语言的程度。因此，是否有可能与注解进行交互并从注解中获得更多的功能？答案是肯定的：\n在运行过程中，使用RUNTIME生命周期类型的注解能够通过反射来访问。通过Class的getAnnotation()和getAnnotations()方法就能完成这件奇妙的事情[1]。\n在编译过程中，注解处理器，一种特殊的类，能够处理从编译的代码中找到的每一个注解。\n从Java 6开始，注解处理器通过JSR 269[2]已经标准化并被纳入到标准库中，apt工具也被无缝集成到Java编译工具javac里面。\n尽管我们只讨论Java 6新注解处理器API的细节，但是你同样可以在这里或者这里找到Java 5文档中关于apt以及Mirror API的相关信息，并在这篇文章中找到适当的例子。\n注解处理器不是简单地实现javax.annotaion.processing.Processor接口并完成其中定义的方法。因此，为方便我们实现自定义处理器，Java提供了一个已经实现通用功能的虚拟类javax.annotation.processing.AbstractProcessor。\n自定义的注解处理器可能会用到下面三个注解来配置自己：\njavax.annotation.processing.SupportedAnnotationTypes：用于给注解处理器注册能够处理的注解类型。可用值为支持的注解类型完整名称——使用通配符也是允许的。\njavax.annotation.processing.SupportedSourceVersion：用来声明注解处理器所支持的源代码版本。\njavax.annotation.processing.SupportOption：用来注册可能从命令行传递过来的自定义选项（参数）。\n最后，我们要实现自己的process()方法。\nimport …\n@SupportedAnnotationTypes(\u0026ldquo;sdc.assets.annotations.Complexity\u0026rdquo;) @SupportedSourceVersion(SourceVersion.RELEASE_6) public class ComplexityProcessor extends AbstractProcessor {\npublic ComplexityProcessor() { super(); } @Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment roundEnv) { return true; } }\n上面这个注解处理器类注册了它所支持的注解类型为sdc.assets.annotations.Complexity，虽然这个注解处理器被调用的时候什么事都没干。这样，每次Java编译器（编译）生成class时，如果有发现使用了Complexity注解就会执行这个注解处理器，这个注解处理器必须能够在classpath中找到（稍后我们会了解这方面的更多细节）。 为了能够与被注解的类进行交互，process()方法提供两个参数： * 一个java.lang.model.TypeElement对象的Set集合：处理注解的过程要经过一个或者多个回合才能完成。每个回合中注解处理器都会被调用，并且接收到一个以在当前回合中已经处理过的注解类型的Type为元素的Set集合。 * 一个javax.annotation.processing.RoundEnvironment对象：通过这个对象可以访问到当前或者之前的回合中处理的Element元素（译注：可以被注解类型注解的元素，如类、方法、参数等等），只有被注解处理器注册的注解类型注解过的元素才会被处理。 除了上面两个参数之外，还有一个ProcessingEnvironment类型的实例对象processingEvn可以使用。通过这个对象可以访问日志或者其它一些工具；其中一些会在稍后讨论。 通过RoundEnvironment对象以及被注解元素的反射方法，我们就可以写一个简单的注解处理器实现类。这个注解处理器的处理方法只是打印出所有能找得到的，被Complexity注解的元素： ```java for (Element elem : roundEnv.getElementsAnnotatedWith(Complexity.class)) { Complexity complexity = elem.getAnnotation(Complexity.class); String message = \u0026#34;annotation found in \u0026#34; + elem.getSimpleName() + \u0026#34; with complexity \u0026#34; + complexity.value(); processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message); } return true; // no further processing of this annotation type 注册处理器最简单的方法就是利用标准的Java服务机制：\n将你的注解处理器打包进一个Jar包。 在这个Jar包中要包含一个文件夹META-INF/services。 在这个文件夹中要包含一个名为javax.annotation.processing.Processor的文件。 在这个文件里面将Jar包中所有注解处理器的完整类名写进去，每个类名一行。 Java编译器或者其它工具将会在所有声明的classpath路径下查找这个文件，并用于注册处理器。\n在我们的示例中，项目文件夹结构以及文件的内容如下：\n完成打包后，我们就开始可以使用它了。\n如果你将注解处理器添加到javac的classpath下，并且使用上面提到的服务机制进行注册了，那么它们将会被javac调用执行。\n在我们的的示例中，下面的命令将会编译并处理使用了Complexity注解的Java源文件（译注：-cp是javac用于指定classpath的可用选项，下面命令中将包含自定义注解和注解处理器的两个jar包添加到classpath下）：\n\u0026gt;javac -cp sdc.assets.annotations-1.0-SNAPSHOT.jar; sdc.assets.annotations.processors-1.0-SNAPSHOT.jar SimpleAnnotationsTest.java 其中用于测试的Java类内容如下：\npackage sdc.startupassets.annotations.base.client; import ... @Complexity(ComplexityLevel.VERY_SIMPLE) public class SimpleAnnotationsTest { public SimpleAnnotationsTest() { super(); } @Complexity() // this annotation type applies also to methods // the default value \u0026#39;ComplexityLevel.MEDIUM\u0026#39; is assumed public void theMethod() { System.out.println(\u0026#34;consoleut\u0026#34;); } } 当我们执行完javac命令后，输出的结果如下：\n尽管使用默认的javac参数配置通常都没有什么问题，不过在某些情况下还有一些选项可以帮助我们运行注解处理器：\n-Akey[=value]：用于传递一个选项给处理器。只有在注解处理器上通过SupportedOptions注解注册过的选项才能传递进去。 -proc:{none|only}：默认情况下，javac会运行注解处理器并编译全部源文件。如果使用了proc:none选项，那么所有的注解处理过程都不会被执行——这在编译注解处理器本身的时候很有用。如果使用了proc:only选项，则只有注解处理过程会被执行——在运行类似质量检查工具或者标准检查器这样功能的注解处理器内部验证时很有用。 -processorpath path：用于指定注解处理器及相关依赖的位置。这是个可选项，如果没有设定，编译器会去默认的classpath路径下搜索。这在项目依赖和注解处理器依赖（运行过程中不需要的部分）之间保持明确的分离时非常有用。 -s dir：用于指定生成代码的保存位置。尽管对应源代码包层级结构的子目录在需要的时候会被自动创建，但是指定的这个父目录必须要在运行javac命令之前就已经存在。 -processor class1[,class2,class3\u0026hellip;]：指定需要执行的注解处理器的完整类名。如果指定这个选项，上面提到的基于服务机制来搜索注解处理器过程就会被忽略。这对于在classpath下有多个注册的注解处理器但只想执行其中几个的情况非常有用。 在Eclipse下，当你打开Java项目的properties对话框后，你可以在Java Compiler分组中找到Annotation Processing选项。\n在Annotation Processing选项标签页中，勾选Annotation Processing选项（默认不勾选）。处理器选项参数可以通过这个标签页中的表单（在编译的时候）传递过去。\n同样，在Factory Path选项页中选择需要执行的注解处理器：\n一旦完成配置，每次编译这个项目的时候，注册的注解处理器都会被执行。\n（在Maven中），我们能够访问到的自动化（处理）层级允许我们将所有的任务类型无缝集成到构建过程中。在一个项目的周期里面，标准验证和代码生成不再需要一个单独的进程。另外，它同样允许与持续集成引擎无缝集成。\n尽管还有其它集成注解处理器到Mavan构建中的方法，但是我们建议使用这里讨论的方法。这种方法基于相同的Mojo（Maven plug-in，译注：Mojo表示一个处理过程的具体实现，通常由maven的Plugin提供这个具体过程），它能够管理编译的任务。实际上，由于（实际）使用了Java编译工具，这种方法能够产生我们熟知的标准做法。\n与Maven集成需要同时将我们的注解和注解处理器以Maven artifact的形式引入。\n我们建议将注解和注解处理器保存到不同的artifact中，因为在一些客户项目中可能不需要这些注解处理器，这样才能减少项目的依赖数量。\n在这个方法中，我们将会创建三个不同的项目，每个项目对应一个Maven artifact：\n关于注解的artifact。它只包含了自定义的注解类型。 关于注解处理器的artifact。它包含了注解处理器。取决于这些处理器在完成它们的处理任务时需要使用的自定义注解，而添加上包含对应注解的artifact依赖。编译插件需要配置上proc:none选项，这样在编译这个artifact的时候，注解处理过程才不会被执行。 客户项目。它包含了具体的业务代码，需要依赖前面的两个artifact。 下面是包含注解的artifact项目文件夹结构以及POM内容：\n注意构建上面这个artifact的maven编译插件版本号。\n下面是包含注解处理器的artifact项目文件夹结构和POM内容：\n注意打包处理器过程中需要的services文件夹、Maven编译插件的版本、用于在编译这个artifact过程中阻止运行处理器的选项proc:none，以及包含注解类型的artifact的依赖。\n最后，下面是客户项目的文件夹结构和POM内容：\n注意这里需要依赖包含自定义注解的artifact以及包含注解处理器的artifact。\n完成之后，每次执行maven构建工具的compile目标，注解处理器都会按照预设的执行。\n本系列将会在第三部分中继续讲解：生成源代码。请阅读这里。\n[1]：从这里查看Class接口文档获取更多内容\n[2]：JSR269，动态注解处理器API，可以在这里在线查看。\n","date":"October 16, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/java%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/","series":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/series/java/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"Annotation","url":"https://www.qinxiandiqi.sbs/tags/annotation/"},{"title":"注解处理器","url":"https://www.qinxiandiqi.sbs/tags/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/"}],"title":"Java语言使用注解处理器生成代码——第二部分：注解处理器"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Java","url":"https://www.qinxiandiqi.sbs/categories/java/"}],"content":" 原文作者：deors 原文地址：https://deors.wordpress.com/2011/09/26/annotation-types/ 译文作者：Jianan - qinxiandiqi@foxmail.com 版本信息：本文基于2015-10-09版本进行翻译 版权声明：经原作者许可进行翻译，保留所有权利，未经允许不得复制和转载。\n在这系列文章中，我们将会：\n介绍Java语言的注解。 了解注解的常用方式以及使用范围。 了解注解处理器以及它们所代表的角色。 学习如何创建注解处理器。 学习如何在终端命令行、Eclipse和Maven中运行注解处理器。 学习如何使用注解处理器生成源代码。 学习如何使用像Apache Velocity这样的外部模板引擎来使用注解处理器生成源代码。 通过注解，我们可以为源代码添加元数据信息，包括编译或部署信息、配置属性、编译行为或者代码质量检查。\n与Javadoc不同，注解属于强类型，用到的注解在类路径下都能找到对应的注解类型定义。因此，定义的注解可以在运行时访问到，而Javadoc是不可能的。\n注解可以添加到package（包）、types（类型，包括类、接口、枚举和其它注解类型）、variable（变量、包括class、类实例、局部变量——包括定义在for或者while循环里面的局部变量）、constructions（构造方法）、methods（方法）和parameters（参数）。\n最简单的注解结构就是内部什么元素都没有，例如：\n@Override() public void theMethod() {…} 在这个例子中，括号可以省略（因为没有参数）：\n@Override public void theMethod() {…} 注解也可以包含元素，这些元素是通过逗号分隔的键值对。允许使用的值类型包括java原生数据类型、String类型、枚举类型，以及这些类型的数组形式：\n@Author(name = \u0026#34;Albert\u0026#34;, created = \u0026#34;17/09/2010\u0026#34;, revision = 3, reviewers = {\u0026#34;George\u0026#34;, \u0026#34;Fred\u0026#34;}) public class SimpleAnnotationsTest {…} 当注解内部只有一个元素，并且这个元素名为value的时候，元素名可以省略：\n@WorkProduct(\u0026#34;WP00000182\u0026#34;) @Complexity(ComplexityLevel.VERY_SIMPLE) public class SimpleAnnotationsTest {…} 注解可以为内部一些元素或者全部元素都设置默认值。在使用这类注解的时候，具备默认值的元素可以省略。\n例如，假设有个注解为Author，它为内部元素revision（默认为1）以及reviewers（默认为空String数组）设置了默认值，下面使用这个注解的两种方式是等效的：\n@Author(name = \u0026#34;Albert\u0026#34;, created = \u0026#34;17/09/2010\u0026#34;, revision = 1, reviewers = {}) public class SimpleAnnotationsTest() {…} @Author(name = \u0026#34;Albert\u0026#34;, // defaults are revision 1 created = \u0026#34;17/09/2010\u0026#34;) // and no reviewers public class SimpleAnnotationsTest() {…} @Deprecated： 用来声明被注解的元素不应该再使用。每当这个注解被使用的时候，编译器就会生成一个警告。它应该与Javadoc的@deprecated一起使用，在Javadoc中解释舍弃被注解元素的原因。\n@Override： 用来声明被注解的元素重写了父类中声明的元素。如果被注解的元素没有在父类中找到对应的被重写的元素，编译器就会生成一个警告。尽管这个注解没有要求一定要使用，但是它对于错误判断非常有用——例如，如果在创建父类之后，有人又修改了父类方法的签名，那么我们在重新编译源代码的时候就能马上得到提醒。\n@SuppressWarnings： 让编译器抑制指定的警告类型，否则被注解的元素就会触发这类警告——例如，为了避免使用了被舍弃的API或者与旧代码（例如Java 5之前的版本）进行了未检查的交互而产生过多的编译器“干扰”。\n自从引入这些注解后，很多库和框架都将注解集成到它们新的发行版本中。通过在源代码中使用注解，这些库和框架都简化甚至移除了所需要的配置文件。\n下面是一些成功使用注解的例子：\nJava企业版和它的主要模块——企业级JavaBeans、Java持久化API或者Web Service API。 Spring框架——用于核心模块中的配置、依赖注解和控制反转中，以及其它一些Spring项目。 Sean、Weld、Guice. Apache Struts 2. 注解的定义要使用**@interface关键字来代替interface**：\npublic @interface Author { String name(); String created(); int revision() default 1; String[] reviewers() default {}; } public @interface Complexity { ComplexityLevel value() default ComplexityLevel.MEDIUM; } public enum ComplexityLevel { VERY_SIMPLE, SIMPLE, MEDIUM, COMPLEX, VERY_COMPLEX; } 注解类型与普通的接口有一些区别：\n只允许原生数据类型、String、枚举、class，以及这些类型的数组。注意注解类型中不允许常用的对象，也不允许数组的数组（因为每一个数组都是一个对象）。\n注解元素的定义与定义方法的语法很类似，但是不允许有修饰符和参数。\n注解元素的默认值定义需要使用default关键字，后面连接字面量、初始化数组或者枚举值。\n正如其它的类或者接口，枚举类型也可以嵌套在注解类型的内部：\npublic @interface Complexity { public enum Level { VERY_SIMPLE, SIMPLE, MEDIUM, COMPLEX, VERY_COMPLEX; } … } @Documented： 声明被@Documented注解后的注解类型，一旦使用，被注解的元素就应该连同注解都记录到Javadoc中。\n@Inherited： 声明被注解的注解类型能够继承到它的子类上。通过这种方法，如果当前子类没有受@Inherited注解的注解类型注解过，但是它的父类有，那么当前子类也能通过继承得到这个注解类型。不过它只适用于类继承，不适用于接口实现。\n@Retention： 声明被注解的注解类型生命周期。可选的值都包含在RetentionPolicy枚举中：CLASS（默认值——能被包含到class文件中，但是在运行时访问不到），SOURCE（创建class文件的时候会被编译器丢弃），RUNTIME（能够在运行过程中访问到）。\n@Target： 声明注解类型能够注解的元素类型。可选的值包含在ElementType枚举中：ANNOTATION_TYPE（用于注解类型），CONSTRUCTOR（用于构造方法），FIELE（用于成员变量），LOCAL_VARIABLE（用于局部变量），METHOD（用于方法），PACKAGE（用于包），PARAMETER（用于方法参数），TYPE（用于类、接口、枚举）。\n本系列将会在第二部分中继续讲解：注解处理器。请阅读这里.\n","date":"October 9, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/java%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B/","series":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/series/java/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"注解","url":"https://www.qinxiandiqi.sbs/tags/%E6%B3%A8%E8%A7%A3/"},{"title":"Annotation","url":"https://www.qinxiandiqi.sbs/tags/annotation/"}],"title":"Java语言使用注解处理器生成代码 —— 第一部分：注解类型"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":"Android的TextView是个很强大的控件，通过Html类处理html文本后可以支持部分html标签。有时候需要捕获TextView中\u0026lt;a\u0026gt;标签的点击事件进行自己的超链接点击处理，下面的代码用于捕获TextView中\u0026lt;a\u0026gt;标签点击后的响应事件：\nCharSequence charSequence = Html.fromHtml(strHtml); SpannableStringBuilder builder = new SpannableStringBuilder(charSequence); URLSpan[] urlSpans = builder.getSpans(0, charSequence.length(), URLSpan.class); for(URLSpan span : urlSpans){ int start = builder.getSpanStart(span); int end = builder.getSpanEnd(span); int flag = builder.getSpanFlags(span); final String link = span.getURL(); builder.setSpan(new ClickableSpan() { @Override public void onClick(View widget) { //捕获\u0026lt;a\u0026gt;标签点击事件，及对应超链接link } }, start, end, flag); builder.removeSpan(span); } textView.setLinksClickable(true); textView.setMovementMethod(LinkMovementMethod.getInstance()); textView.setText(charSequence); 总结为三个步骤：\n使用Html.fromHtml(String strHtml)转换html标签字符串，fromHtml()方法中会对html标签进行替换，并html标签封装成对应的格式对象。其中每一个\u0026lt;a\u0026gt;标签都会对应一个URLSpan对象。 获取文本中所有的URLSpan对象，取出URLSpan对象的对应的位置、标识、以及对应的url地址后，使用ClickableSpan对象进行替换，并做自己的超链接逻辑处理。 Textview设置链接可点击，以及点击响应处理属性。 ","date":"October 3, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/%E6%8D%95%E8%8E%B7textview%E8%B6%85%E9%93%BE%E6%8E%A5/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"textview","url":"https://www.qinxiandiqi.sbs/tags/textview/"},{"title":"html","url":"https://www.qinxiandiqi.sbs/tags/html/"},{"title":"超链接","url":"https://www.qinxiandiqi.sbs/tags/%E8%B6%85%E9%93%BE%E6%8E%A5/"},{"title":"a","url":"https://www.qinxiandiqi.sbs/tags/a/"}],"title":"捕获TextView超链接"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"spring","url":"https://www.qinxiandiqi.sbs/categories/spring/"}],"content":"在Spring项目的配置文件中引用properties属性文件中的属性，运行时无法识别properties属性文件中的属性引用，但properties属性文件和属性明明已经存在，例如：\n要在Spring中使用外部properties属性文件，需要在Spring配置文件中添加bean后处理器PropertyPlaceholderConfigurer，并指明外部properties属性文件的路径：\n\u0026lt;bean class=\u0026#34;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;locations\u0026#34; value=\u0026#34;properties路径\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 如果有多个properties属性文件，可以使用下面方式：\n\u0026lt;bean class=\u0026#34;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;locations\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;properties路径\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;properties路径\u0026lt;/value\u0026gt; ... \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; ","date":"September 26, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/spring/%E8%A7%A3%E5%86%B3spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96properties%E5%B1%9E%E6%80%A7%E9%97%AE%E9%A2%98/","series":[{"title":"spring","url":"https://www.qinxiandiqi.sbs/series/spring/"}],"smallImg":"","tags":[{"title":"spring","url":"https://www.qinxiandiqi.sbs/tags/spring/"},{"title":"Properties","url":"https://www.qinxiandiqi.sbs/tags/properties/"},{"title":"配置文件","url":"https://www.qinxiandiqi.sbs/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"}],"title":"解决Spring配置文件无法读取properties属性问题"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"IDE","url":"https://www.qinxiandiqi.sbs/categories/ide/"}],"content":" Atom是Github开发的一个开源编辑器，类似于SublimeText，功能很强大，界面很漂亮，详情可查看官网atom.io。 如题，Atom默认会根据窗口宽度对文本进行自动软换行处理（如果没有的话，可以在File-\u0026gt;Settings下将Soft Wrap选项的勾打上），然而在处理中文文本的时候自动换行会失效。这是Atom的一个bug，github的issues上已经有人解决了这个问题，只是还没有添加到项目中去。目前可以通过添加AtomicChar这个插件来解决这个问题，方法如下：\n打开File-\u0026gt;Settings-\u0026gt;Install 搜索框中输入atomicchar，点击Install安装，如图 重启Atom，中文自动换行解决。 ","date":"September 9, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/ide/%E8%A7%A3%E5%86%B3atom%E4%B8%AD%E6%96%87%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/","series":[{"title":"IDE","url":"https://www.qinxiandiqi.sbs/series/ide/"}],"smallImg":"","tags":[{"title":"atom","url":"https://www.qinxiandiqi.sbs/tags/atom/"},{"title":"中文自动换行","url":"https://www.qinxiandiqi.sbs/tags/%E4%B8%AD%E6%96%87%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C/"},{"title":"编辑器","url":"https://www.qinxiandiqi.sbs/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"}],"title":"解决Atom中文无法自动换行问题"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":"最近将一个项目从Eclipse转到Android Studio。项目中使用了环信demo中的一些xml资源，转换后发现color资源文件夹下诸如layer- list或者shape等标签报Element xxx must be declared错误，大意就是layer-list或者shape这些标签没有定义。\nlayer-list或者shape等这些标签是常用的标签，Android Studio居然报没有定义错误，在Eclipse中却没有这个问题。网上不少人说这是Android Studio的一个bug，事实正相反，这是Android Studio的优点。\n对于这个问题，首先要了解layer-list、shape等这些标签是什么东西。每一种标签都有对应的资源类，layer- list、shape等等标签代表的其实是个drawable资源。layer- list最终会解析为LayerDrawable，shape会解析为ShapeDrawable，其它的标签类似。由此可以看出layer- list或者shape等资源是drawable资源，应该放到drawable资源文件夹下。color资源不包括drawable资源，当然没有定义drawable类型的标签。\nEclipse不像Android Studio，对资源类型的检查没有那么严格，所以没有报错误。我觉得这倒是Android Studio的优点，是什么资源就应该放到什么位置，不容易让人产生疑惑。所以在Android Studio下的解决方法就是把这些资源文件移动到drawable资源文件夹下，这个问题解决。\n","date":"July 8, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/%E8%A7%A3%E5%86%B3androidstudio%E4%B8%8Belementlayer-listmustbedeclared%E9%97%AE%E9%A2%98/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android studio","url":"https://www.qinxiandiqi.sbs/tags/android-studio/"},{"title":"layer-list","url":"https://www.qinxiandiqi.sbs/tags/layer-list/"},{"title":"shape","url":"https://www.qinxiandiqi.sbs/tags/shape/"},{"title":"Element","url":"https://www.qinxiandiqi.sbs/tags/element/"},{"title":"Declared","url":"https://www.qinxiandiqi.sbs/tags/declared/"}],"title":"解决Android Studio下Element Layer-List Must Be Declared问题"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"由于树莓派是arm架构，node.js上并没有提供arm架构的二进制包下载。试过使用apt包管理安装和直接node.js源码编译安装（编译了四五个小时。。。），都没有成功，报非法指令错误，估计还是编译的处理器架构错误导致的。不过，google上有些小伙伴成功了，我也不清楚是为什么，可能是编译的版本问题。\n这里提供一个比较简单的方法，亲测有效。其实就是在官网的历史列表里面找到了个旧版本v0.10.28的arm架构二进制包，官网的历史列表 http://nodejs.org/dist。\n部署方法如下：\nwget http://nodejs.org/dist/v0.10.28/node-v0.10.28-linux-arm-pi.tar.gz tar -xzf node-v0.10.28-linux-arm-pi.tar.gz 解压后就能看到node-v0.10.28-linux-arm- pi目录，里面的bin目录包含了node和npm。为了使用方便，将bin目录路径配置到PATH环境变量里面。\n编辑~/.bashrc文件，在文件中添加NODE环境变量，并添加到PATH中：\nexport NODE=你的node-v0.10.28-linux-arm-pi的路径 export PATH=$PATH:$NODE/bin 保存后，执行 source ~/.bashrc命令。这样就可以直接使用node和npm命令，可以试试node -v或者npm -v命令打印下当前的版本号，正确打印出来则成功。\n","date":"June 28, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85node.js/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"node.js","url":"https://www.qinxiandiqi.sbs/tags/node.js/"},{"title":"arm架构","url":"https://www.qinxiandiqi.sbs/tags/arm%E6%9E%B6%E6%9E%84/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"title":"树莓派安装node.js"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"路由器","url":"https://www.qinxiandiqi.sbs/categories/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"content":"朋友送了个WZR-HP-300NH的buffalo路由器，只是系统被刷成了openwrt，而且还不知道管理员账号密码= =。。。刷了openwrt系统后，buffalo路由器的恢复出厂设置按钮也失效了，估计是openwrt系统的兼容问题，只能是想办法重新刷下系统了。\ngoogle上找了下tftp刷机的教程，本来以为是很简单的事情，结果还是折腾了好几天。下面是我测试成功的方法：\n需要准备的工具：一台PC机（我用的Ubuntu系统）、一条网线、buffalo路由器、另一台交换机或者路由器（我用的是腾达路由器）。\n1、进入Ubuntu，下载好要刷机的系统包了，想来想去还是去官网下载了DD- WRT系统包来刷，链接地址：\u0026lt;http://www.buffalotech.com/support-and- downloads/downloads\u0026gt;，不过下载的速度很慢。\n2、将buffalo路由器用网线连接交换机或者其它路由器，我用的是之前一直在用的腾达路由器（用的久了不是很稳定，电子产品都这样，就不吐槽了）。为方便说明，下面直接用腾达路由器以示跟buffalo路由器做区别。\n3、PC机连接腾达路由器（wifi或者网线都可以），登录腾达路由器，将腾达路由器局域网网段调整到192.168.11.xxx网段上，分配固定ip 192.168.11.1给buffalo路由器，分配固定ip 192.168.11.2给PC机。\n4、进入Ubuntu，使用下面命令在Ubuntu的arp缓存列表上添加buffalo路由器的信息：\nsudo arp -s 192.168.11.1 xx:xx:xx:xx:xx:xx 其中的xx:xx:xx:xx:xx:xx为buffalo路由器的mac地址，在buffalo路由器背后的标签上可以找到。arp是地址解析协议，可以在发送报文的时候将ip地址解析为mac物理地址。\n5、安装tftp软件包，在Ubuntu终端下，使用下面命令安装：\nsudo apt-get update sudo apt-get install tftp-hpa 6、使用tftp命令传送系统包：\ntftp 192.168.11.1 tftp\u0026gt; verbose tftp\u0026gt; binary tftp\u0026gt; trace tftp\u0026gt; rexmt 1 tftp\u0026gt; timeout 60 tftp\u0026gt; put wzrhpg300nh-pro-v24sp2-14998b.enc 最后put指令的参数为系统包的文件名。执行完这个命令后，tftp就会开始寻找192.168.11.1的目标机器传送系统包，如果目标机器无响应，60秒之后就会显示超时。所以在执行这个命令之后，必须马上把buffalo路由去断电重启。buffalo只有在通电后的几秒钟内才能接收tftp传送过来的系统包并重装系统，错过这个时间就会自动进入原来的系统。在传输系统包的过程中，终端上会显示tftp传输数据包的数据，传输完成后会显示传输成功。这个时候，buffalo路由器开始更新系统，buffalo路由器上的diag红灯会开始闪烁，这个过程要花费好几分钟甚至十几分钟。耐心等待红灯停止闪烁，系统就重装好了，buffalo会自动重启。\n重启之后，用网线连接buffalo路由去和电脑，在浏览器通过192.168.11.1地址就能访问buffalo路由器。首次访问会进入设置账号和密码界面，设置自己的账号名和密码，之后就能进入buffalo路由器的设置界面了，刷buffalo路由器系统到此结束。\n整个刷系统的过程最重要的就是交换机或者另一台路由器（上面的腾达路由器）分配固定的ip地址。之前在网上找到大部分的教程的步骤都是先安装tftp工具，用网线直接连接电脑和路由器，设置电脑的网络和IP，再使用tftp工具传输buffalo系统包到buffalo路由器上。tftp传输系统包的过程中要掐准时间给buffalo断电重启，有的说10秒，有的说10几秒。。。感觉太不靠谱，而且这些方法我也没成功过。基本上都是在tftp的put指令执行完毕之后超时，连接不上buffalo路由器。我的推测是buffalo路由器在断电重启后可以接收tftp数据的模式下，pc机没有正确分配192.168.11.1 ip给buffalo路由器。等到pc机网络ip分配成功后，buffalo已经切换了接收tftp数据模式，正常进入了buffalo路由器的当前系统。所以使用了另一个交换机或者路由器强制分配了固定的ip来确保buffalo路由器在断电重启的过程中分配到的ip没有变化。\n","date":"June 14, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/system/ubuntu%E4%B8%8Bbuffalowzr-hp-300nh%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%B7dd-wrt%E7%B3%BB%E7%BB%9F/","series":[{"title":"路由器","url":"https://www.qinxiandiqi.sbs/series/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"smallImg":"","tags":[{"title":"tftp","url":"https://www.qinxiandiqi.sbs/tags/tftp/"},{"title":"buffalo","url":"https://www.qinxiandiqi.sbs/tags/buffalo/"},{"title":"dd-wrt","url":"https://www.qinxiandiqi.sbs/tags/dd-wrt/"},{"title":"刷系统","url":"https://www.qinxiandiqi.sbs/tags/%E5%88%B7%E7%B3%BB%E7%BB%9F/"}],"title":"Ubuntu下buffalo Wzr-Hp-300nh路由器刷DD-WRT系统"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":"Volley是google推荐的Android网络数据访问处理的库，具有简化网络数据访问、多并发、支持缓存、允许取消网络请求、支持自定义复杂网络数据请求等优点。另外，Volley也提供了处理大量网络图片、处理Json数据的工具。不过，Volley也有它的局限性。它不适用于大文件数据的下载，因为Volley在解析网络数据的过程中会将这些数据都放在内存中，处下载大型文件可能会导致内存OOM问题。在开发中，大部分情况都不需要下载大型数据文件，所以Volley还是能够满足大部分开发需求的。\n1、Volley源码的下载# Volley源码使用git工具管理，可以使用git工具下载：\ngit clone https://android.googlesource.com/platform/frameworks/volley 由于众所周知的原因，不会翻墙的童鞋也可以到github上面下载：\ngit clone https://github.com/mcxiaoke/android-volley.git 2、Volley的主要类# 2.1 Request：Request类是Volley的核心类之一，是个抽象类，代表网络请求的操作。Volley的com.android.volley.toolbox包中提供了Request类的几个具体子类，包括StringRequest（网络请求返回的数据类型是字符串）、ImageRequest（网络请求返回的数据类型是Bitmap）、JsonObjectRequest（网络请求返回的数据类型是JsonObject），以及JsonArrayRequest（网络请求返回的数据类型是JsonArray）。想要发起一次网络请求，必须先创建一个具体的Request对象。一般直接使用toolbox中提供的Request具体子类，当然可以直接继承Request来实现特殊的网络请求。\n2.2 RequestQueue：RequestQueue也是Volley的核心类之一，该类中包含了缓存管理和网络请求管理。想要发起网络请求，必须先获取一个RequestQueue对象，然后将创建的具体Request对象通过RequestQueue.add()方法添加进来，Request的网络请求才会真正执行。\n2.3 DiskBasedCache：管理硬盘缓存的类，RequestQueue类中的缓存管理默认由DiskBasedCache类实现，该类中默认的缓存大小为5M。\n2.4 BasicNetwork：管理网络请求的类，RequestQueue类通过BasicNetwork类实现网络请求的管理。这个类需要提供一个HttpStack对象才能真正实现网络请求，Volley提供了两个HttpStack子类：HurlStack（内部通过HttpURLConnection实现）和HttpClientStack(HttpClient client)。\n2.5 Volley：Volley的工具类，通过Volley.newRequestQueue()方法可以返回一个RequestQueue对象。在newRequestQueue方法中会将DiskBasedCache和BasicNetwork组装到最终返回的RequestQueue对象中。Volley类中有多个newRequestQueue方法的重载，所有的这些方法最终都是通过Volley.newRequestQueue(Context, HttpStack, int)方法实现，这个方法第二个参数HttpStack为BasicNetwork提供Http client实现，如果为null，newRequestQueue会自动提供最适合当前Android版本的HttpStack对象；第三个参数为DiskBasedCache提供缓存的大小，默认为510241024，也就是5M。如果没有特殊的需求，建议直接使用Volley.newRequestQueue创建RequestQueue对象。\n3、Volley的线程结构设计# Volley的架构从功能上来区分，主要跨越了主线程（也就是UI线程）、缓存线程和网络线程。以下是Volley的线程结构设计图：\n图中蓝色部分为主线程、绿色部分为缓存线程（只有一个）、橙色部分为网络线程池。整个发送网络请求的过程大致如下：\n3.1 主线程中通过Volley.newRequestQueue()等方法获取RequestQueue对象，创建具体的Request对象并通过RequestQueue.add(Request)方法添加该对象。\n3.2 添加Request对象到RequestQueue后会进入缓存线程，在缓存线程查询是否有该Request对象的缓存。如果有，则直接将缓存的响应数据返回到主线程，本次访问结束。如果没有，则进入下一步。\n3.3 从网络线程池中分配一个空闲的线程给该Request对象（使用Volley.newRequestQueue()创建的RequestQueue默认线程池最多4个线程），并执行Request对象定义的相关网络访问操作，以及解析数据，保存数据等等，网络访问完毕后返回主线程。\n4、Volley项目导入使用# 使用Volley有三种方式：\n4.1 第一种方式直接将Volley的源码打包出jar文件放到自己Android项目的libs目录下\n4.2 使用maven管理工具的项目可以在pom.xml文件中添加下面依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mcxiaoke.volley\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;library\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;{latest-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 4.3 使用Android Studio的可以只项目module的gradle文件中添加下面依赖：\ncompile 'com.mcxiaoke.volley:library:1.0.16' 5、使用StringRequest# StringRequest的使用比较简单，直接上代码：\nString url = \u0026quot;http://www.baidu.com\u0026quot;; StringRequest mRequest; TextView tvStringRequest; @Override public void onResume() { super.onResume(); mRequest = new StringRequest(Request.Method.GET, url, new Response.Listener\u0026lt;String\u0026gt;() { @Override public void onResponse(String response) { tvStringRequest.setText(response); } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { tvStringRequest.setText(error.getMessage()); } }); tvStringRequest.setText(\u0026quot;start call...\u0026quot;); Volley.newRequestQueue(this).add(mRequest); } @Override public void onStop(){ if(mRequest != null){ mRequest.cancel(); } super.onStop(); } 其中，在onStop()中使用Request.cancel()方法取消网络请求访问。\n另外，由于要访问网络，所以需要在manifest中添加访问网络的权限。\n","date":"May 26, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/volley%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%80/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"Volley","url":"https://www.qinxiandiqi.sbs/tags/volley/"},{"title":"网络","url":"https://www.qinxiandiqi.sbs/tags/%E7%BD%91%E7%BB%9C/"}],"title":"Volley的使用（一）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"IDE","url":"https://www.qinxiandiqi.sbs/categories/ide/"}],"content":"如题，IDEA的maven项目中，默认源代码目录下的xml等资源文件并不会在编译的时候一块打包进classes文件夹，而是直接舍弃掉。\n如果使用的是Eclipse，Eclipse的src目录下的xml等资源文件在编译的时候会自动打包进输出到classes文件夹。Hibernate和Spring有时会将配置文件放置在src目录下，编译后要一块打包进classes文件夹，所以存在着需要将xml等资源文件放置在源代码目录下的需求。\n解决IDEA的这个问题有两种方式。\n第一种是建立src/main/resources文件夹，将xml等资源文件放置到这个目录中。maven工具默认在编译的时候，会将resources文件夹中的资源文件一块打包进classes目录中。\n第二种解决方式是配置maven的pom文件配置，在pom文件中找到节点，添加下列代码：\n\u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; 其中src/main/java表明资源文件的路径，**/*.xml表明需要编译打包的文件类型是xml文件，如果有其它资源文件也需要打包，可以修改或添加通配符。\n","date":"May 13, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/maven/%E5%B0%86ideamaven%E9%A1%B9%E7%9B%AE%E4%B8%ADsrc%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B8%8B%E7%9A%84xml%E7%AD%89%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E8%BF%9Bclasses%E6%96%87%E4%BB%B6%E5%A4%B9/","series":[{"title":"IDE","url":"https://www.qinxiandiqi.sbs/series/ide/"}],"smallImg":"","tags":[{"title":"idea","url":"https://www.qinxiandiqi.sbs/tags/idea/"},{"title":"maven","url":"https://www.qinxiandiqi.sbs/tags/maven/"},{"title":"xml","url":"https://www.qinxiandiqi.sbs/tags/xml/"},{"title":"src","url":"https://www.qinxiandiqi.sbs/tags/src/"},{"title":"classes","url":"https://www.qinxiandiqi.sbs/tags/classes/"}],"title":"将IDEA Maven项目中src源代码下的xml等资源文件编译进classes文件夹"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":"由于Android Studio使用了Gradle构建工具，在library依赖的处理上是将被依赖的library作为一个module引入（拥有一份完整的library拷贝），而Eclipse的ADT则是直接将library作为外部项目依赖链接进来，两者各有各的优缺点。Android Studio的好处是能时刻保持项目的完整性，每一个项目都包含了整个项目所需要的一切东西，当你把项目共享给别人的时候就不会因为落下某个library而导致别人无法正常打开你的项目。缺点则是多个项目都依赖同一个library，每个项目都有自己一份library代码拷贝，当这个library的代码需要更新的时候，每一个项目中的library代码都需要更新一遍。而Eclipse的library依赖，只是做了一个library链接，多个项目可以链接到同一个library，好处是library需要修改的时候只需要修改一处代码，缺点时与他人共享项目的时候可能会落下library忘记共享。\n一般一个公司长期开发累积下来，都会总结出一套自己的SDK或者工具供自己的产品使用。如果使用Android Studio开发，一旦自己的SDK需要更新难免就会遇到前面说的问题。好在Android Studio除了library module依赖这种方法之外，还提供了本地仓库或者（服务器）远程仓库依赖，通过Gradle工具自动从仓库中获取并管理项目所需要的library。Gradle支持maven仓库，早期的Android Studio直接使用的就是maven中央仓库，虽然正式版之后改用jcenter，但是依然可以混用自定义的maven仓库。\n整体上的解决思路分三个步骤：\n第一，就是在自己公司内部的服务器上搭建一个maven仓库\n第二，将自己公司的公共类库发布到公司内部服务器的maven仓库上\n第三，在公司其它项目中配置公司内部服务器maven仓库地址，并引用所需的library，Gradle会自动从服务器maven仓库中获取\n1、在自己公司内部服务器上搭建maven仓库# 服务器上的maven仓库可以使用Sonatype nexus oss来搭建。sonatype nexus oss 是一个maven仓库管理工具，并提供了web控制台，部署和使用都很方便。\n1.1 下载sonatype nexus oss# 将sonatype nexus oss下载到公司内部服务器上，下载地址：http://www.sonatype.org/nexus/go\n1.2 安装并运行sonatype nexus oss# 首先确认服务器上是否已经安装JDK，nexus oss的运行需要JDK7或者JDK8。如果没有安装JDK，请先安装JDK。\n下载下来的nexus oss是一个zip或者tar.gz压缩包，需要将其解压。你可以将其解压到任何位置，nexus oss的运行对其所在位置没有什么特殊要求。解压后会看到两个文件夹，一个是nexus-x.xx.x-xx，一个sonatype- work。其中nexus-x.xx.x-xx是nexus oss的主目录，所有运行程序和配置文件都在里面。sonatype-work是nexus- oss的数据目录，nexus- oss运行过程的maven仓库数据都在这里面。进入nexus-x.xx.-x-xx/bin目录，window平台的服务器直接运行nexus.bat脚本就可以了。下面详细讲下linux平台的安装和运行。\nnexus oss官方建议将nexus-x.xx.x-xx安装到/usr/local目录下，并做个/usr/local/nexus链接指向nexus-x.xx.x-xx目录，方便以后nexus oss版本升级。方法如下\n$ sudo cp nexus-x.xx.x-xx-bundle.tar.gz /usr/local $ cd /usr/local $ sudo tar xvzf nexus-x.xx.x-xx-bundle.tar.gz $ sudo ln -s nexus-x.xx.x-xx nexus 如果你下载的是zip压缩包，则使用sudo unzip nexus-x.xx.x-xx-bundle.zip命令解压。\n为了方便以后使用，可以添加$NEXUS_HOME环境变量指向/usr/local/nexus。另外，默认配置sonatype- work目录与nexus-x.xx.x-xx在同一个目录下，如果你想讲sonatype- work迁移到其它指定路径，可以修改nexus-x.xx.x-xx/conf/nexus.properties配置文件中的nexus-work变量值。\n完成之后，运行nexus oss只需要运行nexus-x.xx.x-xx/bin/nexus脚本，参数可以为console或者start。console会在控制台打印出运行日志。如果有配置NEXUS_HOME环境变量，就可以在任何地方执行下面语句：\n$NEXUS_HOME/bin/nexus start 1.3 配置sonatype nexus oss# 运行成功之后，在浏览器打开http://服务器地址:8081/nexus就可以看到nexus oss的控制面板。\n点击右上角login登录，默认账号密码为admin/admin123。登录后可以看到以下界面：\n左边是功能面板，可以在Repositories里面查看所有的maven仓库，在User里面进行用户管理（修改密码什么的）。点击Repositories，查看maven仓库：\n可以看到nexus oss默认已经建好了几个仓库，每个仓库都有自己的一些属性。\n第一个重要属性是type仓库类型。主要有group、hosted、proxy、virtual四种类型。不同类型的仓库有不用的作用和工作模式，一般只需要关注group、hosted、proxy三种类型。由于nexus oss上面可以有多个maven仓库，但是maven这个工具要求使用groupId:artifactId:version这三个参数就能唯一确定一个项目，因此nexus oss使用group类型的仓库来决定nexus oss上各个maven仓库的优先级，以解决不同maven拥有相同项目的冲突。proxy类型的仓库其实只是个代理，用于代理其他服务器上的maven仓库。hosted类型是nexus oss自己所在服务器本地的maven仓库，也是我们这次主要使用的仓库类型。\nRepository Path是仓库的地址，把自己的项目发布到maven和引用maven仓库中项目的时候需要用到。\n选择一个仓库后，可以在下面窗口中看到这个仓库的具体信息，其中Configuration标签页中可以对仓库进行设置。\n我们的目的是要将我们自己的项目发布到我们自己的服务器上去，因此我们要选择hosted类型的仓库，以免公司内部的代码外泄出去（当然服务器也得是内网的服务器，公网能访问到的服务器，发布上去的代码也有一定的风险）。对于我们要使用的hosted类型的仓库，重点要看的是里面的Repository Policy仓库存储协议，有release和snapshot两种，release表示发行版，snapshot表示快照版本。还有一个Deployment Policy部署协议，有Allow Redeploy（允许部署）、Disable Redeploy（不允许部署）、Read Only（只读）三种模式。只有在Allow Redeploy模式下，我们才有权限可以将我们的项目发布到这个项目中。nexus oss默认已经建立了Releases和snapshots两个hosted仓库，我们检查一下配置就可以直接拿来用，当然你也可以自己建立hosted仓库。\n2、发布公共类库到服务器maven仓库# 编辑需要发布的公共类库的module的build.gradle脚本，在末尾添加下面配置：\napply plugin: 'maven' def isReleaseBuild() { return VERSION_NAME.contains(\u0026quot;SNAPSHOT\u0026quot;) == false } def getRepositoryUsername() { return hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : \u0026quot;\u0026quot; } def getRepositoryPassword() { return hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : \u0026quot;\u0026quot; } afterEvaluate { project -\u0026gt; uploadArchives { repositories { mavenDeployer { pom.groupId = GROUP pom.artifactId = POM_ARTIFACT_ID pom.version = VERSION_NAME repository(url: RELEASE_REPOSITORY_URL) { authentication(userName: getRepositoryUsername(), password: getRepositoryPassword()) } snapshotRepository(url: SNAPSHOT_REPOSITORY_URL) { authentication(userName: getRepositoryUsername(), password: getRepositoryPassword()) } } } } task androidJavadocs(type: Javadoc) { source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) } task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) { classifier = 'javadoc' from androidJavadocs.destinationDir } task androidSourcesJar(type: Jar) { classifier = 'sources' from android.sourceSets.main.java.sourceFiles } artifacts { archives androidSourcesJar archives androidJavadocsJar } } 同样在这个module下添加gradle.properties文件，文件内容如下：\nGROUP=对应maven的groupId值，如果名字中包含SNAPSHOT字符，项目将会发布到snapshots仓库，没有则发布到releases仓库 VERSION_NAME=对应maven的version值 POM_ARTIFACT_ID=对应maven的artifactId值 SNAPSHOT_REPOSITORY_URL=前面配置的snapshots仓库地址 RELEASE_REPOSITORY_URL=前面配置的releases仓库地址 NEXUS_USERNAME=登录nexus oss的用户名 NEXUS_PASSWORD=登录nexus oss的密码 修改完之后，在Android Studio右面的Gradle面板中找到对应的module，在这个module下面就能看到uploadArchive这个task：\n双击运行这个task，项目就发布到nexus oss对应的maven仓库中，在日志中可以看到类似这样的信息：\n看到BUILD SUCCESSFUL表示发布成功，回过头来看nexus oss面板上的仓库，找到你发布上去的仓库，应该就能找到你的项目，比如我发布的项目：\n3、在其它项目用引用我们发布的类库# 方法很简单，在需要添加依赖的module的build.gradle文件中找到dependencies对象，在其中添加我们自己maven服务器的url地址，然后按照前面我们发布项目时配置文件中的gradleId:archiveId:version方式应用就可以了，比如我自己的仓库和项目：\n添加后刷新同步下gradle，项目依赖就自动处理了。公共类库有修改，只需要修改公共类库并修改下version版本号，然后再发布一次代码到maven上去。其它项目只需要修改下gradle脚本中的版本号，代码就都自动更新上了。\n","date":"March 19, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/maven/%E5%BB%BA%E7%AB%8B%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8maven%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E4%BD%BF%E7%94%A8androidstudio%E5%8F%91%E5%B8%83%E5%85%AC%E5%85%B1%E9%A1%B9%E7%9B%AE/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android studio","url":"https://www.qinxiandiqi.sbs/tags/android-studio/"},{"title":"maven","url":"https://www.qinxiandiqi.sbs/tags/maven/"},{"title":"sonatype","url":"https://www.qinxiandiqi.sbs/tags/sonatype/"},{"title":"企业","url":"https://www.qinxiandiqi.sbs/tags/%E4%BC%81%E4%B8%9A/"},{"title":"私有仓库","url":"https://www.qinxiandiqi.sbs/tags/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"}],"title":"建立企业内部maven服务器并使用Android Studio发布公共项目"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"go","url":"https://www.qinxiandiqi.sbs/categories/go/"}],"content":"go语言并没有强制一定要使用一定的工作空间和项目结构，对于小型的go程序依靠go run等命令就可以直接编译运行。然而，保持良好的工作空间和文件结构，对于管理源代码和发布程序都是非常有帮助的。对于大型的go语言项目，工作空间则是一定要的。\n1、go语言的工作空间结构# go语言的工作空间其实就是一个文件目录，目录中必须包含src、pkg、bin三个目录。\n其中src目录用于存放go源代码，pkg目录用于package对象，bin目录用于存放可执行对象。使用go的编译命令工具可以将源代码或package编译后的二进制输出对应存储到bin和pkg目录中。src目录中的源代码根据package名分类到对应的子目录中，并且可以使用各种版本控制工具。举个例子，go的工作空间目录结构大致如下：\nbin/ hello # 可执行命令 outyet # 可执行命令 pkg/ linux_amd64/ github.com/golang/example/ stringutil.a # package对象 src/ github.com/golang/example/ .git/ # Git仓库数据 hello/ hello.go # 源代码 outyet/ main.go # 源代码 main_test.go # 测试源代码 stringutil/ reverse.go # package源代码 reverse_test.go # 测试源代码 上面的工作空间中包含了一个名为example的仓库，其中包含了hello和outyet两个命令，还有一个stringutil库。另外，一个工作空间中通常都会包含多个仓库。\n2、GOPATH环境变量# GOPATH是go语言中跟工作空间相关的环境变量，这个变量指定go语言的工作空间位置。\n当你建立工作空间目录后，你需要把工作空间目录的路径添加的GOPATH环境变量中。GOPATH环境变量支持多个值，如果你有多个工作空间，可以把多个工作空间值都添加到这个环境变量中，window系统使用分号\u0026quot;;\u0026ldquo;分隔不同值，Linux或Unix系统使用冒号”:“分隔不同值。另外，还要将所有工作空间的bin路径添加到PATH环境变量中。在Linux系统下可以在~/.profile文件末尾添加如下内容：\n$ export GOPATH=你的工作空间路径 $ export PATH=$PATH:$GOPATH/bin 当然，如果你的工作空间不止一个，PATH变量中不能直接使用$GOPATH/bin，要分别将各个工作空间中的bin路径添加进去。\n需要注意的是，GOPATH环境变量的值不能与安装的go目录相同。go目录中同样有src、pkg、bin等类似工作空间的目录结构，不过其中包含的是go的标准模块，最好不要将自己的工作空间和go目录混合，对于以后升级go版本也比较容易。\n","date":"February 19, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/golang/go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%92%8Cgopath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","series":[{"title":"go","url":"https://www.qinxiandiqi.sbs/series/go/"}],"smallImg":"","tags":[{"title":"go语言","url":"https://www.qinxiandiqi.sbs/tags/go%E8%AF%AD%E8%A8%80/"},{"title":"工作空间","url":"https://www.qinxiandiqi.sbs/tags/%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/"},{"title":"GOPATH","url":"https://www.qinxiandiqi.sbs/tags/gopath/"},{"title":"golang","url":"https://www.qinxiandiqi.sbs/tags/golang/"},{"title":"go","url":"https://www.qinxiandiqi.sbs/tags/go/"}],"title":"Go语言的工作空间和GOPATH环境变量"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"go","url":"https://www.qinxiandiqi.sbs/categories/go/"}],"content":"之前讲过arm平台上的golang的源代码编译安装，这次补充下golang官方提供的其它平台上二进制包安装方法。\n1、下载golang二进制包# 首先是要下载golang的二进制包，官方下载地址：https://golang.org/dl/\n选择对应平台的二进制包，目前golang官方只提供了以下平台的二进制包：\n1.1 基于386或amd64处理器的Mac OS X 10.6+平台二进制包\n1.2 基于386或amd64处理器的FreeBSD 8+平台的二进制包\n1.3 基于386或amd64处理器的Linux 2.6.23+平台的二进制包，需要注意的是不支持CentOS/RedHat 5平台\n1.4 基于386或amd64处理器的Window XP+平台的二进制包\n如果你的平台不在上列，则无法使用官方提供的二进制包安装，需要直接编译源代码安装。\n2、清理旧版本golang# 如果先前已经安装了旧版本的golang，在安装新版本之前需要先清理旧版本的golang，分两个步骤：\n2.1 删除旧版本golang目录# 通常情况下，Linux、Mac OS X或者FreeBSD平台的go目录在/usr/local/go，Window平台的go目录可能在C:\\go。也有可能在你自定义的其它路径，请直接删除即可。\n2.2 删除版本golang环境变量# 只需要从PATH环境变量删除旧版本go目录的bin路径即可。\nFreeBSD或者Linux通常修改/etc/profile或者$HOME/.profile，根据你显现配置PATH环境变量的位置决定。\nMac OS X平台上，如果旧版本使用package安装包方式安装，需要删除/etc/paths.d/go文件。\nWindow平台上，到系统属性的高级属性配置PATH变量。\n3、Linux、Mac OS X或FreeBSD平台上的tar压缩包安装# 3.1 解压tar压缩包# 下载对应的tar压缩包之后，执行以下命令将压缩包解压到/usr/local目录下：\nsudo tar -C /usr/local -xzf goxxx.tar.gz 其中goxxx.tar.gz为你所下载go压缩包，解压后go的目录为/usr/local/go。\n3.2 配置环境变量# 将/usr/local/go/bin路径配置到PATH环境变量中，可以添加在/etc/profile或者$HOME/.profile文件中：\nexport PATH=$PATH:/usr/local/go/bin 配置完后，根据你配置的文件执行source /etc/profile或者source $HOME/.profile让环境变量生效。\n3.3 自定义安装路径# 不选择/usr/local目录，选择其它路径也是可以的，只要将压缩包解压到你想要的目录下就可以，只不过需要多添加一个 GOROOT 环境变量指明你自定义的路径。因此，配置环境变量的内容为：\nexport GOROOT=自定义go路径 export PATH=$PATH:$GOROOT/bin 同样执行source命令让配置的环境变量生效。\n4、Mac OS X平台的package包安装# Mac OS X平台下使用package包来安装，按照操作提示进行安装。它会将go安装到/usr/local/go，并自动将/usr/local/go/bin配置到PATH环境变量中。打开新的终端才能检查到go的环境变量，已打开的终端检测不到。所以要测试go，需要打开新的终端。\n5、Window平台的安装# 5.1 window平台的msi安装包安装# 打开msi安装包，根据提示安装go。默认会将go安装到C:\\go目录，并将C:\\go\\bin添加到PATH环境变量中。同样，你需要打开新的终端才能看到配置的环境变量生效。\n5.2 window平台的zip压缩包安装# 与Linux等平台的tar压缩包安装类似，可以将zip压缩包解压到任何路径，官方建议解压到C:\\go目录。同样需要自己手动添加GOROOT环境变量指明自己的go目录路径，并将go目录下的bin路径添加到PATH环境变量中。\n6、测试安装# 建立hello.go文件，输入以下代码：\npackage main import \u0026quot;fmt\u0026quot; func main() { fmt.Printf(\u0026quot;hello, world\\n\u0026quot;) } 保存后，在终端上执行hello.go文件：\n$ go run hello.go 如果你看到hello world说明安装成功。\n","date":"February 12, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/golang/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85%E5%AE%89%E8%A3%85golang/","series":[{"title":"go","url":"https://www.qinxiandiqi.sbs/series/go/"}],"smallImg":"","tags":[{"title":"go","url":"https://www.qinxiandiqi.sbs/tags/go/"},{"title":"二进制包","url":"https://www.qinxiandiqi.sbs/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85/"},{"title":"安装","url":"https://www.qinxiandiqi.sbs/tags/%E5%AE%89%E8%A3%85/"},{"title":"golang","url":"https://www.qinxiandiqi.sbs/tags/golang/"}],"title":"二进制包安装golang"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"MySQL","url":"https://www.qinxiandiqi.sbs/categories/mysql/"}],"content":"用Ubuntu的apt包管理工具安装的mysql数据库，默认将数据库文件保存在/var/lib/mysql目录下，时间久了数据库越来越大，所以准备挂载个新的硬盘专门存放mysql数据库。\n1、确定mysql数据库文件存放目录# 一般默认是在/var/lib/mysql目录下。先登录自己的mysql数据库，比如我用root账户登录，然后使用下面查询语句查询：\nshow variables like '%dir%'; 得到数据库文件配置信息：\n![](https://img- blog.csdn.net/20150129135636513?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlueGlhbmRpcWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n可以看到其中datadir的值为/var/lib/mysql/即为当前数据库文件存放目录。\n另外一个basedir参数表示mysql数据库的安装位置，迁移数据库文件位置不需要改动这个参数。\n2、迁移数据库文件到新的目录下# 先使用下面命令将mysql数据库服务停止：\nsudo /etc/init.d/mysql stop 我新的数据盘挂载在/mnt/data目录下，因此要将数据库迁移到/mnt/data。\n2.1 可以使用mv命令将原数据库目录文件移动到新的目录，好处是不会简单，不会修改原数据库文件的权限，以及用户和用户组归属：\nsudo mv /var/lib/mysql /mnt/data/ 2.2 也可以使用cp复制命令将原数据库目录文件复制到新的目录，好处是。。万一迁移失败，恢复工作相对简单一点，等确认迁移成功再来删掉原数据库目录文件也不迟。为了不影响复制过来数据库目录文件权限和用户用户组归属问题，使用cp命令时要加上- a参数：\nsudo cp -a /var/lib/mysql /mnt/data/ 注：由于/var/lib/mysql目录归属于mysql数据库创建的mysql用户和mysql用户组，所以迁移文件的时候需要使用root权限，命令要使用sudo\n迁移成功后，可以看到/mnt/data/目录下已经将mysql数据库文件迁移过来了，并且目录文件的用户用户组归属还是mysql，没有变化：\n![](https://img- blog.csdn.net/20150129141800801?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlueGlhbmRpcWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n3、修改配置文件# 一共有三个配置文件需要修改：\n3.1 my.cnf文件# mysql数据库会按顺序优先级从/etc/my.cnf、/etc/mysql/my.cnf、/usr/etc/my.cnf、~/.my.cnf四个位置找my.cnf配置文件，一旦找到就不再继续往下找。Ubuntu默认将my.cnf配置文件放在/etc/mysql/my.cnf位置，所以在/etc/my.cnf位置没有找到这个配置文件。\n选择自己使用的文本编辑器编辑my.cnf配置文件，我用vim，所以 sudo vim /etc/mysql/my.cnf 。一样需要sudo，使用root权限编辑。将其中[mysqld]标签下的datadir属性值改为新数据库目录路径/mnt/data/mysql，如图：\n![](https://img- blog.csdn.net/20150129143410838?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlueGlhbmRpcWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n修改后保存并退出。\n3.2 usr.bin.mysqld文件# 由于Ubuntu使用了apparmor安全模块，就是类似于沙盒运行的一种机制，它可以限制软件在运行时的一些行为，比如对哪些目录和文件可以读写加锁等等。\n由于修改了数据库文件路径，所以要修改mysql数据库的apparmor配置文件，在其中将新数据库文件目录和文件的读写及加锁权限添加上去，同时可以删除或者注释掉原先/var/lib/mysql数据库文件目录的权限。mysql数据库的apparmor配置文件路径在 /etc/apparmor.d/usr.sbin.mysqld 。使用下面命令编辑这个配置文件：\n**sudo vim /etc/apparmor.d/usr.sbin.mysqld\n**\n找到其中的\n** /var/lib/mysql/ r,\n/var/lib/mysql/** rwk,**\n两行权限声明，可以在前面加上#好注释掉。然后对照格式，加入新路径的权限声明：\n** /mnt/data/mysql/ r,\n/mnt/data/mysql/** rwk,**\n结果如图：\n![](https://img- blog.csdn.net/20150129144833691?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlueGlhbmRpcWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n保存并关闭。\n3.3 abstractions/mysql文件# 由于usr.bin.mysqld文件中引用了abstractions/mysql文件，也就是会将abstractions/mysql文件中的权限声明导入进来。因此，也修改下这个文件：\nsudo vim /etc/apparmor.d/abstractions/mysql\n同样也是将新数据库文件路径中的socket文件权限添加进去，同时可以删除或者注释掉全路径中申请的权限，效果如图：\n![](https://img- blog.csdn.net/20150129145547122?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlueGlhbmRpcWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n保存后退出。\n4、重启数据库# 配置文件修改成功后就可以重启数据库，重启数据库之前需要先重新载入apparmor配置文件，使用下面命令重新载入：\nsudo /etc/init.d/apparmor restart 重载成功就可以使用下面命令启动数据库：\nsudo /etc/init.d/mysql start 5、权限问题# 经过上诉步骤之后，你有可能数据库无法启动。忽略继续登录数据库出现下面关于sock的错误：\nERROR 2002 (HY000): Can\u0026rsquo;t connect to local MySQL server through socket \u0026lsquo;/var/run/mysqld/mysqld.sock\u0026rsquo; (2)\n查看数据库的启动错误日志， sudo vim /var/log/mysql/error.log ，还能看到 Table \u0026lsquo;plugin\u0026rsquo; is read only 这样的错误：\n![](https://img- blog.csdn.net/20150129151421230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlueGlhbmRpcWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n出现这种情况的原因还是在于新数据库文件目录的权限。\nmysql数据库启动的时候需要以mysql用户的身份执行，所以mysql用户需要具备能读写数据库文件目录的权限。虽然上面迁移数据库文件的时候无论是使用mv还是cp -a命令都没有更改mysql目录的用户和用户组，上面也看到了/mnt/data/mysql所属的用户和用户组都还是mysql。因此可以肯定mysql用户具备读写/mnt/data/mysql的权限，但是这并没有保证上级目录/mnt/data和上上级目录/mnt也具备让mysql用户读取的权限。如果mysql用户不具备上级目录/mnt/data和上上级目录/mnt的读取权限，mysql用户一样读写不了自己的/mnt/data/mysql目录，因此就会出现上面的问题。\n可以过头来看看原本数据库文件目录/var/lib/mysql的结构：\n![](https://img- blog.csdn.net/20150129155611680?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlueGlhbmRpcWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n可以看出原本数据库文件目录/var/lib/mysql的上级目录/var/lib属于虽然属于root用户，但是它为同组用户和其它组用户都开放了 ’r\u0026rsquo; 和 ‘x\u0026rsquo; 权限，所以即使上级目录不属于mysql用户，mysql用户同样也能正常进入并访问到自己的数据库文件。\n解决这个问题的方法说起来就是这么简单，只要保证mysql用户具备最终数据库文件目录的所有上级目录的 \u0026lsquo;r\u0026rsquo; 和 ‘x\u0026rsquo; 权限就可以了。\n例如，使用下面命令修改本文中/mnt/data的权限：\nsudo chmod 755 /mnt/data\n再上级目录/mnt是系统目录，归属于root用户，root用户默认的目录的权限都是755，所以不用修改。\n权限修改后再次启动数据库 sudo /etc/init.d/mysql start ，应该就能成功启动了。\n进入数据库，查看当前路径配置信息：\n![](https://img- blog.csdn.net/20150129162333707?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlueGlhbmRpcWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n数据库已经正常启动， 并且数据库文件路径也已经替换到/mnt/data/mysql目标路径，数据库文件迁移成功。\n","date":"January 29, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/mysql/ubuntu%E4%B8%8B%E8%BF%81%E7%A7%BBmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/","series":[{"title":"MySQL","url":"https://www.qinxiandiqi.sbs/series/mysql/"}],"smallImg":"","tags":[{"title":"mysql","url":"https://www.qinxiandiqi.sbs/tags/mysql/"},{"title":"数据库","url":"https://www.qinxiandiqi.sbs/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"迁移","url":"https://www.qinxiandiqi.sbs/tags/%E8%BF%81%E7%A7%BB/"},{"title":"ubuntu","url":"https://www.qinxiandiqi.sbs/tags/ubuntu/"},{"title":"权限","url":"https://www.qinxiandiqi.sbs/tags/%E6%9D%83%E9%99%90/"}],"title":"Ubuntu下迁移MySQL数据库文件目录"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"python","url":"https://www.qinxiandiqi.sbs/categories/python/"}],"content":"1、esay_install# easy_install是Python的发行包管理工具，类似于linux的apt- get或者yum包管理工具，使用easy_install可以很方便的获取第三方的Python发行模块。\n安装方法：\n1.1 Mac OS X 系统可以在终端执行以下命令：\ncurl https://bootstrap.pypa.io/ez_setup.py -o - | sudo python 1.2 Linux系统可以执行以下命令：\nwget https://bootstrap.pypa.io/ez_setup.py -O - | sudo python 1.3 Window系统:\nWindow系统可以直接下载ez_setup.py文件并运行\n2、BeautifulSoup4# BeautifulSoup4是一个Python解析html或者xml的工具模块，使用这个模块做Python爬虫也是很不错的。\n安装方法：\n2.1 Debain或Ubuntu可以通过系统软件包管理安装\n$sudo apt-get install Python-bs4 2.2 使用easy_install或者pip安装：\n$ sudo easy_install beautifulsoup4 或 $ sudo pip install beautifulsoup4 另外附上BeautifulSoup4的中文文档http://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\n还有自己写的Python图片爬虫：https://github.com/qinxiandiqi/Sexy 或 http://git.oschina.net/qinxiandiqi/Sexy\n","date":"January 22, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/python/%E5%AE%89%E8%A3%85python%E7%9A%84easy_install%E5%B7%A5%E5%85%B7%E5%92%8Cbeautifulsoup%E6%A8%A1%E5%9D%97/","series":[{"title":"Python","url":"https://www.qinxiandiqi.sbs/series/python/"}],"smallImg":"","tags":[{"title":"python","url":"https://www.qinxiandiqi.sbs/tags/python/"},{"title":"easy_install","url":"https://www.qinxiandiqi.sbs/tags/easy_install/"},{"title":"BeautifulSoup4","url":"https://www.qinxiandiqi.sbs/tags/beautifulsoup4/"},{"title":"爬虫","url":"https://www.qinxiandiqi.sbs/tags/%E7%88%AC%E8%99%AB/"}],"title":"安装Python的easy_install工具和BeautifulSoup模块"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"go","url":"https://www.qinxiandiqi.sbs/categories/go/"}],"content":"golang也就是go语言，现在已经发行到1.4.1版本了，语言特性优越性和背后google强大靠山什么的就不多说了。golang的官方提供了多个平台上的二进制安装包，遗憾的是并非没有发布ARM平台的二进制安装包。ARM平台没办法直接从官网下载二进制安装包来安装，好在golang是支持多平台并且开源的语言，因此可以通过直接在ARM平台上编译源代码来安装。整个过程主要包括编译工具配置、获取golang源代码、设置golang编译环境变量、编译、配置golang运行环境变量等步骤。\n注：本文选用树莓派做测试，因为树莓派是基于ARM平台的。\n1、编译工具配置# 据说下个版本的golang编译工具要使用golang自己来写，但目前还是使用C编译工具的。因此，首先要配置好C编译工具：\n1.1 在Ubuntu或Debian平台上可以使用 sudo apt-get install gcc libc6-dev 命令安装，树莓派的RaspBian系统是基于Debian修改的，所以可以使用这种方法安装。\n1.2 在RedHat或Centos 6平台上可以使用 sudo yum install gcc libc-devel 命令安装。\n安装完成后可以输入 gcc \u0026ndash;version 命令验证是否成功安装。\n2、获取golang源代码# # 2.1 直接从官网下载源代码压缩包。# golang官网提供golang的源代码压缩包，可以直接下载，最新的1.4.1版本源代码链接：https://storage.googleapis.com/golang/go1.4.1.src.tar.gz\n2.2 使用git工具获取。# golang使用git版本管理工具，也可以使用git获取golang源代码。推荐使用这个方法，因为以后可以随时获取最新的golang源代码。\n2.2.1 首先确认ARM平台上已经安装了git工具，可以使用 git \u0026ndash;version 命令确认。一般linux平台都安装了git，没有的话可以自行安装，不同平台的安装方法可以参考：\u0026lt;http://git- scm.com/download/linux\u0026gt;\n2.2.2 克隆远程golang的git仓库到本地\n在终端cd到你想要安装golang的目录，确保该目录下没有名为go的目录。然后以下命令获取代码仓库：\ngit clone https://go.googlesource.com/go 大陆地区可能会获取失败，在不翻墙的情况下我试了几次都没成功，原因大家都懂的。好在google已经将golang也托管到github上面，所以也可以通过下面命令获取：\ngit clone https://github.com/golang/go.git 视网络情况，下载可能需要不少时间。我2M的带宽花了将近两个小时才下载完，虽然整个项目不过几十兆= =\n下载完成后，可以看到目录下多了一个go目录，里面即为golang的源代码，在终端上执行cd go命令进入该目录。\n执行下面命令检出go1.4.1版本的源代码，因为现在已经有新的代码提交上去了，最新的代码可能不是最稳定的：\ngit checkout go1.4.1 至此，最新1.4.1发行版的源代码获取完毕\n3、设置golang的编译环境变量# 主要有GOROOT、GOOS、GOARCH、GOARM四个环境变量需要设置，先解释四个环境变量的意义。\n3.1 GOROOT# 主要代表golang树结构目录的路径，也就是上面git检出的go目录。一般可以不用设置这个环境变量，因为编译的时候默认会以go目录下src子目录中的all.bash脚本运行时的父目录作为GOROOT的值。为了保险起见，可以直接设置为go目录的路径。\n3.2 GOOS和GOARCH# 分别代表编译的目标系统和平台，可选值如下：\nGOOS GOARCH darwin 386 darwin amd64 dragonfly 386 dragonfly amd64 freebsd 386 freebsd amd64 freebsd arm linux 386 linux amd64 linux arm netbsd 386 netbsd amd64 netbsd arm openbsd 386 openbsd amd64 plan9 386 plan9 amd64 solaris amd64 windows 386 windows amd64 需要注意的是这两个值代表的是目标系统和平台，而不是编译源代码的系统和平台。树莓派的RaspBian是linux系统，所以这些GOOS设置为linux，GOARCH设置为arm。 3.3 GOARM# 表示使用的浮点运算协处理器版本号，只对arm平台有用，可选值有5，6，7。如果是在目标平台上编译源代码，这个值可以不设置，它会自动判断需要使用哪一个版本。\n总结下来，在树莓派上设置golang的编译环境变量，可编辑$HOME/.bashrc文件，在末尾添加下面内容：\nexport GOROOT=你的go目录路径 export GOOS=linux export GOARCH=arm 编辑完后保存，执行 source ~/.bashrc 命令让修改生效。\n4、编译源代码# 环境变量配置完成自后就可以开始编译源代码。在go目录下的src子目录中，主要有 all.bash 和 make.bash 两个脚本（另外还有两个all.bat和make.bat脚本适用于window平台）。编译实际上就是执行其中一个脚本，两者的区别在于all.bash在编译完成后还会执行一些测试套件。如果希望只编译不测试，可以运行make.bash脚本。使用cd命令进入go下src目录，执行 ./all.bash 或者 ./make.bash 命令即可开始编译。由于硬件情况不同，编译耗费的时间不同。在我的B型树莓派编译过程花费了将近半个小时，编译完成后执行的测试套件又花费了差不多一个小时，总共花费了一个半小时左右。\n5、配置golang运行环境变量# 编译完成后，go目录下会生成bin目录，里面就是go的运行脚本。为了以后使用方法，可以将这个bin路径添加到PATH环境变量中。同样编辑~/.bashrc文件，因为前面设置过GOROOT环境变量指向go目录了，所以只需要在末尾加上\nexport PATH=$PATH:$GOROOT/bin 保存后同样执行 source ~/.bashrc 命令让环境变量生效。\n至此，golang源代码编译安装成功。执行 go version 应该就能看到当前golang的版本信息，表示编译安装成功。\n另外还有一个比较重要的GOPATH环境变量需要设置，等有时间再讲讲吧。\n参考官方文档：https://golang.org/doc/install/source\n","date":"January 20, 2015","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/golang/%E5%9C%A8arm%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85golang/","series":[{"title":"go","url":"https://www.qinxiandiqi.sbs/series/go/"}],"smallImg":"","tags":[{"title":"arm","url":"https://www.qinxiandiqi.sbs/tags/arm/"},{"title":"源代码","url":"https://www.qinxiandiqi.sbs/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/"},{"title":"编译安装","url":"https://www.qinxiandiqi.sbs/tags/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"go","url":"https://www.qinxiandiqi.sbs/tags/go/"}],"title":"在ARM平台上编译安装golang"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"IDE","url":"https://www.qinxiandiqi.sbs/categories/ide/"}],"content":"Android Studio正式版已经发布一段时间了，使用Mac版的Android Studio可能与遇到Java not found：Android Studio was unable to find a valid JVM问题。\n解决这个问题：\n首先要确定mac系统上有没有安装jdk，并查看自己的jdk版本，可以在终端上输入命令 java -version查看。如果没有安装jdk请先安装jdk，安装方法就不多说了，可以去Oracle官网上下载安装。\n接下来确定自己的jdk版本，如果jdk的版本不是1.6版本就有可能出现以上问题，无法启动Android Studio。原因在于Android Studio的配置文件中默认要求的是1.6版本的JVM，所以可以简单的修改下Android Studio的配置文件。方法如下：\n1.找到你的Android Studio.app文件位置，一般都是在Applications文件夹下面。\n2.选择Android Studio.app文件，打开右键菜单，选择Show Package Contents打开Android Studio.app（其实Mac系统下的app文件就是一个特殊的文件夹）。\n3.进入Contents文件夹，找到Info.plist配置文件。\n4.可以打开Info.plist配置文件，找到其中的JVMVersion标签，可以看到这个标签下面为1.6，默认使用JVM1.6版本，现在最新的JDK已经是1.8了。把1.6改成你所安装的jdk版本号然后保存修改就可以解决这个问题，或者简单的改成1.6+就可以兼容1.6以上的jdk版本。\n","date":"December 30, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/macos%E4%B8%8Bandroidstudio%E7%9A%84javanotfound%E9%97%AE%E9%A2%98/","series":[{"title":"IDE","url":"https://www.qinxiandiqi.sbs/series/ide/"}],"smallImg":"","tags":[{"title":"android studio","url":"https://www.qinxiandiqi.sbs/tags/android-studio/"},{"title":"jvm","url":"https://www.qinxiandiqi.sbs/tags/jvm/"},{"title":"mac","url":"https://www.qinxiandiqi.sbs/tags/mac/"},{"title":"无法启动","url":"https://www.qinxiandiqi.sbs/tags/%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"}],"title":"Mac OS下Android Studio的Java Not Found问题"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Linux","url":"https://www.qinxiandiqi.sbs/categories/linux/"}],"content":"很少自己写Bash脚本，一写就出现了一些奇怪的问题，主要还是对Bash脚本的语法不够熟悉，毕竟很少使用。\n当做记录一下吧，今天因为空格导致的一些脚本问题：\n1、Bash脚本中的赋值符号“=”前后不能有空格。例如给变量number赋值要写成“number=1”，不能写成“number = 1”。大多数编程语言都会忽略掉一些没有意义的空格，例如对于Java语言上面两种写法在语法上都是正确，但是Bash脚本不会。\n2、Bash脚本中的“[\u0026ldquo;和\u0026rdquo;];\u0026ldquo;中括号是个语法标识符，前后一定要留空格。例如：if [ \u0026ldquo;$number\u0026rdquo; -el 1 ]\u0026rdquo; then\u0026hellip; 如果前后没有空格就会导致语法错误，提示”期待一元表达式“或者缺少一部分中括号之类的一些语法错误。\n另外还有很多Bash常见的语法陷阱，以下两篇博文总结的挺好，别人辛辛苦苦写的文章我就不抄过来了，感兴趣的童鞋请移步：\n1、Bash的陷阱：http://blog.charlee.li/bash-pitfalls/\n2、Bash空格的那些事：http://www.igigo.net/post/archives/152\n","date":"November 30, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/bash/bash%E8%84%9A%E6%9C%AC%E7%9A%84%E7%A9%BA%E6%A0%BC%E5%92%8C%E6%9C%9F%E5%BE%85%E4%B8%80%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%94%99%E8%AF%AF/","series":[{"title":"Linux","url":"https://www.qinxiandiqi.sbs/series/linux/"}],"smallImg":"","tags":[{"title":"bash","url":"https://www.qinxiandiqi.sbs/tags/bash/"},{"title":"脚本","url":"https://www.qinxiandiqi.sbs/tags/%E8%84%9A%E6%9C%AC/"},{"title":"空格","url":"https://www.qinxiandiqi.sbs/tags/%E7%A9%BA%E6%A0%BC/"},{"title":"期待一元表达式","url":"https://www.qinxiandiqi.sbs/tags/%E6%9C%9F%E5%BE%85%E4%B8%80%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"title":"Bash脚本的空格和“期待一元表达式”错误"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":"Wi-Fi peer-to-peer（P2P，对等网络），它允许具备相应硬件的Android 4.0（API level 14）或者更高版本的设备可以直接通过wifi而不需要其它中间中转节点就能直接通信（Android的Wi-Fi P2P框架符合Wi-Fi联盟的Wi-Fi Direct™直连认证标志）。使用这些API，你可以搜索并连接其它同样支持Wi-Fi P2P的设备，然后再通过一个高速的连接进行互相通信，并且这个连接的有效距离要比蓝牙连接的有效距离要长的多。这对于需要在用户之间共享数据的应用程序非常有用，例如多玩家游戏或者照片分享之类应用。\nAndroid的Wi-Fi P2P API主要包含以下几个部分：\n使用WifiP2pManager类定义的方法搜索、请求并连接到其它对等设备。\n监听WiFiP2pManager的方法调用是否成功或者失败的Listener（监听器）。当调用WiFiP2pManager的方法时，每一个方法都可以接收一个指定的监听器作为参数。\n***** 由Wi-Fi P2P框架识别并发送的指定事件类型的Intent，例如撤销一个连接或者新发现了一个对等设备。\n通常你需要一起使用这三个主要部分的API。例如，你可以在调用discoverPeers()方法的时候提供WifiP2pManager.ActionListener监听器对象，这样你就能得到ActionListener.onSuccess()和ActionListener.onFailure()方法的通知。如果discoverPeers()方法发现对等设备列表有更新，同样也会发送 WIFI_P2P_PEERS_CHANGE_ACTION 类型的Intent广播。\n1、API概览# WifiP2pManager类提供了与设备上的Wi-Fi硬件进行交互的方法，例如搜索和连接对等设备。以下是可用的操作：\n表一：Wi-Fi P2P方法\n方法 描述 initialize() 在Wi-Fi框架上注册应用程序。这个方法必须在调用其它Wi-Fi P2P方法之前调用。 connect() 使用指定配置与一台设备开始一个P2P对等连接。 cancelConnect() 取消正在进行中的P2P对等网络组的交互。 requestConnectInfo() 请求一台设备连接信息。 createGroup() 创建一个对等网络组，并将当前设备作为群组的拥有者。 removeGroup() 移除当前的P2P对等网络组。 requestGroupInof() 请求P2P对等网络组信息。 discoverPeers() 开始搜索对等网络（设备）。 requestPeers() 请求当前已发现的对等网络（设备）。 WifiP2pManager的方法允许你传递一个listener监听器，这样Wi-Fi P2P框架才能通知你的activity所调用方法的状态。可使用的listener监听器接口和相应调用这些监听器的WifiP2pManager方法如下表：\n表二：Wi-Fi P2P监听器\n监听器接口 可被使用的操作 WifiP2pManager.ActionListener connect(),cancelConnect(),createGroup(),removeGroup(),discoverPeers() WifiP2pManager.ChannelListener initialize() WifiP2pManager.ConnectionInfoListener requestConnectInfo() WifiP2pManager.GroupInfoListener requestGroupInfo() WifiP2pManager.PeerListListener requestPeers() Wi-Fi P2P的API定义某些Wi-Fi P2P事件发生时要广播的Intent，例如发现了一个新的对等网络（设备）或者一台设备的Wi- Fi状态改变的事件。你可以在你的应用程序中创建并注册一个广播接受者来处理下面这些Intent：\n**\n表三：Wi-Fi P2P Intents**\nIntent 描述 WIFI_P2P_CONNECTION_CHANGED_ACTION 当设备的Wi-Fi连接状态改变时会发送这个广播。 WIFI_P2P_PEERS_CHANGED_ACTION 当你调用discoverPeers()方法就会收到这个广播。如果你在你的应用程序中处理这个intent，你同样需要调用requestPeers()来获取一个最新的对等网络（设备）列表。 WIFI_P2P_STATE_CHANGED_ACTION 当设备的Wi-Fi P2P启用或者禁用时会发送这个广播。当设备的Wi-Fi P2P启用或者禁用时会发送这个广播。 WIFI_P2P_THIS_DEVICE_CHANGED_ACTION 当设备的细节被修改时会发送这个广播，例如设备的名字。 2、为Wi-Fi P2P的Intent创建一个广播接收器# 广播接收器（broadcase receiver）允许你接收Android系统广播出来的Intent，这样你的应用程序才能响应你所感兴趣的时间。创建一个广播接收器来处理Wi-Fi P2P intent的基本步骤如下：\n2.1 创建一个继承BroadcaseReceiver的类。在这个类的构造方法中，你最好将WifiP2pManager、WifiP2pManager.Channel，还有注册了这个广播接收器的activity作为参数传递进来。这样才能让广播接收器向activity发送更新的同时，还能在需要的时候访问Wi- Fi硬件和通信的信道。\n2.2 在广播接收器中，检查onReceive()方法中你所感兴趣的intent。基于接收到的intent完成一些必要的操作。例如，如果广播接收器接收到一个WIFI_P2P_PEERS_CHANGE_ACTION类型的Intent，你可以调用requestPeers()方法来获取当前已发现的对等网络（设备）。\n下面的代码展示如何创建一个典型的广播接收器。这个广播接收器携带一个WifiP2pManager对象和一个activity最为参数，并在广播接收器接到一个intent的时候，使用这两个对象来适当完成所需要的操作：\n/** * 一个接收Wi-Fi P2P重要事件的广播接收器 */ public class WiFiDirectBroadcastReceiver extends BroadcastReceiver { private WifiP2pManager mManager; private Channel mChannel; private MyWiFiActivity mActivity; public WiFiDirectBroadcastReceiver(WifiP2pManager manager, Channel channel, MyWifiActivity activity) { super(); this.mManager = manager; this.mChannel = channel; this.mActivity = activity; } @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION.equals(action)) { // 检查Wi-fi是否已经启用，并通知适当的activity } else if (WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION.equals(action)) { // 调用WifiP2pManager.requestPeers()来获取当前的对等网络（设备）列表 } else if (WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION.equals(action)) { // 响应新的连接或者断开连接 } else if (WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION.equals(action)) { // 响应本台设备wifi状态的改变 } } } 3、创建一个Wi-Fi P2P应用程序# 创建一个Wi-Fi P2P应用程序涉及到为应用程序创建并注册一个广播接收器，搜索对等网络（设备），连接一台对等设备，还有向一台对等设备传输数据。下面的章节描述如何完成这些操作。\n3.1 初始设置# 在使用Wi-Fi P2P的API之前，你必须确认你的应用程序能够访问对应的硬件并且设备支持Wi-Fi P2P协议。如果支持Wi-Fi P2P，你就可以获取一个WifiP2pManager实例，创建并注册你的广播接收器，然后开始使用Wi-Fi P2P的API。\n3.1.1 在Android的manifest文件中请求使用设备上Wi-Fi硬件的权限，并为你的应用程序声明正确的最小SDK版本号：\n\u0026lt;uses-sdk android:minSdkVersion=\u0026quot;14\u0026quot; /\u0026gt; \u0026lt;uses-permission android:name=\u0026quot;android.permission.ACCESS_WIFI_STATE\u0026quot; /\u0026gt; \u0026lt;uses-permission android:name=\u0026quot;android.permission.CHANGE_WIFI_STATE\u0026quot; /\u0026gt; \u0026lt;uses-permission android:name=\u0026quot;android.permission.CHANGE_NETWORK_STATE\u0026quot; /\u0026gt; \u0026lt;uses-permission android:name=\u0026quot;android.permission.INTERNET\u0026quot; /\u0026gt; \u0026lt;uses-permission android:name=\u0026quot;android.permission.ACCESS_NETWORK_STATE\u0026quot; /\u0026gt; 3.1.2 检查Wi-Fi P2P能够支持并且已经启用。进行这项检查的一个较好的地方是在你的广播接收器中，当广播接收器接收到 WIFI_P2P_STATE_CHANGED_ACTION 的时候。从而通知你的activity关于Wi-Fi P2P的状态并做出相应的应对。\n@Override public void onReceive(Context context, Intent intent) { ... String action = intent.getAction(); if (WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION.equals(action)) { int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1); if (state == WifiP2pManager.WIFI_P2P_STATE_ENABLED) { // Wifi P2P已经启用 } else { // Wi-Fi P2P没有启用 } } ... } 3.1.3 在你的activity的onCreate()方法中获取一个WifiP2pManager实例，并通过调用initialize()方法将你的应用程序注册到Wi- Fi P2P框架中。这个方法会返回一个WifiP2pManager.Channel对象，这个对象被用于连接你的应用程序和Wi-Fi P2P框架。你同样需要使用这个WifiP2pManager和WifiP2pManager.Channel对象，还有你的activity引用创建一个你的广播接收器实例。这样才能允许你的广播接收器通知你的activity所感兴趣的事件并进行更新。它同样能让你在需要的时候操作设备的Wi- Fi状态。\nWifiP2pManager mManager; Channel mChannel; BroadcastReceiver mReceiver; ... @Override protected void onCreate(Bundle savedInstanceState){ ... mManager = (WifiP2pManager) getSystemService(Context.WIFI_P2P_SERVICE); mChannel = mManager.initialize(this, getMainLooper(), null); mReceiver = new WiFiDirectBroadcastReceiver(mManager, mChannel, this); ... } 3.1.4 创建一个intent过滤器，并在你的广播接收器中添加相同的Intent以进行检查：\nIntentFilter mIntentFilter; ... @Override protected void onCreate(Bundle savedInstanceState){ ... mIntentFilter = new IntentFilter(); mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION); mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION); mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION); mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION); ... } 3.1.5 在activity的onResume()方法中注册你的广播接收器，并在onPause()方法中注销：\n/* 使用需要匹配的intent值注册广播接收器 */ @Override protected void onResume() { super.onResume(); registerReceiver(mReceiver, mIntentFilter); } /* 注销广播接收器 */ @Override protected void onPause() { super.onPause(); unregisterReceiver(mReceiver); } 当你已经获取到WifiP2pManager.Channel对象并且设置好广播接收器，你的应用程序就可以调用Wi-Fi P2P的方法和接收Wi-Fi P2P的intent。\n你现在可以实现你的应用程序并且通过调用WifiP2pManager中的方法来使用Wi-Fi P2P的功能。下面的章节将阐述如何执行常见的操作，比如搜索和连接对等设备。\n3.2 搜索对等网络（设备）# 搜索允许被连接的对等设备，可以调用discoverPeers()方法来检测附近范围中允许被发现的对等网络（设备）。这个方法的执行过程是异步的，如果你有创建并传递一个WifiP2pManager.ActionListener对象作为参数，你可以在这个对象中的onSuccess()和onFailure()方法中接收到操作执行的结果。其中onSuccess()方法只是通知你搜索程序已经成功执行，但是不会提供任何实际搜索到的对等设备信息；\nmManager.discoverPeers(channel, new WifiP2pManager.ActionListener() { @Override public void onSuccess() { ... } @Override public void onFailure(int reasonCode) { ... } }); 如果搜索程序成功执行并且检测到对等网络和设备，系统将会发送 WIFI_P2P_PEERS_CHANGED_ACTION 类型的intent广播，你可以在广播接收器中监听这个广播以获取对等网络设备列表。当你的应用程序接收到 WIFI_P2P_PEERS_CHANGED_ACTION 类型的intent，你就可以使用requestPeers()方法来请求已被发现的对等网络设备列表。下面的代码展示了如何设置这些步骤：\nPeerListListener myPeerListListener; ... if (WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION.equals(action)) { // 从wifi p2p manager请求可使用的对等设备。这是一个异步调用的方法， // 调用的activity将会在PeerListListener.onPeersAvailable()的回调方法中得到列表结果。 if (mManager != null) { mManager.requestPeers(mChannel, myPeerListListener); } } 这个requestPeers()方法同样是异步执行的方法，当对等设备列表可用时，它会在WifiP2pManager.PeerListListener接口定义的onPeersAvailable()方法中将结果返回给你的activity。onPeersAvailable()方法会提供一个WifiP2pDeviceList对象，你可以通过这个对象找到你想要连接的对等设备。\n3.3 连接对等设备# 当你从获取到的可连接对等设备列表中找出你想要连接的对等设备之后，你就可以调用connect()方法链接这个设备。这个方法的调用需要一个WifiP2pConfig对象，这个对象包含了想要连接的设备信息。你可以通过WifiP2pManager.ActionListener得到连接成功或者失败的结果。下面的代码展示了如何连接目标设备：\n//从WifiP2pDeviceList中获取一个对等设备 WifiP2pDevice device; WifiP2pConfig config = new WifiP2pConfig(); config.deviceAddress = device.deviceAddress; mManager.connect(mChannel, config, new ActionListener() { @Override public void onSuccess() { //连接成功的逻辑处理操作 } @Override public void onFailure(int reason) { //连接失败的逻辑处理操作 } }); # 3.4 传输数据# 一旦连接建立成功，你就可以在设备之间通过socket传输数据。传入数据的基本步骤如下：\n3.4.1 创建一个SeverSocket。这个socket会在一个端口上等待客户端的连接，并且会一直阻塞直到连接请求出现，因此这个方法需要在后台线程执行。\n3.4.2 创建一个客户端的Socket。这个客户端使用服务端ServerSocket的IP地址和端口来连接服务端设备。\n3.4.3 从客户端发送数据到服务端。当客户端的socket成功连接上服务端的socket之后，你就可以通过字节流将数据从客户端发送到服务端。\n3.4.4 服务端的ServerSocket等待着客户端的连接（通过accept()方法）。这个方法会一直阻塞直到客户端连接上，因此要在其它线程中调用这个方法。当连接上之后，服务端设备就能够接收到客户端发送过来的数据。完成对这些数据的一些操作，例如保存为一个文件或者显示给用户。\n下面的例子修改于Wi-Fi P2P Demo（可以在Android SDK中找到），它展示了如何创建客户端和服务端之间的socket通信，并从通过一个service从客户端向服务端发送了一个JPEG图片。完整的代码，可以直接查看Wi- Fi P2P Demo。\npublic static class FileServerAsyncTask extends AsyncTask { private Context context; private TextView statusText; public FileServerAsyncTask(Context context, View statusText) { this.context = context; this.statusText = (TextView) statusText; } @Override protected String doInBackground(Void... params) { try { /** * 创建一个ServerSocket并等待客户端的连接.这个方法会一直阻塞直到接受了一个客户端连接 */ ServerSocket serverSocket = new ServerSocket(8888); Socket client = serverSocket.accept(); /** * 如果代码能够执行到这里，说明已经连接上一个客户端并且开始传输数据 * 将来自客户端的数据流保存为一个JPEG文件 */ final File f = new File(Environment.getExternalStorageDirectory() + \u0026quot;/\u0026quot; + context.getPackageName() + \u0026quot;/wifip2pshared-\u0026quot; + System.currentTimeMillis() + \u0026quot;.jpg\u0026quot;); File dirs = new File(f.getParent()); if (!dirs.exists()) dirs.mkdirs(); f.createNewFile(); InputStream inputstream = client.getInputStream(); copyFile(inputstream, new FileOutputStream(f)); serverSocket.close(); return f.getAbsolutePath(); } catch (IOException e) { Log.e(WiFiDirectActivity.TAG, e.getMessage()); return null; } } /** * 启动能够处理JPEG图片的activity */ @Override protected void onPostExecute(String result) { if (result != null) { statusText.setText(\u0026quot;File copied - \u0026quot; + result); Intent intent = new Intent(); intent.setAction(android.content.Intent.ACTION_VIEW); intent.setDataAndType(Uri.parse(\u0026quot;file://\u0026quot; + result), \u0026quot;image/*\u0026quot;); context.startActivity(intent); } } } 在客户端上，通过一个客户端的socket连接服务端的socket并传输数据。这个例子传输了一个客户端设备文件系统的上的JPEG文件。\nContext context = this.getApplicationContext(); String host; int port; int len; Socket socket = new Socket(); byte buf[] = new byte[1024]; ... try { /** * 使用服务端IP和端口还有连接超时时间创建一个客户端socket */ socket.bind(null); socket.connect((new InetSocketAddress(host, port)), 500); /** * 从一个JPEG文件创建一个字节流，并且传输到socket的输出流上。这些数据将会在服务端设备上接收到。 */ OutputStream outputStream = socket.getOutputStream(); ContentResolver cr = context.getContentResolver(); InputStream inputStream = null; inputStream = cr.openInputStream(Uri.parse(\u0026quot;path/to/picture.jpg\u0026quot;)); while ((len = inputStream.read(buf)) != -1) { outputStream.write(buf, 0, len); } outputStream.close(); inputStream.close(); } catch (FileNotFoundException e) { //catch logic } catch (IOException e) { //catch logic } /** * 当数据传输完成或者发生异常时关闭已经打开的socket。 */ finally { if (socket != null) { if (socket.isConnected()) { try { socket.close(); } catch (IOException e) { //catch logic } } } } 原文地址：http://developer.android.com/guide/topics/connectivity/wifip2p.html\n","date":"November 17, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidwi-fipeer-to-peerandroid%E7%9A%84wi-fip2p%E5%AF%B9%E7%AD%89%E7%BD%91%E7%BB%9C/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"wi-fi","url":"https://www.qinxiandiqi.sbs/tags/wi-fi/"},{"title":"p2p","url":"https://www.qinxiandiqi.sbs/tags/p2p/"},{"title":"对等网络","url":"https://www.qinxiandiqi.sbs/tags/%E5%AF%B9%E7%AD%89%E7%BD%91%E7%BB%9C/"}],"title":"Android Wi-Fi Peer-to-Peer（Android的Wi-Fi P2P对等网络）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":"从API Level 8（Android 2.2）开始，你可以将你的应用程序安装到外部存储上（例如，设备的SD卡）。你可以在应用程序的manifest文件中声明android:installLocation属性来使用这个可选的功能。如果你没有声明这个属性，你的应用程序只能被安装在内部存储中，并且不能移动到外部存储上。\n允许系统将你的应用程序安装到外部存储上，你需要修改你的manifest文件。在其中的标签下，添加android:installLocation属性，并将值设置为“preferExternal”或者“auto”。例如：\n\u0026lt;manifest xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot; android:installLocation=\u0026quot;preferExternal\u0026quot; ... \u0026gt; 如果你声明了“preferExternal”，这就表示请求系统将你的应用程序安装到外部存储中，但是系统不保证一定能将你的应用程序安装到外部存储上。如果外部存储空间已经满了，系统就会将应用程序安装到内部存储上。用户同样可以将你的应用程序在内部和外部存储之间移动。\n如果你声明了“auto”，这表明你的应用程序可以安装到外部存储上，但是你没有指定首选的安装位置。系统会根据几个因素来决定将你的应用程序安装到什么位置。用户同样可以将你的应用程序在内部和外部存储之间移动。\n当你的应用程序安装在外部存储上：\n***** 只要外部存储一直挂载在设备上，将应用程序安装在外部存储上对应用程序的性能没有任何影响。\n*****.apk文件会保存在外部存储上，但是所有用户的私有数据、数据库、优化过的.dex文件，还有附加的本地代码都会保存在内部的设备存储器上。\n安装了你的应用程序的特定存储器会使用一个随机生成的key进行加密，这个key可以被原来安装这个应用程序的设备解密出来。因此，安装在SD卡上的应用程序只能在一台设备上运行。\n***** 用户可以用过系统设置将你的应用程序移动到内部存储上。\n注意：当用户启用USD设备存储模式与计算机共享文件，或者通过系统设置卸载了SD卡，外部存储将会从设备上被卸载下来，并且所有运行在外部存储上的应用程序都会马上结束被杀死。\n1、向后兼容性# 只有运行API Level 8（Android 2.2）或者更高版本的设备才允许将你的应用程序安装到外部存储上。已经存在的应用程序，如果是用低于API Level 8版本所编译的，那么这些应用程序只能一直安装在内部存储上，不能移动到外部存储上（即使程序所安装的设备运行的是Android 2.2或以上的版本）。然而，如果你的应用程序必须支持低于API Level 8的版本，你仍然可以为运行API Level 8或者更高版本的设备提供这个功能，并且兼容低于API Level 8版本的设备。\n为了允许应用程序安装到外部存储上，并且仍然兼容低于API Level 8的版本，你需要：\n1.1 在manifest文件中的标签中添加android:installLocation属性，并设置值为“auto”或者“preferExternal”。\n1.2 继续保持你的android:minSdkVersion属性（低于版本8的值），并且确保你的应用程序的代码只使用了兼容这个版本的API。\n1.3 为了能够编译你的应用程序，将你的android:targetSdkVersion修改为8或者更高的版本。这是必须的，因为旧的Android库不能识别android:installLocation这个属性，这会导致无法编译你的应用程序。\n当你的应用程序安装到低于API Level 8版本的设备上，android:installLocation这个属性就会被忽略，应用程序会被安装到内部存储上。\n警告：尽管像这样的XML标签在旧版本平台上会被忽略，但当你的minSdkVersion低于“8”时，你要小心不要在代码中使用API Level 8版本才提供的API，除非你进行必要的工作以保证你的代码能够向后兼容（进行版本判断后再执行高版本API等）。\n2、不应该安装在外部存储上的应用程序# 当用户启用USB存储模式与他们的计算机共享文件（或者直接卸载和移除外部存储器），安装在外部存储上的应用程序会立即被杀死。系统会无法识别这些应用程序，直到USB存储模式关闭并且外部存储重新挂载到设备上。除了杀死应用程序和让用户无法使用这些应用程序之外，这也可能会造成一些类型的应用程序产生更严重的后果。为了保持你的应用程序始终按照预期运行，如果你的应用程序使用了下面列出的功能，你就不应该将应用程序安装在外部存储上，以避免外部存储被卸载的情况：\n2.1 Services： 你运行的Service会被杀死，并且在外部存储重新挂载后不会重新运行。当然，你也可以注册ACTION_EXTERNAL_APPLICATIONS_AVAILABLE类型的Intent广播，这将会在系统可以重新使用安装在外部存储上的应用程序时通知你的应用程序。接收到广播后，你可以重启的你的Service。\n2.2 Alarm Services（闹钟/系统定时服务）： 你通过AlarmManager注册的闹钟会被取消。你必须在外部存储重新挂载之后手动再注册这些闹钟。\n2.3 Input Method Engines（IME，输入法）： 你的输入法将会被默认的输入法代替。当外部存储重新挂载后，用户可以打开系统设置重新启用你的输入法。\n2.4 Live Wallpapers（动态壁纸）： 你运行的动态壁纸将会被默认的动态壁纸替换。当外部存储重新挂载后，用户可以重新选择你的动态壁纸。\n2.5 App Widget（窗口小部件）： 你的窗口小部件将会从home界面上被移除。当外部存储重新挂载后，你的窗口小部件对于用户同样不可使用，直到系统重置了home上面的应用程序（通常要等到系统重启）。\n2.6 Account Manager（账号管理）： 使用AccountManager创建的账号会消失，知道外部存储重新挂载。\n2.7 Sync Adapter（同步适配器）： 你的AbstractThreadedSyncAdapter和它的同步功能将会停止工作，直到外部存储重新挂载上。\n2.8 Device Administrators（设备管理员）： 你的恶DeviceAdminReceive和它所有的管理权限都会被禁用，这对设备功能可能造成不可预见的后果，并且在外部存储重新挂载后可能还会持续下去。\n2.9 监听“设备启动完成”的广播接收器： 系统在外部存储挂载到设备上之前就会发布ACTION_BOOT_COMPLETED广播。如果你的应用程序安装在外部存储上，它将无法接收到这个广播。\n如果你的应用程序使用上面列出的一些功能，你就不应该允许你的应用程序安装到外部存储上。默认情况下，系统不会允许你的应用程序安装到外部存储上，因此你不用担心你已经发布完成的应用程序。然而，如果你需要确保你的应用程序永远不会被安装到外部存储上，你可以清楚的声明android:installLocation属性，并赋值为“internalOnly”。尽管这不会改变默认的设置，但它可以明确你的应用程序只能安装在内部存储上，并提醒你自己或其他开发者这一个决定。\n3、应该安装在外部存储上的应用程序# 简单来说，任何没有使用前面所列举功能的应用程序安装到外部存储上都是安全的。大型游戏通常都要允许安装到外部存储上，因为游戏通常不会提供待机时运行的服务。当外部存储不可用的时候，游戏进程会被杀死。当外部存储重新可用并且用户重启了游戏，在视觉界面上应该没有什么影响（假设游戏通过标准的Activity生命周期正确保存了它的状态）。\n如果你的应用程序需要几个兆字节的APK文件，你需要仔细考虑是否允许应用程序安装到外部存储上来为用户节省内部存储空间。\n原文地址：http://developer.android.com/guide/topics/data/install-location.html\n","date":"November 13, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/android%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AEappinstalllocation/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"apk","url":"https://www.qinxiandiqi.sbs/tags/apk/"},{"title":"应用程序","url":"https://www.qinxiandiqi.sbs/tags/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"title":"安装位置","url":"https://www.qinxiandiqi.sbs/tags/%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE/"},{"title":"外部存储","url":"https://www.qinxiandiqi.sbs/tags/%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8/"}],"title":"Android应用程序安装位置（App Install Location）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":"Android 4.3（API Level 18）开始引入Bluetooth Low Energy（BLE，低功耗蓝牙）的核心功能并提供了相应的API，应用程序通过这些api可以扫描设备、查询services，读写设备的characteristics（属性特征）。对比传统的蓝牙，BLE的设计能够显著减低功耗。这让Android应用程序与BLE设备之间的低功耗通讯成为可能，例如距离传感器、心率监视器、健身设备等等。\n1、关键术语和概念# 1.1 下面是一些BLE关键术语和概念的摘要：# **\n**\n*** Generic Attribute Profile（GATT）：** GATT profile是一种关于发送和接收简短数据片段的一般规范，这种简短数据片段例如在BLE的连接上众所周知的“attribute（属性）”等。当前所有低功耗应用程序的profile都基于GATT。另外，蓝牙技术联盟（Bluetooth SIG）已经为很多BLE设备定义了profile。profile就是一种在指定的应用程序中定义设备如何工作的规范。注意，一台设备可以实现多个profile。例如，一台设备可以包含心率监视器和电池电量探测器。\n*** Attribute Protocol（ATT，属性协议）：** GATT构建在ATT的基础之上，因此也总被成为GATT/ATT。ATT针对BLE设备的运行进行了优化。为此，它会尽可能的使用更少的字节数据。每一个属性都通过UUID来唯一确定。UUID就是一个标准128位格式的字符串ID，用于唯一确定一个信息。属性通过ATT协议格式化为characteristics和services后进行传输。\n*** Characteristic：** 一个characteristic中包含一个值，以及0个或多个用于描述characteristic值的descriptor。可以将characteristic认为是一种类型，类似于一个类。\n*** Descriptor：** Descriptor（描述符）中定义的属性用于描述一个characteristic值。例如，一个descriptor可以为一个characteristic的值指定一个在可接受范围内的可读性描述，或者为一个characteristic的值指定一个计量单位。 **\nService：** 一个service是一个characteristic的集合。例如，你可以持有一个名为“心率监视器”的service，它包含的characteristic例如“心率测量”。你可以在bluetooth.org上找到一系列基于GATT的profile和service。 1.2 角色和职能# 以下是一台Android设备与BLE设备交互时的一些适用角色和职能：\n*** 中央设备和外围设备。** 这适用于BLE自身的连接。担任中央设备角色的设备负责扫描和搜索广告，担任外围设备的角色负责发送广告。\n*** GATT服务端和GATT客户端。** 这取决于两台设备在建立连接后如何互相通信。\n为了理解这之间的区别，想象你有一台Android手机和一台BLE设备作为活动追踪器。手机将担任中央设备角色；活动追踪器将担任外围设备角色（你需要具备两种角色才能建立一个BLE连接，两者都担任外围设备角色不能互相通信，同样两者都担任中央设备角色也不能互相通信）。\n一旦手机和活动追踪器建立连接，它们就可以互相传输GATT媒体数据。根据它们传输的数据，其中一方需要担任服务端的角色。例如，如果活动追踪器想要发送传感器数据给手机，活动追踪器就需要担任服务端的角色。如果活动追踪器想要接收手机的数据，手机就需要担任服务端的角色。\n在本片文档的例子中，Android应用程序（运行在Android设备上）是GATT客户端。应用程序从GATT服务端获取数据，这个服务端由支持Heart Rate Profile的BLE心率监视器设备担任。但是你可以交替让你的Android应用程序扮演GATT服务端的角色。具体参考BluetoothGattService。\n2、BLE Permissions（BLE权限）# 为了在你的应用程序中使用Bluetooth的功能，你必须声明 android.permission.BLUETOOTH 权限。你需要这个权限来执行一些蓝牙通信的操作，例如请求链接，接受连接，还有传输数据。\n如果你想让你的应用程序进行设备扫描或者管理蓝牙设置，你必须同时声明 android.permission.BLUETOOTH_ADMIN 权限。注意，如果你使用BLUETOOTH_ADMIN权限，你必须同时声明BLUETOOTH权限。\n在你的应用程序manifest文件中声明蓝牙权限，例如：\n\u0026lt;uses-permission android:name=\u0026quot;android.permission.BLUETOOTH\u0026quot;/\u0026gt; \u0026lt;uses-permission android:name=\u0026quot;android.permission.BLUETOOTH_ADMIN\u0026quot;/\u0026gt; 如果你想声明你的应用程序只能在支持BLE的设备上运行，可以将下面声明包含进你的应用程序manifest文件中：\n\u0026lt;uses-feature android:name=\u0026quot;android.hardware.bluetooth_le\u0026quot; android:required=\u0026quot;true\u0026quot;/\u0026gt; 然而，如果你想让你的应用程序也能够在不支持BLE的设备上运行，你就应该将上面标签中的属性设置为required=\u0026ldquo;false\u0026rdquo;。然后在运行的过程中使用PackageManager.hasSystemFeature()方法来判断设备是否支持BLE：\n// 使用下面的方法来确定设备是否支持BLE, 然后你可以选择禁用BLE的功能 if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) { Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show(); finish(); } 3、Setting Up BLE（设置BLE）# 在你的应用程序通过BLE进行通信之前，你需要确认设备是否支持BLE。如果支持，还要再确认是否已经启用。注意这个检查步骤只有在设置为false的情况下才需要执行。\n如果不支持BLE，你应该优雅的禁止一些使用BLE的功能。如果支持BLE，但是目前禁用了，那么你需要在不离开你的应用程序状态下，请求用户启用蓝牙用能。这个过程需要使用BluetoothAdapter，分两个步骤完成：\n3.1 获取BluetoothAdapter。# 基本上所有使用蓝牙的activity都需要BluetoothAdapter。BluetoothAdapter代表了设备本身的蓝牙适配器（蓝牙发送接收器）。在整个系统中有一个BluetoothAdapter对象，你的应用程序可以使用这个对象进行交互。下面的代码片段展示了如果获取这个适配器。注意下面的这种方法使用getSystemService()方法来获取一个BluetoothManager实例，之后再通过BluetoothManager获取BluetoothAdapter。Android 4.3（API Level 18）才开始支持BluetoothManager：\n// 初始化蓝牙适配器. final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); mBluetoothAdapter = bluetoothManager.getAdapter(); 3.2 启用蓝牙# 下一步，你需要确保蓝牙已经启动。调用isEnable()方法来检查蓝牙当前是否已经启用。如果方法返回false，说明蓝牙被禁用了。下面的代码片段中检查蓝牙是否已经启用。如果没有启用，代码片段会显示一个错误提示用户去设置中启用蓝牙：\nprivate BluetoothAdapter mBluetoothAdapter; ... // 确认设备支持蓝牙并且已经启用. 如果没有, // 显示一个对话框要求用户授权启用蓝牙. if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled()) { Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT); } 4、Finding BLE Devices（搜索BLE设备）# 搜索BLE设备，你可以使用startLeScan()方法。这个方法需要一个BluetoothAdapter.LeScanCallback对象作为参数。你必须实现这个callback接口，因为扫描的结果会通过这个接口返回。由于搜索设备是比较耗电的操作，你应该遵循以下指南使用：\n*** ** 一旦你找到目标设备，应该马上停止搜索。\n*** **不要死循环搜索，并设置搜索的最长时间。一台以前可以访问的设备可能已经移出了可检测范围，继续扫描只会消耗电量。\n下面的代码片段展示了如何开始和停止搜索：\n/** * 扫描和显示可访问BLE设备的Activity. */ public class DeviceScanActivity extends ListActivity { private BluetoothAdapter mBluetoothAdapter; private boolean mScanning; private Handler mHandler; // 10秒钟后停止扫描. private static final long SCAN_PERIOD = 10000; ... private void scanLeDevice(final boolean enable) { if (enable) { // 在预定义的扫描时间周期后停止扫描. mHandler.postDelayed(new Runnable() { @Override public void run() { mScanning = false; mBluetoothAdapter.stopLeScan(mLeScanCallback); } }, SCAN_PERIOD); mScanning = true; mBluetoothAdapter.startLeScan(mLeScanCallback); } else { mScanning = false; mBluetoothAdapter.stopLeScan(mLeScanCallback); } ... } ... } 如果你只想搜索指定类型的外围设备，你可以替换成startLeScan(UUID[], BluetoothAdapter.LeScanCallback)方法，并提供一个你的应用程序所支持的GATT服务的UUID对象数组。\n下面是一个BluetoothAdapter.LeScanCallback的实现，它是一个用于接收BLE搜索结果的接口：\nprivate LeDeviceListAdapter mLeDeviceListAdapter; ... // 设备搜索回调接口. private BluetoothAdapter.LeScanCallback mLeScanCallback = new BluetoothAdapter.LeScanCallback() { @Override public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) { runOnUiThread(new Runnable() { @Override public void run() { mLeDeviceListAdapter.addDevice(device); mLeDeviceListAdapter.notifyDataSetChanged(); } }); } }; 注意：正如Bluetooth文档中所描述的，在同一个时间你只能搜索BLE设备或者搜索传统蓝牙设备。你不能同时搜索BLE设备和传统蓝牙设备。\n5、Connecting to a GATT Server（连接一个GATT服务）# 与BLE设备交互的第一步就是要连接上它——更准确的说，是连接设备上的GATT服务。连接BLE设备上的GATT服务，你可以使用connectGatt()方法。这个方法需要三个参数：一个Context对象，autoConnect（一个表示是否当BLE设备可访问时马上自动连接的boolean值），还有一个BluetoothGattCallbackduixiang:\nmBluetoothGatt = device.connectGatt(this, false, mGattCallback); 上面的代码会连接BLE设备管理的GATT服务，并返回一个BluetoothGatt实例，通过这个实例就可以执行GATT客户端的相关操作。这个调用者（Android应用程序）就是GATT客户端。里面的BluetoothGattCallback对象用于交付操作结果给客户端，例如连接状态，还有将来一些GATT客户端操作的结果。\n在这个例子中，BLE应用程序提供了一个activity（DeviceControlActivity）来连接、显示数据，和显示BLE设备所支持的GATT的service以及characteristic。基于用户的输入，这个activity会和一个名为BluetoothLeService的Service通信，这个service通过Android BLE的API与BLE设备进行交互。\n// 一个通过Android BLE API与BLE设备进行交互的service. public class BluetoothLeService extends Service { private final static String TAG = BluetoothLeService.class.getSimpleName(); private BluetoothManager mBluetoothManager; private BluetoothAdapter mBluetoothAdapter; private String mBluetoothDeviceAddress; private BluetoothGatt mBluetoothGatt; private int mConnectionState = STATE_DISCONNECTED; private static final int STATE_DISCONNECTED = 0; private static final int STATE_CONNECTING = 1; private static final int STATE_CONNECTED = 2; public final static String ACTION_GATT_CONNECTED = \u0026quot;com.example.bluetooth.le.ACTION_GATT_CONNECTED\u0026quot;; public final static String ACTION_GATT_DISCONNECTED = \u0026quot;com.example.bluetooth.le.ACTION_GATT_DISCONNECTED\u0026quot;; public final static String ACTION_GATT_SERVICES_DISCOVERED = \u0026quot;com.example.bluetooth.le.ACTION_GATT_SERVICES_DISCOVERED\u0026quot;; public final static String ACTION_DATA_AVAILABLE = \u0026quot;com.example.bluetooth.le.ACTION_DATA_AVAILABLE\u0026quot;; public final static String EXTRA_DATA = \u0026quot;com.example.bluetooth.le.EXTRA_DATA\u0026quot;; public final static UUID UUID_HEART_RATE_MEASUREMENT = UUID.fromString(SampleGattAttributes.HEART_RATE_MEASUREMENT); // BLE API定义的各个回调方法. private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() { @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) { String intentAction; if (newState == BluetoothProfile.STATE_CONNECTED) { intentAction = ACTION_GATT_CONNECTED; mConnectionState = STATE_CONNECTED; broadcastUpdate(intentAction); Log.i(TAG, \u0026quot;连接GATT服务.\u0026quot;); Log.i(TAG, \u0026quot;尝试开始service搜索:\u0026quot; + mBluetoothGatt.discoverServices()); } else if (newState == BluetoothProfile.STATE_DISCONNECTED) { intentAction = ACTION_GATT_DISCONNECTED; mConnectionState = STATE_DISCONNECTED; Log.i(TAG, \u0026quot;断开GATT server连接.\u0026quot;); broadcastUpdate(intentAction); } } @Override // New services discovered public void onServicesDiscovered(BluetoothGatt gatt, int status) { if (status == BluetoothGatt.GATT_SUCCESS) { broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED); } else { Log.w(TAG, \u0026quot;onServicesDiscovered received: \u0026quot; + status); } } @Override // Result of a characteristic read operation public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { if (status == BluetoothGatt.GATT_SUCCESS) { broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic); } } ... }; ... } 当一个特定的的回调方法被调用的时候，它就会适当调用broadcastUpdate()帮助方法并传递一个操作标识。注意本节中的数据是根据蓝牙心率测量的profile规范解析的：\nprivate void broadcastUpdate(final String action) { final Intent intent = new Intent(action); sendBroadcast(intent); } private void broadcastUpdate(final String action, final BluetoothGattCharacteristic characteristic) { final Intent intent = new Intent(action); // 按照心率测量的profile进行的特定处理. // 按照么一个profile规范进行数据解析. if (UUID_HEART_RATE_MEASUREMENT.equals(characteristic.getUuid())) { int flag = characteristic.getProperties(); int format = -1; if ((flag \u0026amp; 0x01) != 0) { format = BluetoothGattCharacteristic.FORMAT_UINT16; Log.d(TAG, \u0026quot;Heart rate format UINT16.\u0026quot;); } else { format = BluetoothGattCharacteristic.FORMAT_UINT8; Log.d(TAG, \u0026quot;Heart rate format UINT8.\u0026quot;); } final int heartRate = characteristic.getIntValue(format, 1); Log.d(TAG, String.format(\u0026quot;Received heart rate: %d\u0026quot;, heartRate)); intent.putExtra(EXTRA_DATA, String.valueOf(heartRate)); } else { // 针对其他profiles, 将数据格式化为16禁止数据. final byte[] data = characteristic.getValue(); if (data != null \u0026amp;\u0026amp; data.length \u0026gt; 0) { final StringBuilder stringBuilder = new StringBuilder(data.length); for(byte byteChar : data) stringBuilder.append(String.format(\u0026quot;%02X \u0026quot;, byteChar)); intent.putExtra(EXTRA_DATA, new String(data) + \u0026quot;\\n\u0026quot; + stringBuilder.toString()); } } sendBroadcast(intent); } 回到DeviceControlActivity，下面的事件通过一个BroadcaseReceiver处理：\n// 处理Service发送过来的各种时间. // ACTION_GATT_CONNECTED: 连接上了一个GATT服务. // ACTION_GATT_DISCONNECTED: 断开了一个GATT服务. // ACTION_GATT_SERVICES_DISCOVERED: 发现了GATT服务. // ACTION_DATA_AVAILABLE: 从设备接收到数据. 这里可能是一个读取或者通知操作的结果。 private final BroadcastReceiver mGattUpdateReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { final String action = intent.getAction(); if (BluetoothLeService.ACTION_GATT_CONNECTED.equals(action)) { mConnected = true; updateConnectionState(R.string.connected); invalidateOptionsMenu(); } else if (BluetoothLeService.ACTION_GATT_DISCONNECTED.equals(action)) { mConnected = false; updateConnectionState(R.string.disconnected); invalidateOptionsMenu(); clearUI(); } else if (BluetoothLeService. ACTION_GATT_SERVICES_DISCOVERED.equals(action)) { // 显示所有支持的service和characteristic。 displayGattServices(mBluetoothLeService.getSupportedGattServices()); } else if (BluetoothLeService.ACTION_DATA_AVAILABLE.equals(action)) { displayData(intent.getStringExtra(BluetoothLeService.EXTRA_DATA)); } } }; 6、Reading BLE Attribute（读取BLE属性）# 一旦你的Android应用程序连接上了一个GATT服务并且发现了设备上的service，就可以在支持读写的地方读写属性。例如，下面的代码片段通过迭代服务的service和characteristic，并将它们显示在界面上：\npublic class DeviceControlActivity extends Activity { ... // 演示如何迭代所支持的GATT Services/Characteristics. // 在这个例子中，我们填充绑定到ExpandableListView的数据结构。 private void displayGattServices(List\u0026lt;BluetoothGattService\u0026gt; gattServices) { if (gattServices == null) return; String uuid = null; String unknownServiceString = getResources(). getString(R.string.unknown_service); String unknownCharaString = getResources(). getString(R.string.unknown_characteristic); ArrayList\u0026lt;HashMap\u0026lt;String, String\u0026gt;\u0026gt; gattServiceData = new ArrayList\u0026lt;HashMap\u0026lt;String, String\u0026gt;\u0026gt;(); ArrayList\u0026lt;ArrayList\u0026lt;HashMap\u0026lt;String, String\u0026gt;\u0026gt;\u0026gt; gattCharacteristicData = new ArrayList\u0026lt;ArrayList\u0026lt;HashMap\u0026lt;String, String\u0026gt;\u0026gt;\u0026gt;(); mGattCharacteristics = new ArrayList\u0026lt;ArrayList\u0026lt;BluetoothGattCharacteristic\u0026gt;\u0026gt;(); // 循环迭代可访问的GATT Services. for (BluetoothGattService gattService : gattServices) { HashMap\u0026lt;String, String\u0026gt; currentServiceData = new HashMap\u0026lt;String, String\u0026gt;(); uuid = gattService.getUuid().toString(); currentServiceData.put( LIST_NAME, SampleGattAttributes. lookup(uuid, unknownServiceString)); currentServiceData.put(LIST_UUID, uuid); gattServiceData.add(currentServiceData); ArrayList\u0026lt;HashMap\u0026lt;String, String\u0026gt;\u0026gt; gattCharacteristicGroupData = new ArrayList\u0026lt;HashMap\u0026lt;String, String\u0026gt;\u0026gt;(); List\u0026lt;BluetoothGattCharacteristic\u0026gt; gattCharacteristics = gattService.getCharacteristics(); ArrayList\u0026lt;BluetoothGattCharacteristic\u0026gt; charas = new ArrayList\u0026lt;BluetoothGattCharacteristic\u0026gt;(); // 循环迭代可访问的Characteristics. for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) { charas.add(gattCharacteristic); HashMap\u0026lt;String, String\u0026gt; currentCharaData = new HashMap\u0026lt;String, String\u0026gt;(); uuid = gattCharacteristic.getUuid().toString(); currentCharaData.put( LIST_NAME, SampleGattAttributes.lookup(uuid, unknownCharaString)); currentCharaData.put(LIST_UUID, uuid); gattCharacteristicGroupData.add(currentCharaData); } mGattCharacteristics.add(charas); gattCharacteristicData.add(gattCharacteristicGroupData); } ... } ... } 7、Receiving GATT Notification（接收GATT通知）# BLE应用程序要求在设备的某个指定characteristic改变的时候接收到通知是很常见。下面的代码片段展示了如何通过使用setCharacteristicNotification()为一个characteristic设置通知：\nprivate BluetoothGatt mBluetoothGatt; BluetoothGattCharacteristic characteristic; boolean enabled; ... mBluetoothGatt.setCharacteristicNotification(characteristic, enabled); ... BluetoothGattDescriptor descriptor = characteristic.getDescriptor( UUID.fromString(SampleGattAttributes.CLIENT_CHARACTERISTIC_CONFIG)); descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE); mBluetoothGatt.writeDescriptor(descriptor); 一旦为一个characteristic启用了通知，当远程设备上的characteristic改变的时候就会触发onCharacteristicChanged()方法：\n@Override // Characteristic notification public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) { broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic); } 8、Closing the Client App（关闭客户端应用程序）# 一旦你的应用程序使用完BLE设备，你应该调用close()方法，这样系统才能适当释放占用的资源：\npublic void close() { if (mBluetoothGatt == null) { return; } mBluetoothGatt.close(); mBluetoothGatt = null; } 原文地址：\u0026lt;http://developer.android.com/guide/topics/connectivity/bluetooth- le.html\u0026gt;\n","date":"November 3, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidbluetoothlowenergyandroid%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"bluetooth","url":"https://www.qinxiandiqi.sbs/tags/bluetooth/"},{"title":"BLE","url":"https://www.qinxiandiqi.sbs/tags/ble/"},{"title":"蓝牙","url":"https://www.qinxiandiqi.sbs/tags/%E8%93%9D%E7%89%99/"},{"title":"低功耗","url":"https://www.qinxiandiqi.sbs/tags/%E4%BD%8E%E5%8A%9F%E8%80%97/"}],"title":"Android Bluetooth Low Energy（Android低功耗蓝牙）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":"Android平台提供了对蓝牙网络协议栈的支持，它允许设备通过无线的方式与其它设备进行数据交换。应用程序框架通过Android Bluetooth APIs提供了对蓝牙功能的访问。这些API允许应用以无线的方式连接其它蓝牙设备，启用点对点或者多点对多点的无线功能。使用蓝牙的API，Android应用程序可以执行以下工作：\n***** 扫描其它蓝牙设备\n***** 查询本地蓝牙适配器以配对蓝牙设备\n***** 建立RFCOMM通道\n***** 通过服务搜索连接其它设备\n***** 传输或者接收其它设备的数据\n***** 管理多个连接\n本文档描述了如何使用Classic Bluetooth（传统蓝牙）。传统蓝牙是耗电操作的理想选择，例如Android设备之间的数据流传输和通讯。为了适应低能耗蓝牙设备，Android 4.3（API Level 18）的API开始支持Bluetooth Low Energy（BLE）。更多信息，请参考Bluetooth Low Energy。\n1、The Basics（基础部分）# 本文档描述了如何使用Android Bluetooth APIs来完成四种需要使用蓝牙通信的任务：设置蓝牙，搜索已经配对或者附近区域允许访问的设备，连接设备，还有在设备之间传输数据。\n所有的Bluetooth API都可以在android.bluetooth包中访问到。下面是你创建蓝牙连接需要使用到的类和接口的摘要：\n1.1 BluetoothAdapter# 代表Local Bluetooth Adapter（本地蓝牙适配器、蓝牙发送接收器）。BluetoothAdapter是所有蓝牙交互的入口点。使用这个对象，你可以搜索发现其他蓝牙设备，查询已配对配备列表，使用已知MAC地址实例化一个BluetoothDevice对象，创建 一个BluetoothServiceSocket来监听来自其它设备的通信。\n1.2 BluetoothDevice# 代表Remote Bluetooth Device（远程的蓝牙设备）。使用这个对象可以通过一个BluetoothSocket来请求一个远程设备的连接，或者查询这个远程设备的信息，例如名字、地址、类别、以及配对状态。\n1.3 BluetoothSocket# 代表Bluetooth socket（蓝牙套接字）的接口（类似于一个TCP socket）。这是一个连接点，它允许一个应用程序通过InputStream和OutputStream与另一个蓝牙设备交换数据。\n1.4 BluetoothServerSocket# 代表一个open server socket（开放的服务套接字），用于监听即将传入的请求（类似于一个TCP的ServerSocket）。为了能够连接两台Android设备，一台设备必须使用这个类开放一个server socket。当一个远程蓝牙设备发送一个连接请求给这台设备的时候，BluetoothServerSocket接受了这个请求就会返回一个已连接的BluetoothSocket。\n1.5 BluetoothClass# 这个类描述了一台蓝牙设备的一般特征（characteristic）和功能（capabilities）。这是一串只读的属性，定义了这台设备的主要和次要设备类型，以及它的服务。然而，它对这台设备所支持的全部Bluetooth Profile和蓝牙功能的描述并不可靠，但作为对设备类型的一种提示还是非常有用的。\n1.6 BluetoothProfile# 代表一个Bluetooth Profile的接口。Bluetooth Profile是一个针对设备之间基础蓝牙通讯的无线接口规范。例如Hands-Free profile（免提规范）。更多关于profile的讨论，请参考后面的Working with Profiles章节。\n1.7 BluetoothHeadset# 提供了对手机蓝牙耳机的支持。它包括蓝牙耳机和Hands-Free(v1.5)profiles。\n1.8 BluetoothA2dp# 定义了高质量音频流怎样通过蓝牙连接以数据流的方式从一台设备传输到另一个设备。“A2DP”代表Advanced Audio Distribution Profile（高级音频分发）。\n1.9 BluetoothHealth# 代表一个Health Device Profile（健康设备）的代理，用来控制蓝牙服务。\n1.10 BluetoothHealthCallback# 用于实现BluetoothHealth回调函数的虚拟类。你必须继承这个类并实现其中的回调函数，才能够接收到关于应用程序的注册状态和蓝牙通道状态的更新。\n1.11 BluetoothHealthAppConfiguration# 代表一个第三方蓝牙健康应用程序在注册后并与一个远程蓝牙健康设备通讯的应用配置。\n1.12 BluetoothProfile.ServiceListener# 一个用于通知BluetoothProfile IPC客户端连接或者断开服务的接口（这意味着有一个内部服务运行着一个指定的Profile）。\n2、Bluetooth Permission（蓝牙权限）# 为了在你的应用程序上可以使用蓝牙功能，你必须声明蓝牙权限 android.permission.BLUETOOTH 。你需要这个权限才能执行一些蓝牙通讯，例如请求一个连接，接受一个连接，传输数据。\n如果你的应用还要启动设备搜索或者管理蓝牙设置，那还需要声明 android.permission.BLUETOOTH_ADMIN 权限。大多数应用需要这个权限只是为了搜索附近的蓝牙设备。这个权限提供的其它功能不应该去使用，除非这个应用程序是一个类似“电池管理”的应用，用户期望通过这个应用去管理蓝牙设置。注意：如果你使用BLUETOOTH_ADMIN权限，那么你必须同样声明BLUETOOTH权限。\n在你的应用manifest文件中声明蓝牙权限，例如：\n\u0026lt;manifest ... \u0026gt; \u0026lt;uses-permission android:name=\u0026quot;android.permission.BLUETOOTH\u0026quot; /\u0026gt; ... \u0026lt;/manifest\u0026gt; 参考[](http://developer.android.com/guide/topics/manifest/uses- permission-element.html)获取更多关于声明应用权限的信息。\n3、Setting up Bluetooth（设置蓝牙）# 在你的应用程序通过蓝牙通讯之前，你需要确认设备是否支持蓝牙。如果支持，还要再确认是否有启用蓝牙。\n如果不支持蓝牙，那么你应该友好的禁用一些蓝牙功能。如果支持蓝牙，但是没有启用，你应该在不离开你的应用程序情况下请求用户启用蓝牙。这种设置需要使用BluetoothAdapter，通过两个步骤完成：\n3.1 获取BluetoothAdapter# 几乎所有使用蓝牙的Activity都要求有BluetoothAdapter。可以通过调用静态的getDefaultAdapter()方法获取BluetoothAdapter。这个方法会返回一个代表设备自身蓝牙适配器的BluetoothAdapter。这个BluetoothAdapter适用于整个系统，你的应用程序可以通过这个对象与系统交互。如果getDefaultAdapter()返回null，可能是设备不支持蓝牙，你的操作到此为止。例如：\nBluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); if (mBluetoothAdapter == null) { // 设备不支持蓝牙 } 3.2 启用蓝牙# 下一步，你需要确认蓝牙已经启用。调用isEnable()方法检查当前蓝牙是否已经启用。如果这个方法返回false，表示蓝牙已经禁用。请求启用蓝牙，要调用startActivityForResult()和使用action为 ACTION_REQUEST_ENABLE 的Intent。这里将会通过系统设置弹出一个启用蓝牙的请求（不会停止你的应用程序）。例如：\nif (!mBluetoothAdapter.isEnabled()) { Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT); } 将会出现一个对话框请求用户授权启用蓝牙，如图。如果用户点击“Yes”，系统将会启用蓝牙，焦点也会在程序完成（或者失败）之后返回到你的应用程序。\n![](https://img- blog.csdn.net/20141027144036437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlueGlhbmRpcWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n传递到startActivityForRequest()的REQUEST_ENABLE_BT常量是自己定义的一个整数（必须大于0），系统会将其作为requestCode参数传递到你的onActivityResult()方法中。\n如果启用蓝牙成功，你的activity就会在onActivityResult()中接收到一个 RESULT_OK 的result code。如果蓝牙由于一个错误（或者是用户点击了“No”）而启用失败，那么result code将会是RESULT_CANCELED。\n另外，你的应用程序同样可以使用广播监听 ACTION_STATE_CHANGED 这种类型的Intent，因为系统在蓝牙状态发生改变的时候会发送广播。这种广播包含extra数据 EXTRA_STATE 和 EXTRA_PREVIOUS_STATE ，分别表示新的和旧的的蓝牙状态。这些extra数据可能值包括 STATE_TURNING_ON 、 STATE_ON、STATE_TURNING_OFF 和 STATE_OFF 。在你的应用程序运行的时候监听这个广播对于检测蓝牙状态引起的变化非常有用。\n提示：启用设备可被发现模式同样会自动启用蓝牙。如果你计划在进入蓝牙功能的Activity之前始终启用设备可被发现，你可以跳过上面步骤2。阅读关于下面启用可被发现模式部分。\n4、Finding Devices（搜索设备）# 你可以使用BluetoothAdapter通过设备搜索或者查询已配对设备列表来发现远程设备。\n设备搜索是一个扫描程序，它会搜索本地附近启用了蓝牙的设备，并从这些设备上获取一些信息（这个过程有时简称为“发现中”、“查询中”或者“扫描中”）。然而，在本地区域范围内的蓝牙设备只有在它是允许被发现的模式下才会响应其它设备扫描发现的请求。如果一个设备是可被发现的状态模式，它会通过共享一些信息来响应搜索发现的请求，例如设备名字，设备类型和它唯一的MAC地址。使用这些信息，执行扫描的设备才能创建一个连接连接上被发现的设备。\n如果是第一次与远程设备建立连接，（本地设备）将会自动提示用户一个配对的请求。当设备配对成功之后，远程设备的基本信息（例如设备名字，类型和MAC地址）将会被保存，并且可以使用Bluetooth APIs读取。使用已知的远程设备的MAC地址，可以在任何时候建立与远程设备的连接，而不需要预先执行扫描（即使远程设备现在不在附近范围内）。\n注意设备配对和设备连接两者之间有点不同。设备配对意味着两个设备彼此之间都知道对方的存在，并且共享一个连接key可以进行互相验证和创建一个加密的连接。设备连接意味着设备之间当前共享一个RFCOMM通道，能够互相传输数据。当前的Android Bluetooth API要求在创建一个RFCOMM连接之前要先配对。（当你使用Bluetooth APIs创建一个加密连接的时候，配对是自动执行的）\n下面的章节阐述如何发现一个已经配对的设备，或者使用设备扫描发现一个新设备。\n注意：Android设备默认是不可被发现的。用户可以通过系统设置让设备在短时间内可被发现，或者一个应用程序可以要求用户在不离开应用程序的情况启用设备的可被发现模式。如何启用设备可被发现模式请参考下面讨论。\n4.1 Querying paired devices（查询配对设备）# 在执行设备扫描之前，查询已配对设备列表看看目标设备是否已经被发现过是非常值得的。可以通过调用getBondedDevice()方法来实现，它会返回一系列代表已配对设备的BluetoothDevice。例如，你可以查询所有已配对设备，然后使用ArrayAdapter显示所有设备的名字给用户：\nSet\u0026lt;BluetoothDevice\u0026gt; pairedDevices = mBluetoothAdapter.getBondedDevices(); // 如果有已配对设备 if (pairedDevices.size() \u0026gt; 0) { // 循环查看已配对设备 for (BluetoothDevice device : pairedDevices) { // 添加名字和地址到一个ArrayAdapter中，以便在ListView中显示 mArrayAdapter.add(device.getName() + \u0026quot;\\n\u0026quot; + device.getAddress()); } } 为了能够建立一个连接，只需要从BluetoothDevice中获取MAC地址。在这个例子中，它被保存为ArrayAdapter的一部分，然后展示给用户。MAC地址可以在稍后再提取出来以进行连接。你可以从下面Connecting Device章节了解更多关于创建连接的内容。\n4.2 Discovering devices（搜索设备）# 开始搜索设备，只需要简单调用startDiscovery()方法。这个方法是异步的，调用这个方法后会马上返回一个Boolean值表示搜素过程有没有成功开始执行。搜索过程通常会扫描12秒，之后在查询页面中扫描每一个发现的设备获取它们的蓝牙名称。\n你的应用程序必须注册一个BroadcastReceiver监听 ACTION_FOUND 类型的Intent，以接收每一个被发现设备的信息。每发现一个设备，系统都会广播一个 ACTION_FOUND 类型的Intent。这个Intent携带了extra数据 EXTRA_DEVICE 和 EXTRA_CLASS ，分别包含了一个BluetoothDevice和一个BluetoothClass。例如，下面注册了一个广播来处理被发现的设备：\n// 创建一个监听ACTION_FOUND的BroadcastReceiver private final BroadcastReceiver mReceiver = new BroadcastReceiver() { public void onReceive(Context context, Intent intent) { String action = intent.getAction(); // 当发现了一个设备 if (BluetoothDevice.ACTION_FOUND.equals(action)) { // 从Intent中获取BluetoothDevice对象 BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); // 将名字和地址添加到ListView的ArrayAdapter中 mArrayAdapter.add(device.getName() + \u0026quot;\\n\u0026quot; + device.getAddress()); } } }; // 注册这个BroadcastReceiver IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); registerReceiver(mReceiver, filter); // 不要忘记在onDestroy方法中注销这个广播 为了能够建立一个连接，只需要从BluetoothDevice中获取MAC地址。在这个例子中，它被保存为ArrayAdapter的一部分，然后展示给用户。MAC地址可以在稍后再提取出来进行连接。你可以从下面Connecting Device章节了解更多关于创建连接的内容。\n注意：执行设备搜索对于BluetoothAdapter是一个重量级的程序，它会消耗大量的资源。一旦你发现了一个设备想要建立连接，在尝试连接之前应该确保已经调用cancelDiscovery()方法停止扫描。同样，如果你已经与一个设备建立了连接再执行搜索程序，这个连接的可用带宽会显著减少，因此你不应该在建立连接之后还进行设备搜索。\n4.3 Enabling discoverability（启用可被发现模式）# 如果你想让本机设备可被其它设备发现，要使用Action为 ACTION_REQUEST_DISCOVERABLE 的Intent调用startActivityForResult(Intent, int)方法。这将会通过系统设置发出启用可被发现模式的请求（并且不会停止你的应用程序）。默认情况下，设备会进入可被发现模式120秒。你可以为Intent添加 EXTRA_DISCOVERABLE_DURATION 附加数据自定义时长。在一个应用程序中最多可以设置3600秒，如果将值设置为0就表示设备永远进入可被发现模式。任何小于0或者大于3600的值都会自动设置为120秒。例如下面的代码片段将时长设置为300：\nIntent discoverableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE); discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300); startActivityForResult(discoverableIntent, REQUEST_DISCOVERABLE);//REQUEST_DISCOVERABLE为自定义的requestcode值 如图，会显示一个对话框请求用户授权让设备进入可被发现模式。如果用户点击“Yes”，设备将会在执行的时间内进入可被发现模式。你的Activity将会在onActivityResult()方法中得到回调，并且resultCode等于设备可被发现的时长。如果用户点击“NO”或者遇到了错误，resultCode将会是 RESULT_CANCELED 。\n![](https://img- blog.csdn.net/20141027145249375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlueGlhbmRpcWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n注意：如果设备没有启用蓝牙，那么启用设备的蓝牙可被发现模式会自动启用设备蓝牙。\n设备将会在配置的时间内一直进入可被发现模式。如果你想要在可被发现模式发生改变的时候得到通知，你可以注册一个BroadcastReceiver监听 ACTION_SCAN_MODE_CHANGE 类型的Intent。这种Intent包含了 EXTRA_SCAN_MODE 和 EXTRA_PREVIOUS_SCAN_MODE 附加数据，分别代表新的和旧的扫描模式。它们的值可能为 SCAN_MODE_CONNECTABLE_DISCOVERABLE 、 SCAN_MODE_CONNECTABLE 或者 SCAN_MODE_NONE ，本别代表设备进入可被发现可连接模式、不可被发现但是可连接模式、不可被发现也不可连接模式。\n如果你只是要与远程设备建立连接，那么你不需要启用设备的可被发现模式。只有当你希望你的应用程序托管一个Server socket来接收传入的连接才需要启用设备可被发现模式，因为远程设备在建立连接之前必须要能够发现这个设备。\n5、Connecting Devices（连接设备）# 为了能够让你的应用程序在两台设备之间建立连接，你必须实现服务端和客户端的机制，因为一台设备必须启动一个server socket，另一台设备必须创建连接（使用服务端设备的MAC地址来创建一个连接）。只有服务端设备和客户端各自都有一个连接在同一个RFCOMM通道上的BluetoothSocket才算完成连接。在这个时候，每一台设备才能获得一个输入和输出流，数据传输才可以开始进行，这部分会在下面Managing a Connection章节讨论。这个章节讨论如何在两台设备间建立连接。\n服务端设备和客户端设备获取BluetoothSocket的方法不同。服务端设备将会在接受一个传入的连接请求时获得。客户端设备会在它打开与服务端设备的RFCOMM通道时获得。\n一种解决方案是自动将每一台设备作为服务端，这样每一台设备都拥有一个server socket可以监听连接。之后，每一台设备都可以启动一个与其它设备的连接并变成客户端设备。另外，也可以明确一台设备作为服务端根据需要启动一个server socket，其它设备只要简单的建立连接。\n注意：如果两台设备之前没有配对，那么Android Framework将会在连接过程中自动提示配对请求信息或者对话框，如图。因此尝试连接其它设备的时候，你的应用程序不需要考虑设备是否已经配对。你的RFCOMM连接将会被阻塞，直到用户配对成功或者失败（用户拒绝配对，或者配对失败，或者超时）。\n![](https://img- blog.csdn.net/20141027145701922?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlueGlhbmRpcWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n5.1 Connecting as server（作为服务端连接）# 当你尝试去连接两台设备，其中一台设备必须作为服务端持有一个BluetoothServerSocket对象。server socket的目的是为了监听传入的连接请求，并在接收请求之后提供一个已连接的BluetoothSocket。当从BluetoothServerSocket获取到BluetoothSocket之后，BluetoothServerSocket应该回收掉，除非你还要接收其它连接。\n下面是设置一个server socket并接收一个连接的一般过程：\n5.1.1 调用listenUsingRfcommWithServiceRecord(String, UUID)方法获取一个BluetoothServerSocket。 方法中的字符串参数是一个表示你的服务的名字，系统将会自动把这个字符串写入到设备上一个新的Service Discovery Protocol（SDP）数据库实体中（名字可以是任意的，可以简单使用你的应用程序名字）。另一个参数UUID也会被包含到SDP实体中，并且会作为与客户端设备连接协议的基础。也就是，当客户端设备尝试连接服务端设备的时候，它会携带一个UUID来标识服务端设备上的哪一个服务才是客户端设备要连接的。这些UUID必须匹配后才能接受连接请求（在下一步中讨论）。\nAbout UUID： 一个Universally Unique Identifier（UUID，通用唯一的ID）是一个标准128格式的字符串ID，用于唯一标识的信息。UUID的关键是它是一个足够大的值，你可以选择任意随机值也不会引起冲突。在这个例子中，它被用来唯一标识你的应用程序的蓝牙服务。为你的应用程序获取一个UUID，你可以使用网上随机生成的众多UUID中的一个，然后使用UUID类的fromString(String)方法生成一个UUID。\n5.1.2 调用accept()方法开始监听连接请求。 这个方法会阻塞，直到接受了一个连接请求或者出现异常才会返回。只有当一个远程设备发送一个携带UUID的连接请求，并且请求的UUID能够匹配注册server socket时的UUID，这个连接请求才会被接受。连接成功后，accept()方法就会返回一个已经连接上的BluetoothSocket。\n**5.1.3 除非你想要接受其它连接，否则你应该马上调用close()方法。**这样才能够释放server socket和它所占用的资源，但是不会关闭accept()方法返回已连接的BluetoothSocket。不像TCP/IP协议，RFCOMM在同一时间同一条通道上只允许连接一个客户端，因此在BluetoothServerSocket接受一个连接socket之后立即调用close()方法是有意义的。\naccept()方法不应该在UI线程中执行，因为这个方法会被阻塞，妨碍其它应用程序的交互。通常都是由你的应用程序新开一个线程执行所有BluetoothServerSocket或者BluetoothSocket的操作。终止一个会阻塞的方法，例如accept()，可以在其他线程调用BluetoothServerSocket或者BluetoothSocket的close()方法，阻塞的方法会立即返回。注意所有BluetoothServerSocket或者BluetoothSocket中的方法都是线程安全的。\n例子：\n以下是关于服务端机制接收传入连接的简单线程：\nprivate class AcceptThread extends Thread { private final BluetoothServerSocket mmServerSocket; public AcceptThread() { // 使用一个临时对象，稍后赋值给mmServerSocket, // 因为mmServerSocket被声明为final BluetoothServerSocket tmp = null; try { // MY_UUID是应用的UUID字符串,同样也会在客户端的代码中使用到 tmp = mBluetoothAdapter.listenUsingRfcommWithServiceRecord(NAME, MY_UUID); } catch (IOException e) { } mmServerSocket = tmp; } public void run() { BluetoothSocket socket = null; // 保持监听知道出现异常或者返回一个socket while (true) { try { socket = mmServerSocket.accept(); } catch (IOException e) { break; } // 如果接受了一个连接 if (socket != null) { // 执行连接的管理操作(在一个独立的线程中) manageConnectedSocket(socket); mmServerSocket.close(); break; } } } /** 将会终止socket的监听，并让线程结束 */ public void cancel() { try { mmServerSocket.close(); } catch (IOException e) { } } } 在这个例子中只会接受一个传入的连接，因此只要接受了一个连接就能获取一个BluetoothSocket，应用程序会将获取到的BluetoothSocket发送到一个独立的线程中，然后关闭BluetoothServerSocket并终止循环。\n注意accept()方法返回的BluetoothSocket已经连接成功，你不能再调用它的connect()方法（这是你在客户端中需要调用的方法）。\nmanageConnectedSocket()方法是应用程序假定的方法，它应该要为传输数据创建一个线程，这会在后面Managing a Connection章节讨论。\n你应该尽可能在你监听完传入的连接之后关闭你的BluetoothServerSocket。在这个例子中，获取到BluetoothSocket之后就马上调用了close()方法。你同样可能需要为你的线程提供一个公共的方法来关闭私有的BluetoothServerSocket，以便在你需要停止server socket监听的时候停止。\n5.2 Connecting as a client（作为客户端连接）# 为了能够与一个远程设备（一个持有server socket的设备）建立连接，你首先需要获取一个代表远程设备的BluetoothDevice对象。（获取一个BluetoothDevice对象的方法已经在上面Finding Device章节阐述过）。之后你需要使用BluetoothDevice来请求一个BluetoothSocket并建立连接。\n以下是基本步骤：\n5.2.1 使用BluetoothDevice对象调用createRfcommSocketToServiceRecord(UUID)方法获取一个BluetoothSocket对象。 这里获取的BluetoothSocket对象将会连接到对应的BluetoothDevice。这里的UUID必须匹配服务端设备启用BluetoothServerSocket（调用listenUsingRfcommWithServiceRecord(String, UUID)）时所用的UUID。使用相同的UUID可以在你的应用程序中写死一个UUID字符串，然后在服务端和客户端中使用。\n5.2.2 调用connect()方法创建连接。 在这里调用这个方法后，系统将会在远程设备上执行SDP查询匹配UUID。如果查询成功，远程设备就会接受这个连接，它会在连接期间共享RFCOMM通道，然后connect()返回。这个方法也是个阻塞的方法。如果因为某种原因连接失败或者connect()方法超时（大概12秒后），这个方法就会抛出一个异常。因为connect()方法也是个阻塞的方法，所以执行这个方法也要在一个在主线程之外独立一个线程执行。\n注意：你需要经常确保你在调用connect()方法的时候设备没有执行设备搜索。如果正在搜索设备，那么尝试连接的过程将会显著变慢，连接失败的几率也会更大。\n例子\n以下是创建一个蓝牙连接的简单线程例子：\nprivate class ConnectThread extends Thread { private final BluetoothSocket mmSocket; private final BluetoothDevice mmDevice; public ConnectThread(BluetoothDevice device) { // 使用临时对象稍候赋值给mmSocket, // 因为mmSocket的类型是final BluetoothSocket tmp = null; mmDevice = device; // 获取一个BluetoothSocket来连接给定的BluetoothDevice try { // MY_UUID是应用的UUID字符串, 也是服务端使用的UUID字符串 tmp = device.createRfcommSocketToServiceRecord(MY_UUID); } catch (IOException e) { } mmSocket = tmp; } public void run() { // 取消扫描设备，因为扫描会让连接速度变慢 mBluetoothAdapter.cancelDiscovery(); try { // 通过socket连接设备,这将会阻塞 // 直到连接成功或者抛出异常 mmSocket.connect(); } catch (IOException connectException) { // 连接失败;关闭socket并退出 try { mmSocket.close(); } catch (IOException closeException) { } return; } // 进行连接管理的操作 (在一个指定的线程中) manageConnectedSocket(mmSocket); } /** 将会取消正在进行中的连接,并关闭socket */ public void cancel() { try { mmSocket.close(); } catch (IOException e) { } } } 注意cancelDiscovery()方法需要在连接之前调用。你应该经常在连接之前调用这个方法，调用这个方法的时候不需要确定当前是否正在扫描其它设备（但是如果你真的要检查当前是否正在扫描设备，你也可以调用isDiscovery()方法）。\nmanageConnectedSocket()方法是应用程序假定的方法，它应该要为传输数据创建一个线程，这会在后面Managing a Connection章节讨论。\n当你对BluetoothSocket的操作完成之后，你应该调用close()方法来释放资源。当你调用这个方法后，会立刻关闭连接中的socket并回收所有网络资源。\n6、Managing a Connection（管理连接）# 当你成功连接两台或者更多设备，每一台设备都会有一个已连接的BluetoothSocket。这就是所有有趣事情的开端，因为你可以开始在设备之间共享数据。使用BluetoothSocket，一般的传出数据过程是很简单的：\n6.1 通过socket用getInputStream()和getOutputStream()方法分别获取InputStream和OutputStream对象来处理数据传输。\n6.2 使用read(byte[])和write(byte[])方法从数据流中读写数据。\n以上就是整个过程。\n当然，也有一些细节的东西需要考虑。首先，你需要为所有数据流的读写操作分派一个特定的线程。这是非常重要的，因为read(byte[])和write(byte[])方法都是会阻塞的方法。read(byte[])方法在从数据流中读取到数据之前会一直阻塞。write(byte[])方法不会经常阻塞，但是在远程设备没有及时调用read(byte[])方法并且中间缓冲区满的时候也会进行阻塞。因此，你的线程中的主循环应该专门用来从InputStream中读取数据。线程中再指定一个公共方法将数据写入到OutputStream中。\n例子\n以下是整个流程大概怎么进行的例子：\nprivate class ConnectedThread extends Thread { private final BluetoothSocket mmSocket; private final InputStream mmInStream; private final OutputStream mmOutStream; public ConnectedThread(BluetoothSocket socket) { mmSocket = socket; InputStream tmpIn = null; OutputStream tmpOut = null; // 使用临时对象获取输入输出流， // 因为成员输入输出流的类型是fianl try { tmpIn = socket.getInputStream(); tmpOut = socket.getOutputStream(); } catch (IOException e) { } mmInStream = tmpIn; mmOutStream = tmpOut; } public void run() { byte[] buffer = new byte[1024]; // 数据流的数据缓冲区 int bytes; // 从read()方法返回的字节数 // 保持对InputStream的监听，直到有异常抛出 while (true) { try { // 从InputStream中读取数据 bytes = mmInStream.read(buffer); // 将获取的字节发送到UI activity mHandler.obtainMessage(MESSAGE_READ, bytes, -1, buffer) .sendToTarget(); } catch (IOException e) { break; } } } /* 在main activity中调用这个方法将数据发送到远程设备 */ public void write(byte[] bytes) { try { mmOutStream.write(bytes); } catch (IOException e) { } } /* 在main activity中调用这个方法来停止连接 */ public void cancel() { try { mmSocket.close(); } catch (IOException e) { } } } 构造方法中获取必要的数据流，并且一旦执行，线程就会开始等待从InputStream中过来的数据。当read(byte[])方法从数据流中获取到字节数据后，这些数据就会被从main activity得到的Handle对象发送到main activity中。然后线程循环阻塞，继续等待从数据流中传输过来的更多字节数据。\n发送输出数据只需要在main activity中简单调用线程的write()方法，并将字节数据传递进去。这个方法会简单的调用write(byte[])方法将数据发送到远程设备。\n线程中的cancel()方法是非常重要的，有这个方法才能在任何时候通过关闭BluetoothSocket来中止连接。当你用完蓝牙连接之后，你应该要调用这个方法。\n使用Bluetooth APIs的实例，请参考Bluetooth Chat sample app。\n7、Working with Profile（使用Profile）# 从Android 3.0开始，Bluetooth API已经支持Bluetooth profiles。一个Bluetooth profile就是一种设备之间基于蓝牙通信的无线接口规范。比如Hands-Free profile（免提）。当一部手机想要连接无线耳机的时候，两台设备都必须支持Hands-Free profile。\n你可以实现BluetoothProfile接口定义自己的类来指定一种特定的Bluetooth profile。Android Bluetooth API已经提供了以下Bluetooth profile的实现：\n*** Headset。** Headset profile对用于手机的蓝牙耳机提供了支持。Android提供了BluetoothHeadset类，这个类是一个代理，通过进程间通信（IPC）来控制蓝牙耳机服务。这里面包括了蓝牙耳机和Hands- Free(v1.5) profile。BluetoothHeadset类同样提供了对AT命令的支持。更多关于这方面主题的讨论，请参考后面Vendor- specific AT commands章节。\n*** A2DP。** Advanced Audio Distribution Profile（A2DP，高级音频分发），它定义了高质量音频如何通过蓝牙连接以数据流的方式从一台设备到另一台设备进行传输。Androd提供了BluetoothA2dp类，同样是个代理，通过进程通信控制Bluetooth A2DP。\n*** Health Device。** Android 4.0开始支持Bluetooth Health Device Profile（HDP，蓝牙健康设备）。这允许你使用蓝牙创建与支持蓝牙的健康设备进行通信的应用程序，例如心律监控器、血压计、温度计、体重计等等。查看所支持的设备，以及它们相应的专业测量数据编码，请参考www.bluetooth.org中的Bluetooth Assigned Numbers。注意这些数值同样在ISO/IEEE 11073-20601[7]规范中作为MDC_DEV_SPEC_PROFILE_*命名编码附件引用。更多关于HDP的讨论，请参考后面Health Device Profile章节。\n以下是使用profile的基本步骤：\n（1）获取一个默认的BluetoothAdapter，在上面Setting Up Bluetooth（设置蓝牙）部分已经提到。\n（2）使用getProfileProxy()方法建立与profile相关联代理对象的连接。在下面的例子中，这个profile代理对象是一个BluetoothHeadset对象的实例。\n（3）配置一个BluetoothProfile.ServiceListener对象。这个监听器对象会通知BluetoothProfile的IPC客户端是否已经连接或者断开服务。\n（4）在onServiceConnected()方法中获取一个profile代理对象。\n（5）一旦你获得profile代理对象，你就可以使用它来监视连接的状态和执行其它一些与profile相关的方法。\n例如，以下的代码片段展示了如何连接一个BluetoothHeadset代理对象然后控制Headset profile。\nBluetoothHeadset mBluetoothHeadset; // 获取默认的adapter BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); // 建立与代理的连接 mBluetoothAdapter.getProfileProxy(context, mProfileListener, BluetoothProfile.HEADSET); private BluetoothProfile.ServiceListener mProfileListener = new BluetoothProfile.ServiceListener() { public void onServiceConnected(int profile, BluetoothProfile proxy) { if (profile == BluetoothProfile.HEADSET) { mBluetoothHeadset = (BluetoothHeadset) proxy; } } public void onServiceDisconnected(int profile) { if (profile == BluetoothProfile.HEADSET) { mBluetoothHeadset = null; } } }; // ... 调用mBluetoothHeadset的方法 // 使用完之后关闭代理连接 mBluetoothAdapter.closeProfileProxy(mBluetoothHeadset); 7.1 Vendor-specific AT commands（特定于供应商的AT命令）# 从android 3.0开始，应用程序可以注册系统广播接收耳机预定义的特定于供应商的AT命令发出的广播（例如Plantronics +XEVENT命令）。例如，一个应用程序可以接收关于连接设备电池情况的广播，然后通知用户或者执行一些需要的操作。创建接收 ACTION_VENDOR_SPECIFIC_HEADSET_EVENT 类型Intent的广播来处理耳机的vendor-specific AT命令。\n7.2 Health Device Profile（健康设备的Profile）# Android 4.0开始支持Bluetooth Health Device Profile（HDP，健康设备的profile）。这允许你创建使用蓝牙与支持蓝牙的健康设备进行通信的应用程序，例如心律监控器、血压计、温度计、体重计等等。Bluetooth Health API包括了BluetoothHealth类、BluetoothHealthCallback类和BluetoothHealthAppConfiguration类，这些都在上面The Basic（基础部分）章节提到过。\n使用Bluetooth Health API，了解以下HDP关键概念是非常有用的：\n概念 描述 Source HDP定义的一个角色。一个source就是一个健康设备，它能够发送医学数据（体重、血糖指标、体温等等）到一个智能设备，例如android手机或者平板。 Sink HDP定义的一个角色。一个sink就是一个智能设备，能够接收医学数据。在一个Android HDP应用程序中，sink由一个BluetoothHealthAppConfiguration对象担任。 Registration 指的是为一个特定的健康设备注册一个sink。 Connection 指的是打开一条健康设备和智能设备（例如Android手机或平板）的通信通道。 7.3 Creating an HDP Application（创建一个HDP应用程序）# 以下是创建一个Android HDP应用程序需要调用的基本步骤：\n（1）获取一个BluetoothHealth代理对象的引用。类似于耳机和A2DP profile设备，你必须使用一个BluetoothProfile.ServiceListener和 BluetoothProfile.HEALTH 的profile类型调用getProfileProxy()方法，创建一个于profile代理对象的连接。\n（2）创建一个BluetoothHealthCallback，并注册一个应用程序配置（BluetoothHealthAppConfiguration）作为health sink。\n（3）创建一个与健康设备的连接。一些设备会启动这个连接，对于这种设备不需要进行此步骤。\n（4）当成功连接上一个健康设备之后，使用文件描述读写这个健康设备。接收到的数据需要使用实现IEEE 11073-xxxxx规范的健康管理器解析。\n（5）完成之后，关闭健康通道并注销应用程序。当有扩展活动的时候，这个通道同样会被关闭。\n本步骤中完整的代码示例请参考Bluetooth HDP（Health Device Profile）。\n原文地址：http://developer.android.com/guide/topics/connectivity/bluetooth.html\n","date":"October 27, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/android%E8%93%9D%E7%89%99/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"bluetooth","url":"https://www.qinxiandiqi.sbs/tags/bluetooth/"},{"title":"蓝牙","url":"https://www.qinxiandiqi.sbs/tags/%E8%93%9D%E7%89%99/"},{"title":"socket","url":"https://www.qinxiandiqi.sbs/tags/socket/"},{"title":"通讯","url":"https://www.qinxiandiqi.sbs/tags/%E9%80%9A%E8%AE%AF/"}],"title":"Android蓝牙"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"如果你没有登录到常用的图形用户界面，这种方法就适合用来设置树莓派的wifi。尤其是在你没有屏幕或者有线网络，仅使用串口控制线的时候。另外，这种方法也不需要额外的软件，所有需要的东西都已经包含进了树莓派。\nGETTING WIFI NETWORK DETAILS（获取wifi网络详情）# 为了扫描wifi网络，可以使用 sudo iwlist wlan0 scan 命令。这个命令会列出所有可使用的wifi网络，以及网络的一些有用信息。例如：\n1、 **ESSID: \u0026ldquo;testing\u0026rdquo; ** ：这是wifi网络的名字。\n2、 IE:IEEE 802.11i/WPA2 Version1 ：这部分表示网络的验证方式，在这里是WPA2，这是一种用于替代WPA1的更新更加安全的无线网络标准。本指南应该适用于WEP、WPA或者WPA2，但是可能不适用企业版WPA2。\n你同样需要wifi网络的密码。大多数家庭路由器（默认密码）都有标注在路由器背面的标签上。在这个例子中，搜索到的wifi网络的ESSID（ssid）是testing，并且密码（psk）是testingPassword。\nADDING THE NETWORK DETAILS TO THE RASSBERRY PI（添加网络到树莓派上）# 使用nano编辑器打开 wpa-supplican t配置文件：\nsudo nano /etc/wpa_supplicant/wpa_supplicant.conf 在文件的底部添加下面内容：\nnetwork={ ssid=\u0026quot;The_ESSID_from_earlier\u0026quot; psk=\u0026quot;Your_wifi_password\u0026quot; } 在本示例网络中，我们应该添加为：\nnetwork={ ssid=\u0026quot;testing\u0026quot; psk=\u0026quot;testingPassword\u0026quot; } 现在按 ctrl +x键然后按 y 键，最后再按 回车键 。\n这个时候， wpa-supplicant 在几秒钟内应该就会注意到设置已经改变了，并且会尝试去连接这个网络。如果没有，那么就需要使用 sudo ifdown wlan0\n和 sudo ifup wlan0 命令手动重启接口，或者直接使用 sudo reboot 命令重启树莓派。\n你可以使用 ifconfig wlan0 命令确认是否已经成功连接上网络。如果 inet addr 中已经有地址了，说明树莓派成功连接上了网络。如果没有，请检查你的密码和ESSID是否正确。\n原文地址：\u0026lt;http://www.raspberrypi.org/documentation/configuration/wireless/wireless- cli.md\u0026gt;\n[\n](http://www.raspberrypi.org/documentation/configuration/wireless/wireless- cli.md)\n","date":"October 2, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84wifi%E7%BD%91%E7%BB%9C/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"wifi","url":"https://www.qinxiandiqi.sbs/tags/wifi/"},{"title":"命令行","url":"https://www.qinxiandiqi.sbs/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}],"title":"使用命令行设置树莓派的wifi网络"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"在你的home目录中，你可以找到一个包含用户配置的隐藏文件 .bashrc 。你可以根据自己的需要修改这个文件。\n文件中为你提供了一些有用的调整设置，默认情况下其中一些设置是被注释掉的。\n例如，一些 ls 命令的别名：\nalias ls='ls --color=auto' #alias dir='dir --color=auto' #alias vdir='vdir --color=auto' alias grep='grep --color=auto' alias fgrep='fgrep --color=auto' alias egrep='egrep --color=auto' 类似上面提供的别名是用来帮助其它系统的用户熟悉使用（例如 dir 相当于DOS/Windows系统中的 ls ）。另外一些是为了给像 ls 和 grep 这些命令的输出结果添加颜色。\n其中也提供了更多 ls 命令的变体别名：\n# some more ls aliases #alias ll='ls -l' #alias la='ls -A' #alias l='ls -CF' Ubuntu用户应该对这些设置更加熟悉，因为这是Ubuntu发行版本的默认设置。取消这些命令的注释就可以让这些别名在稍后生效。\n以 “#” 开头的命令行表示被注释。为了启用它们，只需要将 “#” 移除，等下次启动你的树莓派就会激活这些设置。\n这里同样有关于 .bash_aliases 文件的引用，默认情况下这个文件并不存在：\nif [ -f ~/.bash_aliases ]; then . ~/.bash_aliases fi 这里的if条件用于在导入这个文件之间检查文件是否存在。\n你可以创建这个 .bash_aliases 文件，并在里面添加更多的别名，例如：\nalias gs='git status' 你也可以直接添加其它东西到这个文件中或者是其它文件，只要将文件像 .bash_aliases 文件一样包含进来就可以。\n原文地址：http://www.raspberrypi.org/documentation/linux/usage/bashrc.md\n","date":"September 30, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84.bashrc%E5%92%8C.bash_aliases%E6%96%87%E4%BB%B6/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":".bashrc","url":"https://www.qinxiandiqi.sbs/tags/.bashrc/"},{"title":".bash_aliases","url":"https://www.qinxiandiqi.sbs/tags/.bash_aliases/"}],"title":"树莓派的.bashrc和.bash_aliases文件"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"为了在树莓派启动的时候运行一个命令或程序，你需要将命令添加到 rc.local 文件中。这对于想要在树莓派接通电源后无需配置直接运行程序，或者不希望每次都手动启动程序的情况非常有用。\n另一种替代定时任务的方法是使用cron和crontab。\nEDITING RC.LOCAL（编辑rc.local文件）# 在你的树莓派上，选择一个文本编辑器编辑 /etc/rc.local 文件。你必须使用root权限编辑，例如：\nsudo vim /etc/rc.local 在注释后面添加命令，但是要保证 exit 0 这行代码在最后，然后保存文件退出。\nWARNING（注意）# 如果你的命令需要长时间运行（例如死循环）或者运行后不能退出，那么你必须确保在命令的最后添加 **“ \u0026amp;”**符号让命令运行在其它进程，例如：\npython /home/pi/myscript.py \u0026amp; 否则，这个脚本将无法结束，树莓派就无法启动。这个 **“ \u0026amp;”**符号允许命令运行在一个指定的进程中，然后继续运行启动进程。\n另外，确保文件名使用绝对路径，而不是相对于你的home目录的相对路径。例如：使用 /home/pi/myscript.py 而不是用 myscript.py 。\n原文地址：http://www.raspberrypi.org/documentation/linux/usage/rc-local.md\n","date":"September 30, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84rc.local%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"rc.local","url":"https://www.qinxiandiqi.sbs/tags/rc.local/"},{"title":"开机启动","url":"https://www.qinxiandiqi.sbs/tags/%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"}],"title":"树莓派的rc.local文件（设置开机启动）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"命令可以组合起来保存在文件中，并一块执行。一个比较愚蠢的例子，复制下面的命令到你最喜欢的文本编辑器中：\nwhile 1 do echo Raspberry Pi! done 现在，将其保存为名为fun-script的文件。在你运行这个文件之前，你需要将它设置为可执行文件，可以使用修改模式的命令 chmod 来实现。每一个文件和文件夹都拥有自己的权限来限定哪些用户可以操作它或者不能操作它。在这个例子中，运行命令 chmod +x fun- script，fun-script文件就变成可执行文件了。你可以输入 ./fun-script 来运行这个文件（当然这个文件要在你当前的目录中）。这个脚本将会无限循环输出“Raspberry Pi！”，停止循环可以使用 Ctrl + C键。这将会杀死当前终端中正在运行的命令（进程）。\n原文地址：http://www.raspberrypi.org/documentation/linux/usage/scripting.md\n","date":"September 29, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BEshell%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"shell","url":"https://www.qinxiandiqi.sbs/tags/shell/"},{"title":"脚本","url":"https://www.qinxiandiqi.sbs/tags/%E8%84%9A%E6%9C%AC/"}],"title":"树莓派Shell脚本文件"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"管理安装、升级和卸载软件最简单的方法就是使用Debian上的APT（高级包管理工具）。如果一个软件被打包成Debian上的包并且适用于树莓派的ARM架构，那么这个软件包同样兼容于Raspbian。\n安装或者卸载软件包的时候你需要root用户权限，因此你的用户必须是sudoer用户，或者你必须使用root用户登录。更多信息参考用户管理和root用户。\n安装新的包，或者更新已有的包，你需要连接互联网。\n注意安装软件会消耗你的SD卡存储空间，因此你需要关注磁盘空间并使用合适大小的SD卡。\n同样要注意安装软件的时候会进行加锁操作，因此你不能同时安装多个软件。\nSOFTWARE SOURCES（软件源）# APT在你的树莓派上的 /etc/apt/sources.list 文件中保存了一个软件源列表。在安装软件之前，你应该使用 apt-get update 更新你的包列表：\nsudo apt-get update INSTALLING A PACKAGE WITH APT（使用apt安装一个软件包）# sudo apt-get install tree\r输入以上命令之后将会提示用户安装这个包需要多少存储空间，以及确认安装这个软件包。输入Y（或者直接回车，因为yes是默认操作）将允许安装。可以通过添加 -y 选项跳过这一步：\nsudo apt-get install tree -y 安装这个软件包，使用户可使用tree这个软件。\nUSING AN INSTALLED PACKAGE（使用已经安装的软件包）# tree是一个命令工具，可以提供当前目录的可视化结构，以及所有内容。\n输入tree运行tree命令，例如：\ntree .. ├── hello.py ├── games │ ├── asteroids.py │ ├── pacman.py │ ├── README.txt │ └── tetris.py 输入 man tree 获取tree的用户手册。\n输入 whereis tree 显示tree安装位置：\ntree: /usr/bin/tree UNINSTALLING A PACKAGE WITH APT（使用APT卸载包）# REMOVE（卸载）# 你可以使用 apt-get remove 卸载一个包：\nsudo apt-get remove tree 用户会被提示是否要卸载。同样，添加 -y 选项可以跳过确认步骤。\nPURGE（清除）# 你可以使用 apt-get purge 命令完整的移除包以及它所相关的配置文件。\nsudo apt-get purge tree UPGRADING EXISTING SOFTWARE（更新已安装软件）# 如果有软件可以更新，你可以使用 sudo apt-get update 获取所有更新，并使用 sudo apt-get upgrade 安装所有可以更新的包。如果只更新特定的软件包而不更新其它过期的软件包，你可以使用 sudo apt-get install somepackage 来更新（这对于存储空间不足或者下载带宽比较小的情况比较有用）。\nSEARCHING FOR SOFTWARE（查询软件）# 你可以使用关键字查询一个包的档案信息：\napt-cache search: apt-cache search locomotive sl - Correct you if you type `sl' by mistake 你也可以使用以下命令在安装软件之前查询更多关于该包的信息：\napt-cache show: apt-cache show sl Package: sl Version: 3.03-17 Architecture: armhf Maintainer: Hiroyuki Yamamoto \u0026lt;yama1066@gmail.com\u0026gt; Installed-Size: 114 Depends: libc6 (\u0026gt;= 2.4), libncurses5 (\u0026gt;= 5.5-5~), libtinfo5 Homepage: http://www.tkl.iis.u-tokyo.ac.jp/~toyoda/index_e.html Priority: optional Section: games Filename: pool/main/s/sl/sl_3.03-17_armhf.deb Size: 26246 SHA256: 42dea9d7c618af8fe9f3c810b3d551102832bf217a5bcdba310f119f62117dfb SHA1: b08039acccecd721fc3e6faf264fe59e56118e74 MD5sum: 450b21cc998dc9026313f72b4bd9807b Description: Correct you if you type `sl' by mistake Sl is a program that can display animations aimed to correct you if you type 'sl' by mistake. SL stands for Steam Locomotive. 原文地址：http://www.raspberrypi.org/documentation/linux/software/apt.md\n","date":"September 29, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BEapt%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"apt","url":"https://www.qinxiandiqi.sbs/tags/apt/"},{"title":"软件","url":"https://www.qinxiandiqi.sbs/tags/%E8%BD%AF%E4%BB%B6/"},{"title":"管理","url":"https://www.qinxiandiqi.sbs/tags/%E7%AE%A1%E7%90%86/"}],"title":"树莓派apt软件管理工具"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"Linux操作系统是一个多用户操作系统，它允许多个用户登录和使用一台计算机。为了保护计算机（和其他用户的隐私），用户都被限制了能做的事情。\n大多数用户都允许运行计算机上大部分程序，并且编辑和保存存放在他们自己home目录中的文件。一般用户都不允许编辑其他用户的文件和一些系统文件。然而，在Linux系统上有一个特殊用户叫做超级用户，通常用户名为root。这个超级用户访问计算机没有限制，几乎可以做所有事情。\nSUDO# 你通常不以root用户登录计算机，但是可以使用 sudo 命令来获得超级用户权限。如果你登录树莓派使用的是pi用户，那么你就是以普通用户身份登录。你可以在你想要运行的程序之前添加sudo命令来以root用户身份运行程序。\n例如，如果你想要在树莓派上安装额外的软件，你通常需要使用 apt-get 工具。为了能够更新可使用的软件列表，你需要在 agt-get 命令之前添加 sudo 命令前缀： sudo apt-get update 。\n查看更多apt命令信息。\n你同样也可以使用 sudo su 命令来运行一个超级用户shell终端。一旦以超级用户的身份运行命令，那么就没有什么能够防止造成系统伤害的错误。相当于关闭了机器上的安全防护。虽然这样能够更容易访问系统内部的东西，但是造成损害的风险更大。建议你只在需要超级用户权限的时候以超级用户身份运行命令，在不需要超级用户权限的时候及时退出超级用户shell终端。\nWHO CAN USE SUDO？（谁可以使用sudo）# 如果任何用户都能够在命令之前添加sudo，安全性就会遭到破坏，因此只有指定的用户才能使用sudo获取计算机管理员的权限。pi用户已经包含在 sudoer 文件中。允许其他用户使用超级用户权限，你可以将这些用户添加到sudo分组，或者使用 visudo 添加他们。\n更多详细信息请参考用户管理。\n原文地址：http://www.raspberrypi.org/documentation/linux/usage/root.md\n","date":"September 28, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BEroot%E7%94%A8%E6%88%B7%E5%92%8Csudo/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"sudo","url":"https://www.qinxiandiqi.sbs/tags/sudo/"},{"title":"超级用户","url":"https://www.qinxiandiqi.sbs/tags/%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7/"}],"title":"树莓派——root用户和sudo"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"当你登入树莓派并打开一个终端窗口，或者你替换了图形用户界面直接开机启动到命令行模式，你将会开始于home目录下。假如你的用户名是pi，那么这个路径就是 /home/pi 。\n这个地方是用户保存用户自己的文件，其中包括了用户保存桌面上的文件的文件夹Desktop，以及其它一些文件和文件夹。\n在命令中导航到你的home目录，只需要简单输入 cd 命令然后回车。这相当于你输入了 cd /home/pi （这里的pi是你的用户名）。你也可以使用波浪符号（ ~ ），例如 cd ~ ，这个符号可以用于表示相对于你的home目录路径。例如， cd ~/Desktop/ 等同于 cd /home/pi/Desktop 。\n导航到 /home/ 目录下并运行 ls ，你将会看到系统中每一个用户的home目录。\n注意如果是以root用户登录，输入 cd 或者 cd ~ 将会导航到root用户的home目录；不同于普通用户，这个路径将导航到 /root/ 而不是 /home/root/ 。更多信息请参考root user。\n如果你有一些文件不希望丢失，你可以备份你的home目录。详细请参考backing up。\n原文地址：http://www.raspberrypi.org/documentation/linux/filesystem/home.md\n","date":"September 26, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BEhome%E7%9B%AE%E5%BD%95/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"home","url":"https://www.qinxiandiqi.sbs/tags/home/"}],"title":"树莓派home目录"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"强烈建议定期备份一些重要文件。备份通常不单限于用户文件，还可以是配置文件、数据库、已安装的软件、设置，甚至是整个系统快照。\n这里我们会指导你通过一些备份技术为你的树莓派系统备份。\nHOME FOLDER（Home目录）# 一种比较好的备份Home目录方法是使用 tar 命令生成一个目录快照压缩文件，然后复制到你的PC电脑或者云端存储上。输入下面命令来备份home目录：\ncd /home/ tar czf pi_home.tar.gz pi 这里在/home/目录下创建了一个名为pi_home.tar.gz的tar压缩文件。你可以通过USB或者网络将这个文件复制到你其他的机器设备上。\nMYSQL# 如果你在树莓派上使用了MySQL数据库，备份数据库同样也是比较重要的。备份一个单一的数据库，可以使用 mysqldump 命令：\nmysqldump recipes \u0026gt; recipes.sql 从备份文件中恢复数据库，需要在mysql导入这个备份文件，提供证书（如果需要的话）和数据库名字。\n注意数据库必须是已经存在的，因此要先创建它：\nmysql -Bse \u0026quot;create database recipes\u0026quot; cat recipes.sql | mysql recipes 另外，你还可以使用pv命令（默认没有安装，需要使用 apt-get install pv 命令安装）查看MySQL处理备份文件的进度。这对大文件非常有用：\npv recipes | mysql recipes SD CARD IMAGE（SD卡映像）# 可能你需要备份整张SD卡映像，这样你才能在原SD卡丢失或者损坏的情况下恢复到新的SD卡。你可以使用将映像写入到SD卡的方法来备份SD卡，只是顺序要反过来。\n在Linux或者Mac系统上，例如：\nsudo dd bs=4M if=/dev/sdb of=raspbian.img 这里将会在你的PC上创建一个映像文件，你可以将这个映像文件写入到其它的SD卡来复制相同的内容和设置。恢复或者复制到其它的SD卡，也是使用 dd 命令，只不过要反过来：\nsudo dd bs=4M if=raspbian.img of=/dev/sdb 更多信息请参考：[installing SD card imagers](http://www.raspberrypi.org/documentation/installation/installing- images/README.md)\nAUTOMATION（自动化）# 你可以写一个Bash脚本来让这些备份操作自动化执行，甚至可以使用cron让这些操作定期执行。\n原文地址：http://www.raspberrypi.org/documentation/linux/filesystem/backup.md\n","date":"September 25, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E5%A4%87%E4%BB%BD/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"备份","url":"https://www.qinxiandiqi.sbs/tags/%E5%A4%87%E4%BB%BD/"}],"title":"树莓派的备份"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"Sonic Pi是一个开源的编程环境，设计初衷是为了通过创建声音制作音乐的流程来进行编程概念的探索和教学。\nSonic Pi的执行的代码基于Ruby，这是一种漂亮又简洁的编程语言。这意味着你可以写很多代码而不需要考虑太多关于语法和大小括号的问题——尽管对于复杂程序这些很重要。\n1、GETTING STARTED（开始学习）# 你可以在Raspbin系统的applications菜单的Education中找到Sonic Pi程序。打开这个程序，你将会看到类似下面的窗口：\n这就是Sonic Pi的程序界面。窗口中主要包含三个部分。最大的部分是你写代码的地方，我们叫这里为编程面板。右上角的控制窗口为输出面板，这里会显示你的程序执行过程中的信息。右下方的窗口是错误面板，当你的代码中有错误的时候会在这里显示错误信息。\n2、MAKING SOUNDS（制作声音）# 在Workspace 1中输入以下内容：\nplay 60 现在点击Play按钮，这个音符将会执行。MIDI将值60指定为C音。\n尝试将 play 60 更改为 pley 60 看看会有什么错误。\n现在输入以下代码：\nplay 60 play 67 play 69 然后在点击Play按钮一次。\n这些音符执行的很快，以至于听起来好像是同时发声一样。使用sleep在音符之间添加暂停：\nplay 60 sleep 1 play 67 sleep 2 play 69 3、A TUNE：FRERE JACQUES（一首曲子：雅克兄弟）# 雅克兄弟这首曲子的开头为：\nC D E C 或者在MIDI中的音符为60 62 64 60。\n音符与MIDI音符 值对照：\n**** C D E F G A B 60 62 64 65 67 69 71 以下是曲子：\nplay 60 sleep 0.5 play 62 sleep 0.5 play 64 sleep 0.5 play 60 sleep 0.5 4、LOOPING（循环）# 为了重复执行一系列指令，你可以使用循环。以下是Ruby语言循环的示例：\n2.times do play 60 sleep 0.5 play 62 sleep 0.5 play 64 sleep 0.5 play 60 sleep 0.5 end 5、FUNCTIONS（方法）# 你可以在一个方法中定义一系列执行，以后可以多次调用这个方法以避免复制黏贴多行代码：\ndef frere play 60 sleep 0.5 play 62 sleep 0.5 play 64 sleep 0.5 play 60 sleep 0.5 end 以后就可以输入frere来调用这个方法。例如在一个循环中调用：\n4.times do frere end 6、SYNTHS（合成器）# 合成器能够让play方法发出不同的声音效果。默认的合成器是“pretty_bell”，但是你可以自己更改：\n\u0026quot;pretty_bell\u0026quot; \u0026quot;dull_bell\u0026quot; \u0026quot;beep\u0026quot; \u0026quot;saw_beep\u0026quot; \u0026quot;fm\u0026quot; 尝试一下不同的合成器：\nwith_synth \u0026quot;fm\u0026quot; 2.times do play 60 sleep 0.5 play 62 sleep 0.5 end 7、THREADS（线程）# 你可以使用线程来同时播放两首曲子。类似于循环，它也是以end关键字为结尾的代码块：\nin_thread do with_synth \u0026quot;saw_beep\u0026quot; 2.times do play 60 sleep 0.5 play 67 sleep 0.5 end end 8、WORKSPACES（工作空间）# 你可以在Sonic Pi程序窗口中使用多个工作空间。这意味着你可以在其它工作空间中试用你的代码块，而不需要删除当前的代码。建议你使用其它的工作空间来试用代码，做实现或沙盒测试。\n9、SONIC PI FILES（Sonic Pi文件）# 如果你选择保存为文件，你就可以以后再返回来或者分享给别人。Sonic Pi文件是一个简单的文本文件，因此你可以在其它计算机上查看和编辑，也可以在其他树莓派上运行。\n原文地址：http://www.raspberrypi.org/documentation/usage/sonic-pi/README.md\n","date":"September 22, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BEsonicpi%E5%A3%B0%E9%9F%B3%E7%BC%96%E7%A8%8B/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"Sonic Pi","url":"https://www.qinxiandiqi.sbs/tags/sonic-pi/"},{"title":"音乐","url":"https://www.qinxiandiqi.sbs/tags/%E9%9F%B3%E4%B9%90/"},{"title":"声音","url":"https://www.qinxiandiqi.sbs/tags/%E5%A3%B0%E9%9F%B3/"}],"title":"树莓派 —— Sonic Pi（声音编程）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"你可以使用rsync工具在不同计算机之间同步文件夹。你可能想要从你的桌面计算机或者笔记本上传送文件到你的树莓派上，并保持这个文件的更新。或者，你想要把你的树莓派拍摄的照片自动传送到你的计算机上。\n使用基于SSH的rsync可以让你自动将文件传送到你的计算机上。\n以下的例子是将你的树莓派上的照片文件夹设置为自动同步到你的计算机上：\n在你的计算机上创建一个名为camera的目录：\nmkdir camera 登录树莓派运行 hostname -I 命令查看树莓派的IP地址。在这例子中，树莓派已经创建了定时任务，它每隔一分钟就会拍摄一张照片，并使用时间戳将照片保存在SD卡的本地camera目录下。\n现在在你的计算机上运行以下命令（替换成你自己的树莓派IP地址）：\nrsync -avz -e ssh pi@192.168.1.10:camera/ camera/ 这个命令将会从树莓派的camera文件夹下所有的文件复制到你的计算机camera目录下。\n为了能够保持文件夹的同步，需要在cron中运行这个这个命令。\n原文地址：http://www.raspberrypi.org/documentation/remote-access/ssh/rsync.md\n","date":"September 22, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BErsync%E5%90%8C%E6%AD%A5/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"rsync","url":"https://www.qinxiandiqi.sbs/tags/rsync/"},{"title":"同步","url":"https://www.qinxiandiqi.sbs/tags/%E5%90%8C%E6%AD%A5/"}],"title":"树莓派 —— Rsync（同步）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"Cron是Unix系统的一个配置定期任务的工具，用于定期或者以一定的时间间隔执行一些命令或者脚本；可执行的任务范围可以是每天夜里自动备份用户的home文件夹，也可以每个小时记录CPU的信息日志。\ncrontab（cron table）命令用于编辑执行中的定期任务列表，并且操作是基于每个用户的，每一个用户（包括root用户）都拥有自己的crontab。\nEDITING CRONTAB（编辑crontab）# 运行crontab和-e选项来编辑cron table：\ncrontab -e SELECT AN EDIROR（选择一个编辑器）# 第一次运行crontab命令的时候会提示你选择一个编辑器。如果你不确定使用哪一个，你可以直接回车选择默认的nano编辑器。\n每一项cron实体的内容都包含六个部分：分钟、小时、月份中的哪一天、年份中的哪一月、星期中的哪一天，还有定时执行的命令。\n# m h dom mon dow command # * * * * * command to execute # ┬ ┬ ┬ ┬ ┬ # │ │ │ │ │ # │ │ │ │ │ # │ │ │ │ └───── 星期中的哪一天(0-7)(从0到6代表星期日到星期六,也可以使用名字;7是星期天,等同于0) # │ │ │ └────────── 月份 (1 - 12) # │ │ └─────────────── 月份中的日 (1 - 31) # │ └──────────────────── 小时 (0 - 23) # └───────────────────────── 分钟 (0 - 59) 例如：\n0 0 * * * /home/pi/backup.sh 这项cron实例将会在每一天的午夜执行backup.sh脚本。\n原文地址：http://www.raspberrypi.org/documentation/linux/usage/cron.md\n","date":"September 22, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BEcron%E5%92%8Ccrontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"cron","url":"https://www.qinxiandiqi.sbs/tags/cron/"},{"title":"crontab","url":"https://www.qinxiandiqi.sbs/tags/crontab/"},{"title":"定时任务","url":"https://www.qinxiandiqi.sbs/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}],"title":"树莓派 —— Cron 和 Crontab（定时任务）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"SFTP（SSH文件传输协议）是一种网络协议，提供了基于SSH协议的文件访问、文件传输和文件管理方法。\n通过使用SFTP，你可以很容易修改、浏览以及编辑树莓派上的文件。SFTP比起FTP更容易配置，因为Raspbian默认已经启用SSH。\nFilezilla# 在[filezilla-project.org](https://filezilla- project.org/)上对应你的操作系统下载最新版本的FileZilla客户端。\n启动FileZilla并进入File（文件） \u0026gt; Site manager（站点管理）。\n在对话框中填写你的树莓派的IP地址，用户名和密码（默认用户名是pi，密码是raspberry），并选择SFTP协议。\n点击Connect（连接）按钮，你将会看到用户的home目录。\nUBUNTU USING NAUTILUS（Ubuntu使用Nautilus）# 在客户机上打开Nautilus。\n选择File \u0026gt; Conncect to Server\nType: SSH Server: \u0026lt;The Pi's IP address\u0026gt; Port: 22 (default) User name: pi (default) Password: raspberry (default) 查看[IP地址](http://www.raspberrypi.org/documentation/troubleshooting/hardware/networking/ip- address.md)。\n原文地址：http://www.raspberrypi.org/documentation/remote-access/ssh/sftp.md\n","date":"September 21, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E4%BD%BF%E7%94%A8sftp%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"filezilla","url":"https://www.qinxiandiqi.sbs/tags/filezilla/"},{"title":"sftp","url":"https://www.qinxiandiqi.sbs/tags/sftp/"},{"title":"文件传输","url":"https://www.qinxiandiqi.sbs/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"}],"title":"树莓派上使用SFTP管理文件"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"在Windows平台上你需要下载并安装一个VNC客户端程序。常用的有TightVNC，你可以从tightvnc.com上下载。\n根据你的Window系统版本选择对应的32位或者64位版本下载。如果你不知道你的Window系统版本，可以在控制面板中查看。下载安装文件并运行。\n在安装过程中，你将有机会选择典型安装、自定义安装或者完全安装。你只需要VNC客户端，不需要服务端，所以选择自定义安装。然后，选择TightVNC Server并设置为Entire feature will be unavailable。单击Next。忽略Window防火墙的选项，然后再点击Next，再点击Install安装。\n一旦完成安装，你将会在开始菜单中看到TightVNC Viewer程序。当你运行这个程序的时候将会看到下面的对话框。你需要输入树莓派的IP地址和对应的屏幕编号（:0或:1）。例如，192.168.0.6:1。\n点击Connect按钮，你将会开看到提示输入密码的对话框。这个密码是之前你在树莓派上配置VNC服务指定的密码。正确输入密码之后，你将会看到树莓派的桌面。\n如果你在树莓派桌面上想要退出，不要使用logout（登出）菜单。你只要关闭Remote Desktop Viewer窗口，然后在树莓派上使用先前文章提到的命令关闭VNC服务。\n原文地址：http://www.raspberrypi.org/documentation/remote-access/vnc/windows.md\n","date":"September 20, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E5%9C%A8window%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8vnc%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"vnc","url":"https://www.qinxiandiqi.sbs/tags/vnc/"},{"title":"Windows","url":"https://www.qinxiandiqi.sbs/tags/windows/"},{"title":"desktop","url":"https://www.qinxiandiqi.sbs/tags/desktop/"}],"title":"在Window平台使用VNC连接树莓派"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"在Mac OS平台上你需要安装一个VNC客户端程序。你也可以直接使用屏幕分享（系统自带的程序），但是这个程序需要配置比较多的东西。我们使用另一个能够与树莓派VNC服务友好工作的程序叫RealVNC，你可以从realvnc.com下载。\n下载安装包文件并打开它。在安装过程中你可以选择安装类型。你只需要在你的Mac上安装VNC客户端，不需要vnc服务。因此选择自定义，并不要勾选VNC Server选项（如下图）。\n点击Continue按钮，完成剩下的安装步骤。完成安装之后打开finder，在左边选择Applications并在搜索框中输入vnc。VNC客户款应该就会出现在搜索结果中。可以为它在你的桌面上创建快捷方式以方便以后使用。\n当你运行这个程序，你将会看到上面的对话框。你需要输入树莓派的IP地址以及屏幕编号（:0或者:1），例如：192.168.0.165:1。\n点击Connect按钮，你将会看到一个未加密连接的警告：\n一般情况下，只有当你的Mac和树莓派是通过互联网连接才需要考虑这个警告。如果你使用的是一个本地网络或者学校内部网络，那么你不需要太担心这个问题。点击Continue按钮，之后会提示你输入之前在树莓派上配置VNC服务所指定的密码。完成后你将会看到树莓派的桌面：\n如果你在树莓派桌面上想要退出，不要使用logout（登出）菜单。你只要关闭Remote Desktop Viewer窗口，然后在树莓派上使用先前文章提到的命令关闭VNC服务。\n更多关于RealVNC的文档请参考以下页面：\nhttp://www.realvnc.com/products/vnc/documentation/latest/\n原文地址：http://www.raspberrypi.org/documentation/remote-access/vnc/mac.md\n","date":"September 19, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E5%9C%A8macos%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8vnc%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"vnc","url":"https://www.qinxiandiqi.sbs/tags/vnc/"},{"title":"mac","url":"https://www.qinxiandiqi.sbs/tags/mac/"}],"title":"在Mac OS平台使用VNC连接树莓派"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"你的Linux发行版本可能已经包含了Remote Desktop Viewer（远程桌面）程序，你可以通过这个程序使用VNC连接你的树莓派。通常可以在Applications/Internet菜单下面找到这个程序（下面是Ubuntu的例子）；\n一旦你选择Remote Desktop Viewer程序并点击Connect（连接）按钮，你将会看到以下对话框。在Protocol（协议）选项中选择VNC，然后输入树莓派的IP地址以及屏幕编号（例如:0或者:1），完整例子：192.168.0.6:1。\n点击Connect（连接）按钮，你将会看到一个提示框要求输入密码。这个密码就是之前在树莓派上配置VNC服务所指定的密码。正确输入之后你将会看到树莓派的远程桌面。\n如果你在树莓派桌面上想要退出，不要使用logout（登出）菜单。你只要关闭Remote Desktop Viewer窗口，然后在树莓派上使用先前文章提到的命令关闭VNC服务。\n另一个替代的程序是Remmia Remote Desktop Client，可以从这里下载remmina.sourceforge.net。\n原文地址：http://www.raspberrypi.org/documentation/remote-access/vnc/linux.md\n","date":"September 19, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E5%9C%A8linux%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8vnc%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"vnc","url":"https://www.qinxiandiqi.sbs/tags/vnc/"},{"title":"ubuntu","url":"https://www.qinxiandiqi.sbs/tags/ubuntu/"},{"title":"linux","url":"https://www.qinxiandiqi.sbs/tags/linux/"}],"title":"在Linux平台使用VNC连接树莓派"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"有时候直接操作树莓派不是很方便。你可能想要使用其它计算机通过远程来控制树莓派。\nVNC是系统分享的一个图形界面，能够让你从一台计算机远程控制另一台计算机的桌面接口。它从操作计算机端发送键盘和鼠标事件，并通过网络接收到远程计算机的屏幕更新。\n你将在你的计算机上的一个窗口中看到树莓派的桌面。你可以在这个桌面上跟直接控制树莓派一样操作。\n在你的树莓派上（使用一个显示器或者通过SSH），安装TightVNC包：\nsudo apt-get install tightvncserver\n下一步，运行TightVNC服务，它将会提示你输入密码和一个可选的只读密码：\ntightvncserver\n在终端上启动一个VNC服务。下面的例子在VNC上启动了一个端口为(:0)的全屏HD分辨率会话：\nvncserver :0 -geometry 1920x1080 -depth 24\n现在，在你的计算机上，安装并运行VNC客户端：\n在Linux计算机上可以使用下面命令安装xtightvncviewer包： sudo apt-get install xtightvncviewer\n其他平台，可以从tightvnc.com上下载TightVNC。 AUTOMATION AND RUN AT BOOT（开机自动运行）# 你可以在树莓派上创建一个简单的文件保存一些命令来运行VNC服务，保存后以便不用再记住这些命令：\n创建一个包含下面shell脚本的文件：\n#!/bin/sh vncserver :0 -geometry 1920x1080 -depth 24 -dpi 96\n保存文件，例如保存为vnc.sh。\n设置文件为可执行文件：\nchmod +x vnc.sh\n之后你就可以在任何时候使用下面命令来执行这个文件：\n./vnc.sh\n设置机器启动的时候自动运行：\n在树莓派的终端上以root用户登录：\nsudo su\n导航到/etc/init.d/目录下：\ncd /etc/init.d/\n创建一个包含以下脚本的文件：\nBEGIN INIT INFO# Provides: vncboot# Required-Start: $remote_fs $syslog# Required-Stop: $remote_fs $syslog# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Start VNC Server at boot time# Description: Start VNC Server at boot time.# END INIT INFO# #! /bin/sh\n/etc/init.d/vncboot# USER=root HOME=/root\nexport USER HOME\ncase \u0026ldquo;$1\u0026rdquo; in start) echo \u0026ldquo;Starting VNC Server\u0026rdquo; #Insert your favoured settings for a VNC session /usr/bin/vncserver :0 -geometry 1280x800 -depth 16 -pixelformat rgb565 ;;\nstop) echo \u0026ldquo;Stopping VNC Server\u0026rdquo; /usr/bin/vncserver -kill :0 ;;\n*) echo \u0026ldquo;Usage: /etc/init.d/vncboot {start|stop}\u0026rdquo; exit 1 ;; esac\nexit 0\n保存这个文件，例如保存为vncboot。\n设置这个文件为可执行文件：\nchmod 755 vncboot\n启用基于开机顺序依赖：\nupdate-rc.d /etc/init.d/vncboot defaults\n如果启用基于开机顺序依赖成功，你将会看到：\nupdate-rc.d: using dependency based boot sequencing\n如果失败，你将会看到：\nupdate-rc.d: error: unable to read /etc/init.d//etc/init.d/vncboot\n这个时候你可以使用以下命令：\nupdate-rc.d vncboot defaults\n重启你的树莓派，你将会发现VNC服务已经运行了。\n现在你可以在你的PC机或者笔记本电脑上使用VNC客户端连接VNC服务并控制树莓派。可以根据你的计算机操作系统查看以下相应指南：\nLinux\nMac OS\nWindows\n原文地址：http://www.raspberrypi.org/documentation/remote-access/vnc/README.md\n","date":"September 18, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%92%8Cvnc/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"vnc","url":"https://www.qinxiandiqi.sbs/tags/vnc/"},{"title":"远程控制","url":"https://www.qinxiandiqi.sbs/tags/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"title":"图形","url":"https://www.qinxiandiqi.sbs/tags/%E5%9B%BE%E5%BD%A2/"}],"title":"树莓派和VNC"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"让你的计算机每次连接树莓派都不需要输入密码是可以实现的，你只需要生成一个SSH key。\n1、CHECK FOR EXISTING SSH KEYS（检查已存在的SSK key）# 首先，检查你的计算机（你用来连接树莓派的设备）是否已经有SSH key：\nls ~/.ssh 如果你看到像 id_rsa.pub 或者 id_dsa.pub 这样的文件，那么你就已经配置好key了。你可以直接跳过生成key这个步骤（或者使用 rm id* 命令删除这些文件，然后重新生成key）。\n2、GENEERATE NEW SSH KEYS（生成新的SSH key）# 生成一个新的SSH Key可以输入以下命令（选用一个类似“ \u0026lt; 你的名字\u0026gt;@\u0026lt;你的设备\u0026gt;”这样可辨识的主机名，这里我们使用eben@pi）：\nssh-keygen -t rsa -C eben@pi 你也可以使用引号来添加更加详细的带有空格描述，例如 ssh-keygen -t rsa -C \u0026ldquo;Raspberry Pi #123\u0026rdquo;。\n输入上面的命令之后，你要被要求输入保存key的位置。我们建议你直接回车使用默认的路径（/home/XXX/.ssh/id_rsa）。\n你也会被要求输入一个密码。这是一种附加的安全保障，确保在没有你的密码情况下无法使用你的key。这样，即使有人复制了你的key，他们也没有办法冒充你进行访问。如果你要使用一个密码，则输入这个密码然后回车，之后根据提示再输入密码确认一次。如果直接回车什么都不输入则表示不使用密码。\n现在你应该就能在你的home目录下的.ssh文件夹中看到id_ras和id_ras.pub这样的文件：\nls ~/.ssh authorized_keys id_rsa id_rsa.pub known_hosts 这里的 id_rsa 文件就是你的私有key，将这个key继续保存在你的计算机上。 id_rsa.pub 文件是你的公共key，你需要把这个可以放到你想要连接的设备上。当你想要连接的设备匹配你的公共key和私有key成功，它就会允许你访问。\n输入以下命令查看你的公共key内容：\ncat ~/.ssh/id_rsa.pub 公共key的格式应该如下：\nssh-rsa \u0026lt;REALLY LONG STRING OF RANDOM CHARACTERS\u0026gt; eben@pi 3、COPY YOUR PUBLIC KEY TO YOUR RASPBERRY PI（将你的公共Key复制到你的树莓派上）# 将你的公共key复制到你的树莓派上，在你的计算机终端上使用下面命令将公共key附加到你的树莓派上的 authorized_keys 文件，发送是通过SSH实现（将其中USERNAME和IP-ADDRESS替换为树莓派上的用户名和树莓派的IP）：\ncat ~/.ssh/id_rsa.pub | ssh \u0026lt;USERNAME\u0026gt;@\u0026lt;IP-ADDRESS\u0026gt; 'cat \u0026gt;\u0026gt; .ssh/authorized_keys' 注意这次你仍然需要验证你的密码。\n现在尝试使用 **ssh @**命令，你应该可以不需要密码直接就能连接上去。\n如果你看见“Agent admitted failure to sign using the key”信息，你需要将你的RSA或者DSA标识添加到认证代理上，执行以下命令使用ssh-agent：\nssh-add 如果这仍然不起作用，使用 rm ~/.ssh/id* 命令删除你的key，然后根据本文档重新配置一遍。\n通过SSH发送文件，你同样可以使用scp命令（安全复制）。参考SCP 指南获取更多信息。\n**\n付：SCP 指南 ——**\nscp是一个通过SSH发送文件的命令。这意味着你可以在两台计算机之间发送文件，也就是说可以在你的树莓派和桌面计算机或者笔记本之间互相发送文件。\n原文地址：\u0026lt;http://www.raspberrypi.org/documentation/remote- access/ssh/passwordless.md\u0026gt;\n","date":"September 11, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E4%BD%BF%E7%94%A8ssh%E6%97%A0%E5%AF%86%E7%A0%81%E9%AA%8C%E8%AF%81%E8%AE%BF%E9%97%AE%E6%A0%91%E8%8E%93%E6%B4%BE/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"SSH远程登录","url":"https://www.qinxiandiqi.sbs/tags/ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"},{"title":"无密码","url":"https://www.qinxiandiqi.sbs/tags/%E6%97%A0%E5%AF%86%E7%A0%81/"},{"title":"rsa","url":"https://www.qinxiandiqi.sbs/tags/rsa/"}],"title":"使用SSH无密码验证访问树莓派"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"你可以在一台Linux或者Mac计算机（或者另一个树莓派）的终端上使用SSH连接你的树莓派，并且不需要其它软件。\n你需要知道你的树莓派IP地址以便连接上它。查询IP，可以在树莓派的终端上输入命令“hostname -I”。另外，如果你运行的树莓派没有显示器，你可以查看你的路由器上的设备列表或者使用像nmap这样的工具。\n在计算机的终端上复制黏贴以下命令，但是要把其中的替换你的树莓派IP。终端上要使用Ctrl + Shift + V进行黏贴。\nssh pi@\u0026lt;IP\u0026gt; 如果你接收到一个connection timed out（连接超时）的错误，很有可能是你输错了你的树莓派IP。\n如果连接成功，你将会看到一个安全验证的警告。输入yes继续，你只会在第一次连接的时候看到这个警告。\n有时候你的树莓派可能会占用了你的计算机以前曾经连接过（也有可能是在其它网络中连接过）的IP地址，你将会得到一个警告并要求清空你的已知设备列表。根据指示操作，然后再次使用ssh命令连接应该就能成功连接上。\n下一步，你将会被提示输入pi用户的密码进行登录，Raspbian默认的密码时raspberry。现在，你应该能够看到树莓派的提示符，它代表了在树莓派上找到的一个用户。\n如果你在树莓派上添加了其他用户，你也可以使用同样的方式连接，只需要将用户名替换，例如eben@192.168.1.5.\npi@raspberrypi ~ $ 现在你已经远程登录了树莓派，可以直接在上面执行命令。\n获取更多ssh命令的文档只需要在终端上输入man ssh。\n配置你的树莓派允许通过公共/私有键值对进行无密码SSH访问，可以参考passwordless SSH指南。\n原文地址：http://www.raspberrypi.org/documentation/remote-access/ssh/unix.md\n","date":"September 10, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/linux%E6%88%96%E8%80%85mac%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8ssh%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"ssh","url":"https://www.qinxiandiqi.sbs/tags/ssh/"},{"title":"linux","url":"https://www.qinxiandiqi.sbs/tags/linux/"},{"title":"mac","url":"https://www.qinxiandiqi.sbs/tags/mac/"}],"title":"Linux或者Mac系统使用SSH连接树莓派"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"播放视频，先在命令行终端上使用“cd”命令将路径切换到你的视频文件所在目录，然后输入以下命令：\nomxplayer example.mp4 这将会全屏播放example.mp4文件，按Ctrl + C可以退出。\nEXAMPLE VIDEO SAMPLE：BIG BUCK BUNNY（示例视频：大雄兔）\n这里有一个可在树莓派上播放的实例视频：动画片《大雄兔》。播放这部影片，可以在终端上输入以下命令：\nomxplayer /opt/vc/src/hello_pi/hello_video/test.h264 原文地址：http://www.raspberrypi.org/documentation/usage/video/README.md\n","date":"September 9, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"视频","url":"https://www.qinxiandiqi.sbs/tags/%E8%A7%86%E9%A2%91/"}],"title":"在树莓派上播放视频"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"播放一个MP3文件，在命令行终端上用“cd”命令导航到.mp3文件所在的路径，然后输入以下命令：\nomxplayer example.mp3 这将会通过你的显示器内置音箱或者你的耳机接口连接设备播放example.mp3音频文件。\n如果你需要一个示例音频文件，你可以输入以下命令来获取：\nwget http://goo.gl/MOXGX3 -O example.mp3 --no-check-certificate 如果你没有听到任何声音，请确认你的耳机或者音箱已经正确连接上。注意omxplayer不使用ALSA（高级Linux声音体系），因此可以忽略audio Configuration中通过raspi- config或者amixer的设置。\n如果omxplayer自动识别当前音频输出设备错误，你可以使用以下命令强制使用HDMI输出：\nomxplayer -o hdmi example.mp3 或者你也可以强制使用耳机接口输出：\nomxplayer -o local example.mp3 原文地址：http://www.raspberrypi.org/documentation/usage/audio/README.md\n","date":"September 9, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"音频","url":"https://www.qinxiandiqi.sbs/tags/%E9%9F%B3%E9%A2%91/"},{"title":"mp3","url":"https://www.qinxiandiqi.sbs/tags/mp3/"}],"title":"在树莓派上播放音频"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"raspi-config是由Alex Bradbury设计并维护的树莓派配置工具，适用于Raspbian系统。\n1、USAGE（使用）# 当你第一次启动Raspbian的时候会有rasp-config的提示。打开这个配置工具，只需要在终端上简单输入以下命令：\nsudo raspi-config 要求sudo管理员权限是因为你要修改的文件不属于pi用户所有。\n你将会看到一个蓝色的屏幕，中间有带选项的灰色框，类似下面：\n2、MOVING AROUND THE MENU（在菜单中移动）# 使用上下光标控制键来移动可选选项中的高光显示。按右光标控制键跳出选项菜单转移到底部的和按钮。按左光标控制键返回选项菜单。另外，使用tab键可以在这里面互相切换。\n注意在一些有很多选项的菜单中（例如时区城市的选择菜单），你可以直接输入对应选项的相关内容来跳转到菜单中对应的选项。例如，输入“L”将会跳转到Lisbon，发现距离London只有2个选项，这样就避免了滚动所有的选项来查找的麻烦。\n3、WHAT PASPI-CONFIG DOES（raspi-config可以做什么）# 总的来说，raspi- config的目标是提供便捷的方法来修改大多数常用的配置。它会自动去修改对应的/boot/config.txt和其它标准的Linux配置文件。有一些选项会要求重启系统来使设置生效。如果你修改了这些选项，raspi- config会询问你是否在按下按钮之后重启系统。\n4、MENU OPTION（菜单选项）# 4.1 EXPAND FILESYSTEM（扩展文件系统）# 如果你使用NOOBS的方式安装Raspbian系统，那么你可以忽略这部分，因为NOOBS在安装系统的时候已经自动扩展了文件系统。然而，如果你是自己将系统映像文件写入到SD上，那么SD卡上的一部分空间将没有被使用。这个选项可以另外挂载3GB以上的容量。选择这个选项可以将SD卡剩余的空间全部挂载上来，为你的文件提供更大的空间。你需要重启树莓派来让这个设置生效。注意这个选项没有确认过程，选择之后会直接开始扩展空间。\n4.2 CHANGE USER PASSWORD（修改用户密码）# 树莓派默认的用户是pi，密码是raspberry。你可以在这里修改pi的密码。其它用户管理可以参考这里。\n4.3 ENABLE BOOT TO DESKTOP OR SCRATCH（设置启动进入桌面或者Scratch）# 你可以修改你的树莓派启动时的操作。使用这个选项可以修改你的启动首选项是进入命令行终端，还是桌面环境，或者直接进入Scratch编程环境。\n4.4 INTERNATIONALISATION OPTION（国际化选项）# 选择Internationalisation Options，然后点击回车将会进入以下子菜单：\n4.4.1 CHANGE LOCALE（修改本地属性）# 选择一个本地属性，例如en_GB.UTF-8 UTF-8\n4.4.2 CHANGE TIMEZONE（修改时区）# 选择你自己的时区，先选择地域例如Europe（欧洲）；然后选择城市例如London。可以直接输入目标字符跳转到对应的选项上。\n4.4.3 CHANGE KEYBOARD LAYOUT（修改键盘类型）# 这个选项将会打开另一个允许你选择的键盘类型的菜单。它将会花费比较长的时间读取所有的键盘类型。修改通常会立即生效，但也可能会要求重启。\n4.5 ENABLE CAMERA（启用摄像头）# 为了使用树莓派的摄像头模块，你必须在这里启用它。选择这个选项，然后选择Enable。这将会确保至少有128M内存分配给GPU。\n4.6 ADD TO RASTRACK（添加Rastrack）# Rastrack是由社区中的树莓派用户提供自己的地理位置形成的Google Map，它展示了一张全世界树莓派爱好者的分布图。这是在2012年由年轻的树莓派爱好者Ryan Walmsley创建的。可以在rastrack.co.uk访问Rastrack。\n你可以使用这个选项将你的地理位置添加到这张地图中。\n4.7 OVERCLOCK（超频）# 将你的树莓派CPU超频是可以的。默认的主频是700MHz，但是它可以超频到1000MHz。你能够达到的主频是不确定的，主频太高可能会导致不稳定问题。选择这个选项将会提示以下警告：\n你应该明白超频可能会导致你的树莓派寿命缩短。如果你超频到一定频率导致系统不稳定，应该尝试降低主频。在系统启动的时候按住“shift”可以暂时禁用超频。\n4.8 ADVANCED OPTIONS（高级选项）# 4.8.1 OVERSACN# 旧电视机的画幕有很很多种不同的尺寸，有一些的机柜还覆盖到屏幕上。电视机的画幕因此使用了黑色边框来保证画面没有丢失，这就是overscan。现代的电视机和显示器不需要这个边框，而且信号也没有支持。如果初始的文字显示超出了屏幕的显示范围，你就需要启用overscan将黑色边框带回来。\n所有的设置将会在重启系统之后开始作用。你也可以直接编辑[config.txt](http://www.raspberrypi.org/documentation/configuration/config- txt.md)来进行更详细的设置。\n在一些显示情况下，特别是显示器，禁用overscan会让画幕填充整个屏幕并校正。还有其它的情况可能需要启用overscan并判断它的值。\n4.8.2 HOSTNAME（主机名）# 设置网络中树莓派的主机名。\n4.8.3 MEMORY SPLIT（分割内存）# 修改分配给GPU的内存。\n4.8.4 SSH# 启用或者禁用使用SSH远程终端登录你的树莓派。\nSSH允许你在另外一台计算机上使用命令行终端远程登录你的树莓派。禁用将会导致SSH服务不会在开机的时候启动以释放程序的资源。更多关于SSH的内容参考[这里](http://www.raspberrypi.org/documentation/remote- access/ssh/README.md)。注意SSH默认是启用的。如果你的树莓派直接连接到公共网络，你应该禁用SSH，除非你确认已经为树莓派上每一个用户设置了密码。\n4.8.5 SPI（串行外设接口）# 启用或者禁用自动加载SPI内核模块，需要其它的外设产品例如PiFace。\n4.8.6 AUDIO（音频）# 强制音频通过HDMI或者3.5毫米接口输出。更多信息请参考audio configuration。\n4.8.7 UPDATE（更新）# 将这个工具升级到最新版本。\n4.9 ABOUT RASPI-CONFIG（关于raspi-config）# 选择这个选项将会显示以下信息：\n这个工具提供更加直接的途径来设置树莓派的初始配置。尽管这个工具可以在任何时候运行，但是如果你已经深度定制了你的设备，其中一些选项可能没有作用。\n4.10、 FINISH（完成）# 当你完成了你的修改后点击这个按钮，你将会被询问是否要重启设备。如果是第一次使用最好是重启设备。如果你选择了扩展你的SD卡，在启动过程中可能会有点延迟。\n5、 DEVELOPMENT OF THIS TOOL（本工具的开发）# 本工具的源代码托管在https://github.com/asb/raspi-config，你可以在这里查看问题和推送请求。\n原文地址：http://www.raspberrypi.org/documentation/configuration/raspi-config.md\n","date":"September 8, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BEraspi-config%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"raspi-config工具","url":"https://www.qinxiandiqi.sbs/tags/raspi-config%E5%B7%A5%E5%85%B7/"}],"title":"树莓派raspi-Config配置工具"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n原文作者：Raspberry Pi Foundation\n原文地址：\u0026lt;http://www.raspberrypi.org/documentation/configuration/audio- config.md\u0026gt;\n原文版权：CC BY-SA\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：基于原文2014-09-08版本进行翻译\n译文版权：[CC BY-SA](http://creativecommons.org/licenses/by- sa/4.0/)，允许复制转载和演绎，但必须保留译者署名和译文链接，并遵守相同共享协议\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n树莓派有两种音频输出模式：HDMI和耳机接口。你可以在任何时候切换这两种模式。\n如果你的HDMI显示器有内置的音箱，音频是可以通过HDMI接口播放的。你也可以切换到耳机接口，使用耳机或者其它耳机接口的音箱播放。如果你的显示器请求音箱支持，声音默认通过HDMI输出；如果没有，那将通过耳机接口输出。这可能不是你所期望的设置，也有可能自动检测的结果不准确，这种情况你可以手动选择输出。\n1、CHANGE THE AUDIO OUTPUT（修改音频输出）# 这里有两种方法设置音频输出：\n1.1 COMMAND LINE（命令行）# 在命令行终端上输入下面命令将会切换到HDMI输出模式：\namixer cset numid=3 2 这里将输出设置为2，也就是HDMI。\n将输出设置为1将切换到模拟信号（也就是耳机接口）。\n默认的设置为0，代表自动选择。\n1.2 RASPI-CONFIG（raspi-config设置工具）# 在命令行中输入以下命令打开raspi-config工具：\nsudo raspi-config 输入命令后会打开以下界面：\n选择第八项Advanced Options并回车，然后选择第六项Audio再回车：\n现在你可以看到默认选择Auto选项以及另外两种模式的列表。选择其中一种模式然后回车，再按向右光标控制键跳出选项菜单，选择Finish退出配置工具。\n2、 IF YOU\u0026rsquo;RE STILL NOT GETTING SOUND VIA HDMI（如果你还是没有从HDMI接口听到声音）# 在一些少见的情况下，你需要编辑config.txt文件来强制进入HDMI模式（为了排除没有附带声音的DVI模式）。实现这个目的，你可以编辑/boot/config.txt文件设置hdmi_drive=2，然后重启系统让修改生效。\n","date":"September 8, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%9F%B3%E9%A2%91%E9%85%8D%E7%BD%AE/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"audio","url":"https://www.qinxiandiqi.sbs/tags/audio/"},{"title":"音频","url":"https://www.qinxiandiqi.sbs/tags/%E9%9F%B3%E9%A2%91/"}],"title":"树莓派音频配置"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n原文作者：Raspberry Pi Foundation\n原文地址：http://www.raspberrypi.org/documentation/linux/usage/users.md\n原文版权：CC BY-SA\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：基于原文2014-09-08版本进行翻译\n译文版权：[CC BY-SA](http://creativecommons.org/licenses/by- sa/4.0/)，允许复制转载和演绎，但必须保留译者署名和译文链接，并遵守相同共享协议\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n树莓派的用户管理需要在命令行终端上处理。默认的用户名是pi，密码为raspberry。你可以添加用户并修改每一个用户的密码。\n1、CHANGE YOUR PASSWORD（修改你的密码）# 当你使用pi用户登录之后，你可以使用passwd命令修改你的密码。\n如果你使用的用户拥有sudo权限，你可以通过其他用户的用户名和passwd命令修改他们的密码。例如，sudo passwd bob将允许你设置bob用户的密码，以及用户的其他可选值（例如姓名）。可以简单按回车跳过这些选项。\n在命令行中输入passwd，然后按回车。命令行终端会提示你输入当前的密码进行验证，验证通过后会要求你输入新的密码。输完按回车完成，你会被要求重新输入一遍新密码进行确认。注意当你输入密码的时候，命令行上不会显示任何字符。一旦你完成确认并且没有错误，命令行会打印成功信息（passwd: password updated successfully），新的密码也会立即生效。\n2、REMOVE A USE\u0026rsquo;S PASSWORD（删除用户密码）# 你可以通过sudo passwd bob -d命令删除用户bob的密码。\n3、CREATE A NEW USER（创建一个新用户）# 你可以使用adduser命令在你的树莓派设备上创建其他用户。\n输入sudo adduser bob，将会提示你输入新用户bob的密码，也可以直接回车留空白表示不设置密码。\n3.1 HOME FOLDER（Home文件夹）# 当你创建一个新的用户，新的用户将会在/home/目录下创建自己的home文件夹。pi用户的home文件夹位于/home/pi/。\n3.2 SKEL# 上面创建了一个新的用户，/etc/skel/目录下的文件也会复制一份到用户的home文件夹下。你可以根据你自己的喜好添加或者修改类似/etc/skel/中.bashrc这样以“.”开头的文件，这些修改后的版本将会被应用到新创建的用户上。\n4、SUDOERS（sudo用户）# 树莓派上默认的pi用户是一个sudoer（sudo用户）。这种类型的用户在命令行上输入命令之前先输入sudo就能拥有root权限执行命令，也能够通过sudo su完全切换到root用户。\n添加一个用户到sudoer用户组，需要使用一个sudo用户输入sudo visudo命令打开配置文件，找到文件中“# User privilege specification”下面的“root ALL=(ALL:ALL) ALL”。复制这一行并将其中的root替换为对应的用户名。为了免验证密码使用root权限，修改为NOPASSWD:ALL。下面的例子给予了bob用户免密码访问sudo权限：\n# User privilege specification root ALL=(ALL:ALL) ALL bob ALL = NOPASSWD: ALL 保存并退出以完成修改。千万小心，因为这些操作可能会意外移除你自己的sudo权限。\n注意你可以通过以下命令修改visudo命令使用的编辑器（默认的编辑器是Nano）：\nupdate-alternatives --set editor /usr/bin/vim.tiny 上面的命令将编辑器修改为Vim。\n5、DELETE A USER（删除用户）# 你可以使用userdel命令将你系统上的一个用户删除掉。附加-r标签可以同时删除它们的home文件夹：\nsudo userdel -r bob ","date":"September 8, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"用户管理","url":"https://www.qinxiandiqi.sbs/tags/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"title":"user","url":"https://www.qinxiandiqi.sbs/tags/user/"}],"title":"树莓派用户管理"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"上两篇介绍了树莓派系统的安装，用网线接入路由器，以及树莓派的vnc配置。\n使用网线将树莓派接入路由器的方法虽然简单，但是会让树莓派的移动性大大降低。我的路由器是wifi路由器，我希望在我的路由器信号范围内可以把树莓派放到任意到一个地方，插上电源就可以远程访问，不被网线限制。因此，需要给树莓派添加wifi模块。\n给树莓派添加wifi模块，实际上就是一个usb无线网卡。我使用的是EOUP的usb无线网卡，经测试树莓派可以直接识别，不需要额外配置驱动。\n树莓派添加usb网卡之后，使用vnc登录树莓派。可以看到RaspBian系统已经提供wifi管理软件：\n打开这个软件，切换到中间Manager Network标签后，点击Scan按钮搜索网络：\n这时会弹出新的窗口，点击Scan开始搜索网络：\n这时可以看到无线网卡扫描到的wifi，双击选择你需要连接的wifi，弹出新的窗口：\n在上面PSK中输入wifi的密码，然后点击Add按钮添加。回到主窗口可以看到列表中已经多了我们刚刚添加的wifi连接点，切换到Current Statu当前状态标签页，点击connect按钮连接wifi：\n这时可以在File菜单中选择Save Configuration保存配置。\n至此，已经可以摆脱网线的限制，以后只要树莓派一启动就会自动搜索到这个wifi然后连接上去（注意：你需要重新查看你的路由器分配给树莓派无线网卡的ip是多少，你也可以让你的路由器分配一个固定的ip给树莓派，以后就不用经常查看树莓派的ip是多少）。\n那么回到putty的SSH终端，来看一下上面的操作改变了什么。\n树莓派系统自带的编辑器是nano，个人比较习惯使用vim，所以先用以下命令安装vim编辑器：\nsudo apt-get intall vim 安装完成之后，输入以下命令查看树莓派的网络设置文件：\nsudo vim /etc/network/interfaces 在我的树莓派上文件内容如下：\n可以看到中间两行代码是有线网卡的设置，最后一段是wifi的设置。而其中wifi的连接信息又保存在/etc/wpa_supplicant/wpa_supplicant.conf文件中。\n输“:p”让vim退出当前文件，回到终端，输入以下命令查看wpa_supplicant.conf文件：\nsudo vim /etc/wpa_supplicant/wpa_supplicant.conf 我文件内容如下：\n可以看到其实就是刚才在vnc中使用wifi管理软件添加的wifi信息。\n也就是说，实际上我们是可以不通过可视化桌面wifi管理软件添加wifi节点，我们完全可以直接编辑这两个文件来配置wifi连接。\n","date":"September 7, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BEwifi%E8%87%AA%E5%8A%A8%E8%81%94%E7%BD%91/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"wifi","url":"https://www.qinxiandiqi.sbs/tags/wifi/"},{"title":"network","url":"https://www.qinxiandiqi.sbs/tags/network/"},{"title":"自动连接","url":"https://www.qinxiandiqi.sbs/tags/%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5/"}],"title":"树莓派wifi自动联网"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"在没有显示器的情况下，可以使用putty远程终端登录树莓派。然而，所有的操作都要通过输入命令来执行，这对于习惯了桌面可视化操作的我们来说一时可能难以适应。\n一种解决的方法是使用vnc远程桌面。\n首先要在树莓派上安装VNC服务。\n打开putty登录上树莓派，输入以下命令：\nsudo apt-get install tightvncserver 确保你的树莓派能够连接上互联网，树莓派会自动联网下载相应的包，中途会询问你是否确认安装，输入y后回车，根据你的网络情况会花费一定的时间安装vnc服务：\n安装完vnc Server之后，输入以下命令配置vcn服务：\ntightvncserver 中间会让你输入vnc服务的访问密码（输入一次，确认一次，共两次），这个密码用于远程vnc终端连接时输入。另外还可以输入一个可选的只读密码，我这里选择不设置。\nvnc服务配置好之后，输入以下命令启动一个vnc服务：\nvncserver :1 -geometry 1920x1080 -depth 24 上面命令启动了一个端口号为1，分辨率为1920x1080，色彩位深为24位的vnc服务。实际上后面的-geometry和- depth选项是可选的。我直接输入了vncservier:1命令启动一个端口号为1的vnc服务：\n到这里，vnc服务已经安装完毕并启动成功。下一步是远程vnc客户端连接。这里需要一个vnc- viewer软件，我使用的是Window平台，这个软件可以在这里下载。\n下载后打开vnc-viewer，输入树莓派的ip地址和刚才设置的端口号1,。比如我的树莓派分配到的地址是192.168.0.106：\n输入后点击connect按钮连接树莓派vnc服务，由于没有配置通道加密，所以会有未加密通道连接警告：\n可以勾选不要再提示然后点击Continue继续，输入我们配置树莓派vnc的访问密码：\n点击OK，如果密码没错的话，将出现树莓派的桌面：\n至此，vnc远程登录树莓派目标完成。\n","date":"September 7, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BEvnc%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"vnc","url":"https://www.qinxiandiqi.sbs/tags/vnc/"},{"title":"远程登录","url":"https://www.qinxiandiqi.sbs/tags/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"},{"title":"桌面","url":"https://www.qinxiandiqi.sbs/tags/%E6%A1%8C%E9%9D%A2/"}],"title":"树莓派vnc远程桌面"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/categories/raspberry/"}],"content":"树莓派是一种微型计算机，只有卡片般大小，而且便宜。非常适合用于学习Linux操作系统，或者搭建家庭微型服务器媒体中心等。\n关于树莓派的详细介绍我就不再多说了，想要了解更多树莓派的内容可以自行google或者直接访问树莓派的官方网站http://www.raspberrypi.org/。\n这里主要讨论下如何在没有显示器的情况下安装树莓派操作系统并登录上去。\n实际上由于成本关系，我们购买的树莓派产品通常只有一块主板。当然，主板上有cpu，内存等主要部件。虽然树莓派提供了HDMI接口用于外接显示器，但不是每个人手头都刚好有一块支持HDMI的显示器，而且由于电压关系也不是一定能够带动HDMI显示器。我的树莓派很悲剧的就带不动显示器，怀疑是电压不够带不动我的显示器。所以，只能想办法在没有显示器的情况下安装系统和登录系统了。\n整体的方案就是树莓派安装系统之后，用网线将树莓派连接到路由器上，再通过局域网SSH远程登录树莓派。\n硬件准备工作：\n1、树莓派一块（这里用的是B型树莓派，相对于A型，B型树莓派性能更加强大，提供的接口更多）。\n2、电源和数据线格一个（现在手机使用的电源和数据线就可以，用于给树莓派供电，电源额定电流能够有2A更好一点）\n3、网线一条，路由器一台。\n4、计算机一台（这里用的是Window平台计算机）。\n5、SD卡一张，或者一张TF卡+TF卡转换器。\n首先要为树莓派安装系统。\n树莓派没有硬盘，但是留下了SD卡接口。对于树莓派来说，SD卡就是硬盘。当然你也可以使用TF卡+TF转换器，本人使用的就是TF卡，相对SD卡更便宜一点。\n安装系统实际上就是将系统映像烧录到SD卡中。树莓派官网提供了多种类型的系统，本人使用的是RaspBian系统，这是树莓派官方根据DeBian系统修改的。你可以根据自己的需要直接从官方下载对应的系统映像，你也可以直接在百度网盘下载我使用的版本。\n下载后你会得到一个zip压缩包，解压后就是我们需要的img系统映像文件。接下来我们还需要一个映像烧录工具，官方推荐Win32DiskImage这个烧录工具，你可以在这里下载到。\n系统映像和烧录工具都下载完成后就可以开始进行烧录。先将你的SD卡或者TF卡连接电脑，然后打开Win32DiskImage烧录工具，注意最好以管理员身份运行这个工具。运行后你将会看到这个软件界面：\n左边选择我们下载的树莓派系统映像文件，右边Device选择你的SD卡盘符，这里我的SD卡盘符是F（千万注意！一定要确认是SD卡，否则烧录到其他分区覆盖了你宝贵的数据，后果不堪设想）。确认无误之后，就可以点击Write按钮进行烧录。\n烧录完成之后取下SD卡，安装到树莓派上。将树莓派用网线连接上你的路由器，然后接通电源。RaspBian系统默认在启动的同时会启动SSH服务，我们就是要利用SSH远程登录上树莓派。\n这个时候，你可以先登录你的路由器，查看路由器当前的客户端列表，目的就是要查看路由器当前分配给树莓派的ip地址，例如在我的路由器中分配了192.168.0.106这个ip给了树莓派：\n记下你的路由器分配给树莓派的ip地址，接下来我们还要在同个局域网内的一台Window机上安装putty这个SSH协议远程客户端软件，你可以在这里下载到这个软件。安装putty之后，打开putty这个软件，在Host Name中填写你的路由器分配给树莓派的ip，以下是我的分配到ip：\n完成后点击open就会远程连接树莓派。首次连接的时候会提醒是否信任树莓派SSH的指纹：\n点击确认，出现终端：\n树莓派默认的用户名为pi，密码raspberry，输入进行登录：\n如果看到这个界面，说明你已经成功登录树莓派，系统已经安装成功。\n接下来，你可以根据你的需要为树莓派安装你需要的软件，例如vnc远程桌面等等。\n","date":"September 7, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/raspberry/%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8%E5%AE%89%E8%A3%85%E6%A0%91%E8%8E%93%E6%B4%BE%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","series":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/series/raspberry/"}],"smallImg":"","tags":[{"title":"RaspBerry","url":"https://www.qinxiandiqi.sbs/tags/raspberry/"},{"title":"树莓派","url":"https://www.qinxiandiqi.sbs/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"title":"安装系统","url":"https://www.qinxiandiqi.sbs/tags/%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F/"},{"title":"无显示器","url":"https://www.qinxiandiqi.sbs/tags/%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8/"},{"title":"SSH远程登录","url":"https://www.qinxiandiqi.sbs/tags/ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"}],"title":"无显示器安装树莓派操作系统"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Gson","url":"https://www.qinxiandiqi.sbs/categories/gson/"}],"content":"作者：Inderjeet Singh, Joel Leitch, Jesse Wilson\n1、Overview（概览）# Gson是一个Java类库，用于将Java对象转换为它们所代表的JSON数据，也可以用于将一个JSON字符串转换为对应的Java对象。Gson是一个开源项目，托管于\u0026lt;http://code.google.com/p/google- gson\u0026gt;。\nGson可以用于任意的Java对象，包括已经存在但你没有对应源代码的对象。\n2、Goals for Gson（Gson的目标）# * 提供像toString()和构造方法（工厂方法）一样简单使用的机制来将Java对象转换为JSON或者反过来将JSON转换为Java对象。 * 允许将已经存在并且不可修改的对象转换JSON，或者反过来。 * 允许为对象自定义映射关系。 * 支持任意复杂的对象。 * 生成紧凑又易读的JSON输出。 3、Gson Performance and Scalability（Gson的性能和可扩展性）# 以下是我们在一个台式机（皓龙双核，8GB内存，64位Ubuntu系统）下进行大量测试得出的指标。你可以使用[PerformanceTest](http://code.google.com/p/google- gson/source/browse/trunk/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java) 类进行重新测试。\n* String字符串：反序列化一个超过25MB的字符串没有任何问题（参考PerformanceTest类中的disabled_testStringDeserializationPerformance方法）。 * 大型集合对象： ** 序列化一个包含一百四十万个对象的集合（参考PerformanceTest中的disabled_testLargeCollectionSerialization方法） ** 反序列化一个包含八万七千个对象的集合（参考PerformanceTest中的disabled_testLargeCollectionDeserialization方法） * Gson 1.4将字节数组和集合的限制从80KB提升到11MB。 注意：删除disabled_前缀后再运行测试。我们添加这个前缀是为了防止每一次运行JUnit测试都要将这些测试重新运行一遍。\n4、Gson Users（Gson用户）# Gson原本是为Google内部大量项目创建使用的，但是现在已经有大量公司和公共项目都在实现，详细可查看[这里](https://sites.google.com/site/gson/gson- users)。\n5、Using Gson（Gson的使用）# Gson主要的类即为Gson类，你可以简单的使用new Gson()创建一个Gson对象。另外也可以使用GsonBuilder这个类，它允许使用参数（例如版本控制等等）来才创建一个Gson实例。\nGson实例并不会保存Json操作的状态。因此，你可以重用同一个Gson对象进行多次Json序列化和反序列化操作。\n5.1 Primitives Examples（基本示例）# （序列化）\nGson gson = new Gson(); gson.toJson(1); ==\u0026gt; 结果为 1 gson.toJson(\u0026quot;abcd\u0026quot;); ==\u0026gt; 结果为 \u0026quot;abcd\u0026quot; gson.toJson(new Long(10)); ==\u0026gt; 结果为 10 int[] values = { 1 }; gson.toJson(values); ==\u0026gt; 结果为 [1] （反序列化）\nint one = gson.fromJson(\u0026quot;1\u0026quot;, int.class); Integer one = gson.fromJson(\u0026quot;1\u0026quot;, Integer.class); Long one = gson.fromJson(\u0026quot;1\u0026quot;, Long.class); Boolean false = gson.fromJson(\u0026quot;false\u0026quot;, Boolean.class); String str = gson.fromJson(\u0026quot;\\\u0026quot;abc\\\u0026quot;\u0026quot;, String.class); String anotherStr = gson.fromJson(\u0026quot;[\\\u0026quot;abc\\\u0026quot;]\u0026quot;, String.class); 5.2 Object Examples（对象示例）# class BagOfPrimitives { private int value1 = 1; private String value2 = \u0026quot;abc\u0026quot;; private transient int value3 = 3; BagOfPrimitives() { // no-args constructor } } （序列化）\nBagOfPrimitives obj = new BagOfPrimitives(); Gson gson = new Gson(); String json = gson.toJson(obj); ==\u0026gt;结果为{\u0026quot;value1\u0026quot;:1,\u0026quot;value2\u0026quot;:\u0026quot;abc\u0026quot;} 注意，你不能序列化一个内部包含循环引用（比如包含自身引用）的对象，那会导致无限递归。\n（反序列化）\nBagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class); ==\u0026gt; obj2对象与obj对象一样 5.2.1 Finer Points with Objects（关于对象的一些细节）# * 完美支持对象的私有成员变量。 * 不需要任何注解来声明一个成员变量是否需要进行序列化和反序列化。类中所有的成员变量（包括父类的成员）默认都要进行序列化和反序列化。 * 如果一个成员变量使用了transient关键字标识，默认情况下它将被忽略，将不会进行JSON的序列化和反序列化。 * 对于null值的正确处理： ** 进行序列化的时候，一个值为null的成员在输出中将被忽略。 ** 进行反序列化的时候，对应JSON数据中丢失的成员变量将会使用null。 * 使用synthetic关键字标识的成员将被忽略，不进行JSON的序列化和反序列化。 * 对应外部类，内部类、匿名类和局部类中的成员将被忽略，不进行序列化和反序列化。 5.3 Nested Classes（including Inner Classes）—— 嵌套类（包括内部类）# Gson可以很容易的序列化静态嵌套类。\nGson也可以反序列化静态嵌套类。但是，Gson没办法自动序列化一个纯内部类。因为即使内部类的构造方法不需要参数，但实际上也需要一个外部类对象的引用。这个外部类对象在反序列化的时候已经是不可访问的了。你可以通过将内部类标识为静态类或者提供自定义的InstanceCreator来解决这个问题。以下是例子：\npublic class A { public String a; class B { public String b; public B() { // No args constructor for B } } } 注意：上面的类B默认情况下不能使用Gson序列化。\nGson没办法将{\u0026ldquo;b\u0026rdquo;:\u0026ldquo;abc\u0026rdquo;}反序列化为B类的实例，因为B是一个内部类。如果使用static class B将B类标识为静态内部类，那么Gson就能够将这个字符串反序列化为B类的实例。另一种解决方法是为B类写一个自定义的InstanceCreator：\npublic class InstanceCreatorForB implements InstanceCreator\u0026lt;A.B\u0026gt; { private final A a; public InstanceCreatorForB(A a) { this.a = a; } public A.B createInstance(Type type) { return a.new B(); } } 上面的方法可以解决这个问题，但是不推荐。\n5.4 Array Examples（数组示例）# Gson gson = new Gson(); int[] ints = {1, 2, 3, 4, 5}; String[] strings = {\u0026quot;abc\u0026quot;, \u0026quot;def\u0026quot;, \u0026quot;ghi\u0026quot;}; (序列化)\ngson.toJson(ints); ==\u0026gt; 结果为 [1,2,3,4,5] gson.toJson(strings); ==\u0026gt; 结果为 [\u0026quot;abc\u0026quot;, \u0026quot;def\u0026quot;, \u0026quot;ghi\u0026quot;] (反序列化)\nint[] ints2 = gson.fromJson(\u0026quot;[1,2,3,4,5]\u0026quot;, int[].class); ==\u0026gt; ints2数组与ints数组一样 我们同样支持任意复杂类型的多维数组。\n5.5 Collections Examples（集合示例）# Gson gson = new Gson(); Collection\u0026lt;Integer\u0026gt; ints = Lists.immutableList(1,2,3,4,5); (序列化)\nString json = gson.toJson(ints); ==\u0026gt; json is [1,2,3,4,5] (反序列化)\nType collectionType = new TypeToken\u0026lt;Collection\u0026lt;Integer\u0026gt;\u0026gt;(){}.getType(); Collection\u0026lt;Integer\u0026gt; ints2 = gson.fromJson(json, collectionType); ==\u0026gt; ints2集合与ints集合一样 相当可怕的：注意我们是如何定义集合的类型的，很不幸单纯在Java中没有办法解决这个问题。\n5.5.1 Collections Limitations（集合的局限性）# * 能够序列化任意对象类型的集合，但是没办法反序列化，因为没有办法让我们指定结果对象的类型。 * 反序列化的时候，集合必须是一个具体的泛型。 然而只要遵循良好的Java编程习惯，所有的这些都是意义的，很少会成为一个问题。\n5.6 Serializing and Deserializing Generic Types（序列化和反序列化泛型）# 当你调用toJson(obj)方法的时候，Gson会调用obj.getClass()方法来获取类中成员变量的信息来进行序列化。同样的，你可以直接传递MyClass.class对象到formJson(json, MyClass.class)方法，这种做法非常适合对象不是泛型的情况。然而，如果对象是一个泛型，由于Java类型的擦除关系，泛型的信息将会丢失。下面的例子可以很好的说明这个问题：\nclass Foo\u0026lt;T\u0026gt; { T value; } Gson gson = new Gson(); Foo\u0026lt;Bar\u0026gt; foo = new Foo\u0026lt;Bar\u0026gt;(); gson.toJson(foo); // 没办法正确序列化foo.value gson.fromJson(json, foo.getClass()); // 将foo.value反序列化为Bar对象失败 上面的代码将结果解析为Bar对象失败，是因为Gson调用foo.getClass()方法来获取它的类信息，但是这个方法返回的是一个原始类，也就是Foo.class。这意味着Gson没有办法知道那是一个Foo类型的对象，因此失败。\n为了解决这个问题，你可以为你的泛型指定一个当前的参数类型。你可以使用TypeToken类来实现：\nType fooType = new TypeToken\u0026lt;Foo\u0026lt;Bar\u0026gt;\u0026gt;() {}.getType(); gson.toJson(foo, fooType); gson.fromJson(json, fooType); 上面的fooType实际是定义了一个局部匿名内部类，这个类里面包含了一个getType()方法可以返回完整的参数类型。\n5.7 Serializing and Deserializing Collection with Objects of Arbitrary# Types（序列化和反序列化任意对象类型的集合）\n有时候你需要处理一些包含混合数据类的JSON数组，例如：\n['hello',5,{name:'GREETINGS',source:'guest'}] 其中相对的集合如下：\nCollection collection = new ArrayList(); collection.add(\u0026quot;hello\u0026quot;); collection.add(5); collection.add(new Event(\u0026quot;GREETINGS\u0026quot;, \u0026quot;guest\u0026quot;)); 里面对应的Event类如下：\nclass Event { private String name; private String source; private Event(String name, String source) { this.name = name; this.source = source; } } 你可以使用Gson序列化这个集合而不需要指定任何东西：toJson(collection)将会得到以上输出。\n然而，使用fromJson(json, Collection.class)进行反序列化将会失败，因为Gson没办法知道如何映射其中的类型。Gson要求你在fromJson中提供一个集合的泛型版本。因此，你有三种选择：\n第一种选择：使用Gson的解析API（底层的数据流解析器或者DOM解析器JsonParser）来解析出数组元素，然后为每一个数组元素调用Gson.fromJson()方法。这是一种比较好的实现方法，具体做法可以参考以下例子：\n/* * Copyright (C) 2011 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \u0026quot;License\u0026quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \u0026quot;AS IS\u0026quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.gson.extras.examples.rawcollections; import java.util.ArrayList; import java.util.Collection; import com.google.gson.Gson; import com.google.gson.JsonArray; import com.google.gson.JsonParser; public class RawCollectionsExample { static class Event { private String name; private String source; private Event(String name, String source) { this.name = name; this.source = source; } @Override public String toString() { return String.format(\u0026quot;(name=%s, source=%s)\u0026quot;, name, source); } } @SuppressWarnings({ \u0026quot;unchecked\u0026quot;, \u0026quot;rawtypes\u0026quot; }) public static void main(String[] args) { Gson gson = new Gson(); Collection collection = new ArrayList(); collection.add(\u0026quot;hello\u0026quot;); collection.add(5); collection.add(new Event(\u0026quot;GREETINGS\u0026quot;, \u0026quot;guest\u0026quot;)); String json = gson.toJson(collection); System.out.println(\u0026quot;Using Gson.toJson() on a raw collection: \u0026quot; + json); JsonParser parser = new JsonParser(); JsonArray array = parser.parse(json).getAsJsonArray(); String message = gson.fromJson(array.get(0), String.class); int number = gson.fromJson(array.get(1), int.class); Event event = gson.fromJson(array.get(2), Event.class); System.out.printf(\u0026quot;Using Gson.fromJson() to get: %s, %d, %s\u0026quot;, message, number, event); } } 第二种选择：注册一个Collection.class的类型适配器来查找数组中的每一个元素，并映射为合适的对象。这种做法的缺点是它可能会破坏Gson反序列化中的其它集合类型。\n第三种选择：注册一个MyCollectionMemberType的类型适配器，并使用Collection的fromJson。这种做法只适合数组是顶层元素的情况，或者你可以改变字段的类型以匹配Collection。\n5.8 Built-in Serializers and Deserializers（内置的序列化构造器和反序列化解析器）# Gson为常用的类提供了内置的序列化构造器和反序列化解析器（但是默认的设置可能不太适合你具体的要求）。\n下面是这些类的列表：\n1、java.net.URL匹配类似“http://code.google.com/p/google-gson/”的字符串。\n2、java.net.URI匹配类似“/p/google-gson/”的字符串。\n（译注：这段话什么意思我一直理解不了= =）\n你同样也能在[这里](https://sites.google.com/site/gson/gson-type-adapters-for-common- classes-1)找到类似JodaTime这样常用类的源代码。\n5.9 Custom Serialization and Deserialization（自定义序列化和反序列化）# 有时候默认的配置可能不符合你的要求。这种情况在处理类库中的类（DateTime等等）时经常出现。\nGson允许你注册自己自定义的序列化构造器和反序列化解析器。这需要通过定义两个部分来完成：\nJson序列化构造器：需要为一个对象定义自定义的序列化过程。\nJson反序列化解析器：需要为一个类型定义自定义的反序列化过程。\n实例构造器：如果有不带参数的构造器可以访问或者已经注册了反序列化解析器，那么可以不需要提供。\nGsonBuilder gson = new GsonBuilder(); gson.registerTypeAdapter(MyType2.class, new MyTypeAdapter()); gson.registerTypeAdapter(MyType.class, new MySerializer()); gson.registerTypeAdapter(MyType.class, new MyDeserializer()); gson.registerTypeAdapter(MyType.class, new MyInstanceCreator());\nregisterTypeAdapter将会检查类型适配器是否实现了多个接口，如果有会全部注册上去。\n5.9.1 Writing a Serializer（设计一个序列化构造器）# 下面是自定义JodaTime DateTime类序列化构造器的例子：\nprivate class DateTimeSerializer implements JsonSerializer\u0026lt;DateTime\u0026gt; { public JsonElement serialize(DateTime src, Type typeOfSrc, JsonSerializationContext context) { return new JsonPrimitive(src.toString()); } } Gson在序列化时进入DateTime对象将会调用toJson()方法。\n5.9.2 Writing a Deserializer（设计一个反序列化解析器）# 下面是自定义JodaTime DateTime类反序列化解析器的例子：\nprivate class DateTimeDeserializer implements JsonDeserializer\u0026lt;DateTime\u0026gt; { public DateTime deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { return new DateTime(json.getAsJsonPrimitive().getAsString()); } } 当Gson需要将一段JSON字符串片段解析为DataTime对象的时候将会调用fromJson()方法。\n5.9.3 Finer points withs Serializers and Deserializers（序列化构造器和反序列化解析器的细节）# 你经常需要为一个原始类型的泛型注册一个单一的处理器。\n例如，假设你有一个“Id”类来代表或者转换Id（例如内部代表和外部代表）\nId类型对于所有的泛型都具有相同的序列化过程：输出本质代表的Id值。\n反序列过程很类似但是不完全一样：需要调用“new Id(Class, String)”来返回一个Id实例。\nGson支持注册一个单一的处理器来处理这些事情。你也可以为一个指定的类型（例如Id需要指定的处理过程）注册特定的处理器。\ntoJson()和fromJson()包含的泛型类型参数可以帮你为所有对应相同原始类型的泛型写一个单一的处理器。\n5.10 Writing an Instance Creator（设计一个实例构造器）# 反序列化一个对象的时候，Gson需要为对应的类创建一个默认的实例。\n规范的类会为序列化和反序列化提供一个不带参数的构造方法（无论是public或者private的构造方法）。\n典型的情况是你需要处理类库中没有定义不带参数构造方法的类，你就需要一个实例构造器。\n5.10.1 Instance Creator Example（实例构造器示例）# private class MoneyInstanceCreator implements InstanceCreator\u0026lt;Money\u0026gt; { public Money createInstance(Type type) { return new Money(\u0026quot;1000000\u0026quot;, CurrencyCode.USD); } } Type可以是一个相关的泛型类型：\n当需要特定泛型类型信息的时候，调用构造器是非常有用的做法。\n例如，Id类保存了将要被创建Id的类信息。\n5.10.2 InstanceCreator for a Parameterized Type（带参数类型的实例构造器）# 有时候你要实例化的类型是一个带参数的类型。通常这不是一个问题，因为实际实例是原始类型中的一种。\n以下是一个例子：\nclass MyList\u0026lt;T\u0026gt; extends ArrayList\u0026lt;T\u0026gt; { } class MyListInstanceCreator implements InstanceCreator\u0026lt;MyList\u0026lt;?\u0026gt;\u0026gt; { @SuppressWarnings(\u0026quot;unchecked\u0026quot;) public MyList\u0026lt;?\u0026gt; createInstance(Type type) { // No need to use a parameterized list since the actual instance will have the raw type anyway. return new MyList(); } } 然而，有时候你需要创建对应实际带参数类型的实例。这种情况下，你可以使用传递进createInstance方法的类型参数。以下是例子：\npublic class Id\u0026lt;T\u0026gt; { private final Class\u0026lt;T\u0026gt; classOfId; private final long value; public Id(Class\u0026lt;T\u0026gt; classOfId, long value) { this.classOfId = classOfId; this.value = value; } } class IdInstanceCreator implements InstanceCreator\u0026lt;Id\u0026lt;?\u0026gt;\u0026gt; { public Id\u0026lt;?\u0026gt; createInstance(Type type) { Type[] typeParameters = ((ParameterizedType)type).getActualTypeArguments(); Type idType = typeParameters[0]; // Id has only one parameterized type T return Id.get((Class)idType, 0L); } } 上面的例子中，由于没有实际传递进来的带参数类型，Id类的实例没办法创建。我们通过传递type参数到方法里面来解决这个问题。上面例子中的type对象是一个java带参数类型，假如是Id，那么创建的实例应该是Id实例。因为Id类只包含一个带参数类型的参数T，我们直接使用getActualTypeArgument()方法返回的数组中的第一个元素，在这个例子中也就是Foo.class。\n5.11 Compact Vs. Pretty Printing for JSON Output Fromat（对比Gson紧凑型和优雅型的输出格式）# Gson提供的默认输出格式是紧凑型的JSON格式。这意味着在输出的JSON结构中没有任何空白，也就是在输出的JSON中字段名和字段值、对象成员、数组中的对象之间没有任何留白。另外，“null”字段将会在输出中被忽略（注意null值仍然包含在对象的集合或者数组中）。参考下面Null Object Support章节来配置Gson输出所有的null值。\n如果你想要使用优雅的格式输出，你可以使用GsonBuilder配置你的Gson实例。由于我们的public API中没有开放JsonFormatter，因此没有办法配置默认JSON输出的设置和边距。目前，我们只提供了一个默认的JsonPrintFormatter，它规定输出的格式每一行的长度为80个字符，2个字符缩进，4个字符的右边距。\n下面的例子展示了如何使用默认的JsonPrintFormatter取代JsonCompactFormatter配置一个Gson实例。\nGson gson = new GsonBuilder().setPrettyPrinting().create(); String jsonOutput = gson.toJson(someObject);Gson gson = new GsonBuilder().setPrettyPrinting().create(); String jsonOutput = gson.toJson(someObject); 5.12 Null Object Support（空对象支持）# Gson对于null字段的默认处理是忽略掉，因为这样才能生成更加紧凑的输出格式。然而，客户端必须为这些字段定义默认值，这样JSON格式才能转换回对应的Java对象。\n以下是配置一个Gson实例来输出null的方法：\nGson gson = new GsonBuilder().serializeNulls().create(); 注意：当使用Gson序列化null值的时候，它将添加一个JsonNull元素到JsonElement结构中。因此，这个对象能够被用于自定义的序列化和反序列化。\n下面是示例：\npublic class Foo { private final String s; private final int i; public Foo() { this(null, 5); } public Foo(String s, int i) { this.s = s; this.i = i; } } Gson gson = new GsonBuilder().serializeNulls().create(); Foo foo = new Foo(); String json = gson.toJson(foo); System.out.println(json); json = gson.toJson(null); System.out.println(json);\r======== 输出结果 ========\n{\u0026ldquo;s\u0026rdquo;:null,\u0026ldquo;i\u0026rdquo;:5}\nnull\n5.13 Versioning Support（版本支持）# 可以使用@Since注解来维护同一个对象的多个版本。这个注解可以用于类、字段、未来发布、方法。为了充分利用这个特性，你必须配置你的Gson实例忽略掉版本比一些版本号更大的字段或者对象。如果Gson实例没有设置版本，那么它将序列化和反序列所有的字段和类而不考虑版本的影响。\npublic class VersionedClass { @Since(1.1) private final String newerField; @Since(1.0) private final String newField; private final String field; public VersionedClass() { this.newerField = \u0026quot;newer\u0026quot;; this.newField = \u0026quot;new\u0026quot;; this.field = \u0026quot;old\u0026quot;; } } VersionedClass versionedObject = new VersionedClass(); Gson gson = new GsonBuilder().setVersion(1.0).create(); String jsonOutput = gson.toJson(someObject); System.out.println(jsonOutput); System.out.println(); gson = new Gson(); jsonOutput = gson.toJson(someObject); System.out.println(jsonOutput); ======== 输出结果 ========\n{\u0026ldquo;newField\u0026rdquo;:\u0026ldquo;new\u0026rdquo;,\u0026ldquo;field\u0026rdquo;:\u0026ldquo;old\u0026rdquo;}\n{\u0026ldquo;newerField\u0026rdquo;:\u0026ldquo;newer\u0026rdquo;,\u0026ldquo;newField\u0026rdquo;:\u0026ldquo;new\u0026rdquo;,\u0026ldquo;field\u0026rdquo;:\u0026ldquo;old\u0026rdquo;}\n5.14 Excluding Fields From Serialization and Deserialization（在序列化和反序列中排除字段）# Gson提供了多种途径来排除顶级类、字段和字段类型。以下是排除字段和类的一些方法。如果以下方法对于你需求来说不安全，那么你也可以直接自定义序列化构造器和反序列化解析器来实现。\n5.14.1 Java Modifier Exclusion（Java修正器排除）# 默认情况下，如果你将一个字段声明为transient，这个字段就会被排除。同样，如果一个字段被标识为“static”，那么默认也会被排除。如果你想把一些transient字段也包含进来，那么你可以尝试以下做法：\nimport java.lang.reflect.Modifier; Gson gson = new GsonBuilder() .excludeFieldsWithModifiers(Modifier.STATIC) .create(); 注意：你可以同时在excludeFieldsWithModifiers方法中包含多个Modifier数值，例如：\nGson gson = new GsonBuilder() .excludeFieldsWithModifiers(Modifier.STATIC, Modifier.TRANSIENT, Modifier.VOLATILE) .create(); 5.14.2 Gson\u0026rsquo;s @Expose（Gson的@Expose注解）# 这个功能提供一种途径来表示你的对象中哪些字段是JSON的序列化和反序列化时候要排除的。要使用这个注解，你需要使用以下方式创建Gson实例：\nnew GsonBuilder().excludeFieldsWithoutExposeAnnotation().create(); 这个Gson实例将会排除类中没有使用@Expose注解的字段。\n5.14.3 User Defined Exclusion Strategies（用户自定义排除策略）# 如果上述排除字段和类型的方法不符合你的要求，你可以定义自己的排除策略然后添加到Gson中。参考[ExclusionStrategy](http://google- gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/ExclusionStrategy.html)的Java文档获取更多信息。\n下面的例子展示了如何排除由指定“@Foo”注解标识和顶层类型（或者声明字段类型）String的字段。\n@Retention(RetentionPolicy.RUNTIME) @Target({ElementType.FIELD}) public @interface Foo { // Field tag only annotation } public class SampleObjectForTest { @Foo private final int annotatedField; private final String stringField; private final long longField; private final Class\u0026lt;?\u0026gt; clazzField; public SampleObjectForTest() { annotatedField = 5; stringField = \u0026quot;someDefaultValue\u0026quot;; longField = 1234; } } public class MyExclusionStrategy implements ExclusionStrategy { private final Class\u0026lt;?\u0026gt; typeToSkip; private MyExclusionStrategy(Class\u0026lt;?\u0026gt; typeToSkip) { this.typeToSkip = typeToSkip; } public boolean shouldSkipClass(Class\u0026lt;?\u0026gt; clazz) { return (clazz == typeToSkip); } public boolean shouldSkipField(FieldAttributes f) { return f.getAnnotation(Foo.class) != null; } } public static void main(String[] args) { Gson gson = new GsonBuilder() .setExclusionStrategies(new MyExclusionStrategy(String.class)) .serializeNulls() .create(); SampleObjectForTest src = new SampleObjectForTest(); String json = gson.toJson(src); System.out.println(json); } ======== 输出结果 ========\n{\u0026ldquo;longField\u0026rdquo;:1234}\n5.15 JSON Field Naming Support（JSON字段命名支持）# Gson支持一些预定义的字段命名策略来将标准的Java字段名（例如小写字母开头的骆驼命名法——“sampleFieldNameInJava”）覆盖为Json的字段名（例如sample_field_name_in_java或者SampleFieldNameInJava）。参考[FieldNamingPolicy](http://google- gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/FieldNamingPolicy.html)类查看预定义的命名策略。\nGson同样也提供了一个基于策略的注解允许客户端为每一个字段自定义名字。注意基于策略的注解会检查字段的名字，如果注解值提供了一个无效的名字将会抛出“Runtime”异常。\n下面例子展示了如何同时使用Gson的预定义命名策略和注解命名策略特性：\nprivate class SomeObject { @SerializedName(\u0026quot;custom_naming\u0026quot;) private final String someField; private final String someOtherField; public SomeObject(String a, String b) { this.someField = a; this.someOtherField = b; } } SomeObject someObject = new SomeObject(\u0026quot;first\u0026quot;, \u0026quot;second\u0026quot;); Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create(); String jsonRepresentation = gson.toJson(someObject); System.out.println(jsonRepresentation); ======== 输出结果 ========\n{\u0026ldquo;custom_naming\u0026rdquo;:\u0026ldquo;first\u0026rdquo;,\u0026ldquo;SomeOtherField\u0026rdquo;:\u0026ldquo;second\u0026rdquo;}\n如果你需要自定义命名策略（参考这个[讨论](http://groups.google.com/group/google- gson/browse_thread/thread/cb441a2d717f6892)），你可以使用@SerializedName注解。\n5.16 Sharing State Across Custom Serializers and# Deserializers（通过自定义序列化构造器和反序列化解析器共享状态）\n有时候你需要通过自定义序列化构造器和反序列化解析器来共享状态（参考这里的[讨论](http://groups.google.com/group/google- gson/browse_thread/thread/2850010691ea09fb)）。你可以通过以下三种方法来达到目的：\n1、使用静态变量保存共享的状态。\n2、声明序列化构造器或反序列化解析器作为父类的内部类，然后使用父类的实例变量保存共享的状态。\n3、使用Java ThreadLocal。\n1和2是非线程安全的做法，3是线程安全的。\n5.17 Streaming （流操作）# 由于Gson的对象模型和数据绑定，你可以使用Gson读写一个数据流。你可以组合数据流和对象模型入口来获取最佳的实现。\n6、Issues in Designing Gson（设计中的问题）# 参考[Gson design document](https://sites.google.com/site/gson/gson-design- document)中关于我们在设计Gson过程中遇到的问题。里面也包含Gson和其它用于Json转换的Java类库的比较。\n7、Future Enhancements to Gson（Gson未来的强化）# 对于最新的功能增强建议列表或者你有什么新的建议，可以参考[Issue Session](http://code.google.com/p/google- gson/issues/list)。\n原文地址：https://sites.google.com/site/gson/gson-user-guide\n","date":"September 7, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/gson%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/","series":[{"title":"Gson","url":"https://www.qinxiandiqi.sbs/series/gson/"}],"smallImg":"","tags":[{"title":"gson","url":"https://www.qinxiandiqi.sbs/tags/gson/"},{"title":"json","url":"https://www.qinxiandiqi.sbs/tags/json/"},{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"}],"title":"Gson用户指南"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Beacon","url":"https://www.qinxiandiqi.sbs/categories/beacon/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\n原文作者：Adam Warski\n原文地址：http://www.warski.org/blog/2014/01/how-ibeacons-work/\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-09-02版本进行翻译\n版权声明：本文经原作者许可进行翻译，保留所有权利，未经许可不得复制和转载。\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\niBeacon是最近非常火的话题。这种技术能够实现室内定位，让你的手机能够知道是否处于一个Beacon的范围内。使用这种技术能够产生很多应用程序：比如帮助你在停车场中找到你的汽车，或者在零售店中根据所处位置提供优惠券或者其它一些位置相关的服务。还有很多我们现在无法想象得到的应用程序。\n现在有很多种关于iBeacon是什么，以及我们可以如何使用它们的解释。然而从技术角度上来说，它们是如何工作的？底层的技术使用的使用Bluetooth LE，因此。。。\nWhat is Bluetooth LE？（什么是Bluetooth LE，简写BLE）# Bluetooth Low Energy（BLE）是2010年发布的蓝牙4.0技术规范的一部分。它起源于2006年Nokia的Wibree技术，但最终被整合进了蓝牙。这是一组与传统蓝牙不同的协议，并且使用的设备上也不会向后兼容。因此，现在市面上你可以看到三种类型的设备：\n1.Bluetooth设备：只支持传统蓝牙的设备。\n2.Bluetooth Smart Ready设备：同时支持传统蓝牙和LE模式的设备。\n3.Bluetooth Smart设备：只支持LE模式的设备。\n最新的手机（iPhone 4s+, SG3+)、笔记本、平板电脑等，基本上都已经支持蓝牙4.0，也就是Bluetooth Smart Ready设备。Beacon，从另一方面来说，这种设备只支持low energy protocols（LE低功耗协议），属于上面说所的“Bluetooth Smart”设备，这也是它们靠一颗纽扣电池就能运行很长时间的原因。老式设备，比如外设、汽车系统、旧手机等通常只支持传统蓝牙协议。\nBLE最重要的特点当然在于它的低能耗。举个例子，一些beacon设备靠一颗微型电池就能够持续发送一个信号两年左右（这种电池一般是不可拆卸的，你可能需要在beacon停止工作之后替换一个新的beacon）。传统蓝牙和LE蓝牙使用的都是相同的波段（2.4GHz-2.4835GHz）。BLE协议的传输速率比较低，因此除了用于发现设备和做一些简单通信之外，不太适合用于传输大量的数据流。在协议条款上，LE和传统蓝牙的信号都能够覆盖到100米的范围。\nHow does BLE communication work？（BLE设备如何通信）# BLE的通信包括两个主要部分：advertising（广告）和connecting（连接）。\n广告（Advertising）是一种单向的发送机制。想要被搜索到的设备可以以20毫秒到10秒钟的时间间隔发送一段数据包。使用的时间间隔越短，电池消耗的越快，但设备被发现的速度也就会快。数据包长度最多47个字节，由以下部分组成：\n**\n1 byte preamble（1字节做报头）**\n** 4 byte access address（4字节做地址）**\n** 39 bytes advertising channel PDU（39个字节用于PDU数据包）**\n** 3 bytes CRC（3个字节用于CRC数据校验）**\n对于广告通信信道，地址部分永远都是0x8E89BED6。对于其它数据信道，地址部分由不同的连接决定。\n返回的PDU数据也拥有自己的数据报头（2个字节：声明有效载荷数据的长度和类型——设备是否支持连接等等）和当前有效载荷数据（最多37个字节）。\n最终，有效载荷数据中的头6个字节是设备的MAC地址，所以实际信息数据最高可占31个字节。\nBLE设备可以运行在单一的不可连接的广告模式中（在这种模式下所有的信息都包含在广告数据包中），然而设备也是允许运行在可被连接的模式下（通常情况下都是这种模式）。\n当设备被发现之后，一个连接就会被建立起来。之后就可以读取BLE设备提供的Service，以及每个Service的characteristic（属性，类似于GATT Profile实例）。每一个characteristic都会提供一些值，这些值可以被读取或者修改。例如，一个小型温控器可以开放一个service用于获取当前的温度或者湿度读数（相当于是service的characteristic），同时也可以开放其它的service和characteristic用于设置期望的温度。这里因为beacon不使用连接模式，我将会跳过这些细节。如果你想要了解更多关于连接BLE设备的内容，可以参考Apple\u0026rsquo;s Core Bluetooth guide，尽管你可能不是一个IOS开发者。更多相关技术性的文章，可以参考Introduction to BLE，Making the most out of BLE Advertising mode。\nHow do beacons use BLE？（beacon设备如何使用BLE）# Beacon设备只使用了广告通信信道。正如beacon（信标、灯塔）的字面意思，这种设备以一定的时间间隔发送数据包，并且发送的数据被可以被像手机这样的设备获取。也就是说，iBeacon只是BLE广告模式的一种简单的使用，并在此基础上提供了对IOS的一些附加支持。\n如果你试着拦截一段iBeacon广告数据包，例如下面从Estimote beacon截获的数据包：\n02 01 06 1A FF 4C 00 02 15 B9 40 7F 30 F5 F8 46 6E AF F9 25 55 6B 57 FE 6D 00 49 00 0A C5 （截获以上数据，如果你使用的Mac设备，你可以参考[additional XCode download](http://stackoverflow.com/questions/5863088/bluetooth-sniffer- preferably-mac- osx)为XCode添加蓝牙扫描和数据包打印工具。如果是Window设备，请参考这里）\n以上的数据已经将广告数据包的报头、修正地址、广告PDU数据包的报头和其中的MAC地址部分都移除掉了，也就是说这部分数据只包含了实际信息数据——一共30个字节，符合实际信息数据最多31个字节的限制。\n那么一个iBeacon设备的BLE广告数据是如何组成的？以下是Apple修正的数据格式，整理如下（也可以参考[这里](http://stackoverflow.com/questions/18906988/what- is-the-ibeacon-bluetooth-profile)）：\n02 01 06 1A FF 4C 00 02 15: iBeacon prefix (fixed) B9 40 7F 30 F5 F8 46 6E AF F9 25 55 6B 57 FE 6D: proximity UUID (here: Estimote’s fixed UUID) 00 49: major 00 0A: minor C5: 2’s complement of measured TX power 根据这些原理，如果你想要实验beacon的功能，你不必需要一个真正的beacon设备。如果你有最新的手机（例如iPhone4S+，SG3+）或者配备蓝牙4的笔记本（例如Retina MacBook），你可以将这些设备转换成iBeacon发送设备和接收设备。以iPhone为例，你可以在AppStore上下载“Locate iB”应用。对于MacOS，可以参考[这里](http://stackoverflow.com/questions/19410398/turn- macbook-into- ibeacon)。当然你可以可以使用[树莓派](http://developer.radiusnetworks.com/2013/10/09/how-to- make-an-ibeacon-out-of-a-raspberry-pi.html)。\nBreaking down the iBeacon format（解析iBeacon的数据格式）# 除了修正的iBeacon前缀数据（02 01 \u0026hellip; 15），其它各部分数据各代表什么？\nProximity UUID （上面例子中的B9 \u0026hellip; 6D部分）：这是将你所有的beacon与其他人的beacon设备区别开的id！例如，目前在商店里某个区域分布着多个beacon形成一条“链带”，用于为顾客提供特定的服务，那么归属于同一条“链带”的beacon将分配到相同的proximity UUID。为这条“链带”设计的专用应用程序将会在后台使用这个UUID扫描到这条“链带”中的beacon设备。\nmajor 编号（2个字节，上面例子中为0x0049，也就是73）：用于将相关的beacon标识为一组。例如，一个商店中的所有beacon将会分配到相同的major编号。通过这种方式，应用程序就能够知道顾客位于哪一家商店。\nminor 标号（也是2个字节，上面例子中为0x000A，也就是10）：用于标识特定的beacon设备。例如一个商店中的每一个beacon设备都拥有唯一的minor编号，这样你才能够知道顾客位于商店中的哪个位置。\nMeasuring distance（测量距离）# 最后一个值， TX power ，用于确定你和beacon之间距离有多近。根据这个值不但可以获得粗略的信息（比如靠近/远离/不在范围内等），也可以获取精确到米的距离（当然你也可以转换为以步为单位的距离）。那么如何实现？\nTX power （上面例子中为0xC5=197，根据2的补码测得256-197=-59dBm）是距离设备1米测得的信号强度值（RSSI- Received Signal Strength Indication，接收到的信号强弱指标）。假如接收到的信号强度减弱了，那么我们可能在远离。只要知道1米距离的RSSI，以及当前的RSSI（我们可以从接收到的信号中一块获取到这些信息），那么计算出当前的距离是可能的。IOS已经实现了个这个功能，对于其它平台需要自己手动编码计算，可以参考[这里](http://stackoverflow.com/questions/20416218/understanding- ibeacon-distancing)。\n译注：Java代码粗略计算距离代码：\nprotected static double calculateAccuracy(int txPower, double rssi) { if (rssi == 0) { return -1.0; // if we cannot determine accuracy, return -1. } double ratio = rssi*1.0/txPower; if (ratio \u0026lt; 1.0) { return Math.pow(ratio,10); } else { double accuracy = (0.89976)*Math.pow(ratio,7.7095) + 0.111; return accuracy; } } 然而，在实际应用中，由于人体或者其它通信阻碍物都有可能削弱信号，因此这个距离只是一个估算值。\nIOS integration（IOS整合）# IOS已经整合了iBeacon。当你进入beacon的范围内，你的应用程序就可以接收到通知，即使你的应用程序处于在后台也能接收到。一个应用程序可以注册一个区域的进入或者退出事件，因此即使应用程序没有运行也可以被唤醒。为了响应这些事件，应用程序可以发送例如本地推送通知，提示用户打开应用程序查看商店的促销广告（这些促销广告可以从网络上面获取），或者是其它相关的内容。\n更准确的说，当手机处于不活动状态时，也就是IOS进入了低电量监控模式的时候，只有iBeacon区域进入/退出事件能够被接收到。当手机和应用程序处于活动状态，你可以进入ranging模式，这个能够让你检测的信号强度和估算距离更加准确。\n注意你的手机检测beacon需要花费一定的时间。首先，beacon设备是间隔一定的时间才发送一次广告。其次，如果你的手机处于非活动模式，它只在有些时候才会检测蓝牙信号。一个beacon设备要被检测到，上面两段工作时间就需要有交集。实践证明，它可能需要15分钟才能检测到一个beacon设备。\n按步骤开发一个iOS iBeacon应用程序可以参考[这里](http://www.cocoanetics.com/2013/11/can-you- smell-the-ibeacon/)。Beacon的制造商通常也会提供SDK帮助开发Beacon应用程序。参考Estimote的iOS SDK 和Android SDK。\nHow can I get some beacons？（如何获取Beacon设备）# Beacon设备资源现在比较稀少，你通常需要等上几个星期才能拿到货，但可以肯定的是将来这种情况会改善。\n因此，最快的选择就是创建一个Beacon模拟器：将iPhone/Android/MacBook/其它笔记本/树莓派转换成了Beacon模拟器。\n第二种选择就是试着去订购一些Beacon设备了：\npre-order Estimote beacons; 3 for $99 Kontakt beacons come in a couple of packages; 4 for $99, 10 for $279 RaspberryPi kits from RadiusNetworks: 1 for $99 RedBearLab offers BLE shields for Arduino for $30 Bleu sells USB-iBeacon dongles. 1 for $40, 5 for $150 Alternatives（替代品）# iBeacon不是唯一一种基于BLE近距离技术开发的设备。高通同样正在开发自己的Beacon——Gimbal，并集合了iOS和Android SDK。它们提供的功能比较类似，但是BLE广告的数据格式可能不一样。我的开发工具还在运送途中，因此我还没有测试过，但是这种Beacon肯定很有趣，尤其是它的价格最低只有5美元。\nWhat\u0026rsquo;s next？（下一步是什么？）# 现在还没有做的事情就是开发一些基于Beacon的应用程序。为了实现这个目的，记住SoftwareMill：我们经常寻找一些有趣的项目来开发。\n","date":"September 2, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/hardware/ibeacon%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86howdoibeaconwork/","series":[{"title":"Beacon","url":"https://www.qinxiandiqi.sbs/series/beacon/"}],"smallImg":"","tags":[{"title":"iBeacon","url":"https://www.qinxiandiqi.sbs/tags/ibeacon/"},{"title":"bluetooth","url":"https://www.qinxiandiqi.sbs/tags/bluetooth/"},{"title":"BLE","url":"https://www.qinxiandiqi.sbs/tags/ble/"},{"title":"工作原理","url":"https://www.qinxiandiqi.sbs/tags/%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"title":"蓝牙","url":"https://www.qinxiandiqi.sbs/tags/%E8%93%9D%E7%89%99/"}],"title":"IBeacon工作原理（How Do IBeacon Work？）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/categories/android-gradle/"}],"content":"原文地址：\u0026lt;http://tools.android.com/tech-docs/new-build-system/user-guide#TOC- Advanced-Build-Customization\u0026gt;\n7、 Advanced Build Customization（高级构建定制）# 7.1 Build options（构建选项）# 7.1.1 Java Compilation options（Java编译选项）# android { compileOptions { sourceCompatibility = \u0026quot;1.6\u0026quot; targetCompatibility = \u0026quot;1.6\u0026quot; } } 默认值是“1.6”。这个设置将影响所有task编译Java源代码。\n7.1.2 aapt options（aapt选项）# android { aaptOptions { noCompress 'foo', 'bar' ignoreAssetsPattern \u0026quot;!.svn:!.git:!.ds_store:!*.scc:.*:\u0026lt;dir\u0026gt;_*:!CVS:!thumbs.db:!picasa.ini:!*~\u0026quot; } } 这将影响所有使用aapt的task。\n7.1.3 dex options（dex选项）# android { dexOptions { incremental false preDexLibraries = false jumboMode = false } } 这将应用所有使用dex的task。\n7.2 Manipulation tasks（操作task）# 基础Java项目有一组有限的task用于互相处理生成一个输出。\nclasses 是一个编译Java源代码的task。可以在build.gradle文件中通过脚本很容易使用classes。这是 project.tasks.classes 的缩写。\n在Android项目中，相比之下这就有点复杂。因为Android项目中会有大量相同的task，并且它们的名字基于Build Types和Product Flavor生成。\n为了解决这个问题，android对象有两个属性：\n** * applicationVariants（只适用于app plugin）**\n** * libraryVariants（只适用于library plugin）**\n** * testVariants（两个plugin都适用）**\n这三个都会分别返回一个ApplicationVariant、LibraryVariant和TestVariant对象的 DomainObjectCollection 。\n注意使用这三个collection中的其中一个都会触发生成所有对应的task。这意味着使用collection之后不需要更改配置。\nDomainObjectCollection可以直接访问所有对象，或者通过过滤器进行筛选。\nandroid.applicationVariants.each { variant -\u0026gt; .... } 这三个variant类都共享下面的属性：\n属性名 属性类型 说明 name String Variant的名字，必须是唯一的。 description String Variant的描述说明。 dirName String Variant的子文件夹名，必须也是唯一的。可能也会有不止一个子文件夹，例如“debug/flavor1” baseName String Variant输出的基础名字，必须唯一。 outputFile File Variant的输出，这是一个可读可写的属性。 processManifest ProcessManifest 处理Manifest的task。 aidlCompile AidlCompile 编译AIDL文件的task。 renderscriptCompile RenderscriptCompile 编译Renderscript文件的task。 mergeResources MergeResources 混合资源文件的task。 mergeAssets MergeAssets 混合asset的task。 processResources ProcessAndroidResources 处理并编译资源文件的task。 generateBuildConfig GenerateBuildConfig 生成BuildConfig类的task。 javaCompile JavaCompile 编译Java源代码的task。 processJavaResources Copy 处理Java资源的task。 assemble DefaultTask Variant的标志性assemble task。 ApplicationVariant类还有以下附加属性：\n属性名 属性类型 说明 buildType BuildType Variant的BuildType。 productFlavors List Variant的ProductFlavor。一般不为空但也允许空值。 mergedFlavor ProductFlavor android.defaultConfig和variant.productFlavors的合并。 signingConfig SigningConfig Variant使用的SigningConfig对象。 isSigningReady boolean 如果是true则表明这个Variant已经具备了所有需要签名的信息。 testVariant BuildVariant 将会测试这个Variant的TestVariant。 dex Dex 将代码打包成dex的task。如果这个Variant是个库，这个值可以为空。 packageApplication PackageApplication 打包最终APK的task。如果这个Variant是个库，这个值可以为空。 zipAlign ZipAlign zip压缩APK的task。如果这个Variant是个库或者APK不能被签名，这个值可以为空。 install DefaultTask 负责安装的task，不能为空。 uninstall DefaultTask 负责卸载的task。 LibraryVariant类还有以下附加属性：\n属性名 属性类型 说明 buildType BuildType Variant的BuildType. mergedFlavor ProductFlavor The defaultConfig values testVariant BuildVariant 用于测试这个Variant。 packageLibrary Zip 用于打包库项目的AAR文件。如果是个库项目，这个值不能为空。 TestVariant类还有以下属性：\n属性名 属性值 说明 buildType BuildType Variant的Build Type。 productFlavors List Variant的ProductFlavor。一般不为空但也允许空值。 mergedFlavor ProductFlavor android.defaultConfig和variant.productFlavors的合并。 signingConfig SigningConfig Variant使用的SigningConfig对象。 isSigningReady boolean 如果是true则表明这个Variant已经具备了所有需要签名的信息。 testedVariant BaseVariant TestVariant测试的BaseVariant dex Dex 将代码打包成dex的task。如果这个Variant是个库，这个值可以为空。 packageApplication PackageApplication 打包最终APK的task。如果这个Variant是个库，这个值可以为空。 zipAlign ZipAlign zip压缩APK的task。如果这个Variant是个库或者APK不能被签名，这个值可以为空。 install DefaultTask 负责安装的task，不能为空。 uninstall DefaultTask 负责卸载的task。 connectedAndroidTest DefaultTask 在连接设备上行执行Android测试的task。 providerAndroidTest DefaultTask 使用扩展API执行Android测试的task。 Android task特有类型的API：\n* ProcessManifest * File manifestOutputFile * AidlCompile * File sourceOutputDir * RenderscriptCompile * File sourceOutputDir * File resOutputDir * MergeResources * File outputDir * MergeAssets * File outputDir * ProcessAndroidResources * File manifestFile * File resDir * File assetsDir * File sourceOutputDir * File textSymbolOutputDir * File packageOutputFile * File proguardOutputFile * GenerateBuildConfig * File sourceOutputDir * Dex * File outputFolder * PackageApplication * File resourceFile * File dexFile * File javaResourceDir * File jniDir * File outputFile * 直接在Variant对象中使用“outputFile”可以改变最终的输出文件夹。 * ZipAlign * File inputFile * File outputFile * 直接在Variant对象中使用“outputFile”可以改变最终的输出文件夹。 每个task类型的API由于Gradle的工作方式和Android plugin的配置方式而受到限制。\n首先，Gradle意味着拥有的task只能配置输入输出的路径和一些可能使用的选项标识。因此，task只能定义一些输入或者输出。\n其次，这里面大多数task的输入都不是单一的，一般都混合了sourceSet、Build Type和Product Flavor中的值。为了保持构建文件的简单和可读性，目标是要让开发者通过DSL语言修改这些对象来配饰构建的过程，而不是深入修改输入和task的选项。\n另外需要注意，除了ZipAlign这个task类型，其它所有类型都要求设置私有数据来让它们运行。这意味着不可能自动创建这些类型的新task实例。\n这些API也可能会被更改。一般来说，目前的API是围绕着给定task的输入和输出入口来添加额外的处理（如果需要的时候）。欢迎反馈意见，特别是那些没有预见过的需求。\n对于Gradle的task（DefaultTask，JavaCompile，Copy，Zip），请参考Gradle文档。\n7.3 BuildType and Product Flavor property reference（BuildType和Product# Flavor属性参考）\ncoming soon。。。。= =\n对于Gradle的task（DefaultTask，JavaCompile，Copy，Zip），请参考Gradle文档。\n7.4 Using sourceCompatibility 1.7（使用（JDK）1.7版本的sourceCompatibility）# 使用Android KitKat（19版本的buildTools）就可以使用diamond operator，multi- catch，switch中使用字符串，try with resource等等（译注：都是JDK7的一些新特性，详情请参考JDK7文档）。设置使用1.7版本，需要修改你的构建文件：\nandroid { compileSdkVersion 19 buildToolsVersion \u0026quot;19.0.0\u0026quot; defaultConfig { minSdkVersion 7 targetSdkVersion 19 } compileOptions { sourceCompatibility JavaVersion.VERSION_1_7 targetCompatibility JavaVersion.VERSION_1_7 } } 注意：你可以将minSdkVersion的值设置为19之前的版本，只是你只能使用除了try with resources之外的其它新语言特性。如果你想要使用try with resources特性，你就需要把minSdkVersion也设置为19。\n你同样也需要确认Gradle使用1.7或者更高版本的JDK（Android Gradle plugin也需要0.6.1或者更高的版本）。\n","date":"July 18, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidgradleplugin/androidgradleplugin%E6%8C%87%E5%8D%97%E5%85%AD%E9%AB%98%E7%BA%A7%E6%9E%84%E5%BB%BA%E5%AE%9A%E5%88%B6/","series":[{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/series/android-gradle/"}],"smallImg":"","tags":[{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/tags/android-gradle/"},{"title":"gradle","url":"https://www.qinxiandiqi.sbs/tags/gradle/"}],"title":"Android Gradle Plugin指南（六）——高级构建定制"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/categories/android-gradle/"}],"content":"原文地址：\u0026lt;http://tools.android.com/tech-docs/new-build-system/user-guide#TOC- Build-Variants\u0026gt;\n6、 Build Variants（构建变种版本）# 新构建系统的一个目标就是允许为同一个应用创建不同的版本。\n这里有两个主要的使用情景：\n1、同一个应用的不同版本。例如一个免费的版本和一个收费的专业版本。 2、同一个应用需要打包成不同的apk以发布Google Play Store。查看\u0026lt;http://developer.android.com/google/play/publishing/multiple-apks.html\u0026gt;获取更多详细信息。 3、综合1和2两种情景。 这个目标就是要让在同一个项目里生成不同的APK成为可能，以取代以前需要使用一个库项目和两个及两个以上的应用项目分别生成不同APK的做法。\n6.1 Product flavors（不同定制的产品）# 一个product flavor定义了从项目中构建了一个应用的自定义版本。一个单一的项目可以同时定义多个不同的flavor来改变应用的输出。\n这个新的设计概念是为了解决不同的版本之间的差异非常小的情况。虽然最项目终生成了多个定制的版本，但是它们本质上都是同一个应用，那么这种做法可能是比使用库项目更好的实现方式。\nProduct flavor需要在productFlavors这个DSL容器中声明：\nandroid { .... productFlavors { flavor1 { ... } flavor2 { ... } } } 这里创建了两个flavor，名为flavor1和flavor2。\n注意：flavor的命名不能与已存在的Build Type或者androidTest这个sourceSet有冲突。\n6.2 Build Type + Product Flavor = Build Variant（构建类型+定制产品=构建变种版本）# 正如前面章节所提到的，每一个Build Type都会生成一个新的APK。\nProduct Flavor同样也会做这些事情：项目的输出将会拼接所有可能的Build Type和Product Flavor（如果有Flavor定义存在的话）的组合。\n每一种组合（包含Build Type和Product Flavor）就是一个Build Variant（构建变种版本）。\n例如，在上面的Flavor声明例子中与默认的debug和release两个Build Type将会生成4个Build Variant：\n***** Flavor1 - debug ***** Flavor1 - release ***** Flavor2 - debug ***** Flavor2 - release 项目中如果没有定义flavor同样也会有Build Variant，只是使用的是默认的flavor和配置。默认的flavor是没有名字的，所以生成的Build Variant列表看起来就跟Build Type列表一样。\n6.3 Product Flavor Configuration（Product Flavor的配置）# 每一个flavor都是通过闭包来配置的：\nandroid { ... defaultConfig { minSdkVersion 8 versionCode 10 } productFlavors { flavor1 { packageName \u0026quot;com.example.flavor1\u0026quot; versionCode 20 } flavor2 { packageName \u0026quot;com.example.flavor2\u0026quot; minSdkVersion 14 } } } 注意ProductFlavor类型的 android.productFlavors.* 对象与 android.defaultConfig 对象的类型是相同的。这意味着它们共享相同的属性。\ndefaultConfig为所有的flavor提供基本的配置，每一个flavor都可以重设这些配置的值。在上面的例子中，最终的配置结果将会是：\n*** flavor1** * packageName: com.example.flavor1 * minSdkVersion: 8 * versionCode: 20 *** flavor2** * packageName: com.example.flavor2 * minSdkVersion: 14 * versionCode: 10 通常情况下，Build Type的配置会覆盖其它的配置。例如，Build Type的 packageNameSuffix 会被追加到Product Flavor的packageName上面。\n也有一些情况是一些设置可以同时在Build Type和Product Flavor中设置。在这种情况下，按照个别为主的原则决定。\n例如，signingConfig就这种属性的一个例子。\nsigningConfig允许通过设置 android.buildTypes.release.signingConfig 来为所有的release包共享相同的SigningConfig。也可以通过设置 android.productFlavors.*.signingConfig 来为每一个release包指定它们自己的SigningConfig。\n6.4 Sourcesets and Dependencies（源组件和依赖关系）# 与Build Type类似，Product Flavor也会通过它们自己的sourceSet提供代码和资源。\n上面的例子将会创建4个sourceSet：\n* android.sourceSets.flavor1：位于src/flavor1/ * android.sourceSets.flavor2：位于src/flavor2/ * android.sourceSets.androidTestFlavor1：位于src/androidTestFlavor1/ * android.sourceSets.androidTestFlavor2：位于src/androidTestFlavor2/ 这些sourceSet用于与 android.sourceSets.main 和Build Type的sourceSet来构建APK。\n下面的规则用于处理所有使用的sourceSet来构建一个APK：\n** * 多个文件夹中的所有的源代码（src/*/java）都会合并起来生成一个输出。**\n** * 所有的Manifest文件都会合并成一个Manifest文件。类似于Build Type，允许Product Flavor可以拥有不同的的组件和权限声明。**\n** * 所有使用的资源（Android res和assets）遵循的优先级为Build Type会覆盖Product Flavor，最终覆盖main sourceSet的资源。**\n** * 每一个Build Variant都会根据资源生成自己的R类（或者其它一些源代码）。Variant互相之间没有什么是共享的。**\n最终，类似Build Type，Product Flavor也可以有它们自己的依赖关系。例如，如果使用flavor来生成一个基于广告的应用版本和一个付费的应用版本，其中广告版本可能需要依赖于一个广告SDK，但是另一个不需要。\ndependencies { flavor1Compile \u0026quot;...\u0026quot; } 在这个例子中，src/flavor1/AndroidManifest.xml文件中可能需要声明访问网络的权限。\n每一个Variant也会创建额外的sourceSet：\n* android.sourceSets.flavor1Debug：位于src/flavor1Debug/ * android.sourceSets.flavor1Release：位于src/flavor1Release/ * android.sourceSets.flavor2Debug：位于src/flavor2Debug/ * android.sourceSets.flavor2Release：位于src/flavor2Release/ 这些sourceSet拥有比Build Type的sourceSet更高的优先级，并允许在Variant的层次上做一些定制。\n6.5 Building and Tasks（构建和任务）# 我们前面提到每一个Build Type会创建自己的 assemble task，但是Build Variant是Build Type和Product Flavor的组合。\n当使用Product Flavor的时候，将会创建更多的assemble-type task。分别是：\n**1、assemble \u0026lt;Variant Name\u0026gt;：**允许直接构建一个Variant版本，例如assembleFlavor1Debug。 **2、assemble \u0026lt;Build Type Name\u0026gt;：**允许构建指定Build Type的所有APK，例如assembleDebug将会构建Flavor1Debug和Flavor2Debug两个Variant版本。 **3、assemble \u0026lt;Product Flavor Name\u0026gt;：**允许构建指定flavor的所有APK，例如assembleFlavor1将会构建Flavor1Debug和Flavor1Release两个Variant版本。 另外 assemble task会构建所有可能组合的Variant版本。\n6.6 Testing（测试）# 测试multi-flavors项目非常类似于测试简单的项目。\nandroidTest sourceSet用于定义所有flavor共用的测试，但是每一个flavor也可以有它自己特有的测试。\n正如前面提到的，每一个flavor都会创建自己的测试sourceSet：\n* android.sourceSets.androidTestFlavor1：位于src/androidTestFlavor1/ * android.sourceSets.androidTestFlavor2：位于src/androidTestFlavor2/ 同样的，它们也可以拥有自己的依赖关系：\ndependencies { androidTestFlavor1Compile \u0026quot;...\u0026quot; } 这些测试可以通过main的标志性 deviceCheck task 或者main的 androidTest task （当flavor被使用的时候这个task相当于一个标志性task）来执行。\n每一个flavor也拥有它们自己的task来这行这些测试： androidTest 。例如：\n* androidTestFlavor1Debug * androidTestFlavor2Debug 同样的，每一个Variant版本也会创建对应的测试APK构建task和安装或卸载task：\n* assembleFlavor1Test * installFlavor1Debug * installFlavor1Test * uninstallFlavor1Debug * ... 最终的HTML报告支持根据flavor合并生成。\n下面是测试结果和报告文件的路径，第一个是每一个flavor版本的结果，后面的是合并起来的结果：\n* build/androidTest-results/flavors/\u0026lt;FlavorName\u0026gt; * build/androidTest-results/all/ * build/reports/androidTests/flavors\u0026lt;FlavorName\u0026gt; * build/reports/androidTests/all/ 6.7 Multi-flavor variants# 在一些情况下，一个应用可能需要基于多个标准来创建多个版本。例如，Google Play中的multi- apk支持4个不同的过滤器。区分创建的不同APK的每一个过滤器要求能够使用多维的Product Flavor。\n假如有个游戏需要一个免费版本和一个付费的版本，并且需要在multi- apk支持中使用ABI过滤器（译注：ABI，应用二进制接口，优点是不需要改动应用的任何代码就能够将应用迁移到任何支持相同ABI的平台上）。这个游戏应用需要3个ABI和两个特定应用版本，因此就需要生成6个APK（没有因计算不同Build Types生成的Variant版本）。\n然而，注意到在这个例子中，为三个ABI构建的付费版本源代码都是相同，因此创建6个flavor来实现不是一个好办法。\n相反的，使用两个flavor维度，并且自动构建所有可能的Variant组合。\n这个功能的实现就是使用Flavor Groups。每一个Group代表一个维度，并且flavor都被分配到一个指定的Group中。\nandroid { ... flavorGroups \u0026quot;abi\u0026quot;, \u0026quot;version\u0026quot; productFlavors { freeapp { flavorGroup \u0026quot;version\u0026quot; ... } x86 { flavorGroup \u0026quot;abi\u0026quot; ... } ... } } andorid.flavorGroups数组按照先后排序定义了可能使用的group。每一个Product Flavor都被分配到一个group中。\n上面的例子中将Product Flavor分为两组（即两个维度），为别为abi维度[x86,arm,mips]和version维度[freeapp,paidapp]，再加上默认的Build Type有[debug,release]，这将会组合生成以下的Build Variant：\n* x86-freeapp-debug * x86-freeapp-release * arm-freeapp-debug * arm-freeapp-release * mips-freeapp-debug * mips-freeapp-release * x86-paidapp-debug * x86-paidapp-release * arm-paidapp-debug * arm-paidapp-release * mips-paidapp-debug * mips-paidapp-release android.flavorGroups中定义的group排序非常重要（Variant命名和优先级等）。\n每一个Variant版本的配置由几个Product Flavor对象决定：\n* android.defaultConfig * 一个来自abi组中的对象 * 一个来自version组中的对象 flavorGroups中的排序决定了哪一个flavor覆盖哪一个，这对于资源来说非常重要，因为一个flavor中的值会替换定义在低优先级的flavor中的值。\nflavor groups使用最高的优先级定义，因此在上面例子中的优先级为：\nabi \u0026gt; version \u0026gt; defaultConfig Multi-flavors项目同样拥有额外的sourceSet，类似于Variant的sourceSet，只是少了Build Type：\n* android.sourceSets.x86Freeapp：位于src/x86Freeapp/ * android.sourceSets.armPaidapp：位于src/armPaidapp/ * etc... 这允许在flavor-combination的层次上进行定制。它们拥有过比基础的flavor sourceSet更高的优先级，但是优先级低于Build Type的sourceSet。\n","date":"July 17, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidgradleplugin/androidgradleplugin%E6%8C%87%E5%8D%97%E4%BA%94buildvariants%E6%9E%84%E5%BB%BA%E5%8F%98%E7%A7%8D%E7%89%88%E6%9C%AC/","series":[{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/series/android-gradle/"}],"smallImg":"","tags":[{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/tags/android-gradle/"},{"title":"flavor","url":"https://www.qinxiandiqi.sbs/tags/flavor/"},{"title":"variant","url":"https://www.qinxiandiqi.sbs/tags/variant/"},{"title":"多版本输出","url":"https://www.qinxiandiqi.sbs/tags/%E5%A4%9A%E7%89%88%E6%9C%AC%E8%BE%93%E5%87%BA/"},{"title":"gradle","url":"https://www.qinxiandiqi.sbs/tags/gradle/"}],"title":"Android Gradle Plugin指南（五）——Build Variants（构建变种版本）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/categories/android-wear/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n原文作者：Google\n原文地址：http://developer.android.com/design/wear/structure.html[](http://developer.android.com/design/wear/creative- vision.html)[](http://developer.android.com/wear/notifications/remote- input.html)[](http://developer.android.com/wear/design/user- interface.html#Stream)[](https://developers.google.com/maps/documentation/android- api/intro)\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-07-16版本翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n用户习惯于点击图标来启动应用程序，但是Android Wear不一样。一个典型的Wear应用程序会在一个情境的合适时刻插入一张卡片到信息流中。这张卡片可能会包含一个用于快速交互的按钮来打开一个全屏视图（在一些情况下，卡片也可能不会提供交互按钮）：\n以下是简单排序的构建模块。你可以使用其中的一个或者多个模块，但是我们强烈推荐不要构建这样的应用：用户在启动或者退出应用之前必须仔细考虑应该怎样响应一个指定的地点、活动、一天中某个具体的时间，或者是云端上发生的一些事情。\n信息流中的上下文卡片\nBridged notifications（桥接通知）是从手持设备上推送到穿戴设备上的通知，例如新的短信通知等等，它们使用的是的标准的Android通知。在穿戴设备上这种通知只需要少量甚至根本不需要任何代码。 Contextual Notifications（上下文通知）是在穿戴设备上本地生成的，并且只在相关的上下文时间点出现，比如当你跑步的时候出现一张锻炼身体的卡片。对比从手持设备上桥接过来的通知，你可以在这种类型的卡片上做的更多。 全屏应用\n2D Picker（二维选择器）是为了允许用户从一系列选项中做选择而设计的，比如选择艺术家和流派等等。每当有关联的时候，我们建议使用SDK中的预构建组件。 当基本的卡片后者信息流组件无法满足应用程序的时候，自定义布局也是被允许的。比如显示一张图片或者地图。 1、Bridged Notifications（桥接通知）# 在Android Wear上，这可以通过简单的途径来获取。实际上，你的应用如果使用了通知就已经完成了这一部分。你可以使用新的notification APIs像添加extra pages一样添加具体的穿戴特征或者支持语音回复。\nDEVELOPER DOCS Creating a Notification\n![](https://img- blog.csdn.net/20140716173457851)\n2、Contextual Notifications（上下文通知，情境通知）# Android Wear擅长处理这种事情：当用户需要的时候显示用户需要的信息和功能。\n以下是它的工作原理：你的应用程序知道什么时候与用户有所关联。当对应的事件发生的时候，应用程序将会触发一个通知。可能你正在设计一个跑步应用程序在用户跑步的时候使用。或者是一个博物馆导航程序在用户参观你的博物馆时候使用。查看设计指南获取更多关于如何让你的应用与上下文情境相关联。\n![](https://img- blog.csdn.net/20140716173736503)\n在适合的上下文情境中正确触发相应事件是非常重要的事情，也是你设计良好的用户体验所需要做的事情。\n实现这种通知最简单的方法就是使用Android Notifications的标准模板。当然，你也可以在卡片中整合一个Activity来实现自己的界面布局。如果你真的决定这么做，我们强烈建议你看一看风格指南以保证你使用与设备一致的风格。\n不要忘记测试你的应用程序的所有触发点。触发的次数太多会严重骚扰用户，以至于用户可能关闭你所有的通知。\nDEVELIPER DOCS Creating Custom Layouts\n3、2D Picker（二维选择器）# 二位选择器设计模型（可作为GridViewPager组件）非常适用于在列表中显示选项。Google搜索的搜索结果就是采用这种模型的好例子：\n这种模型可以用来显示一个单一的垂直列表，或者说是一维选择器。\n它也可以作为一个二维选项矩阵，作为显示分类选项的一种方法。\nActions# 关于每一张卡片的动作响应，使用Action cards pattern（模型）\nMaking it fast(让它运行更加流畅)# 以下是我们一些如何让二维选择器变得更加快速的建议：\n减少卡片的数量 在顶部显示最常用的卡片 让卡片尽可能保持简单 优化速度以超过定制 导航应该是先垂直后横向，而且不是先横向后垂直，并且限制垂直方向上的卡片不超过5张。\nExiting（退出）# 当用户做出选择之后，你应该关闭二维选择器。用户也可能通过将第一张卡片向下滑或者将最左边的卡片向右滑动来退出。\n4、Breaking out of the card(with custom layouts) （使用自定义布局突破卡片限制）# 有一些东西你没办法在卡片上显示。例如在地图上滑动一些路线或者使用摇杆控制游戏。这些情况下，快速跳转到全屏可能是一个不错的解决方案。\n在Android Wear上一个典型的全屏应用体验大致如下：\n你的上下文卡片插入到信息流中 用户点击卡片的动作按钮。 打开一个微型交互的全名Activity。 退出Activity并且用户回到信息流中。 When to go full screen（进入全屏的时机）# 我们强烈建议只有当你无法在一张卡片上处理你的事务时才跳转到全屏界面，并且在用户完成简单交互之后要快速退出全屏回到信息流中。这样才能让你的应用程序让用户感觉更像是系统的一部分。Android Wear本身在语音回复或者停止可视化的时候会进入全屏。\nMaking it distinct（让它与众不同）# 你的全屏界面不应该与卡片信息流很类似以免误导用户。如果你真的需要一个卡片风格的UI，应该考虑使用二维选择器。\nAutomatically exiting（自动退出）# 很多设备没有提供返回和主界面按钮，因此如何退出是你应该考虑的事情。以下是一些自然退出的例子：\n如果地图要求用户标注一个地点，当用户标注后应该就退出。 当一个小游戏完成之后自然退出。 一个动画应用可以在激活5秒钟之后退出。 Manually exiting（手动退出）# 存在着这样的一些逻辑退出情况，比如在一些情境下用户想要马上退出。这通常都是一些长时间运行的应用程序。在这种情况下使用DismissOverlayView，你应该处理长按事件以发送退出的Intent。\n","date":"July 16, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidwear-appstructureforandroidwear%E5%BA%94%E7%94%A8%E7%BB%93%E6%9E%84/","series":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/series/android-wear/"}],"smallImg":"","tags":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/tags/android-wear/"},{"title":"结构","url":"https://www.qinxiandiqi.sbs/tags/%E7%BB%93%E6%9E%84/"},{"title":"桥接通知","url":"https://www.qinxiandiqi.sbs/tags/%E6%A1%A5%E6%8E%A5%E9%80%9A%E7%9F%A5/"},{"title":"上下文通知","url":"https://www.qinxiandiqi.sbs/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E9%80%9A%E7%9F%A5/"},{"title":"全屏应用","url":"https://www.qinxiandiqi.sbs/tags/%E5%85%A8%E5%B1%8F%E5%BA%94%E7%94%A8/"}],"title":"Android Wear - App Structure for Android Wear（应用结构）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/categories/android-gradle/"}],"content":"原文地址：\u0026lt;http://tools.android.com/tech-docs/new-build-system/user-guide#TOC- Testing\u0026gt;\n# 5、Testing（测试）# 构建一个测试程序已经被集成到应用项目中，没有必要再专门建立一个测试项目。\n5.1 Basics and Configuration（基本知识和配置）# 正如前面所提到的，紧邻main sourceSet的就是androidTest sourceSet，默认路径在src/androidTest/下。\n在这个测试sourceSet中会构建一个使用Android测试框架，并且可以部署到设备上的测试apk来测试应用程序。这里面包含单元测试，集成测试，和后续UI自动化测试。\n这个测试sourceSet不应该包含AndroidManifest.xml文件，因为这个文件会自动生成。\n下面这些值可能会在测试应用配置中使用到：\n** * testPackageName**\n** * testInstrumentationRunner**\n** * testHandleProfiling**\n** * testfunctionalTest**\n正如前面所看到的，这些配置在defaultConfig对象中配置：\nandroid { defaultConfig { testPackageName \u0026quot;com.test.foo\u0026quot; testInstrumentationRunner \u0026quot;android.test.InstrumentationTestRunner\u0026quot; testHandleProfiling true testFunctionalTest true } } 在测试应用程序的manifest文件中，instrumentation节点的targetPackage属性值会自动使用测试应用的package名称设置，即使这个名称是通过defaultConfig或者Build Type对象自定义的。这也是manifest文件需要自动生成的一个原因。\n另外，这个测试sourceSet也可以拥有自己的依赖。\n默认情况下，应用程序和他的依赖会自动添加的测试应用的classpath中，但是也可以通过以下来扩展：\ndependencies { androidTestCompile 'com.google.guava:guava:11.0.2' } 测试应用通过assembleTest task来构建。assembleTest不依赖于main中的assemble task，需要手动设置运行，不能自动运行。\n目前只有一个Build Type被测试。默认情况下是debug Build Type，但是这也可以通过以下自定义配置：\nandroid { ... testBuildType \u0026quot;staging\u0026quot; } 5.2 Running tests（运行测试）# 正如前面提到的，标志性task connectedCheck要求一个连接的设备来启动。\n这个过程依赖于androidTest task，因此将会运行androidTest。这个task将会执行下面内容：\n** * 确认应用和测试应用都被构建（依赖于assembleDebug和assembleTest）。**\n** * 安装这两个应用。**\n** * 运行这些测试。**\n** * 卸载这两个应用。**\n如果有多于一个连接设备，那么所有测试都会同时运行在所有连接设备上。如果其中一个测试失败，不管是哪一个设备算失败。\n所有测试结果都被保存为XML文档，路径为：\n** build/androidTest-results**\n（这类似于JUnit的运行结果保存在build/test-results)\n同样，这也可以自定义配置：\nandroid { ... testOptions { resultsDir = \u0026quot;$project.buildDir/foo/results\u0026quot; } } 这里的android.testOptions.resultsDir将由Project.file(String)获得。\n5.3 Testing Android Libraries（测试Android库）# 测试Android库项目的方法与应用项目的方法类似。\n唯一的不同在于整个库（包括它的依赖）都是自动作为依赖库被添加到测试应用中。结果就是测试APK不单只包含它的代码，还包含了库项目自己和库的所有依赖。\n库的manifest被组合到测试应用的manifest中（作为一些项目引用这个库的壳）。\nandroidTest task的变改只是安装（或者卸载）测试APK（因为没有其它APK被安装）。\n其它的部分都是类似的。\n5.4 Test reports（测试报告）# 当运行单元测试的时候，Gradle会输出一份HTML格式的报告以方便查看结果。\nAndroid plugin也是基于此，并且扩展了HTML报告文件，它将所有连接设备的报告都合并到一个文件里面。\n5.4.1 Single projects（独立项目）# 一个项目将会自动生成测试运行。默认位置为： build/reports/androidTests\n这非常类似于JUnit的报告所在位置build/reports/tests，其它的报告通常位于build/reports//。\n这个路径也可以通过以下方式自定义：\nandroid { ... testOptions { reportDir = \u0026quot;$project.buildDir/foo/report\u0026quot; } } 报告将会合并运行在不同设备上的测试结果。\n5.4.2 Multi-projects reports（多项目报告）# 在一个配置了多个应用或者多个库项目的多项目里，当同时运行所有测试的时候，生成一个报告文件记录所有的测试可能是非常有用的。\n为了实现这个目的，需要使用同一个依赖文件（译注：指的是使用android gradle插件的依赖文件）中的另一个插件。可以通过以下方式添加：\nbuildscript { repositories { mavenCentral() } dependencies { classpath 'com.android.tools.build:gradle:0.5.6' } } apply plugin: 'android-reporting' 这必须添加到项目的根目录下，例如与settings.gradle文件同个目录的build.gradle文件中。\n之后，在命令行中导航到项目根目录下，输入以下命令就可以运行所有测试并合并所有报告：\ngradle deviceCheck mergeAndroidReports --continue 注意：这里的\u0026ndash; continue选项将允许所有测试，即使子项目中的任何一个运行失败都不会停止。如果没有这个选项，第一个失败测试将会终止全部测试的运行，这可能导致一些项目没有执行过它们的测试。\n5.5 Lint support（Lint支持，译者注：Lint是一个可以检查Android项目中存在的问题的工具）# 从0.7.0版本开始，你可以为项目中一个特定的Variant（变种）版本运行lint，也可以为所有Variant版本都运行lint。它将会生成一个报告描述哪一个Variant版本中存在着问题。\n你可以通过以下lint选项配置lint。通常情况下你只需要配置其中一部分，以下列出了所有可使用的选项：\nandroid { lintOptions { // set to true to turn off analysis progress reporting by lint quiet true // if true, stop the gradle build if errors are found abortOnError false // if true, only report errors ignoreWarnings true // if true, emit full/absolute paths to files with errors (true by default) //absolutePaths true // if true, check all issues, including those that are off by default checkAllWarnings true // if true, treat all warnings as errors warningsAsErrors true // turn off checking the given issue id's disable 'TypographyFractions','TypographyQuotes' // turn on the given issue id's enable 'RtlHardcoded','RtlCompat', 'RtlEnabled' // check *only* the given issue id's check 'NewApi', 'InlinedApi' // if true, don't include source code lines in the error output noLines true // if true, show all locations for an error, do not truncate lists, etc. showAll true // Fallback lint configuration (default severities, etc.) lintConfig file(\u0026quot;default-lint.xml\u0026quot;) // if true, generate a text report of issues (false by default) textReport true // location to write the output; can be a file or 'stdout' textOutput 'stdout' // if true, generate an XML report for use by for example Jenkins xmlReport false // file to write report to (if not specified, defaults to lint-results.xml) xmlOutput file(\u0026quot;lint-report.xml\u0026quot;) // if true, generate an HTML report (with issue explanations, sourcecode, etc) htmlReport true // optional path to report (default will be lint-results.html in the builddir) htmlOutput file(\u0026quot;lint-report.html\u0026quot;) // set to true to have all release builds run lint on issues with severity=fatal // and abort the build (controlled by abortOnError above) if fatal issues are found checkReleaseBuilds true // Set the severity of the given issues to fatal (which means they will be // checked during release builds (even if the lint target is not included) fatal 'NewApi', 'InlineApi' // Set the severity of the given issues to error error 'Wakelock', 'TextViewEdits' // Set the severity of the given issues to warning warning 'ResourceAsColor' // Set the severity of the given issues to ignore (same as disabling the check) ignore 'TypographyQuotes' } } ","date":"July 15, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidgradleplugin/androidgradleplugin%E6%8C%87%E5%8D%97%E5%9B%9B%E6%B5%8B%E8%AF%95/","series":[{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/series/android-gradle/"}],"smallImg":"","tags":[{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/tags/android-gradle/"},{"title":"gradle","url":"https://www.qinxiandiqi.sbs/tags/gradle/"},{"title":"自动化测试","url":"https://www.qinxiandiqi.sbs/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"title":"单元测试","url":"https://www.qinxiandiqi.sbs/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"title":"合并","url":"https://www.qinxiandiqi.sbs/tags/%E5%90%88%E5%B9%B6/"}],"title":"Android Gradle Plugin指南（四）——测试"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/categories/android-gradle/"}],"content":"原文地址：\u0026lt;http://tools.android.com/tech-docs/new-build-system/user-guide#TOC- Dependencies-Android-Libraries-and-Multi-project-setup\u0026gt;\n4、Dependencies，Android Libraries and Multi-project# setup（依赖关系，Android库和多项目设置）\nGradle项目可以依赖于其它组件。这些组件可以是外部二进制包，或者是其它的Gradle项目。\n4.1 Dependencies on binary packages（依赖二进制包）# 4.1.1 Local packages（本地包）# 配置一个外部库的jar包依赖，你需要在compile配置中添加一个依赖。\ndependencies { compile files('libs/foo.jar') } android { ... } 注意：这个dependencies DSL标签是标准Gradle API中的一部分，所以它不属于android标签。\n这个compile配置将被用于编译main application。它里面的所有东西都被会被添加到编译的classpath中，同时也会被打包进最终的APK。\n以下是添加依赖时可能用到的其它一些配置选项：\n** * compile：main application（主module）。**\n** * androidTestCompile：test application（测试module）。**\n** * debugCompile：debug Build Type（debug类型的编译）。**\n** * releaseCompile：release Build Type（发布类型的编译）。**\n因为没有可能去构建一个没有关联任何Build Type（构建类型）的APK，APK默认配置了两个或两个以上的编译配置：compile和Compile.\n创建一个新的Build Type将会自动创建一个基于它名字的新配置。\n这对于debug版本需要使用一个自定义库（为了反馈实例化的崩溃信息等）但发布版本不需要，或者它们依赖于同一个库的不同版本时会非常有用。\n4.2.2 Remote artifacts（远程文件）# Gradle支持从Maven或者Ivy仓库中拉取文件。\n首先必须将仓库添加到列表中，然后必须在依赖中声明Maven或者Ivy声明的文件。\nrepositories { mavenCentral() } dependencies { compile 'com.google.guava:guava:11.0.2' } android { ... } 注意：mavenCentral()是指定仓库URL的简单方法。Gradle支持远程和本地仓库。\n注意：Gradle会遵循依赖关系的传递性。这意味着如果一个依赖本身依赖于其它东西，这些东西也会一并被拉取回来。\n更多关于设置依赖关系的信息，请参考Gradle用户指南和DSL文档。\n4.2 Multi project setup（多项目设置）# Gradle项目也可以通过使用多项目配置依赖于其它Gradle项目。\n多项目配置的实现通常是在一个根项目路径下将所有项目作为子文件夹包含进去。\n例如，给定以下项目结构：\nMyProject/ + app/ + libraries/ + lib1/ + lib2/ 我们可以定义3个项目。Grand将会按照以下名字映射它们：\n** :app**\n** :libraries:lib1**\n** :libraries:lib2**\n每一个项目都拥有自己的build.gradle文件来声明自己如何构建。\n另外，在根目录下还有一个setting.gradle文件用于声明所有项目。\n这些文件的结构如下：\nMyProject/ | settings.gradle + app/ | build.gradle + libraries/ + lib1/ | build.gradle + lib2/ | build.gradle 其中setting.gradle的内容非常简单：\ninclude ':app', ':libraries:lib1', ':libraries:lib2' 这里定义了哪一个文件夹才是真正的Gradle项目。\n其中:app项目可能依赖于这些库，这是通过以下依赖配置声明的：\ndependencies { compile project(':libraries:lib1') } 更多关于多项目配置的信息请参考这里。\n4.3 Library projects（库项目）# 在上面的多项目配置中，:libraries:lib1和:libraries:lib2可能是一个Java项目，并且:app这个Android项目将会使用它们的jar包输出。\n但是，如果你想要共享代码来访问Android API或者使用Android样式的资源，那么这些库就不能是通常的Java项目，而应该是Android库项目。\n4.3.1 Creating a Library Project（创建一个库项目）# 一个库项目与通常的Android项目非常类似，只是有一点小区别。\n尽管构建库项目不同于构建应用程序，它们使用了不同的plugin。但是在内部这些plugin共享了大部分相同的代码，并且它们都由相同的com.android.tools.build.gradle.jar提供。\nbuildscript { repositories { mavenCentral() } dependencies { classpath 'com.android.tools.build:gradle:0.5.6' } } apply plugin: 'android-library' android { compileSdkVersion 15 } 这里创建了一个使用API 15编译SourceSet的库项目，并且依赖关系的配置方法与应用程序项目的配置方法一样，同样也支持自定义配置。\n4.3.2 Differences between a Project and a Library Project（普通项目和库项目之间的区别）# 一个库项目的main输出是一个.aar包（它代表Android的归档文件）。它组合了编译代码（例如jar包或者是本地的.so文件）和资源（manifest，res，assets）。\n一个库项目同样也可以独立于应用程序生成一个测试用的apk来测试。\n标识Task同样适用于库项目（assembleDebug，assembleRelease），因此在命令行上与构建一个项目没有什么不同。\n其余的部分，库项目与应用程序项目一样。它们都拥有build type和product flavor，也可以生成多个aar版本。\n记住大部分Build Type的配置不适用于库项目。但是你可以根据库项目是否被其它项目使用或者是否用来测试来使用自定义的sourceSet改变库项目的内容。\n4.3.3 Referencing a Library（引用一个库项目）# 引用一个库项目的方法与引用其它项目的方法一样：\ndependencies { compile project(':libraries:lib1') compile project(':libraries:lib2') } 注意：如果你要引用多个库，那么排序将非常重要。这类似于旧构建系统里面的project.properties文件中的依赖排序。\n4.3.4 Library Publication（库项目发布）# 一般情况下一个库只会发布它的release Variant（变种）版本。这个版本将会被所有引用它的项目使用，而不管它们本身自己构建了什么版本。这是由于Gradle的限制，我们正在努力消除这个问题，所以这只是临时的限制。\n你可以控制哪一个Variant版本作为发行版：\nandroid { defaultPublishConfig \u0026quot;debug\u0026quot; } 注意这里的发布配置名称引用的是完整的Variant版本名称.Relesae，debug只适用于项目中没有其它特性版本的时候使用。如果你想要使用其它Variant版本取代默认的发布版本，你可以：\nandroid { defaultPublishConfig \u0026quot;flavor1Debug\u0026quot; } 将库项目的所有Variant版本都发布也是可能的。我们计划在一般的项目依赖项目（类似于上述所说的）情况下允许这种做法，但是由于Gradle的限制（我们也在努力修复这个问题）现在还不太可能。\n默认情况下没有启用发布所有Variant版本。可以通过以下启用：\nandroid { publishNonDefault true } 理解发布多个Variant版本意味着发布多个arr文件而不是一个arr文件包含所有Variant版本是非常重要的。每一个arr包都包含一个单一的Variant版本。\n发布一个变种版本意味着构建一个可用的arr文件作为Gradle项目的输出文件。无论是发布到一个maven仓库，还是其它项目需要创建一个这个库项目的依赖都可以使用到这个文件。\nGradle有一个默认文件的概念。当添加以下配置后就会被使用到：\ncompile project(':libraries:lib2') 创建一个其它发布文件的依赖，你需要指定具体使用哪一个：\ndependencies { flavor1Compile project(path: ':lib1', configuration: 'flavor1Release') flavor2Compile project(path: ':lib1', configuration: 'flavor2Release') } 重要：注意已发布的配置是一个完整的Variant版本，其中包括了build type，并且需要像以上一样被引用。\n重要：当启用非默认发布，maven发布插件将会发布其它Variant版本作为扩展包（按分类器分类）。这意味着不能真正的兼容发布到maven仓库。你应该另外发布一个单一的Variant版本到仓库中，或者允许发布所有配置以支持跨项目依赖。\n","date":"July 14, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidgradleplugin/androidgradleplugin%E6%8C%87%E5%8D%97%E4%B8%89%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BBandroid%E5%BA%93%E5%92%8C%E5%A4%9A%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/","series":[{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/series/android-gradle/"}],"smallImg":"","tags":[{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/tags/android-gradle/"},{"title":"依赖关系","url":"https://www.qinxiandiqi.sbs/tags/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/"},{"title":"库项目","url":"https://www.qinxiandiqi.sbs/tags/%E5%BA%93%E9%A1%B9%E7%9B%AE/"},{"title":"多项目配置","url":"https://www.qinxiandiqi.sbs/tags/%E5%A4%9A%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/"}],"title":"Android Gradle Plugin指南（三）——依赖关系、android库和多项目配置"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/categories/android-gradle/"}],"content":"原文地址：\u0026lt;http://tools.android.com/tech-docs/new-build-system/user-guide#TOC- Basic-Project\u0026gt;\n3、Basic Project（基本项目）# 一个Gradle项目的构建过程定义在build.gradle文件中，位于项目的根目录下。\n3.1 Simple build files（简单的构建文件）# 一个最简单的Gradle纯Java项目的build.gradle文件包含以下内容：\napply plugin: 'java' 这里引入了Gradle的Java插件。这个插件提供了所有构建和测试Java应用程序所需要的东西。\n最简单的Android项目的build.gradle文件包含以下内容：\nbuildscript { repositories { mavenCentral() } dependencies { classpath 'com.android.tools.build:gradle:0.11.1' } } apply plugin: 'android' android { compileSdkVersion 19 buildToolsVersion \u0026quot;19.0.0\u0026quot; } 这里包括了Android build file的3个主要部分：\nbuildscrip{\u0026hellip;}这里配置了驱动构建过程的代码。\n在这个部分，它声明了使用Maven仓库，并且声明了一个maven文件的依赖路径。这个文件就是包含了0.11.1版本android gradle插件的库。\n注意：这里的配置只影响控制构建过程的代码，不影响项目源代码。项目本身需要声明自己的仓库和依赖关系，稍后将会提到这部分。\n接下来，跟前面提到的Java Plugin一样添加了android plugin。\n最后，andorid{\u0026hellip;}配置了所有android构建过程需要的参数。这里也是Android DSL的入口点。\n默认情况下，只需要配置目标编译SDK版本和编译工具版本，即compileSdkVersion和buildToolsVersion属性。\n这个complieSdkVersion属性相当于旧构建系统中project.properites文件中的target属性。这个新的属性可以跟旧的target属性一样指定一个int或者String类型的值。\n重要：你只能添加android plugin。同时添加java plugin会导致构建错误。\n注意：你同样需要在相同路径下添加一个local.properties文件，并使用sdk.dir属性来设置SDK路径。\n另外，你也可以通过设置ANDROID_HOME环境变量，这两种方式没有什么不同，根据你自己的喜好选择其中一种设置。\n3.2 Project Structure（项目结构）# 上面提到的基本的构建文件需要一个默认的文件夹结构。Gradle遵循约定优先于配置的概念，在可能的情况尽可能提供合理的默认配置参数。\n基本的项目开始于两个名为“source sets”的组件，即main source code和test code。它们分别位于：\n** * src/main/\n* src/androidTest/**\n里面每一个存在的文件夹对应相应的源组件。\n对于Java plugin和Android plugin来说，它们的Java源代码和资源文件路径如下：\n*** java/\n* resources/**\n但对于Android plugin来说，它还拥有以下特有的文件和文件夹结构：\n** * AndroidManifest.xml\n* res/\n* assets/\n* aidl/\n* rs/\n* jni/**\n注意：src/androidTest/AndroidManifest.xml是不需要的，它会自动被创建。\n3.2.1 Configuring the Structure（配置项目结构）\n当默认的项目结构不适用的时候，你可能需要去配置它。根据Gradle文档，重新为Java项目配置sourceSets可以使用以下方法：\nsourceSets { main { java { srcDir 'src/java' } resources { srcDir 'src/resources' } } } 注意：srcDir将会被添加到指定的已存在的源文件夹中（这在Gradle文档中没有提到，但是实际上确实会这样执行）。\n替换默认的源代码文件夹，你可能想要使用能够传入一个路径数组的srcDirs来替换单一的srcDir。以下是使用调用对象的另一种不同方法：\nsourceSets { main.java.srcDirs = ['src/java'] main.resources.srcDirs = ['src/resources'] } 想要获取更多信息，可以参考Gradle文档中关于Java Pluign的部分。\nAndroid Plugin使用的是类似的语法。但是由于它使用的是自己的sourceSets，这些配置将会被添加在android对象中。\n以下是一个示例，它使用了旧项目结构中的main源码，并且将androidTest sourceSet组件重新映射到tests文件夹。\nandroid { sourceSets { main { manifest.srcFile 'AndroidManifest.xml' java.srcDirs = ['src'] resources.srcDirs = ['src'] aidl.srcDirs = ['src'] renderscript.srcDirs = ['src'] res.srcDirs = ['res'] assets.srcDirs = ['assets'] } androidTest.setRoot('tests') } } 注意：由于旧的项目结构将所有的源文件（java,aidl,renderscripthe和java资源文件）都放在同一个目录里面，所以我们需要将这些sourceSet组件重新映射到src目录下。\n注意：setRoot()方法将移动整个组件（包括它的子文件夹）到一个新的文件夹。示例中将会移动scr/androidTest/*到tests/*下。\n以上这些是Android特有的，如果配置在Java的sourceSets里面将不会有作用。\n以上也是将旧构建系统项目迁移到新构建系统需要做的迁移工作。\n3.3 Build Tasks（构建任务）# 3.3.1 General Tasks（通用任务）# 添加一个插件到构建文件中将会自动创建一系列构建任务( build tasks )去执行（注：gradle属于任务驱动型构建工具，它的构建过程是基于Task的）。Java plugin和Android plugin都会创建以下task：\n** * assemble：这个task将会组合项目的所有输出。\n** * check：这个task将会执行所有检查。\n*** build： 这个task将会执行assemble和check两个task的所有工作\n*** clean： 这个task将会清空项目的输出。\n实际上assemble，check，build这三个task不做任何事情。它们只是一个Task标志，用来告诉android plugin添加实际需要执行的task去完成这些工作。\n这就允许你去调用相同的task，而不需要考虑当前是什么类型的项目，或者当前项目添加了什么plugin。\n例如，添加了findbugs plugin将会创建一个新的task并且让check task依赖于这个新的task。当check task被调用的时候，这个新的task将会先被调用。\n在命令行环境中，你可以执行以下命令来获取更多高级别的task：\ngradle tasks 查看所有task列表和它们之间的依赖关系可以执行以下命令：\ngradle tasks --all 注意：Gradle会自动监视一个task声明的所有输入和输出。\n两次执行build task并且期间项目没有任何改动，gradle将会使用UP-TO- DATE通知所有task。这意味着第二次build执行的时候不会请求任何task执行。这允许task之间互相依赖，而不会导致不需要的构建请求被执行。\n3.3.2 Java project tasks（Java项目的Task）# Java plugin主要创建了两个task，依赖于main task（一个标识性的task）：\n*** assemble\n* jar：**这个task创建所有输出\n** * check\n* test：**这个task执行所有的测试。\njar task自身直接或者间接依赖于其他task：classes task将会被调用于编译java源码。\ntestClasses task用于编译测试，但是它很少被调用，因为test task依赖于它（类似于classes task）。\n通常情况下，你只需要调用到assemble和check，不需要其他task。\n你可以在Gradle文档中查看java plugin的全部task。\n3.3.3 Android tasks# Android plugin使用相同的约定以兼容其他插件，并且附加了自己的标识性task，包括：\n*** assemble：** 这个task用于组合项目中的所有输出。\n** * check：**这个task用于执行所有检查。\n** * connectedCheck：**这个task将会在一个指定的设备或者模拟器上执行检查，它们可以同时在所有连接的设备上执行。\n** * deviceCheck：**通过APIs连接远程设备来执行检查，这是在CL服务器上使用的。\n** * build：**这个task执行assemble和check的所有工作。\n** * clean：**这个task清空项目的所有输出。\n这些新的标识性task是必须的，以保证能够在没有设备连接的情况下执行定期检查。\n注意build task不依赖于deviceCheck或者connectedCheck。\n一个Android项目至少拥有两个输出：debug APK（调试版APK)和release APK（发布版APK）。每一个输出都拥有自己的标识性task以便能够单独构建它们。\n** * assemble：\n* assembleDebug\n* assembleRelease**\n它们都依赖于其它一些tasks以完成构建一个APK需要多个步骤。其中assemble task依赖于这两个task，所以执行assemble将会同时构建出两个APK。\n小提示：gradle在命令行终端上支持骆驼命名法的task简称，例如，执行gradle aR命令等同于执行gradle assembleRelease。\ncheck task也拥有自己的依赖：\n** * check：\n* lint\n* connectedCheck：\n* connectedAndroidTest\n* connectedUiAutomatorTest(目前还没有应用到）\n* deviceCheck: **这个test依赖于test创建时，其它实现测试扩展点的插件。\n最后，只要task能够被安装（那些要求签名的task），android plugin就会为所有构建类型（debug，release，test）安装或者卸载。\n3.4 Basic Build Customization（基本的构建定制）# Android plugin提供了大量DSL用于直接从构建系统定制大部分事情。\n3.4.1 Manifest entries （Manifest属性）# 通过SDL可以配置一下manifest选项：\n** * minSdkVersion\n* targetSdkVersion\n* versionName\n* packageName\n* package Name for the test application\n* Instrumentation test runner**\n例如：\nandroid { compileSdkVersion 19 buildToolsVersion \u0026quot;19.0.0\u0026quot; defaultConfig { versionCode 12 versionName \u0026quot;2.0\u0026quot; minSdkVersion 16 targetSdkVersion 16 } } 在android元素中的defaultConfig元素中定义所有配置。\n之前的Android Plugin版本使用packageName来配置manifest文件中的packageName属性。从0.11.0版本开始，你需要在build.gradle文件中使用applicationId来配置manifest文件中的packageName属性。\n这是为了消除应用程序的packageName（也是程序的ID）和java包名所引起的混乱。\n在构建文件中定义的强大之处在于它是动态的。\n例如，可以从一个文件中或者其它自定义的逻辑代码中读取版本信息：\ndef computeVersionName() { ... } android { compileSdkVersion 19 buildToolsVersion \u0026quot;19.0.0\u0026quot; defaultConfig { versionCode 12 versionName computeVersionName() minSdkVersion 16 targetSdkVersion 16 } } 注意：不要使用与在给定范围内的getter方法可能引起冲突的方法名。例如，在defaultConfig{\u0026hellip;}中调用getVersionName()将会自动调用defaultConfig.getVersionName()方法，你自定义的getVersionName()方法就被取代掉了。\n如果一个属性没有使用DSL进行设置，一些默认的属性值将会被使用。以下表格是可能使用到的值：\nProperty Name Default value in DSL object Default value versionCode -1 value from manifest if present versionName null value from manifest if present minSdkVersion -1 value from manifest if present targetSdkVersion -1 value from manifest if present packageName packageName value from manifest if present testPackageName null app package name + “.test” testInstrumentationRunner null android.test.InstrumentationTestRunner signingConfig null null proguardFile N/A (set only) N/A (set only) proguardFiles N/A (set only) N/A (set only) 如果你在构建脚本中使用自定义代码逻辑请求这些属性，那么第二列的值将非常重要。例如，你可能会写：\nif (android.defaultConfig.testInstrumentationRunner == null) { // assign a better default... } 如果这个值一直保持null，那么在构建执行期间将会实际替换成第三列的默认值。但是在DSL元素中并没有包含这个默认值，所以，你无法查询到这个值。\n除非是真的需要，这是为了预防解析应用的manifest文件。\n3.4.2 Build Types（构建类型）# 默认情况下，Android Plugin会自动给项目设置同时构建应用程序的debug和release版本。\n两个版本之间的不同主要围绕着能否在一个安全设备上调试，以及APK如何签名。\nDebug版本采用使用通用的name/password键值对自动创建的数字证书进行签名，以防止构建过程中出现请求信息。Release版本在构建过程中没有签名，需要稍后再签名。\n这些配置通过一个BuildType对象来配置。默认情况下，这两个实例都会被创建，分别是一个debug版本和一个release版本。\nAndroid plugin允许像创建其他构建类型一样定制debug和release实例。这需要在buildTypes的DSL容器中配置：\nandroid { buildTypes { debug { applicationIdSuffix \u0026quot;.debug\u0026quot; } jnidebug.initWith(buildTypes.debug) jnidebug { packageNameSuffix \u0026quot;.jnidebug\u0026quot; jnidebugBuild true } } } 以上代码片段实现了以下功能：\n* 配置默认的debug构建类型：将debug版本的包名设置为.debug以便能够同时在一台设备上安装debug和release版本的apk。\n* 创建了一个名为“jnidebug”的新构建类型，并且这个构建类型是debug构建类型的一个副本。\n* 继续配置jnidebug构建类型，允许使用JNI组件，并且也添加了不一样的包名后缀。\n创建一个新的构建类型就是简单的在buildType标签下添加一个新的元素，并且可以使用initWith()或者直接使用闭包来配置它。\n以下是一些可能使用到的属性和默认值：\nProperty name Default values for debug Default values for release / other debuggable debuggable false jniDebugBuild false false renderscriptDebugBuild false false renderscriptOptimLevel 3 3 packageNameSuffix null null versionNameSuffix null null signingConfig android.signingConfigs.debug null zipAlign false true runProguard false false proguardFile N/A (set only) N/A (set only) proguardFiles N/A (set only) N/A (set only) 除了以上属性之外，Build Type还会受项目源码和资源影响：\n对于每一个Build Type都会自动创建一个匹配的sourceSet。默认的路径为：\nsrc/\u0026lt;buildtypename\u0026gt;/ 这意味着BuildType名称不能是main或者androidTest（因为这两个是由plugin强制实现的），并且他们互相之间都必须是唯一的。\n跟其他sourceSet设置一样，Build Type的source set路径可以重新被定向：\nandroid { sourceSets.jnidebug.setRoot('foo/jnidebug') } 另外，每一个Build Type都会创建一个新的assemble任务。\nassembleDebug和assembleRelease两个Task在上面已经提到过，这里要讲这两个Task从哪里被创建。当debug和release构建类型被预创建的时候，它们的tasks就会自动创建对应的这个两个Task。\n上面提到的build.gradle代码片段中也会实现assembleJnidebug task，并且assemble会像依赖于assembleDebug和assembleRelease一样依赖于assembleJnidebug。\n提示：你可以在终端下输入gradle aJ去运行assembleJnidebug task。\n可能会使用到的情况：\n** * release模式不需要，只有debug模式下才使用到的权限\n* 自定义的debug实现\n* 为debug模式使用不同的资源（例如当资源的值由绑定的证书决定）**\nBuildType的代码和资源通过以下方式被使用：\n** * manifest将被混合进app的manifest\n* 代码行为只是另一个资源文件夹\n* 资源将叠加到main的资源中，并替换已存在的资源。**\n3.4.3 signing configurations（签名配置）# 对一个应用程序签名需要以下：\n** * 一个Keystory\n* 一个keystory密码\n* 一个key的别名\n* 一个key的密码\n* 存储类型**\n位置，键名，两个密码，还有存储类型一起形成了签名配置。\n默认情况下，debug被配置成使用一个debug keystory。debug keystory使用了默认的密码和默认key及默认的key密码。\ndebug keystory的位置在$HOME/.android/debug.keystroe，如果对应位置不存在这个文件将会自动创建一个。\ndebug构建类型会自动使用debug签名配置。\n可以创建其他配置或者自定义内建的默认配置。通过signingConfigs这个DSL容器来配置：\nandroid { signingConfigs { debug { storeFile file(\u0026quot;debug.keystore\u0026quot;) } myConfig { storeFile file(\u0026quot;other.keystore\u0026quot;) storePassword \u0026quot;android\u0026quot; keyAlias \u0026quot;androiddebugkey\u0026quot; keyPassword \u0026quot;android\u0026quot; } } buildTypes { foo { debuggable true jniDebugBuild true signingConfig signingConfigs.myConfig } } } 以上代码片段修改debug keystory的路径到项目的根目录下。在这个例子中，这将自动影响其他使用到debug构建类型的构建类型。\n这里也创建了一个新的Single Config（签名配置）和一个使用这个新签名配置的新的Build Type（构建类型）。\n注意：只有默认路径下的debug keystory不存在时会被自动创建。更改debug keystory的路径并不会自动在新路径下创建debug keystory。如果创建一个新的不同名字的SignConfig，但是使用默认的debug keystore路径来创建一个非默认的名字的SigningConing，那么还是会在默认路径下创建debug keystory。换句话说，会不会自动创建是根据keystory的路径来判断，而不是配置的名称。\n注意：虽然经常使用项目根目录的相对路径作为keystore的路径，但是也可以使用绝对路径，尽管这并不推荐（除了自动创建出来的debug keystore）。\n注意：如果你将这些文件添加到版本控制工具中，你可能不希望将密码直接写到这些文件中。下面Stack Overflow链接提供从控制台或者环境变量中获取密码的方法：\n\u0026lt;http://stackoverflow.com/questions/18328730/how-to-create-a-release-signed- apk-file-using-gradle\u0026gt;\n我们以后还会在这个指南中添加更多的详细信息。\n3.4.4 Running Proguard（运行 Proguard）# 从Gradle Plugin for ProGuard version 4.10之后就开始支持ProGuard。ProGuard插件是自动添加进来的。如果Build Type的runProguard属性被设置为true，对应的task将会自动创建。\nandroid { buildTypes { release { runProguard true proguardFile getDefaultProguardFile('proguard-android.txt') } } productFlavors { flavor1 { } flavor2 { proguardFile 'some-other-rules.txt' } } } 发布版本将会使用它的Build Type中声明的规则文件，product flavor（定制的产品版本）将会使用对应flavor中声明的规则文件。\n这里有两个默认的规则文件：\n** * proguard-android.txt\n* proguard-android-optimize.txt**\n这两个文件都在SDK的路径下。使用getDefaultProguardFile()可以获取这些文件的完整路径。它们除了是否要进行优化之外，其它都是相同的。\n[](http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Basic- Project)\n","date":"July 14, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidgradleplugin/androidgradleplugin%E6%8C%87%E5%8D%97%E4%BA%8C%E5%9F%BA%E6%9C%AC%E9%A1%B9%E7%9B%AE/","series":[{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/series/android-gradle/"}],"smallImg":"","tags":[{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/tags/android-gradle/"},{"title":"项目结构","url":"https://www.qinxiandiqi.sbs/tags/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"},{"title":"Build Task","url":"https://www.qinxiandiqi.sbs/tags/build-task/"},{"title":"Build Type","url":"https://www.qinxiandiqi.sbs/tags/build-type/"},{"title":"签名配置","url":"https://www.qinxiandiqi.sbs/tags/%E7%AD%BE%E5%90%8D%E9%85%8D%E7%BD%AE/"}],"title":"Android Gradle Plugin指南（二）——基本项目"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/categories/android-gradle/"}],"content":"原文地址：\u0026lt;http://tools.android.com/tech-docs/new-build-system/user-guide#TOC- Introduction\u0026gt;\n译者：google推出了全新的Android Studio集成开发环境，其中Android项目的结构与Eclipse的Android项目结构有很大的区别，原因就在于两开发环境使用的构建工具不同。Android Studio使用Gradle构建工具，Eclipse的ADT插件使用的是Ant构建工具。因为两个构建工具的区别，导致习惯了Eclipse开发环境的开发者刚开始比较难适应Android Studio。如果要迁移到Android Studio，建议最好了解下Gradle构建工具。Gradle构建工具是任务驱动型的构建工具，并且可以通过各种Plugin插件扩展功能以适应各种构建任务。对应Android项目的Gradle插件就是Android Gradle Plugin。本文是Google官方的Android Gradle Plugin使用指南翻译，以方便我大天朝开发者学习。如英语水平还不错的同学，建议直接查看官方原文，本人的理解和翻译难免有所疏漏。\n1、Introduction（简介）# 本文档适用于0.9版本的Gradle plugin。由于我们在1.0版本之前介绍的不兼容，所以早期版本可能与本文档有所不同。\n1.1 Goals of the new Build System（gradle构建系统的目标）# 采用Gradle作为新构建系统的目标：\n***** 让重用代码和资源变得更加容易。\n** * **让创建同一应用程序的不同版本变得更加容易，无论是多个apk发布版本还是同一个应用的不同定制版本。\n** *** 让构建过程变得更加容易配置，扩展和定制。\n***** 整合优秀的IDE\n1.2 Why Gradle？（为什么使用gradle）# Gradle是一个优秀的构建系统和构建工具，它允许通过插件创建自定义的构建逻辑。\n我们基于Gradle以下的一些特点而选择了它：\n** *** 采用了Domain Specific Language(DSL语言)来描述和控制构建逻辑。\n***** 构建文件基于Groovy，并且允许通过混合声明DSL元素和使用代码来控制DSL元素以控制自定义的构建逻辑。\n***** 支持Maven或者Ivy的依赖管理。\n** *** 非常灵活。允许使用最好的实现，但是不会强制实现的方式。\n** * **插件可以提供自己的DSL和API以供构建文件使用。\n** * **良好的API工具供IDE集成。\n2、Requirements（要求）# ***** Gradle 1.10 或者 Gradle 1.11 或者 Gradle 1.12，并使用0.11.1插件版本。 ** * **SDK build tools 要求版本19.0.0。一些新的特征可能需要更高版本。\n[](http://tools.android.com/tech-docs/new-build-system/user-guide#TOC- Introduction)\n","date":"July 14, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidgradleplugin/androidgradleplugin%E6%8C%87%E5%8D%97%E4%B8%80%E7%AE%80%E4%BB%8B/","series":[{"title":"Android Gradle","url":"https://www.qinxiandiqi.sbs/series/android-gradle/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"gradle","url":"https://www.qinxiandiqi.sbs/tags/gradle/"},{"title":"groovy","url":"https://www.qinxiandiqi.sbs/tags/groovy/"},{"title":"插件","url":"https://www.qinxiandiqi.sbs/tags/%E6%8F%92%E4%BB%B6/"},{"title":"文档","url":"https://www.qinxiandiqi.sbs/tags/%E6%96%87%E6%A1%A3/"}],"title":"Android Gradle Plugin指南（一）——简介"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Ant","url":"https://www.qinxiandiqi.sbs/categories/ant/"}],"content":"1、Ant（another neat tool）是一个基于Java的生成工具，其作用类似于命令的批处理，通过设置一个xml文件后，Ant将会执行xml文件中指定的系列命令。这对于随着应用程序的生成过程变得更加复杂，又需要确保在每次生成期间都使用精确相同的生成步骤，同时实现尽可能多的自动化，以便于及时产生一致的生成版本非常重要。\n2、Ant是基于命令行操作的。单纯使用ant命令时，Ant将会在使用命令的文件夹内寻找默认的build.xml配置文件执行预定义的系列命令操作，如果不存在build.xml文件则会提示Build ailed生成失败。ant命令后也可直接显示指定xml文件，如ant -f hello.xml来显示使用hello.xml配置文件执行系列命令。\n3、Ant最基本的xml文件格式：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot; ?\u0026gt; \u0026lt;project default=\u0026quot;defaName\u0026quot;\u0026gt; \u0026lt;target name=\u0026quot;defaName\u0026quot;\u0026gt; \u0026lt;mkdir dir=\u0026quot;helloworld\u0026quot; /\u0026gt; \u0026lt;delete dir=\u0026quot;helloworld\u0026quot; /\u0026gt; \u0026lt;/target\u0026gt; \u0026lt;/project\u0026gt; 1）Ant的xml文件中根元素为project，一般都必须有属性default，其属性值为一个子元素target的属性name的属性值，表示该target为此project的默认执行目标。 2）子元素target为一个Ant需要执行的命令目标，需要属性name来确定一个target，一个project中可以有多个target。每个target的子元素为需要执行的系列命令，如\u0026lt;mkdir dir=\u0026quot;\u0026quot;/\u0026gt;创建一个文件夹，\u0026lt;delete dir=\u0026quot;\u0026quot;/\u0026gt;删除一个文件夹。 4、使用Ant推荐将一次生成过程分割为多个target去完成以提高生成的灵活性。\n5、Ant执行一个xml中的project只会执行project中属性名为project标签default值的target，比如project的default=\u0026ldquo;first\u0026rdquo;，那么整个xml只会执行name值为“first”的target。如果要连续执行多个target的话，需要在target添加属性depends，其属性值为另一个target的name值，这么一来当Ant执行这个target时就会先执行其depends指定的另一个target。\n6、使用ant命令也可以显式指定需要执行的target。在ant命令最后添加上需要执行的target的name值（多个target使用空格隔开），Ant就会依次执行指定的每一个target（此时不再自动执行默认的target）.\n7、Ant的xml其它标签和属性：\n1）\u0026lt;description\u0026gt;\u0026lt;/description\u0026gt;其中包含的标签内容为注释内容。 2）project可带属性name，表示该project的名称。 3）Ant的xml标签可带属性description，属性值为该标签的说明。 8、Ant中的属性类似于编程语言中的属性，但是Ant中的属性赋值后就不能再改变，因为Ant只是一个生成工具。\n9、Ant的属性一旦被设定，值就不能再改变。\n1）定义Ant属性的方法：\n2）使用Ant属性的方法：${hell0}，中括号内为属性名，整个表达式为属性值。该表达式可以插入到任何使用值的地方。\n3）location属性：其值用于表示一个路径字符串，特点是字符串中的分隔符\u0026quot;/\u0026ldquo;或\u0026rdquo;\u0026quot;会自动根据不同的操作系统平台自动选用相应的分隔符。\n10、Ant的xml中target的属性depends值表示需要先执行的其它target的name，如果有多个target需要先执行，则depends值的多个target的name值需要使用\u0026quot;,\u0026ldquo;来分隔。\n11、Eclipse中集成了Ant工具，在项目中创建build.xml文档，Eclipse将会自动识别为Ant配置文档，可以使用ant执行并在控制台输出执行产生的信息。如果Eclipse没有识别出build.xml，则需要在window- preferences-General-Editors-File Associations中创建build.xml文档类型，并为其选择默认编辑器为Ant Editor。\n12、Ant执行后生成的文档一般在xml配置文档所在的目录中，也可以显示指定生成文档目录，在xml文档的project标签中添加属性basedir，其值为需要指定的文档目录路径（当值为\u0026rdquo;.\u0026ldquo;时表示当前目录）。\n13、Eclipse提供了Ant视图。\n14、ant命令的另一个选项“-D”用于对Ant属性进行初始化赋值。如ant -Dmetal=beryllium将会在执行build.xml中任务之间将build.xml中的属性metal赋值为beryllium。如果build.xml已经给metal赋值，那么新的值将覆盖旧的值。\n15、Ant可执行命令：\n1）：java源文件编译命令，将src目录下所有的源文件进行编译，编译后的class文件存放于dest目录下。如果没有指定属性destdir，则默认将编译好的class存放于源文件所在目录中。可带属性classpath（等价于javac的-classpath选项）和debug=\u0026ldquo;true\u0026rdquo;（指示编译器应该带调试信息编译源文件）。另外，该命令只编译需要编译的源文件，如果源文件已经编译过并且没有发生改变，Ant不会再对该源文件进行编译，而是跳过。\n2）\n\u0026lt;jar destfile=\u0026quot;...dist.jar\u0026quot; basedir=\u0026quot;classes\u0026quot;\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;attribute name=\u0026quot;Main-Class\u0026quot; value=\u0026quot;mainclasspath\u0026quot;/\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/jar\u0026gt; 将编译好的class类文件打包命令，classes文件夹中的所有class文件将被打包到dist.jar文件中，并且manifest向jar文件中的MANIFEST.MF文件添加属性Main-Class和属性值mainclasspath（完整的类名），指定了jar文件含main的类（可以执行的jar文件所需）。 3）\u0026lt;tstamp/\u0026gt;：初始化在生成环境中使用当前的时间和日期，之后可以使用Ant属性DSTAMP（设置当前日期，默认格式为YYYYMMDD）、TSTAMP（设置为当前时间，默认格式为HHMM）、TODAY（设置为当前日期，带完整年份，如2012年10月01日）。 4）\u0026lt;mkdir dir=\u0026quot;newdir\u0026quot;/\u0026gt;：创建新目录newdir，如果父目录不存在则连同父目录一并创建，如果目录已经存在则忽略不执行。 5）\u0026lt;delete dir=\u0026quot;olddir\u0026quot;/\u0026gt;：删除文件夹olddir。 6）\u0026lt;delete file=\u0026quot;oldfile\u0026quot;/\u0026gt;：删除文件oldfile。 7）\u0026lt;copy file=\u0026quot;srcfile\u0026quot; tofile=\u0026quot;destfile\u0026quot;/\u0026gt;：复制文件srcfile到destfile，destfile为目标文件名（可以与原文件名不一致）。 8）\u0026lt;copu file=\u0026quot;srcfile\u0026quot; todir=\u0026quot;destdir\u0026quot;/\u0026gt;：复制文件srcfile到destdir目标文件夹，复制后的文件名与原文件名一致。 9）\u0026lt;move file=\u0026quot;srcfile\u0026quot; tofile=\u0026quot;destfile\u0026quot;/\u0026gt;：移动文件srcfile到destfile目标文件（名字可以不一致）。 10）\u0026lt;move file=\u0026quot;srcfile\u0026quot; todir=\u0026quot;destdir\u0026quot;/\u0026gt;：移动文件srcfile到destdir目标文件夹。 11）\u0026lt;zip destfile=\u0026quot;output.zip\u0026quot; basedir=\u0026quot;output\u0026quot; /\u0026gt;：将文件夹output中的所有文件打包压缩到文件output.zip文件中。 12）\u0026lt;unzip dest=\u0026quot;destdir\u0026quot; src=\u0026quot;src.tar.gz\u0026quot;/\u0026gt;：将文件src.tar.gz解压缩到文件夹destdir中，默认覆盖已存在的重名的文件，可以使用属性overwrite控制是否覆盖。 13）\u0026lt;cvs cvsroot=\u0026quot;crsRoot\u0026quot; package=\u0026quot;chat\u0026quot; command=\u0026quot;checkout\u0026quot; dest=\u0026quot;destdir\u0026quot;\u0026gt;\u0026lt;/cvs\u0026gt;：关于CVS版本控制的操作，其中cvsroot属性为连接CVS服务器的参数（:pserver:qinxiandiqi:nan@localhost:C:\\cvs；代表意义为:连接方式:用户名:密码@主机IP:主机CVS项目目录），package属性为操作的项目名称，command属性为执行的cvs操作命令，dest属性为操作的目标目录。 14）\u0026lt;replace file=\u0026quot;input.txt\u0026quot; token=\u0026quot;old\u0026quot; value=\u0026quot;new\u0026quot;/\u0026gt;：文件内容替换操作，将input.txt文件中所有的old字符串替换为new。标签添加属性summary为true可以输出找到和替换的标记字符串实例的数目。 15）模式匹配：*/*.java匹配当前目录下所有目录里的所有java文件，**/*.java匹配当前目录下以及其所有后代子目录中的java文件。如： \u0026lt;copy todir=\u0026quot;destdir\u0026quot;\u0026gt; \u0026lt;fileset dir=\u0026quot;src\u0026quot;\u0026gt; \u0026lt;include name=\u0026quot;*.java\u0026quot;/\u0026gt; \u0026lt;/fileset\u0026gt; \u0026lt;/copy\u0026gt; 将src目录中所有java文件复制到destdir目录中。另外，fileset默认情况下包含指定src目录下的所有文件。另一方面，与include相对的元素exclude表示除去目录中符合exclude条件的文件。 16、自定义Ant的xml文档命令标签（类似于JSP的自定义标签定义过程）：\n1）定义标签的处理类，需要继承org.apache.tools.ant.Task类，并且重写类中方法execute()。\n2）标签中的属性对应于标签处理类中的成员变量，只要提供成员变量的get和set方法，Ant能够自动将标签属性转换为处理类中的成员变量。\n3）处理类中的方法execute()即为该标签需要执行的逻辑操作。\n4）定义完标签的处理类后需要对处理类与标签进行关联，使用。其中tagName即为自定义标签的名字，classname为标签处理类的类全名，classpath为处理类class文件所在路径。\n5）与使用Ant提供的命令标签一样使用自定义标签。\n","date":"July 11, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/ant%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","series":[{"title":"Ant","url":"https://www.qinxiandiqi.sbs/series/ant/"}],"smallImg":"","tags":[{"title":"ant","url":"https://www.qinxiandiqi.sbs/tags/ant/"},{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"eclipse","url":"https://www.qinxiandiqi.sbs/tags/eclipse/"},{"title":"xml","url":"https://www.qinxiandiqi.sbs/tags/xml/"}],"title":"Ant学习笔记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaScript学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、浏览器的事件机制：冒泡事件机制，IE浏览器的冒泡机制是内容元素的事件处理后逐层抛出给外层元素进行事件处理，其它浏览器基本沿用这个方向，但也有相反的。\n2、浏览器自动生成的事件对象even方法.stopPropagation()可以阻断事件继续冒泡到下一层，而.perventDeafult()可以阻止这个对象的默认行为，如表单对象的action事件默认行为是提交表单。而在事件处理方法中使用return false可以阻断事件继续冒泡也可阻止默认动作。\n3、jquery绑定事件的方法.bind(\u0026ldquo;eventName\u0026rdquo;,\u0026ldquo;para\u0026rdquo;,function(){})，第一个参数eventName表示监听的事件类型，如click表示单击事件、mouseover表示鼠标进入元素事件，mouseout表示鼠标离开元素事件；第二个参数为可选参数，表示可以向事件对象传递的额外数据；第三个参数为事件的处理方法。另外bind中第一个参数\u0026quot;evnetName\u0026quot;也可以通知指定多个eventName事件类型，如\u0026quot;click mouseover\u0026quot;。\n4、jquery的$(document).ready(function(){})方法中function的执行在整个页面的DOM架构加载完毕后就开始执行，而纯JavaScript的window.onload(function(){})方法中的function在整个页面完全加载完毕，包括页面中的其它链接文件全部下载完毕后才开始执行。\n5、jquery关于动画的方法，这些方法一般都可接收四种参数：slow表示0.6秒，normal表示0.4秒，fast表示0.2秒，以及具体的毫秒数值。参数表示执行完该方法需要的时间，没有参数则表示为0秒即马上。这些方法全部使用方法链设计：\n1）show()方法：使用这个方法的标签在show方法被执行后才会显示。 2）hide()方法：使用该方法的标签在hide方法执行后将会被隐藏。 3）fadeOut()方法：使用该方法的标签将在指定的时间内淡出。 4）fadeIn()方法：使用该方法的标签将在指定的时间内淡入。 5）slideUp()方法：使用该方法的标签将在指定的时间内由下往上被收起。 6）slideDown()方法：使用该方法的标签将在指定的时间内由上往下被拉出。 7）animate({attribute1:value1,attribute2:value2...},time,function(){})方法：其中第一个参数由花括号括起来，其中每对值为标签需要改变的属性对；第二个参数time为完成这些改变需要的时间；第三个参数为完成改变后自动回调的方法。如$(\u0026quot;div\u0026quot;).animate({left:\u0026quot;+=500px\u0026quot;},3000,function(){alert(3);})，div标签将会向右移动到距离由编剧500px像素的地方，特别的，500前的“+=”会每执行一次后自动以500的距离增加，即第二次执行将变成left:1000px，否则第二次执行将原地不动。多个animate以方法链形式连接时将会逐个执行，而链中的其它属性方法（如css）则会直接先执行。 6、jquery对象.is(\u0026quot;:visible\u0026quot;)用于判断该jquery对象是否可见，返回值为boolean。\n7、jquery中与bind方法相对应的是unbind()方法。当unbind不带参数时则取消绑定标签上所有的事件监听；当unbind接收一个event事件类型做参数时则取消绑定标签上的这个event的事件监听；当unbind接收一个event事件类型和一个具体event事件对象做参数时，则取消标签上指定的这个event事件对象。\n8、jquery类似于bind的另一个绑定方法.one(\u0026ldquo;eventName\u0026rdquo;,function(){})，区别在于one绑定的事件使用一次后就失效。\n9、jquery对象提供方法.trigger(\u0026ldquo;eventName\u0026rdquo;)，用于模拟触发一个eventName事件，相当于直接调用这个事件的处理方法.eventName()。\n10、JSON（JavaScript Object Notation）：可代替XML进行数据传输（相比较XML，传输相同的数据需要的流量要小的多得多），但本身不是一门新的语言，是利用JavaScript的子集创建出来的一种数据格式。多种语言都支持这种JSON数据格式，也就是可以利用JSON数据格式在不同语言之间传递。\n11、JSON基于两种结构：\n1）基于name/value的字符串，可以看做是JSON的对象，如{name1:value1,name2:value2,...}。 2）基于有序value的列表，可以看做是JSON的数组，如[value1,value2,...]。 3）JSON的对象或者数组严格按照规定的格式书写。 4）JSON的对象中不包括方法。 12、JSON的类型书写格式：\n1）object：{name1:value1,name2:value2,...}。以花括号包围，每对name和value之间用“:”分隔，对与对之间使用“,”分隔。这种格式是JavaScript内置支持的格式，也就是JavaScript本身就能解析这种格式。 2）array：[value1,value2,value3...]。以中括号包围，value之间使用“,”分隔。 3）value：可以使string（字符串类型）、number（数值类型）、object（对象类型）、array（数组类型）、boolean（true或false）、null。 4）string：字符串类型，由一个或多个Unicode字符构成，使用\u0026quot;\u0026quot;包围就表示string类型，其中也可使用转义字符将字符转义。特别的，JSON中没有字符的概念，字符就是长度为1的字符串。 5）number：数值类型，包括整数和浮点数。JSON不支持八进制和十六进制数。 13、XML转JSON例子：\nXML格式： \u0026lt;users\u0026gt; \u0026lt;user gender='male'\u0026gt; \u0026lt;username type='string'\u0026gt;aaa\u0026lt;/username\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;user gender=\u0026quot;male'\u0026gt; \u0026lt;username type='string'\u0026gt;bbb\u0026lt;/username\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;/users\u0026gt; 转为JSON格式： {users:[ {user:{gender:'male',username:['aaa',type:'string']}}, {user:{gender:'male',username:['bbb',type:'string']}} ] } 14、JavaScript内置支持JSON，要获取13例中aaa，比如该JSON字符赋给var json，则通过json.user[0].user.username[0]便可获得aaa。\n15、在页面中引入json的媒体格式为application/json，而html媒体格式为text/html，css文件媒体格式为text/css，xml文件媒体格式为text/xml。\n16、JSON没有命名空间，没有验证器，不可以扩展，不是XML。对于JSON来说，每一个JSON对象就已经相当于一个命名空间。\n17、Douglas，JSON创始人为Java语言设计的douglascrockford-JSON- java类包，需要将Douglas设计的JSON类放置到org.json包下，并在Java项目中import导入。\n18、douglascrockford-JSON-java中主要类：\n1）JSONObject，其构造方法JSONObject(String json)能够通过JSON格式字符串构造出JSONObject对象，如果json字符串不符合JSON的object格式将构造失败并抛出异常。对象中主要提供了大量获取json中各种数据类型的name/value的value值方法。如getString(String name)、getJSONObject(String name)、getInt(String name)等等。 2）JSONArray，其构造方法JSONArray(String json)能够通过JSON格式字符串构造出JSONArray对象，如果json字符串不符合JSON的array格式将会构造失败并抛出异常。对象中主要提供了获取json中各种数据类型的value值。如getString(int index)、getJSONObject(int index)、getInt(int index)等。 19、使用广泛的另一个为Java设计的JSON：Gson，google设计的，能够支持泛型的JSON。使用Gson需要将Gson的jar包导入到Java项目中。\n20、Gson中主要的类com.google.gson.Gson，通过这个类基本能实现Gson的操作。Gson类中主要两个方法：\n1）String toJson(Object object)：接收一个对象，返回值为将对象的属性转换为JSON格式的对象的字符串。 2）\u0026lt;T\u0026gt; T formJson(String json,Class\u0026lt;T\u0026gt; classofT)：将json格式字符串转换为Java类对象。 21、jquery中提供的支持Ajax的方法：\n1） $.ajax({ url:url, type:type, dataType:\u0026quot;html\u0026quot;, data:params, success:function(returnedData){} }); 其中url参数为请求的服务器资源，type为发送请求的方式（POST、GET等），dataType为得到服务器响应的数据类型（默认为\u0026quot;html\u0026quot;，即字符串格式；也可以为json或者xml），data为请求附加的数据（无论是GET还是POST方式都以同样的方式附加data数据，数据json对象的方式附加，如{username:'abc',age:20}），success:function为请求成功得到服务器响应后回调的方法。 2）$.post(\u0026quot;url\u0026quot;,data,function(returnedData,status){})：jquery对ajax的post提交方式的简化。第一个参数url为请求的服务器资源；data为请求附加的数据（同样适用json的数据格式）；function的returnedData参数表示服务器响应的数据，status为服务器响应的状态（如200,403等）。方法中并没有指定服务器响应数据的媒体格式，因为这个媒体格式在服务器发送响应之间就使用resp.setContectType(\u0026quot;application/json;charset=utf-8\u0026quot;)的方式确定。 3）$.get(\u0026quot;url\u0026quot;,data,function(returnedData,status){})：使用方式和参数意义与post方法一致，不同的只是发出请求的方法是GET而已。 ","date":"July 11, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/javascript/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%85%AD%E8%AE%B0/","series":[{"title":"JavaScript学习笔记","url":"https://www.qinxiandiqi.sbs/series/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javascript","url":"https://www.qinxiandiqi.sbs/tags/javascript/"},{"title":"jquery","url":"https://www.qinxiandiqi.sbs/tags/jquery/"},{"title":"json","url":"https://www.qinxiandiqi.sbs/tags/json/"},{"title":"gson","url":"https://www.qinxiandiqi.sbs/tags/gson/"},{"title":"动画","url":"https://www.qinxiandiqi.sbs/tags/%E5%8A%A8%E7%94%BB/"}],"title":"JavaScript学习笔记 第六记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaScript学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、jquery对象的两个方法.html()返回的是标签对象包含的html内容（包括包含的其它标签元素一并输出），而.text()返回的是标签对象最终显示的文本格式（包含的其它格式标签作用在文本后输出最终的文本格式）。\n2、jquery过滤选择器的表单对象属性过滤选择器：\n1）:enabled选择器：$(\u0026quot;#form1 :enabled\u0026quot;)，选取id为form1的表单内所有可用的元素。注意form1之后有空格，加了空格即为层次选择器才能选择form表单内enabled的元素，没有空格则选择的是enabled的form1对象。 2）:disabled选择器：$(\u0026quot;#form1 :disabled\u0026quot;)，选取id为form1的表单内所有不可用的元素。注意！form1之后有空格，加了空格即为层次选择器才能选择form表单内enabled的元素，没有空格则选择的是disabled的form1对象。 3）:checked选择器：$(\u0026quot;input:checked\u0026quot;)，选取所有被选中的input元素，包括单选框和复选框。 4）:selected选择器：$(\u0026quot;select :selected\u0026quot;)，选取所有选择列表select中被选中的选项元素。注意select之后有空格，加了空格表示层次选择器，匹配的所有select中的选项元素，没有加空格则匹配的是select元素。 3、jquery对象的方法.val()用于返回标签对象的value值，而.val(value)用于设置标签对象的value值。\n4、HTML的select标签添加属性multiple=\u0026ldquo;multiple\u0026quot;后，选择列表将变为多选选择列表。\n5、jquery的select对象方法.change(function(){})，当select选择列表选择发生改变后就会调用这个function方法。\n6、jquery对象的.each(function(){})方法用于向jquery对象中的每一个标签元素添加方法function。\n7、jquery的表单选择器：\n1）:input选择器：$(\u0026quot;:input\u0026quot;)，选取所有\u0026lt;input\u0026gt;、\u0026lt;textarea\u0026gt;、\u0026lt;select\u0026gt;、\u0026lt;button\u0026gt;元素。 2）:text选择器：选取所有单行文本框。 3）:password选择器：选取所有密码框。 4）:radio选择器：选取所有单选框。 5）:checkbox选择器：选取所有多选框。 6）:submit选择器：选取所有提交按钮。 7）:image选择器：选取所有的图像按钮。 8）:reset选择器：选取所有的重置按钮。 9）:button选择器：选取所有的按钮。 10）:file选择器：选取所有的上传域。 11）:hidden选择器：选取所有不可见元素。 8、$(\u0026quot;#form1 :input\u0026rdquo;)与$(\u0026quot;#form1 input\u0026quot;)的区别：$(\u0026quot;#form1 :input\u0026quot;)获取的是表单form1中素有的input、textarea、select和button元素，而$(\u0026quot;#form1 input\u0026quot;)是层次选择器选择的是form1中所有的后代input元素。\n9、jquery的选择器$(\u0026ldquo;element :selcetor\u0026rdquo;)与$(\u0026ldquo;element:selector\u0026rdquo;)不同，$(\u0026ldquo;element :selector\u0026rdquo;)选择的是element中符合selector条件的后代元素，$(\u0026ldquo;element:selector\u0026rdquo;)选择的是符合selector条件的element元素。\n10、JavaScript推荐申明的jquery对象名称以$开头，如$element。\n11、jquery对象的.attr(attribute)方法返回jquery对象的属性attribute的属性值，.attr(attribute,value)方法设置jquery对象的属性attribute值为value。\n12、JavaScript创建新的DOM对象使用document.createElement(\u0026ldquo;Tag\u0026rdquo;)方法，创建好后可以使用新对象的setAttribute(\u0026ldquo;attribute\u0026rdquo;,\u0026ldquo;value\u0026rdquo;)方法设置新对象的属性，最后还要使用Element.appendChild(\u0026ldquo;newElement\u0026rdquo;)方法将新的DOM对象newElement插入到Element对象中，作为Element对象的子元素，所以使用这个appendChild方法的前提是Element对象是个可以带内容的对象。\n13、jquery插入新节点的方法：\n1）使用append()方法：向每个匹配的元素内部追加内容。如原有\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;，使用$(\u0026quot;p\u0026quot;).append(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;)后，结果为\u0026lt;p\u0026gt;我想说：\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;。 2）使用appendTo()方法：将所有匹配的元素追加到指定的元素中，实际上是append()方法的倒置。如\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;，使用$(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;).appendTo(\u0026quot;p\u0026quot;)之后，结果为\u0026lt;p\u0026gt;我想说：\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;。 3）perpend()方法：向每个匹配元素的内部前置内容。如\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;，使用$(\u0026quot;p\u0026quot;).prepend(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;)之后，结果为\u0026lt;p\u0026gt;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;我想说：\u0026lt;/p\u0026gt;. 4）perpendTo()方法：将所有匹配的元素前置到指定的元素中，实际上是perpend()方法的倒置。如\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;，使用$(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;).appendTo(\u0026quot;p\u0026quot;)之后，结果为\u0026lt;p\u0026gt;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;我想说：\u0026lt;/p\u0026gt;。 5）after()方法：在每个匹配的元素之后插入内容。如\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;，使用$(\u0026quot;p\u0026quot;).after(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;)方法后，结果为\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;。 6） insertAfter()方法：将所有匹配元素插入到指定元素的后面，实际上是after()方法的倒置。如\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;，使用$(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;).insertAfter(\u0026quot;p\u0026quot;)之后，结果为\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;。 7）before()方法：在每个匹配元素之前插入内容。如\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;，使用$(\u0026quot;p\u0026quot;).before(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;)之后，结果为\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;。 8）insertBefore()方法：将所有匹配元素插入到指定的元素前面，实际上是堆before()方法的倒置。如\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;，使用$(\u0026quot;\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026quot;).insertBefore(\u0026quot;p\u0026quot;)之后，结果为\u0026lt;b\u0026gt;你好\u0026lt;/b\u0026gt;\u0026lt;p\u0026gt;我想说：\u0026lt;/p\u0026gt;。 14、jquery插入新节点的方法都采用方法链的设计模式设计。\n15、通过$(\u0026quot;你好\u0026quot;)的方式就可以直接创建一个p标签的jquery节点对象。\n16、jquery插入新节点的系列方法的参数也可以直接是一个jquery对象，如$(\u0026ldquo;p\u0026rdquo;).perpend($(\u0026quot;#insert\u0026quot;))。特别的，当参数是已存在的标签对象是，使用这些列方法就可以达到间接移动页面标签位置的作用，如$(\u0026ldquo;ul li:eq(2)\u0026rdquo;).insertAfter(\u0026ldquo;ul li:eq(4)\u0026quot;)就可以将ul列表中第三个li移动到第五个li后面。\n17、每个jquery对象都提供方法.remove()，调用这个方法的jquery对象将会从页面中被移除，方法的返回值为被删除的对象，也就是说被删除的对象实际上还存在内存里。remove方法也可带参数，参数为一个过滤条件（jquery的过滤选择器）。如$(\u0026ldquo;ul li\u0026rdquo;).remove(\u0026ldquo;li[title!=2]\u0026quot;)将会移除ul列表中所有title不等于2的li。\n18、jquery对象的.empty()方法用于将jquery对象的内容清除。\n19、jquery对象的.clone(boolean)方法用于复制一个jquery对象，当参数为true时则连同原对象的事件监听器一起复制，当参数为false是则源对象的事件监听器不复制。不带参数则默认参数为false。\n20、$(\u0026ldquo;ul li\u0026rdquo;).click(function(){$(this).clone().appendTo(\u0026ldquo;ul\u0026rdquo;);})，其中$(this)表示当前的li对象，因为jquery在底层上是遍历整个li组成的数组的。\n21、jquery代替对象：\n1）$(\u0026quot;p\u0026quot;).replaceWith(\u0026quot;\u0026lt;a\u0026gt;repalce\u0026lt;/a\u0026gt;\u0026quot;)，使用a标签的代替p标签，replaceWith的参数也可以是jquery对象变量。 2）$(\u0026quot;\u0026lt;a\u0026gt;replace\u0026lt;/a\u0026gt;\u0026quot;).replaceAll(\u0026quot;p\u0026quot;)，使用a标签代替页面中所有的p标签。 22、jquery包围对象：\n1）$(\u0026quot;p\u0026quot;).wrap(\u0026quot;\u0026lt;a\u0026gt;\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt;\u0026lt;/a\u0026gt;\u0026quot;)，将整个p标签包围到warp参数标签的最内层，本例结果为\u0026lt;a\u0026gt;\u0026lt;b\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/b\u0026gt;\u0026lt;/a\u0026gt;。 2）$(\u0026quot;p\u0026quot;).wrapInner(\u0026quot;\u0026lt;a\u0026gt;\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt;\u0026lt;/a\u0026gt;\u0026quot;)，将p标签的内容包含到warpInner参数的最内层，本例结果为\u0026lt;p\u0026gt;\u0026lt;a\u0026gt;\u0026lt;b\u0026gt;p标签内容\u0026lt;/b\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;。 23、jquery对象获取或添加属性方法.attr()，移除属性方法.removeAttr()。当要使用attr方法设置多个属性和属性值时，需要使用格式attr({attribute1:value1,attribute2:value2\u0026hellip;})。\n24、jquery对象设置css类样式方法：\n1）Element.attr(\u0026quot;class\u0026quot;,\u0026quot;className\u0026quot;)：设置Element对象的class属性值为className样式。 2）Element.addClass(\u0026quot;className\u0026quot;)：添加Element对象的一个class属性值className。由于同一个标签的class引用css类选择器可以多个（多个class值之间用空格分隔），因此，使用addClass方法会检查Element是否已经具有className样式，有则不添加，没有则添加。而attr方法则直接覆盖掉原有class值。 3）Element.removeClass()：带参数时移除Element指定参数的class值，不带参数则移除Element全部class值。 4）Element.toggleClass(\u0026quot;className\u0026quot;)：如果Element带有className的class值则移除这个className值，如果不带有className的class值则添加这个className值。 5）Element.hasClass(\u0026quot;className\u0026quot;)：检查Element是否具有className的class值，有则返回true，没有返回false。 6）Element.is(\u0026quot;.className\u0026quot;)：功能与hasClass方法一样。实际上is方法还有其它功能。 25、jquery对象的html()和text()方法都可带字符串参数，当字符串参数中含有标签符号时，html方法会将标签符号当做标签来处理，而text方法会将标签符号转义成字符以字符来处理。\n26、jquery对象的focus(function(){})方法用于对象获得焦点时触发，blur(function(){})方法用于对象失去焦点时触发。\n27、DOM对象具有属性defaultValue，表示对象最初的value值。\n28、jquery对象的.children()方法返回对象的子元素数组。\n","date":"July 11, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/javascript/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%94%E8%AE%B0/","series":[{"title":"JavaScript学习笔记","url":"https://www.qinxiandiqi.sbs/series/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javascript","url":"https://www.qinxiandiqi.sbs/tags/javascript/"},{"title":"jquery","url":"https://www.qinxiandiqi.sbs/tags/jquery/"},{"title":"选择器","url":"https://www.qinxiandiqi.sbs/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"},{"title":"替代对象","url":"https://www.qinxiandiqi.sbs/tags/%E6%9B%BF%E4%BB%A3%E5%AF%B9%E8%B1%A1/"}],"title":"JavaScript学习笔记 第五记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaScript学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、选择器的目的是为了获取页面中的标签元素，jquery提供了四类选择器：基本选择器、层次选择器、过滤选择器、表单选择器。\n2、jquery的基本选择器：\n1）ID选择器：$(\u0026quot;#idvalue\u0026quot;)，选取id为idvalue的元素。返回的数组中只有一个元素，即使页面中存在多个相同id的元素也只获得最前面的元素，因为ID本来就不提倡同个页面中出现多个。 2）类选择器：$(\u0026quot;.classvalue\u0026quot;)，选取页面中所有class为classvalue的元素，返回的是一个数组对象。 3）元素选择器：$(\u0026quot;element\u0026quot;)，选取页面中所有元素名称为element的元素，返回的是一个数组对象。 4）通配选择器：$(\u0026quot;*\u0026quot;)，选择页面中所有的元素，返回的是一个数组对象。 5）组合选择器：$(\u0026quot;seletor1,seletor2...\u0026quot;)，使用“,”分隔各个选择条件，返回的数组对象中元素将包含所有符合其中任意一个条件的元素。 3、jquery的层次选择器：\n1）后代选择器：$(\u0026quot;ancestor descendant\u0026quot;)，选择符合ancestor条件的元素下的所有后代元素descendant，也就是只要是符合ancestor条件的元素包含的descendant元素全部都会被选择，返回的是一个数组对象。 2）子选择器：$(\u0026quot;parent \u0026gt; child\u0026quot;)，选择符合parent条件的元素下所有的child子元素，返回的是一个数组对象。与后代选择器的区别是选择的是符合parent条件元素包含的所有child子元素，而不是parent下所有的child元素。 3）next选择器：$(\u0026quot;prev + next\u0026quot;)，选择符合prev条件的元素的下一个与prev同等级的next元素，也就是选择与prev为兄弟元素的下一个next元素。返回的是一个数组对象，因为一个页面中可能出现多个符合prev条件的元素，这些元素的next元素全部都会被选择。 4）~选择器：$(\u0026quot;prev ~ siblings\u0026quot;)，选择符合prev条件元素后面的所有兄弟siblings元素，返回的是一个数组对象。 4、$(\u0026ldquo;prev + next\u0026rdquo;)等价于方法$(\u0026ldquo;prev\u0026rdquo;).next(\u0026ldquo;next\u0026rdquo;)。\n5、$(\u0026ldquo;prev ~ siblings\u0026rdquo;)等价于方法$(\u0026ldquo;prev\u0026rdquo;).nextAll(\u0026ldquo;siblings\u0026rdquo;)。\n6、方法$(\u0026ldquo;prev\u0026rdquo;).siblings(\u0026ldquo;siblings\u0026rdquo;)用于获得所有与prev同等级的siblings元素，无论前后位置。\n7、jquery的过滤选择器又分为基本过滤、内容过滤、可见性过滤、属性过滤、子元素过滤、表单对象属性过滤几种。\n8、jquery过滤选择器的基本过滤选择器：\n1）:first选择器：$(\u0026quot;element:first\u0026quot;)，用于获得页面中所有element元素中的第一个element元素对象，返回的是单个对象。 2）:last选择器：$(\u0026quot;element:last\u0026quot;)，用于获得页面中所有element元素中的最后一个element元素对象，返回的是单个对象。 3）:not(selector)选择器：$(\u0026quot;element:not(selector)\u0026quot;)，用于获得页面中所用element元素符合selector条件的元素，返回的是一个element元素数组对象。如$(\u0026quot;div:not(.notclass)\u0026quot;)将获得页面中所有div中没有使用notclass的div元素。 4）:even选择器：$(\u0026quot;element:even\u0026quot;)，获取页面所有element中排序索引为偶数的element元素组成的数组对象，索引从0开始，返回的是element数组对象 5）:odd选择器：$(\u0026quot;element:odd\u0026quot;)，获取页面中所有element中排序索引为奇数的element元素组成的数组对象，索引从0开始，返回的是element数组对象。 6）:eq(index)选择器：$(\u0026quot;element:eq(index)\u0026quot;)，获取页面所有element元素中排序索引为index的element元素独享，索引从0开始，返回的是单个element对象。 7）:gt(index)选择器：$(\u0026quot;element:gt(index)\u0026quot;)，获取页面所有element元素中排序索引index之后（不包括本身）的所有element元素数组对象，索引从0开始，返回的是element数组对象。 8）:lt(index)选择器：$(\u0026quot;element:lt(index)\u0026quot;)，获取页面中所有element元素中排序索引index之前（不包括本身）的所有element元素数组对象，索引从0开始，返回的是element数组对象。 9）:header选择器：$(\u0026quot;:header\u0026quot;)，获取页面中所有标题元素，如\u0026lt;h1\u0026gt;、\u0026lt;h2\u0026gt;等。返回的是数组对象。 10）:animated选择器：$(\u0026quot;element:animated\u0026quot;)，选取页面中正在执行动画的element对象，返回的是element数组对象。 9、jquery过滤选择器的内容过滤选择器：\n1）:contains('text')选择器：$(\u0026quot;element:contains('text')\u0026quot;)，选取页面中含有文本内容为text的element元素，返回的是element元素数组集合。 2）:empty选择器：$(\u0026quot;element:empty\u0026quot;)，选取页面中不包含子元素（包括文本）的所有element元素，返回的是element元素数组集合。 3）:has(selector)选择器：$(\u0026quot;element:has(selector)\u0026quot;)，选取页面中所有包含selector元素的element元素，返回element元素数组集合。 4）:parent选择器：$(\u0026quot;element:parent\u0026quot;)，选取所有拥有子元素（包括文本元素）的element元素，返回element元素数组集合。 10、jquery过滤选择器的可见性过滤器：\n1）:hidden选择器：$(\u0026quot;element:hidden\u0026quot;)，选取页面中所有隐藏的element元素，返回element元素数组。 2）:visible选择器：$(\u0026quot;element:visible\u0026quot;)，选取页面中所有可见的element元素，返回element元素数组。 11、jquery为$(document).ready(function(){})提供了两种简化方式：\n1）$().ready(function(){}) 2）$(function(){}) 12、jquery过滤选择器的属性过滤器：\n1）[attribute]过滤器：$(\u0026quot;element[attribute]\u0026quot;)，选取所有拥有属性attribute的element元素，返回数组。 2）[attribute=value]选择器：$(\u0026quot;element[attribute=value]\u0026quot;)，选取拥有属性attribute且属性值为value的所有element元素。 3）[attribute!=value]选择器：$(\u0026quot;element[attribute!=value]\u0026quot;)，选取attribute属性值不为value的所有element元素，包括不拥有attribute属性的element元素。 4）[attribute^=vlaue]选择器：$(\u0026quot;element[attribute^=value]\u0026quot;)，选取拥有attribute属性且属性值以value开头的所有element元素。 5）[attribute$=value]选择器：$(\u0026quot;element[attribute$=value]\u0026quot;)，选取拥有attribute属性且属性值以value结束的的所有element元素。 6）[attribute*=value]选择器：$(\u0026quot;element[attribute*=value]\u0026quot;)，选取拥有attribute属性且属性值中含有value的所有element元素。 7）[selector1][selector2]...选择器：$(\u0026quot;element[selector1][selector2]...\u0026quot;)，选取符合所有selector条件的element元素。 13、jquery过滤选择器的子元素过滤器：\n1）:nth-child(index/even/odd/equation)选择器：$(\u0026quot;element:nth=child(index/even/odd/equation)，选取每个父元素下第index个子元素的或者奇偶元素，返回的是一个元素集合，索引从1开始。注意匹配的是所有是父元素的element，即使这个element又是另一个element的子元素，这是与:eq(index)等选择器最大的区别。 2）:first-child选择器：$(\u0026quot;element:first-child\u0026quot;)，将每个是父元素的element的第一个子元素返回，返回的是一个数组。而:first只返回单个元素。 3）:last-child选择器：$(\u0026quot;element:last-child\u0026quot;)，选取每个父元素element的最后一个子元素，与:first-child类似。 4）:only-child选择器：$(\u0026quot;element:only-child\u0026quot;)，选取所有只拥有一个子元素的element元素。 ","date":"July 11, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/javascript/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E8%AE%B0/","series":[{"title":"JavaScript学习笔记","url":"https://www.qinxiandiqi.sbs/series/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javascript","url":"https://www.qinxiandiqi.sbs/tags/javascript/"},{"title":"jquery","url":"https://www.qinxiandiqi.sbs/tags/jquery/"},{"title":"选择器","url":"https://www.qinxiandiqi.sbs/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"}],"title":"JavaScript学习笔记 第四记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaScript学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、路径中的..表示上一层路径。\n2. JavaScript编码规范：通常在JavaScript中不希望外界访问的成员和方法名以下划线开始。\n3. jsUnit测试函数的要遵循的规则与JUnit 3.8类似（比如说测试函数名以test开头等）。\n4. 对于JsUnit来说，其setUp和tearDown方法与JUnit的运行原理是不同的，JUnit中的setUp和tearDown之间是没有关系的，也就是说不同的测试方法运行在不同的测试对象之中，而JsUnit的各个测试函数是运行在同一个测试页面中。因此setUp和tearDown会针对同一个变量进行操作。\n5、JsUnit中对应于JUnit4.x中的@BeforeClass注解（整个测试之前执行一次）的方法为setUpPage，要求方法块中最后一行代码必须为setUpPageStatus = \u0026ldquo;complete\u0026rdquo;;，这行代码告诉JsUnit方法已经执行结束，否则测试肯定超时不通过。然而，JsUnit中没有对应@AfterClass的方法。\n6、Ajax（Asynchronous JavaScript and XML）：异步的JavaScript和XML，通过Ajax可以实现保持当前页面发出HTTP请求与服务器交互后，依据返回的响应只更改当前页面的一部分内容。\n7、Ajax实现的关键在于浏览器提供了XMLHttpRequest对象，但是不同的浏览器对XMLHttpRequest的支持不同，主要是IE和其它浏览器的区别。为了让代码能兼容不同的浏览器，获得XMLHttpRequest对象一般使用以下方法：\nvar xmlHttpRequest = null； //检测是否是IE浏览器，IE提供了ActiveXObject对象支持XMLHttpRequest。 if(window.ActiveXObject){ xmlHttpRequest = new ActiveXObject(\u0026quot;Microsoft.XMLHTTP\u0026quot;); } //除了IE之外的其它浏览器直接提供XMLHttpRequest实现XMLHttpReques对象。 else if(window.XMLHttpRequest){ xmlHttpRequest = new XMLHttpRequest(); } 8、使用Ajax向服务器发送请求，需要先使用XMLHttpRequest对象的open方法设置HTTP请求方式和请求资源，以及XMLHttpRequest对象onreadystatechange属性关联响应的数据处理方法，最后再使用XMLHttpRequest对象的send方法向服务器发送数据。另外，由于有些小众化的浏览器不支持Ajax，没有提供XMLHttpRequest对象，所以这部分代码最后放在if(null != xmlHttpRequest){}判断语句中。\n1）open(method,url,asyn,username,password)：method参数表示发送HTTP请求的方法（GET或者POST）；url为请求的服务器组件，如果是使用GET方法，附加的数据要写在url后面（与浏览器使用GET提交附加数据的格式一样）；asyn为boolean值，为true表示使用异步操作，为false表示使用同步操作，IE支持同步，FireFox不支持同步，因为使用同步就失去了Ajax的意义。\n2）onreadystatechange：为该属性关联一个Function方法对象，也就是Function对象名后不能加括号，加了括号表示执行这个function方法。这个方法会在请求状态改变的时候被调用，XMLHttpRequest.readyState属性用于表示当前的状态。发送一个请求并得到响应的过程中一共有4中状态，各用1-4表示：1表示XMLHttpRequest对象刚刚构造完毕，但是还没有向服务器发送请求；2表示开始向服务器发送请求，但还没有收到响应；3表示开始接收到服务器的响应，但响应还没有完全发送过来；4表示已经完全接收到服务器的响应。\n3）send（String elements）：向服务器发送请求，elements参数表示请求的附加数据。当使用GET方法时，不需要参数，因为GET方法的参数附加在请求资源后面，此时可以不写参数或者使用null做参数。当使用POST方法时，有附加数据的话需要将附加数据的字符串形式作为参数，附加数据的字符串格式与GET方法附加在请求资源后面的参数格式一样。\n9、服务器返回XMLHttpRequest请求的响应后，获得服务器响应的数据需要通过XMLHttpRequest的两个属性：\n1）XMLHttpRequest.responseText：服务器直接通过字符串返回响应数据时使用这个属性可以获得响应的字符串数据。\n2）XMLHttpRequest.responseXML：服务器以XML文档的格式返回响应数据的时候，通过这个属性获得响应的XML文档。\n10、Servlet设置Response对象不使用缓存的方法，添加以下代码：\nresp.setHeader(\u0026ldquo;pragma\u0026rdquo;,\u0026ldquo;no-cache\u0026rdquo;);\nresp.setHeader(\u0026ldquo;cache-control\u0026rdquo;,\u0026ldquo;no-cache\u0026rdquo;);\n11、XMlHttpRequest使用POST方式提交附加数据，需要在send方法之前设置请求头信息，将请求数据编码方式设置为表单编码方式：XMLHttpRequest.setRequestHeader(\u0026ldquo;Content- Type\u0026rdquo;,\u0026ldquo;application/x-www-form-urlencoded\u0026rdquo;)。\n12、jquery是一个js库，目的是为了简化JavaScript的使用，通过jquery只需要使用简单的代码就可以完成很复杂的工作，原因在于jquery库的JavaScript已经完成了很复杂的工作。\n13、使用jquery需要在页面中导入jquery库，\u0026lt;script type=\u0026ldquo;text/javascript\u0026rdquo; src=\u0026ldquo;jqueryurl\u0026rdquo; /\u0026gt;，jqueryurl为jquery的js文件路径。\n14、jquery库中提供了与DOM相对应的内置对象，jquery大部分将DOM对象中的属性包装为方法，并采用方法链的设计模式设计方法。使用jquery就是通过使用jquery对应DOM对象的对象方法，因此，DOM对象可以转换为jquery对象。另外jquery对象也可以转换为DOM对象。转换的方法有：\n1）直接从页面获取DOM对象的方法：通过document对象的getElementByID或者getElementsByTagName等方法获得。\n2）直接从页面获取jquery对象的方法：$(\u0026ldquo;TagName\u0026rdquo;)获取标签名为TagName的jquery对象数组；$(\u0026quot;#ID\u0026quot;)获取此ID的jquery数组，但实际上只获取第一个此ID的标签元素；$(\u0026quot;.Element\u0026quot;)获取CSS对象名为Element的jquery对象。特别需要注意的是获取的jquery对象是个数组，即使是页面中只有一个对象也是以数组的形式返回。操作获取的jquery对象实际上操作的整个数组的中的每个元素，jquery底层的代码就是遍历数组中每个元素来操作的。\n3）DOM对象转换为jquery对象：$(DOM对象)。$()类似于强制转换，将DOM对象强制转换为jquery对象，转换后的对象就可以使用jquery对象的提供的非常便利的方法。\n4）jquery对象转换为DOM对象：直接从页面获取的jquery对象都是以数组对象，使用“对象[i]”或者“对象.get(i)”获得的元素就是DOM对象。\n15、jquery对象的html()方法对应DOM对象的innerHTML属性，都是获得该对象的内容。\n16、jquery对象的click(function(){})方法对应DOM对象的onclick属性，在点击事件触发的时候得到调用。\n17、jquery的$(document).ready(function(){})对应DOM的window.onload属性，区别在于jquery的多个ready方法都会在页面加载完毕后全部按照顺序执行，而DOM的onload属性关联的function方法再页面加载完毕后只执行最后一个onload关联的function。原因在DOM的onload属性是对象，后一个关联Function对象会覆盖前面Function关联对象，所以得不到调用。\n18、jquery中获取的jquery对象是个数组，即使页面中不存在符合条件的标签，也会获取到一个jquery数组，只是这个数组是个空数组。对这个jquery对象进行操作，如果是个空数组则jquery会自动过滤掉不执行操作；相比较之下，如果页面标签不存在，对获取的DOM对象进行操作将抛出错误。每个jquery对象都有属性length代表该对象中的标签元素个数。\n19、jquery对象提供关于操作标签属性的方法一般都具有一个参数和两个参数的版本，带两个参数的方法一般都用于设置属性的值（第一个参数为属性名，第二个参数为新的属性值），带一个参数的方法一般用于返回属性的值。如jquery对象的css()方法，它具有css(type,value)用于设置css样式属性type的值为value，以及css(type)用于获取css样式的属性type的值。\n20、对于css中很多使用“-”连接符的属性（如background- color），在JavaScript中必须取消“-”连接符并将连接符的下一个字母改为大写（如backgroundColor）。\n","date":"July 11, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/javascript/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E8%AE%B0/","series":[{"title":"JavaScript学习笔记","url":"https://www.qinxiandiqi.sbs/series/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javascript","url":"https://www.qinxiandiqi.sbs/tags/javascript/"},{"title":"ajax","url":"https://www.qinxiandiqi.sbs/tags/ajax/"},{"title":"xmlhttprequest","url":"https://www.qinxiandiqi.sbs/tags/xmlhttprequest/"},{"title":"jquery","url":"https://www.qinxiandiqi.sbs/tags/jquery/"},{"title":"JsUnit","url":"https://www.qinxiandiqi.sbs/tags/jsunit/"}],"title":"JavaScript学习笔记 第三记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaScript学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、JavaScript的Cookie：添加cookie格式为document.cookie=\u0026ldquo;key=value;expries=有效日期\u0026rdquo;。其中有效日期为GMT事件格式，可以使用new Date()的toGMTString()方法获得；删除cookie格式为document.cookie=\u0026ldquo;key=;expries=当前日期\u0026rdquo;。\n2、两种类型的cookie：\n1）持久性cookie，存储在客户端的硬盘上。 2）session的cookie，不会保存在客户端的硬盘上，放在浏览器进程所处的内存中，当浏览器关闭的时候session的cookie就被销毁。 3、cookie保存在客户端硬盘上的文件格式：\n1）NS内核浏览器：Cookie.txt 2）IE内核浏览器：用户名@域名.txt 4、JavaScript的parseInt(param)方法会将参数中的数字提取出来，不是数字的字符丢弃。\n5、JavaScript获取得控件对象后，对象具有属性style，通过属性style可以控制该控件的一些风格。比如table为Table控件，通过table.style.display=\u0026ldquo;none\u0026quot;可以将table控件隐藏，通过table.style.display=\u0026ldquo;block\u0026quot;可以将table控件以block块的样式显示。\n6、JavaScript语句在客户端执行，JSP语句在服务器执行。\n7、JavaScript中的function：\n1）在JavaScript中，函数（function）就是一个Function对象。 2）function methodName(paramelist){}等同于var methodName = function(paremlist){}。可以看出methodName其实就是一个Function对象，所以只要methodName同名，写在后面的就会覆盖前面的function，本质上就是对methodName变量重新赋值。因此，在JavaScript中没有方法重载的说法。 3）function定义的变量是Function对象，可以通过var methodName = new Function(\u0026quot;parame1\u0026quot;,\u0026quot;parame2\u0026quot;...,\u0026quot;methodbody\u0026quot;);来定义一个Function对象，其中parame1为方法的参数名，最后一个参数methodbody为方法体的内容，参数和方法体内容全部以字符串的形式做为Function构造方法的参数。 4）调用Function对象传递的参数其实是一个arguments对象，这个对象是一个Array对象，长度为传递参数的个数，数组中的第i个元素可以通过arguments[i]获得。 5）调用function的参数可以与定义function的参数数量不同，少于定义的参数数量时，后面没有提供的参数默认值为Undefined类型的值undefined；多于定义的参数数量时，多出来的参数也会传递到function中。在传递参数的本质是通过arguments来传递，所以，即使定义function没有定义参数但在调用时传递了参数，通过arguments同样可以获得传递过来的参数。 8、每个function对象的arguments.length表示实际接收到的参数个数，而methodName.length表示function期望得到的参数个数（也就是定义的参数个数）。\n9、JavaScript的5中原始数据类型，包括Undefined、Null、Boolean、Number、String：\n1)Undefined类型：只有一个值undefined。当使用var声明一个变量时，如果没有对该变量进行赋值，默认值就是Undefined类型的undefined值。Undefined本身是Null类型的派生类型。\n2）Null类型：只有一个值null。在if的判断语句中，除了null和undefined两个值之外的其它值都等同于true。\n3）Boolean：拥有过两个值true和false。\n4）Number：数值类型。\n5）String：字符串类型，在JavaScript中没有char类型，因此在JavaScript中使用\u0026quot;\u0026ldquo;和‘’都表示字符串。\n10、typeof在JavaScript中是一个单目运算符，用于运算变量的类型，运算结果只有5个值：undefined、boolean、number、string、object。前四个返回值对应JavaScript的原始数据类型（Undefined和Null返回值都是undefined），最后一个返回值object对应对象变量，只要是对象的返回值都是object。\n11、JavaScript中3中类型强制转换：Boolean(value)、Number(value)、String(value)。如果在强制类型转换前加上new标识符则不是强制类型转换，而是构造对象，如new String(value)是构造一个String对象，使用typeof运算符的结果是object而不是string。\n12、JavaScript中的所有对象都是从Object对象继承过来，Object中属性是不可枚举的，使用Object.propertyEnumerable(\u0026ldquo;element\u0026rdquo;)返回的结果是false，所以不能使用for..in语句遍历Object中的属性。\n13、JavaScript是一种动态编程语言，可以动态添加已有对象的属性和方法，也可以动态删除对象的属性和方法。比如object为已有的对象：\n1）动态添加对象的属性和方法：object.newElement = value 或者 object[\u0026ldquo;newElement\u0026rdquo;] = value。其中newElement为新的属性或者方法的名称，value新添加属性或者方法的类型，可以是JavaScript的原始数据类型，也可以是对象。当newElement为方法时，value为Function对象。\n2）动态删除对象的属性和方法：使用单目运算符delete object.newElement。\n14、JavaScript的Array数组具有方法sort()用于对Array数组进行排序，它的排序方法是将数组中的元素先转换成字符串，再根据字符串从小到大的排序规则排序。因此，这个方法对于数字类型的排序不准确，sort方法也支持传递一个function对象作为参数来修正sort的排序方法。可以定义一个Function对象比较两个参数，返回值为正数、负数和0三种，sort根据返回结果排序，原理类似于Java的compare类。\n15、JavaScript中定义对象的方法（JavaScript中没有类的感念，只有对象）：\n1）基于已有对象进行扩充属性和方法，原理是根据JavaScript语言的动态性，向已有对象动态添加新的属性和方法来形成自定义的对象。但这种做法的缺点是不能重复构造这种对象，也就是一次性和临时性的。另外，定义一次性对象有种便捷方法就是使用{}括号，如：var object = { name1:value1;name2:value2\u0026hellip;}，其中name为对象属性名称，value为属性内容，可以使原始数据类型或者对象（name为方法时，value为function对象）。\n2）工厂方式，利用function来构造对象。既然没有类，那么就使用方法将扩充已有对象的代码放到function中，并将扩充的对象以返回值的形式返回，那么只要调用function就能够重复构造这种对象。 如：\nfunction createObject(){ var object = new Object(); object.name = \u0026quot;name\u0026quot; ; object.get =function(){}; return object; } 调用的时候直接使用var object = createObject(); 以上做法有一个缺点就是每构造一个对象出来都会创建一份对象的属性和方法，但是方法不需要每个对象都创建一份，同类对象共享一份就够了。解决的方法就是把对象内的方法定义移动到function之外，再在对象内调用外部的方法。 3）构造函数方式：与工厂方式很类似，不同之处在于function中不需要定义个对象变量，也不需要使用return语句，并且在构造对象使不是调用构造方法，而是使用new关键字。 如： function createObject(){ this.name = \u0026quot;name\u0026quot;; this.get = function(){}; } 调用的时候使用var object = new createObject(); 这么做的原因在于使用function定义的本来就是一个Function对象，使用new构造的时候就会默认构造一个Function对象出来，function中的this就是它本身的这个Function对象，最后也会默认返回它自身这个对象。 4）原型方式（prototype）：这种方式与扩充已有对象的方式很类似，不同的是扩充已有对象的方式扩充的只是当前的这一个对象，而原型方式扩充的是当前类的原型。如： function Person(){} Person.prototype.name = \u0026quot;name\u0026quot;; Person.prototype.get = function(){}; 这么一来使用new Person()构造的Person对象就拥有过name和get两个属性。需要注意的是使用原型添加的属性在构造出来的所有对象中共享。如果是个对象，那么构造出来的所有对象的这个属性指向的都是同一个对象，一处改变就会影响其它对象；但对于常量属性来说就不会，修改的对象属性指向新的常量不会影响其它对象。使用原型方式还有一个缺点在于无法在构造函数中为属性赋初值，只能在对象生成之后再去改变。 5）原型方式+构造函数方式：为解决原型方式共享属性的缺点，将属性使用构造函数方式实现，将方式使用原型方式实现，这样就更加贴近Java的规则。 6）动态原型方式：为了将方法放进构造函数内部，又不会每构造一个对象都会重新生成一个方法，因此，引入一个标识量来判定是否第一次构造，第一次构造就使用原型方法添加方法，不是第一次就跳过添加方法。如： function Person(){ this.name = \u0026quot;name\u0026quot;; if(typeof Person.flag == \u0026quot;undefined\u0026quot;){ Person.prototype.get = function(){}; Persion.flag = ture; } } 16、JavaScript的继承：\n1）对象的冒充，关键在于JavaScript的this标示符表示的是当前对象或者调用当前Function对象的对象。如：\nfunction Parent(name){ this.name = name; } function Child(name){ this.method = Parent; this.method(name); delete this.method; } 这个例子中Child先定义了属性method类型为Parent，然后通过method属性调用Parent方法，关键就是这句this.method(name)，因为function中的this在被其它对象调用的情况下代表的是这个对象，所以this.method(name)就是Child对象调用Parent，Parent中的this也就变成了Child，相当于Child拥有了name属性。通过这个原理，只要Parent中使用this定义的属性和方法统统都能够被Child继承过来。 对象冒充的缺点在于多级继承的时候容易出现混乱，当子对象中存在与父对象相同名称的属性时就会覆盖父对象的属性。 2）call方式继承：每一个Function对象都具有call方法，call方法的第一个参数是传递给Function对象中的this，剩下的参数逐一赋给Function中的其它参数。如： function Parent(name){ this.name = name; } function Child(name){ Parent.call(this,name); } 这个例子中Child的对象就具有了Parent的属性name。 3）apply方式继承：每一个Function对象也都具有apply方法，它的使用与call方法基本一样，第一个参数与call方法第一个参数功能一样。两个方法的不同之处在于后续的参数，apply只有两个参数，第二个参数是一个Array数组，数组中的元素就是传递参数，相当于对call方法的后续参数组合成一个数组而已。两个方法之间本质上基本没有区别。 4）原型链方式继承：这种方法的关键在于每个对象具有的属性prototype，对象.prototype可以看做是定义对象内部的this。如： function Parent(){}; Parent.prototype.name = \u0026quot;hello\u0026quot;; function Child(){}; Child.prototype = new Parent(); 以上例子，Child通过prototype赋予Parent对象等于Child与Parent对象一样，只要再使用Child.prototype.Element添加Child自己的属性就等同于继承了Parent又添加了自己的属性。但是这种方式的缺点在于无法给构造函数传递参数。 5）混合方式（最推荐的方式）：混合call\\apply和原型继承方式。如： function Parent(hello){ this.hello = hello; } Parent.prototype.sayHello = function(){}; function Child(hello,world){ Parent.call(this,hello); this.world = world; } Child.prototype = new Parent(); 以上例子中，最后还需要使用Child.protytype = new Parent()是因为call方法没有继承到sayHello，sayHello是通过prototype在function外部定义的，call只能继承到function中this定义的属性。 17、JavaScript的console对象只能用于FireFox浏览器，这个对象能够像FireFox的FireBug插件的控制台输出相关信息：\n1）console.log(message)：输出日志信息。\n2）console.info(message)：输出信息。\n3）console.warn(message)：输出警告信息。\n4）console.error(message)：输出错误信息。\n5）console.debug(message)：输出调试信息。\n","date":"July 10, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/javascript/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E8%AE%B0/","series":[{"title":"JavaScript学习笔记","url":"https://www.qinxiandiqi.sbs/series/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javascript","url":"https://www.qinxiandiqi.sbs/tags/javascript/"},{"title":"function","url":"https://www.qinxiandiqi.sbs/tags/function/"},{"title":"对象","url":"https://www.qinxiandiqi.sbs/tags/%E5%AF%B9%E8%B1%A1/"},{"title":"继承","url":"https://www.qinxiandiqi.sbs/tags/%E7%BB%A7%E6%89%BF/"},{"title":"object","url":"https://www.qinxiandiqi.sbs/tags/object/"}],"title":"JavaScript学习笔记 第二记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaScript学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、JavaScript是一种可以嵌入在Web页面中的面向对象和事件驱动的解释性语言，使用动态绑定（在运行时才对对象进行检查）。\n2、JavaScript区分大小写，语句以行为单位，可以加“;”或者不加。\n3、Web页面中嵌入JavaScript需要使用标签，可以嵌入到页面中的任何位置。\n4、使用JavaScript的基本格式：\n1）\u0026lt;script\u0026gt; document.write(\u0026quot;Hello World\u0026quot;);\u0026lt;/script\u0026gt; 2）\u0026lt;script language=\u0026quot;JavaScript\u0026quot;\u0026gt;document.write(\u0026quot;Hello World\u0026quot;);\u0026lt;/script\u0026gt; 3）\u0026lt;script language=\u0026quot;JavaScript\u0026quot; type=\u0026quot;text/JavaScript\u0026quot;\u0026gt; document.write(\u0026quot;Hello Wrold\u0026quot;);\u0026lt;/script\u0026gt; 4）\u0026lt;script language=\u0026quot;JavaScript1.2\u0026quot;\u0026gt;document.write(\u0026quot;Hello Wrold\u0026quot;);\u0026lt;/script\u0026gt; 5）引用外部js文件：\u0026lt;script src=\u0026quot;js-url\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;。在外部js文件中不需要使用\u0026lt;script\u0026gt;标签，直接写JavaScript语句，引用后将自动把js文件中的JavaScript语句包含到\u0026lt;script\u0026gt;中进来。 5、JavaScript可以嵌入到Web页面的任何位置，执行顺序是标签中的JavaScript代码在加载Web页面的时候被装载进来，但是其中的function不执行，必须调用后才会执行。中的JavaScript一旦加载便立刻执行。通常将定义function和全局变量的语句放到标签中。\n6、HTML中的某些标签使用JavaScript协议调用JavaScript语句，如href=\u0026ldquo;JavaScript:alert(\u0026lsquo;Hello World\u0026rsquo;)\u0026rdquo; 等同于 href=\u0026quot;#\u0026quot; onClick=\u0026ldquo;alert(\u0026lsquo;Hello World\u0026rsquo;)\u0026quot;。\n7、对于JavaScript变量，没有定义在function中的变量为全局变量，使用var声明定义在function中的变量为局部变量，但是在function中没有使用var声明直接使用的变量也是全局变量。\n8、JavaScript的with语句：with(对象){\u0026hellip;}。with语句是对象操作的简化语句，with后的括号内为一个对象，中括号中可以直接使用对象的内容，相当于默认在中括号中使用的方法或变量前添加了“对象.”。\n9、for(var i in object)：遍历对象object中所有的属性，其中i为每个属性的属性名，可以使用object[i]获得i属性的值。\n10、JavaScript不像Java语言有很规范的定义类语法，JavaScript中定义对象使用function，function name(parmes){}类似于Java中的类的构造方法。使用function就等于声明了一个类，通过new name就可以构造一个该类型的对象。由于JavaScript弱类型的特性，在function中使用this.AtributeName就等于为该类声明一个属性名为AttributeName的属性，并且类型不限（JavaScript中没有强的类型规范）。\n11、JavaScript内置对象Date，使用new Date()可以构造一个Date对象。Date中主要方法：\n1）getYear()：返回距离1900年的年数，获得当前年份需要在返回值的基础上加1900. 2）getMonth()：返回当前月份数，范围为0-11，因此需要在返回值的基础上加1. 3）getDate()：返回当前的日期数，范围为1-31. 4）getDay()：返回星期数，范围为0-6. 4）getHours()：返回当前的时数，范围为0-23. 5）getMinutes()：返回当前的分钟数，范围为0-59. 6）getSeconds()：返回当前的秒数，范围为0-59. 12、JavaScript内置对象Array，使用new Array(数组长度)或new Array(元素1，元素2\u0026hellip;)或者“数组名称=[元素1，元素2\u0026hellip;]”构造Array数组对象。JavaScript中的Array类似于Java中的集合，因为它的长度不限制（当长度不够时，Array会自动扩容），存储的元素类型也不限制（JavaScript只用一种类型标识符var）.\n13、JavaScript内置对象Array的主要属性和方法：\n1）length：Array表示数组长度的属性。 2）join(分隔符)：方法，将数组元素组合成字符串，并使用参数分隔符分隔每个元素，不提供参数时默认使用“,”分隔符。 3）toString()：方法，返回数组的字符串，以“,”为元素分隔符，相当于使用join()方法。 4）reverse()：方法，将数组的元素倒序，这种修改直接在原数组上修改，也就是改变将影响原数组。 5）valueOf()：方法，返回数组值，相当于使用join()方法。 6）push()：方法，向数组中添加一个元素。 7）pop()：方法，移除数组中一个元素。 14、当Array数组的元素又是一个Array数组时，这个Array数组便成为多维数组。\n15、JavaScript的document.write()方法中参数组合多个数据，可以使用“+”运算符，也可以使用“,”运算符，两者没有区别。\n16、JavaScript的内置对象String，使用new String(字符串常量)或者“字符串变量=\u0026ldquo;字符串常量\u0026rdquo;”构造String对象，主要的属性和方法有：\n1）length：属性，String字符串的长度。 2）charAt(索引)：方法，返回索引位置的字符。 3）indexOf(\u0026quot;字符串\u0026quot;)：返回字符串在对象中的索引位置。 4）lastIndexOf(\u0026quot;字符串\u0026quot;)：返回字符串在对象中的索引位置（反向搜索）。 5）replace(\u0026quot;字符串1\u0026quot;,\u0026quot;字符串2\u0026quot;)：使用字符串2替换字符串1。 6）search(\u0026quot;字符串\u0026quot;)：返回字符串在对象中的索引位置。 7）subString(索引1,索引2)：返回索引1到索引2的子字符串（不包括索引2位置上的字符）。 17、定义自己的JavaScript类需要使用function，在JavaScript中的this不一定就是指当前对象，也可以是使用当前对象的对象。在function中，使用this.AttributeName定义类的属性，同样也是使用this.MethodName定义类的方法，所不同的是这个MethodName是另外一个function定义的类，这个类将当做一个方法使用。使用类方法的时候，根据类名.MethodName()就可以使用类中的方法。\n18、JavaScript是基于事件驱动的，在很多HTML标签中添加属性onClick、onMouseOver、onMouseOut等，属性值为一个JavaScript表达式，当接收到相应的事件后边会触发对应的JavaScript处理方法。\n19、JavaScript的定时器：\n1）内置window对象的setTimeout()方法返回一个定时器对象。使用格式为：定时器对象名称=setTimeout(\u0026quot;\u0026lt;表达式\u0026gt;\u0026quot;,time毫秒数)。这个定时器对象将在time毫秒后执行\u0026lt;表达式\u0026gt;的内容。 2）内置window对象的setInterval()方法返回一个循环定时对象。使用格式为：定时器对象名称=setInterval(\u0026quot;\u0026lt;表达式\u0026gt;\u0026quot;,time)。这个定时器对象将每隔time毫秒执行一次\u0026lt;表达式\u0026gt;的内容。 3）window对象的clearInterval(定时器对象名称)方法用于终止定时器对象。 20、document.getElementById(tagID).innerHTML用于获取标签ID为tagID的标签的HTML内容。\n21、JavaScript中对于HTML的每个标签都可以处理为一个对象，在一个标签或者控件中使用JavaScript的方法时，将this作为参数即表示将这个控件对象作为参数。如。\n22、控件的属性onblur表示监听焦点离开控件的监听器。\n23、JavaScript的confirm(tipcontext)方法用于弹出选择对话框，当选择确定时返回true，选择取消时返回false。\n24、JavaScript的window.location.href=url，用于跳转到url地址。\n25、JavaScript内置对象screen的属性：\n1）availHeight：浏览器内容显示区的实际高度。 2）availWidth：浏览器内容县市区的实际宽度。 3）height：显示器屏幕的高度。 4）width：显示器屏幕的宽度。 26、JavaScript事件绑定的两种方法：\n1）直接在控件标签中使用相应事件监听器属性，如\u0026lt;input type=\u0026quot;button\u0026quot; onclick=\u0026quot;test();\u0026quot;\u0026gt;。 2）在\u0026lt;script\u0026gt;标签中使用JavaScript脚本绑定，先使用document.getElementById()等方法获取控件对象，在调用控件对象相应的事件监听属性赋予function处理方法（注意值只是function的方法名，后面不带括号）。这种绑定方法需要将\u0026lt;script\u0026gt;脚本位置放置到控件标签之后，因为HTML解析是按照先后顺序解析，放在控件标签前面将绑定到一个空对象上。另外这种绑定也可以使用匿名function，即直接在给控件对象事件监听属性赋值时定义function(){}。 27、JavaScript的事件绑定处理方法function获取事件对象时，根据不同浏览器可能需要在function的参数使用参数event。FireFox的处理方法是事件触发后生成是个事件对象作为function的参数（如果function带有event参数的话）。IE的处理方法是使用内置事件对象event，function有没有带参数都可以在function方法中通过event获得事件对象。\n28、JavaScript内置对象history方法back()，用于返回历史页面，不带参数默认返回上一个历史页面，等同于history.back(-1)，返回到历史第i个页面使用history.bake(-i)。对于，如果onclick后面不添加return false语句，那么执行back方法返回历史页面后又由于返回true继续实行href=\u0026rdquo;#\u0026quot;，从而又返回到当前页面，导致back方法失效。\n29、标签的属性onload：该事件监听属性的特点是当整个网页内容全部加载完毕后触发这个方法。\n30、JavaScript的document.links用于获得页面中所有的超链接地址组成的数组，通过document.links[i]可以获得页面中的第i个超链接地址。\n31、JavaScript的document.from[i]用于获得页面中的第i个form表单对象，通过document.forms[i].elements[j]可以获得第i个表单中的第j个控件对象。\n32、JavaScript中的控件对象调用focus()方法可以让该控件获得焦点。\n","date":"July 10, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/javascript/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E8%AE%B0/","series":[{"title":"JavaScript学习笔记","url":"https://www.qinxiandiqi.sbs/series/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javascript","url":"https://www.qinxiandiqi.sbs/tags/javascript/"},{"title":"function","url":"https://www.qinxiandiqi.sbs/tags/function/"},{"title":"类","url":"https://www.qinxiandiqi.sbs/tags/%E7%B1%BB/"}],"title":"JavaScript学习笔记 第一记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、HttpServletResponse的对象resp的以下代码：\nresp.setContentType(\u0026quot;text/xml;charset=utf-8\u0026quot;); resp.setHeader(\u0026quot;pargma\u0026quot;,\u0026quot;no-cache\u0026quot;); resp.setHeader(\u0026quot;cache-control\u0026quot;,\u0026quot;no-cache\u0026quot;); 分别用于通知客户浏览器服务器响应的数据媒体格式为text/xml，字符编码集为utf-8，浏览器不使用响应缓冲。对应使用Ajax更新数据的页面需要此设置，缓冲可能会影响页面数据的更新。 2、Ajax接收到服务器响应的xml数据时，接收到的是xml的DOM对象，将DOM对象转换为jquery对象就可以使用jquery中xml对象的find(\u0026ldquo;element\u0026rdquo;)方法获得xml文件中相应的元素节点对象，再使用.text()方法就能获得节点对象的内容。如：$.ajax()方法中的回调方法中$(returnedData).find(\u0026ldquo;element\u0026rdquo;).text()。\n3、google提供使用ajax和json格式的image搜索api开发文档：https://developers.google.com/image- search/v1/jsondevguide。实际上就是google提供了一组搜索图片的api网络服务，通过这些api访问google，google将搜索结果以json的形式返回。这个搜索图片的api为：https://ajax.googleapis.com/ajax/services/search/images?，只要在这个url后加上开发文档中指定的其它参数就能够获得google服务返回的结果。如必须的参数v=1.0（表示api的版本）、q=\u0026quot;\u0026quot;（表示搜索的关键字）、start=\u0026ldquo;\u0026ldquo;返回从搜索结果的第i幅图片开始的8幅图片信息）、rsz=\u0026ldquo;1-8\u0026rdquo;（设置返回图片的大小级别）等等。google的图片搜索每次请求能够返回的图片json信息只有8组。\n4、Java使用google api获取搜索图片服务结果过程（queryUrl为获取google服务的API搜索url）：\nURL url = new URL(queryUrl); URLConnection conn = url.openConnection(); InputStream is = conn.getInputStream(); InputStreamReader isr = new InputStreamReader(is);//返回结果是json字符串 BufferedReader br = new BufferedReader(isr); StringBuffer buffer = new StringBuffer(); String line = null; while(null != (line = br.readLine()){ buffer.append(line); } br.close(); isr.close(); is.close(); 最终buffer.toString()获得字符串就是google搜索返回json结果字符串。 5、将使用指定url文件保存到本地的方法（fileUrl为指定文件的url）：\nURL url = new URL(fileUrl); InputStream is = url.openStream(); OutputStream os = new FileOutputStream(new File(\u0026quot;path\u0026quot;)); int length = -1 byte[] buffer = new byte[bufferSize]; while(-1 != (length = is.read(buffer,0,bufferSize))){ os.write(buffer,0,length); } 6、req.getSession().getServletContext().getRealPath(\u0026ldquo;webFile\u0026rdquo;)用于获得请求资源所在web应用的webFile资源在服务器上的真实文件系统路径。\n7、设置临时域名：Windows系统下C:\\WINDOWS\\system32\\drivers\\etc\\hosts文件，最后添加“IP地址 临时域名”，保存后即可在本机使用临时域名访问设置IP地址的主机。\n8、Tomcat设置虚拟主机：Tomcat目录的conf目录中server.xml文件中\n\u0026lt;Engine name=\u0026quot;Catalina\u0026quot; defaultHost=\u0026quot;localhost\u0026quot;\u0026gt; \u0026lt;Host name=\u0026quot;www.nan.com\u0026quot; appBase=\u0026quot;././.\u0026quot;/\u0026gt; \u0026lt;Host name=\u0026quot;www.qinxiandiqi.com\u0026quot; appBase=\u0026quot;././.\u0026quot;/\u0026gt; \u0026lt;/Engine\u0026gt; 子标签Host即为设置Tomcat虚拟主机，对应域名到对应的应用目录中。 9、Eclipse中，Debug模式下，使用F6但不运行程序并在下一处断点位置暂停；F5单步运行程序。变量信息窗口中没有想要查看的变量，在代码窗口中选中某个变量后右击弹出快捷菜单，选择watch选项，右上方窗口中就会出现该变量。\n10、Servlet除了doGet和doPost两个常用方法之外，还有getLastModified(HttpServletRequest requset)常用方法，用于返回该文档的最后修改时间，默认为-1，表示该文档永远都是最新的。当Tomcat执行Servlet时，在调用doGet之前会先调用gatLastModified。此时，如果浏览器发现getLastModified返回值与上次访问时的返回值相同，则浏览器认为该文档没有更新，采用缓存而不要求执行doGet；如果getLastModified返回-1，则认为时刻都是最新的，总是要求执行doGet。\n","date":"July 10, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AE%B0/","series":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/series/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javaweb","url":"https://www.qinxiandiqi.sbs/tags/javaweb/"},{"title":"tomcat","url":"https://www.qinxiandiqi.sbs/tags/tomcat/"},{"title":"虚拟主机","url":"https://www.qinxiandiqi.sbs/tags/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/"},{"title":"servlet","url":"https://www.qinxiandiqi.sbs/tags/servlet/"}],"title":"JavaWeb学习笔记 第十二记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、Servlet监听器HttpSessionListener：实现javax.servlet.http.HttpSessionListener接口的类，主要包含两个方法：\n1）sessionCreated(HttpSessionEvent se)：当创建一个Session时调用。 2）sessionDestroyed(HttpSessionEvent se)：当销毁一个Session时调用，需要注意不是浏览器一关闭就调用，Session的生命周期是由Session的不活动最长时间决定。 3）部署HttpSessionListener监听器需要在web.xml文件中布置\u0026lt;listener\u0026gt;标签。 2、Servlet监听器HttpSessionAttributeListener：实现接口javax.servlet.http.HttpSessionAttributeListener的类，主要包括三个方法：\n1）attributeAdded(HttpSessionBindingEvent se)：当使用Session对象的setAttribute方法添加一个Attribute时调用的方法。 2）attributeRemoved(HttpSessionBindingEvent se)：当使用Session对象的setAttribute方法更新一个Attribute值时调用的方法。 3）attributeReplaced(HttpSessionBinding se)：当使用Session对象的removeAttribute方法时调用的方法。 4）部署HttpSessionAttributeListener同样需要在web.xml文件中使用\u0026lt;listener\u0026gt;标签布置。 3、EL表达式：为了简化JSP中的Java代码的表达式，以减少JSP中对JSP脚本的使用。\n4、EL表达式语法：${ expr }。\n5、“${ expr }”：在EL表达式前添加“\\”将使EL表达式无效，与普通文本一样。\n6、EL的内置对象：\n1）PageContext：类型为javax.servlet.jsp.pageContext，表示此JSP的PageContext。 2）pageScope：类型为java.util.Map，是取得Page范围的属性名称对应的值。 3）requestScope：类型为java.util.Map，是Request对象使用setAttribute方法存储的Attribute对应的值。 4）sessionScope：类型为java.util.Map，是Session对象使用setAttribute方法存储的Attribute对应的值。 5）applicationScope：类型为java.util.Map，是Application对应使用setAttribute方法存储的Attribute对应的值。 6）param：类型为java.util.Map，是客户端发出请求附加的数据param，等同于Request的方法getParamter(String name)获得的值。 7）paramValues：类型为java.util.Map，是客户端发出请求附加的数据param，等同于Request的方法getParamterValues(String name)获得的值的数组（附加数据一个name对应多个值时需要这种这个对象）。确定paramValues中的哪个值需要使用[]运算符来确定。 8）header：类型为java.util.Map，等同ServletRequest.getHeader(String name)获得的值。 9）headerValues：类型为java.util.Map，等同于ServletRequest.getHeaders(String name)获得的值的数据，需要使用[]运算符具体确定数组中哪个值。 10）cookie：类型为java.util.Map，等同于HttpServletRequest.getCookies()获得的Cookie数组，需要使用[]运算符。 11）initParam：类型为java.util.Map，等同于ServletContext.getInitParameter(String name)获得的String值。 7、EL提供.和[]两种运算符来存取数据，两者基本一样，区别在于[]运算符中的索引可以是确定的值也可以是变量（变量灵活性比较高），并且当存取的属性名称中包含一些特殊字符（.或者- 等非字母或数字的符号）时，必须使用[]运算符。\n8、当EL表达式中的属性名没有指明具体范围时，EL表达式默认会先中Page范围查找这个属性。找不到的话则依次查找Request、Session、Application范围，如果找到则不继续让下查找并返回值，如果都找不到则返回null。\n9、EL支持大多数数学和逻辑运算符，如+、-、*、/等。当运算符处理的数据类型不一致时能够根据类型转换规则自动转换数据类型。\n10、EL表达式也可以处理JavaBean：${ JavaBeanName.Attribute }。\n11、EL表达式的内置对象除了pageContext之外，其它的内置对象都只能够获取对应Attitude的值，因为它们的类型只是java.util.Map。但是pageContext的类型是PageContext，通过pageContext.request.*类型的样式可以获取PageContext的其它对象来处理更复杂的操作。\n12、JSP标签技术从JSP 1.1版本开始支持，目的是使JSP代码更加简洁，运用这些可重用的标签能处理复杂的逻辑运算和事务，或者定义JSP网页的输出内容和格式。\n13、创建自定义JSP标签的步骤：\n1）创建标签的处理类。 2）创建标签库的描述文件。 3）在JSP文件中引入标签库，然后便可以在JSP使用自定义的标签。 14、创建标签的处理类：创建标签的处理类需要继承javax.servlet.tagext.TagSupport或者javax.servlet.jsp.tagext.BodyTagSupport两个类其中一个，BodyTagSupport本身就是TagSupport的子类。一般继承后都需要重写doStartTag和doEndTag两个方法。\n15、TagSupport类中的主要方法：\n1）int doStartTag()：当Servlet容器解析JSP时遇到自定义标签的起始标签时调用的方法，其返回值有Tag.SKIP_BODY或者Tag.EVAL_BODY_INCLUDE两种，分别代表忽略自定义标签之间的内容和正常执行自定义标签之间的内容，一旦忽略则自定义标签之间的内容等于不存在。 2）int doEndTag()：当Servlet容器解析JSP时遇到自定义标签的结束标签时调用的方法，其返回值同样有Tag.SKIP_PAGE和Tag.EVAL_PAGE两种，分别代表忽略结束标签之后所有的JSP页面内容并将已有的输出内容立刻返回到客户的浏览器上，和代表按照正常的流程继续执行后续的JSP页面内容。 3）setValue(String k,Object o)：在标签处理类中设置一对键值。 4）getValue(String k)：获得在标签处理类中的键名为k的value。 5）removeValue(String k)：移除标签处理类中键名为k的键值对。 6）setPageContext(PageContext pc)：设置pageContext对象，该方法在Servlet容器调用doStartTag或doEndTag方法之前调用。 7）setParent(Tag t)：设置嵌套了当前标签的上层标签的处理类，同样该方法再Servlet容器调用doStartTag或doEndTag方法之前调用。 8）getParent()：获得嵌套当前标签的上层标签的处理类。 16、TagSupport类的两个重要属性：\n1）parent：代表当前标签的上层标签的处理类（类中定义为私有类型，所以J2EE帮助文档中没有显示这个属性）。 2）pageContext：代表Web应用中的javax.servlet.jsp.PageContext对象。PageContext提供了public void setAttribute(String name,Object value,int scope)和public Object getAttribute(String name,int scope)两个方法用来获取scope范围内设置的Attribute属性。其中scope的值有PageContext.PAGE_SCOPE（page范围内设置的Attribute）、PageContext.REQUEST_SCOPE（request范围内设置的Attribute）、PageContext.SESSION_SCOPE（session范围内实质的Attribute）、PageContext.APPLICATION_SCOPE（application范围内实质的Attribute）。 17、JSP自定义标签处理业务的关键在于访问到JSP中的application、session、request和page范围内的共享数据。为了实现，所以TagSupport类中提供了方法setPageContext和setParent方法并且这两个方法在doStartTag和doEndTag方法调用之前调用，以此来保证自定义标签处理类的业务逻辑开始之前处理类获得PageContext对象和标签的上层标签处理类对象。之后，在doStartTag和doEndTag方法中就可以通过getParent方法获得上层标签的处理类（parent属性是private，所以需要方法获得），或者直接访问pageContext成员（pageContext成员是protected，所以在子类中可以直接访问）。通过这两个对象就能访问到JSP中的共享数据。\n18、自定义标签也可具有自己的属性，并且自定义标签的属性需要在对应的处理类中定义属性名的成员变量和它的get\\set方法。使用自定义标签，并且标签中有属性时，处理类的set方法会被调用。\n19、创建标签库的描述文件，其后缀名为“.tld”，本质上描述文件是一个有效的xml文件，使用DTD进行验证。因此，描述文件需要添加以下声明：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE taglib PUBLIC \u0026quot;-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN\u0026quot; \u0026quot;http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd\u0026quot;\u0026gt; 20、标签库描述文件的DTD验证中规定了tld文件根元素为。其中必须由子元素：\n1）\u0026lt;tlib-version\u0026gt;（int）tldversion\u0026lt;/tlib-version\u0026gt;：表示标签库描述文件的版本号。 2）\u0026lt;jsp-version\u0026gt;1.1\u0026lt;/jsp-version\u0026gt;：JSP的版本号，一般都是1.1。 3）\u0026lt;short-name\u0026gt;tlibname\u0026lt;/short-name\u0026gt;：标签库的简称。 4）\u0026lt;uri\u0026gt;tliuri\u0026lt;/uri\u0026gt;：最终要的子元素之一，代表引用该标签库的uri地址。 5）\u0026lt;tag\u0026gt;tag\u0026lt;/tag\u0026gt;：必须有一个或多个tag标签，一个tag标签代表一个自定义标签，必须含有子元素\u0026lt;name\u0026gt;（表示自定义标签的标签名）、\u0026lt;tag-class\u0026gt;（表示自定义标签的处理类，元素内容为处理类的全称）。可选元素\u0026lt;body-content\u0026gt;（表示自定义标签是否具有内容，值为empty表示该标签为空标签）、\u0026lt;attribute\u0026gt;（表示自定义标签的属性，带有子标签\u0026lt;name\u0026gt;表示属性名，\u0026lt;required\u0026gt;表示该元素是否必须具有）。 21、JSP中引入自定义标签库，使用JSP命令\u0026lt;%@taglib uri=\u0026quot;\u0026quot; prefix=\u0026quot;\u0026quot; %\u0026gt;。其中属性uri就是标签库描述文件中的子元素的内容，prefix为JSP页面中引用该标签库标签的前缀。 如prefic:tag。\n22、自定义标签库的描述文件必须放在/WEB-INF文件夹下，因为Web应用可能被部署到不同操作系统平台上，借由每个Web应用都具有WEB- INF文件夹的特点，将描述文件放置到这个目录下可以提高Web应用的跨平台性。而且，Tomcat默认也会自动到这个目录查找自定义标签库的描述文件。\n23、自定义标签的运转流程：\n1）Servlet容器解析JSP文件，使用taglib命令引入自定义标签库。 2）解析JSP遇到自定义标签时，从标签库的描述文件中查找tag元素的class。先调用setPageContext和setParent方法，以及标签存在属性的话调用处理类中对应属性的set方法。 3）解析到自定义标签开始标签，调用处理类的doStartTag方法。 4）解析到自定义标签结束标签，调用处理类的doEndTag方法。 需要注意的是！自定义标签处理类的调用是在得到请求执行JSP调用，但是在JSP解析阶段是将JSP中的自定义标签解析为Servlet中调用处理类方法的代码。 24、PageContext对象提供了方法getOut()可以获得一个JspWriter对象，这个对象又提供了多个重载print方法，通过这些方法可以将对应的内容写到JSP页面上，从而最终输出到客户的浏览器。\n25、Java的标准配置文件，后缀名为“.properties”，文件的内容是一行一行的key=value，每一行都是一个键值对表达式。\n26、对应Java的标准配置文件，Java的java.util.Properties类对处理properties文件特别合适。Properties类继承Hashtable类，并且它的Key和Value都是String，符合properties文件的键值对类型。Properties提供了三个重要方法：\n1）load(InputStream inStream)：从输入流中读取属性列表键值对，当使用FileInputStream将properties文件读取进来加载如Properties对象，便可以通过Properties对象方便获得properties文件中的键值。 2）getProperties(String key)：返回指定key的Value，类型为String。 3）getProperties(String key,String defaultValue）：返回指定key的Value，类型为String。如果不存在这个key，则返回defaultValue。 27、自定义标签与properties的结合使用：可以解决Web应用应对不用语言的情况，根据客户端的默认语言，Web应用对应使用不用语言的properties配置文件。\n28、使用properties配置文件，通常需要一个初始化的Servlet，在这个初始化Servlet的init(ServletConfig config）方法中将properties配置文件的键值加载进Properties对象中。因此，这个Servlet需要在web.xml文件中不提供并且在标签中添加子标签设置启动加载的优先级。\n29、Servlet的init方法中加载properties文件的方法(ps为Properties对象）：\nServletContext context = config.getServletContext(); InputStream in = context.getResourceAsStream(\u0026quot;/WEB-INF/*.properties\u0026quot;); ps.load(in); in.close(); context.setAttribute(\u0026quot;ps\u0026quot;,ps);//将Properties对象放置到ServletContext全局对象中供其他组件使用。 30、标签处理类的TagSupport类中定义pageContext成员变量，通过它的getSession()方法同样可以获得当前HttpSession对象，从而获得session的共享数据。\n31、如果有以下代码：\n\u0026lt;% String path = request.getContextPath(); String basePath = request.getScheme()+\u0026quot;://\u0026quot;+request.getServerName()+\u0026quot;:\u0026quot;+request.getServerPort()+path+\u0026quot;/\u0026quot;; %\u0026gt; \u0026lt;base href=\u0026quot;http://www.baidu.com\u0026quot;\u0026gt; 那你下面的href属性就会以你上面设的为基准,如:你现在就只需要写\n","date":"July 10, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AE%B0/","series":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/series/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javaweb","url":"https://www.qinxiandiqi.sbs/tags/javaweb/"},{"title":"servlet listenter","url":"https://www.qinxiandiqi.sbs/tags/servlet-listenter/"},{"title":"EL表达式","url":"https://www.qinxiandiqi.sbs/tags/el%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"JSP标签","url":"https://www.qinxiandiqi.sbs/tags/jsp%E6%A0%87%E7%AD%BE/"},{"title":"Properties","url":"https://www.qinxiandiqi.sbs/tags/properties/"}],"title":"JavaWeb学习笔记 第十一记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、FilterChain链的形成：定义好各个链中的Filter过滤器后，决定FilterChain链中各个过滤器顺序的关键在于web.xml文档中Filter配置标签的前后顺序。当web.xml中配置的多个的子标签内容是同一个或包含有同一个url时，这个几个标签代表的Filter过滤器就存在于同一个FilterChain链中，并且它们在链中的顺序按Filter的标签在web.xml中的先后顺序排列。\n2、Filter中doFilter方法里面对FilterChain的doFilter方法的调用语句是个分界线：在调用FilterChain的doFilter方法之前的语句是在请求传入FilterChain的时候执行，分界线之后的代码是在请求传达到最终请求资源并返回响应反向通过FilterChain的过程中执行。简单的说，FilterChain的doFilter方法之前的代码针对Request对象进行处理，方法之后的代码针对Response对象进行处理。\n3、如果配置了Filter的url- pattern标签为/*，则对所有Web资源进行过滤。如果要排除其中几个资源不过滤，只能在doFilter方法中使用代码进行排除，如调用HttpServletRequest的getRequestURI等方法获取请求的资源的URI，再根据URI决定是否不进行过滤。\n4、Filter可以实现对敏感字符的过滤，在doFilter方法中使用String的replace方法可以对字符串进行过滤。\n5、Filter在web.xml中的标签可以添加多个子标签\u0026lt;/param- name\u0026gt;，这个子标签用于配置Filter的一些初始化参数。在Filter的init方法中可以通过inti的参数FilterConfig的getInitParameter(String name)方法获得name对应的value，或者通过FilterConfig的getInitParameterNames()方法获得所有参数的name组成的字符串数组。\n6、Filter中同样可以访问到ServletContext中的数据，可以通过init方法中的FilterConfig的方法getServletContext()获得当前web应用的ServletContext对象，或者在doFilter方法中通过HttpServletRequest的getSession().getServletContext()来获得。\n7、对于判断用户是否登录的代码通常放置在Filter中，因为这部分验证是通用的；对于判断用户是否有权限访问当前资源的代码通常直接放置在该资源中，因为这部分代码是针对特定资源的。\n8、Servlet监听器ServletContextListener：实现接口javax.servlet.ServletContextListener，接口中有两个方法：\n1）contextDestroyed(ServletContextEvent sce)：当ServletContext对象（JSP中的application）被销毁时自动调用的方法，该方法在所有的Servlet和Filter的Destroy方法调用之后再调用，也就是最后一个被调用。\n2）contextInitialized(ServletContextEvent sce)：当ServletContext对象被创建的时候自动调用的方法，由于每个Web应用只有唯一一个ServletContext对象，并且在Web中其它组件之前创建出来，所以启动Web应用时这个方法最先被调用。\n3）要让实现ServletContextListener的类监听一个Web应用，必须在该Web应用的web.xml配置文件中添加监听类的全名。\n9、Servlet监听器ServletContextAttributeListener：实现接口javax.servlet.ServletContextAttributeListener，接口中有三个方法：\n1）attributeAdded(ServletContextAttributeEvent scab)：当使用ServletContext对象的setAttribute方法添加Attribute时自动调用的方法。\n2）attributeRemoved(ServletContextAttributeEvent scab)：当使用ServletContext对象的removeAttribute(String name)方法删除一个Attribute时自动调用的方法。\n3）attributeReplaced(ServletContextAttributeEvent scab)：当使用ServletContext对象的setAttribute方法更改一个已有Attribute的值时自动调用的方法。\n4）要让实现ServletContextAttributeListener的类监听一个Web应用，需要在web.xml配置文件中添加监听类的全名。\n10、事件类javax.servlet.ServletContextAttributeEvent中对应ServletContext的Attribute的两个方法：\n1）String getName()：获得更改Attribute的名字。\n2）Object getValue()：获得更改Attribute的值。\n","date":"July 10, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E8%AE%B0/","series":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/series/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javaweb","url":"https://www.qinxiandiqi.sbs/tags/javaweb/"},{"title":"filter","url":"https://www.qinxiandiqi.sbs/tags/filter/"},{"title":"servlet","url":"https://www.qinxiandiqi.sbs/tags/servlet/"},{"title":"listener","url":"https://www.qinxiandiqi.sbs/tags/listener/"}],"title":"JavaWeb学习笔记 第十记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、HttpServletRequest和HttpServletResponse对象由Servlet容器负责创建，对于每一个HTTP请求，Servlet容器都会创建一个HttpServletRequest对象和HttpServletResponse对象。\n2、Web服务器跟踪客户状态的四种常见方法：\n1）建立含有跟踪数据的隐藏字段（如input标签type属性值为hidden的控件）。 2）重写包含额外参数的URL。 3）使用持续的Cookie。 4）使用Servlet API中的Session机制（依赖于Cookie）。 3、Session指的是在一段时间内，单个客户与Web服务器的一连串相关的交互过程，在一个Session中，客户可能会多次请求同一个网页，也有可能请求不同的服务器资源。\n4、Session的运行机制：\n1）当客户首次访问服务器支持Session的资源时，Servlet容器将创建一个HttpSession对象，在HttpSession对象中存放客户的状态信息。 2）Servlet容器创建HttpSession对象的时候会为HttpSession对象分配一个唯一的标识符（很长以防止重复），称为Session ID。当客户首次访问Web服务器可支持Session的资源并返回响应时，HttpServletResponse对象中会自动添加一个Cookie对象，这个Cookie的name为SESSIONID，value为HttpSession的Session ID。客户得到服务器的响应后就得到了Session的Cookie。 3）当这个客户向该Web服务器再次发出请求时，Servlet容器就能够从HttpServletRequest对象中获取客户端保存的Session ID，然后根据Session ID找到相应的HttpSession对象，从而获得该客户的状态信息。如果是一个新的客户发出请求，Servlet容器必然无法从客户端获取Session ID，也就找不到匹配的HttpSession对象，Servlet容器就会重复步骤1，为新的客户创建一个新的HttpSession对象以及后续系列操作。 4）当客户端（也就是浏览器）关闭的时候，并没有向Web服务器发出请求，自然Servlet容器无法获知客户端已经关闭，Servlet容器也就没有将该客户的HttpSession对象销毁。HttpSession的销毁一般是根据HttpSession设定的无活动最长时间由服务器自动销毁。 5、HttpSession的主要方法：\n1）getID()：返回Session的ID。同一个浏览器只要未关闭，再开启这个浏览器的另一个标签页或者窗口，它们使用的都是同一个Session。而当这个浏览器关闭，就算再开启这个浏览器的另一个窗口所使用的Session也不是同一个Session。 2）invalidate()：使当前的Session失效，Servlet容器会释放HttpSession对象占有的资源。一般不会使用这个方法，该方法主要提供给服务器使用。 3）isNew()：判断当前Session是否是新创建的Session。 4）setMaxInactiveInterval()：设定当前Session可以处于不活动状态的最大时间间隔，一旦超过这个时间间隔，Session就会自动失效。当它接收一个整数参数时表示不活动状态的最大时间间隔（单位为秒）；当它为负数时，表示不限制Session处于不活动状态的时间。 6、设置HttpSession最大不活动状态时间的方法：\n1）使用setMaxInactiveInterval()方法，设置的只是调用该方法的Session对象。 2）进入Tomcat服务器管理后台，在控制台上设置具体Web应用的所有Session。 3）在Web应用的web.xml文档中添加元素：\u0026lt;session-config\u0026gt;\u0026lt;session-timeout\u0026gt;min\u0026lt;/session-timeout\u0026gt;\u0026lt;/session-config\u0026gt;。其中min为最长处于不活动状态的时间（单位为分钟）。 4）默认的Session最长不活动状态时间为30分钟，30分钟是个合理的时间，没有特殊需要，一般不改变。 7、不支持Session的情况：\n1）客户端禁止Cookie。 2）JSP显示使用\u0026lt;%@ page session=\u0026quot;false\u0026quot;\u0026gt; 8、Session结束生命周期的情况：\n1）客户端浏览器关闭，Session结束现象的本质：Session Cookie存在于浏览器线程中，一旦浏览器线程结束，存在浏览器中的Session Cookie也随着一起销毁。一旦Session Cookie被销毁，服务器将没有办法再接收到SessionID为被结束SessionCookie的ID值。等到Session有效期到期时，服务器自动销毁Session。如果Session被设置为永远不销毁，则服务器永远存在这个Session，但无法再访问到，长期下来服务器上将会堆积很多无法访问的Session，造成服务器内存溢出崩溃。为使浏览器关闭时能够向服务器发送销毁Session的请求，可以使用JS脚本在Web应用的每个页面中调用内置对象window.onclose方法，使得在关闭浏览器之前向服务器发送一个销毁Session的请求。然而，如果浏览器崩溃或者浏览器进程被强制杀死，这种做法也无能为力。 2）Session最长无活动时间到期，Session自动被服务器销毁。最为推荐的结束Session方法。 3）调用Session的invalidate方法，一般也很少使用。 9、对于用户登陆的Web应用，一般都需要使用Session来记录跟踪用户的活动，并在每个页面执行之前都需要通过Session获取用户登陆信息来判断该请求是否拥有相关权限。\n10、Filter过滤器：Java Servlet规范2.3中定义的对Servlet容器的请求和响应进行检查和修改的组件，在使用上与Servlet非常类似，可以将Filter当做特殊的Servlet。\n11、Filter的特点：\n1）Filter本身不生成请求和响应对象，只提供过滤作用。 2）Filter能够在它负责过滤的组件调用之前检查Request对象，修改Request Header和Request内容。 3）Filter能够在它负责过的的组件调用之后检查Response对象，修改Response Header和Response内容。 4）Filter负责过滤的组件可以是任何一种Web组件，包括Servlet、JSP、HTML等。 12、定义自己的Filter，需要直接实现javax.servlet.Filter接口，这个接口中含有三个方法：\n1）init(FilterConfig)：Filter过滤器初始化方法，当Servlet容器创建Filter过滤器实例后就会调用这个方法。方法中可以通过FilterConfig对象读取web.xml文件中Filter过滤器的初始化参数。 2）destroy()：Servlet容器在销毁Filter对象之前调用这个方法，在这个方法中可释放Filter的占有资源。 3）doFilter(ServletRequest,ServletRespone,FilterChain)：Filter中最核心的方法，用于完成实际的过滤操作。当客户请求访问与该Filter过滤器关联的URL资源时，Servlet容器将先调用过滤器的doFilter方法。需要注意的是，doFilter方法接收的参数是ServletRequest和ServletResponse对象，通常需要将这两个参数强制转换为实际的HttpServletRequest和HttpServletResponse对象。而且！由于Filter和Filter或者Web组件实际上是串成一条链，当请求进入Filter的doFilter方法时，执行完过滤操作后需要使用它的参数FilterChain的方法doFilter(ServletRequst,ServletRespone)执行链中的下一个资源，否则请求将终止于当前Filter对象。 13、定义自己的Filter步骤：\n1）实现Filter接口，并实现接口的中三个方法。 2）配置web.xml文件，与Servlet非常类似，需要配置两个标签： \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;filtername\u0026lt;/filter-name\u0026gt; \u0026lt;filter-calss\u0026gt;filtercalss\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;filtername\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;url\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 与Servlet的配置标签不同的是所有的Filter配置标签都必须写在所有的Servlet配置标签之上，否则无效。另外，filter-mapping标签中的url-pattern子标签内容就是Filter过滤器需要过滤的资源的url，可以使用“/*”表示过滤Web应用的所有资源。 14、javax.servlet.FilterChain接口：其中只定义了一个方法doFilter(ServletRequest,ServletRespone)。Filter与它所过滤的Filter或者其它web组件构成一条FilterChain链，当一个Filter过滤后，需要调用Filter的doFilter方法中的参数FilterChain的doFilter(ServletRequest,ServletRespone)才能够将请求继续往下一个过滤器或者最终的Web资源发送。\n15、Filter的运行流程：\n1）Servlet容器启动的时候，会自动加载所有的Filter对象（Filter是单例模式，所以所有的请求都共享同一个Filter对象，也不建议将需要更改的变量定义为Filter的成员）。一旦Filter加载失败（如Filter的init代码抛异常等），整个Web应用就无法启动，因此必须保证每个Filter代码的正确。 2）Servlet容器接收到客户端请求后，生成对应的HttpServletRequest和HttpServletResponse对象，并将这两个对象发送给请求资源的FilterChain的第一个Filter。 3）Filter接收到请求后，进行过滤操作，再调用FilterChain的doFilter方法将请求发送给FilterChain的下一个资源，直到请求到达最终的请求资源或者Filter过滤处理不符合要求直接返回响应为止。 4）若请求能到达最终求的资源，资源处理请求后返回响应，这个响应同样需要经过之间经过的FilterChain链，只不过顺序相反。 5）响应通过FilterChain链，向客户端返回最终的响应。 ","date":"July 10, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B9%9D%E8%AE%B0/","series":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/series/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javaweb","url":"https://www.qinxiandiqi.sbs/tags/javaweb/"},{"title":"session","url":"https://www.qinxiandiqi.sbs/tags/session/"},{"title":"filter","url":"https://www.qinxiandiqi.sbs/tags/filter/"},{"title":"cookie","url":"https://www.qinxiandiqi.sbs/tags/cookie/"}],"title":"JavaWeb学习笔记 第九记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、ServletRequest接口中主要方法：\n1）getAttribute：根据参数给定的属性名返回属性值。 2）getContentType：返回客户请求数据MIME类型（MIME类型是定义在Tomcat的web.xml文档中的一组媒体类型）。 3）getInputStream：返回以二进制方式直接读取客户请求数据的输入流。 4）getParameter：根据给定的参数名返回参数值。 5）getRemoteAddr：返回远程客户主机的IP地址。 6）getRemoteHost：返回远程客户主机名。 7）getRemotePort：返回远程客户主机的端口。 2、ServletResponse接口中的主要方法：\n1）getOutputStream：返回可以向客户端发送二进制数据的输出流对象ServletOutputStream。 2）getWriter：返回可以向客户端发送字符数据的PrintWriter对象。 3）getCharacterEncoding：返回Servlet发送的响应数据的字符编码集。 4）getContentType：返回Servlet发送的响应数据的MIME类型。 5）setContentType：设置Servlet发送的响应数据的MIME类型。 3、Servlet容器装载Servlet的时刻：\n1）Servlet容器启动时自动装载某些Servlet，这种Servlet需要在Web应用中的web.xml文档中对应的servlet标签中添加子标签\u0026lt;load-on-startup\u0026gt;\u0026lt;/load-on-startup\u0026gt;，标签内容接收一个整数，表示Servlet容器启动时加载的优先级。 2）Servlet容器启动后，客户首次向Servlet发出请求。 3）Servlet的类文件被更新后，重新装载Servlet。 4、Servlet被装载后，Servlet容器将创建一个Servlet实例，并且调用Servlet的init方法进行初始化。整个Servlet生命周期中，init方法只会被调用一次。\n5、Servlet终止的时刻（Servlet终止的时候会先调用Servlet的destroy方法，在destroy方法中可以释放Servlet占有的资源）：\n1）Servlet所在的Web应用被终止。 2）Servlet容器终止运行。 3）Servlet容器重新装载Servlet的新实例。 6、有些Servlet在web.xml文件中只有标签没有标签，这就说明客户端无法访问这个Servlet。这样的Servlet在标签下通常都有子标签，目的是在web应用启动的使用自动加载这个servlet，并且通过这个servlet的init方法来完成一些全局性的初始化工作。这种Servlet被加载后无法再访问到。\n7、Tomcat容器中，将客户端随着请求发送过来的参数放在一个HashTable对象中个，这个HashTable是一个String- String[]的键值映射，也就是说getParameter和setParameter方法的底层是通过操作HashTable对象来实现。\n8、Web应用的启动时刻：\n1）Servlet容器启动的时候会自动启动容器中所有的web应用。 2）通过Servlet控制台启动web应用。 9、Tomcat控制台管理web应用：Tomcat的conf目录下的tomcat- users.xml文件用于配置Tomcat服务器的管理账户。浏览器直接登录Tomcat首页从Status入口可以用Tomcat服务器的管理账户登录，在从applications入口进入可以管理Tomcat的Web应用，包括提交web应用并部署web应用，以及卸载web应用。\n10、ServletContext和Web应用的关系：当Servlet容器启动Web应用的时候会自动为每个Web应用创建一个唯一的ServletContext对象（JSP中将这个对象内置为application对象），ServletContext与Web应用的服务器端组件共享内存。ServletContext是单例模式，因此一个Web应用也只能有一个ServletContext对象，又由于它的特性称为一个Web应用的全局对象。\n11、获得ServletContext对象的方法：\n1）JSP中已经将其所在Web应用的ServletContext对象内置为JSP对象application。 2）Servlet中通过ServletRequest.getSession().getServletContext()获得。 12、Servlet/JSP技术基于多线程运行，具有很高的执行效率，但也再带一些多线程问题，其根源在于：\n1）Web应用的Servlet都是单例模式，同一个Servlet无论创建多少个对象都是同一个Servlet对象。 2）Tomcat每接收到一个客户端请求后生成了对应的Request和Response对象，并为这个请求创建了一个线程。线程中构造请求中的Servlet对象，由于Servlet是单例模式，所以多个客户端发送对同一个Servlet的请求的线程中使用Servlet对象实际上都是同一个Servlet对象，也就是多个客户端共享同一个Servlet对象和对象中的成员变量。 3）由于每个客户端对同一个Servlet请求共享同一个Servlet对象中的成员变量，而多个客户端在各自处理线程中并发运行。当它们访问Servlet对象中的成员变量就可能导致多线程的同步问题。 13、解决Servlet/JSP同步问题方案：\n1）不使用Servlet成员变量，使用局部变量。最提倡最推荐使用的做法。 2）使用同步代码块：synchronized{}。 3）Servlet实现javax.servlet.SingleThreadModel接口，该接口是个标志接口，在Servlet2.4中已经废弃。实现这个接口的Servlet将使Servlet以单线程的方式运行，也就是同一个时刻只有一个线程执行Servlet的service方法，这么一来就失去了Servlet多线程的优势，因此强烈不推荐使用！ 14、Thread.currentThread().getName()静态方法可以获得当前线程的名字（这个名字是唯一的）。\n15、Cookie是用于访问Web服务器时，服务器在客户端硬盘上存放的信息，服务器可以根据Cookie来跟踪用于，对于需要区分用户的场合（如电子商务）特别有用。\n16、Cookie对象中包含了一对Key/Value，与Cookie相关的方法：\n1）构造方法：Cookie(String cookiename,String cookievalue)，构造一个名字为cookiename，值为cookievalue的Cookie对象。 2）setMaxAge(int expiry)：设置该Cookie在客户端的存活时间，当参数expiry为正数时表示Cookie对象在客户端硬盘上能够存活的秒数（单位为秒）；当expiry为负数时，表示当客户端（也就是浏览器）关闭的时候销毁这个Cookie；当expiry为0时，客户端销毁这个Cookie。 3）HttpServletResponse.addCookie(Cookie cookie)：Cookie是由服务器创建但是存放在客户端，所以需要将服务器创建的Cookie对象发送为客户端，也就是通过HttpServletResponse响应对象。addCookie方法可以多次使用，也就是一个响应可以向客户端发送多个Cookie，保存多对Cookie键值对。 4）HttpServletRequest.getCookies()：服务器可以从客户端取回Cookie，所以需要通过客户端的请求HttpServletRequest对象来获取。由于客户端可以保存多个Cookie，所欲getCookies()方法返回的是一个Cookie[]数组。 ","date":"July 9, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%85%AB%E8%AE%B0/","series":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/series/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javaweb","url":"https://www.qinxiandiqi.sbs/tags/javaweb/"},{"title":"tomcat","url":"https://www.qinxiandiqi.sbs/tags/tomcat/"},{"title":"cookie","url":"https://www.qinxiandiqi.sbs/tags/cookie/"},{"title":"web应用","url":"https://www.qinxiandiqi.sbs/tags/web%E5%BA%94%E7%94%A8/"},{"title":"servlet","url":"https://www.qinxiandiqi.sbs/tags/servlet/"}],"title":"JavaWeb学习笔记 第八记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、JSP标签\u0026lt;jsp:setProperty property=\u0026ldquo;number\u0026rdquo; name=\u0026ldquo;JavaBeanID\u0026rdquo; param=\u0026ldquo;elementname\u0026rdquo; /\u0026gt;用于为JavaBeanID对象的number成员赋值elementname的值。param的值通常是request中的附加的数据的数据名，在JSP解析为Servlet后这部分实际上就是使用request.getParameter(elementname)。需要注意的是param属性和value属性不能同时使用，一个jsp:setProperty标签中只能使用两者其一。\n2、jsp:useBean属性scope可选值：page、request、session、application。jsp:useBean标签在JSP解析为Servlet后会做两件是：先new一个JavaBean对象，再调用_jspx_page_context.setAttribute(\u0026ldquo;JavaBeanID\u0026rdquo;,JavaBeanID,PageContext.XXX_SCOPE)方法。其中_jspx_page_context是一个PageContext对象，PageContext一般由Tomcat服务器使用，它的setAttribute方法将JavaBeanID以PageContext.XXX_SCOPE方法存到对应的内置对象中，它的getAttribute(\u0026ldquo;JavaBeanID\u0026rdquo;,PageContext.XXX_SCOPE)方从对应的内置对象中取出JavaBean对象。\n1）page是默认值，表示声明的JavaBean对象只在当前页面内存活。当客户请求访问的当前JSP页面通过\u0026lt;jsp:forward\u0026gt;标签转移到另一个文件或者客户请求访问的当前JSP页面顺利执行完毕并向客户端发回响应后，JavaBean对象的生命周期就停止。 2）request表示只能存活于一个请求的范围内。客户每次发出请求访问JSP页面的时候都会创建一个新的JavaBean对象，这个JavaBean对象可以在请求访问的当前JSP页面，或者当前JSP页面使用\u0026lt;%@ include\u0026gt;和\u0026lt;jsp:forward\u0026gt;包含的其它JSP文件中使用。一旦客户端发送的这个请求得到响应，JavaBean对象的生命周期就结束。也就是说，request为属性值的JavaBean对象可以存活在这个request对象访问的所有页面中，通过这个request的getAttribute(JavaBeanID)就能够从request中获得这个JavaBean对象。 3）session表示存活于一个会话范围内。只要是同一个session对象，就能够拥有同一个JavaBean对象，同样通过session.getAttribute(JavaBeanID)可以获得session对象中的JavaBean对象。 4）application表示存活于当前web应用范围内。同样通过application.getAttribute(JavaBeanID)可以访问到这个JavaBean对象。 3、服务器返回给客户端的响应显示出现乱码的情况，通常是客户端提交的数据编码方式与服务器端编码方式不同导致。客户端通常使用ISO-8859-1编码方式提交数据，但为正常显示中文提倡使用utf-8编码方式。为此，需要在服务器端对客户端提交的数据进行转码，利用String的构造方法String(byte[] ,String type)进行转码。使用框架设计的web应用在框架本身基本能够自己完成编码的统一。\n4、Servlet和Servlet容器：\n1）Servlet是和平台无关的服务器端组件，运行在Servlet容器中。 2）Servlet容器负责Servlet和客户的通信以及调用Servlet的方法，比如Tomcat。 3）Servlet和客户的通信采用“请求/响应”的模式。 5、Servlet的作用：\n1）创建并返回基于客户请求的动态HTML页面。 2）创建可嵌入到现有HTML页面中的部分HTML页面。 3）与其它服务器资源（如数据库或者基于Java的应用程序）进行通信。** 6、Servlet框架的两个构成Java包：\n1）javax.servlet：定义了所有Servlet类都必须实现或者扩展的通用接口和类，可能包含多种协议的Servlet。 2）javax.servlet.http：定义了采用HTTP协议通信的HttpServlet类，编写Web应用直接与这个类包打交道比较多。 7、所有的Servlet都必须实现javax.servlet.Servlet接口，HttpServlet类实现了这个接口，所以可以直接继承HttpServlet类。\n8、Servlet接口中提供了三个代表Servlet生命周期的方法：\n1）init(ServletConfig config)：当Servlet被初始化的时候由Servlet自动回调的方法。 2）service(ServletRequest req,ServletResponse res)：当Servlet接收到客户端请求后自动回调的处理请求的方法。 3）destroy()：当Servlet生命周期结束时，由Servlet容器自动回调的销毁方法。 9、javax.servlet.GenericServlet类：实现了Servlet接口，提供了不基于任何通信协议的通用Servlet，对Servlet接口的init和destroy方法进行了简单实现，而对service方法定义为abstract抽象方法，需要它的子类去具体实现。虽然GenericServlet提供了对Servlet接口的简单实现，但是不建议直接继承该类来实现自己的Servlet，而是建议继承它的子类，如HttpServlet。\n10、javax.servlet.http.HttpServlet类：继承了GenericServlet类和实现了Serializable序列化接口，是基于HTTP协议的Servlet。由于继承了GenericServlet，所以对service方法进行了简单实现，而且还提供了重载方法service(HttpServletRequest req,HttpServletResponse resp)。Tomcat响应请求的过程：\n1）客户端向Tomcat服务器发送HTTP请求，Tomcat接收到HTTP请求后为该请求创建HttpServletRequest对象和HttpServletResponse对象。 2）Tomcat将生成的HttpServletRequest和HttpServletResponse对象发送给Servlet接口的service(ServletRequest res,ServletResponse resp)方法。HttpServlet对Servlet接口的这个service方法的实现就是将接收的参数res和resp对象强制还原回HttpServletRequest和HttpServletResponse对象，并将还原的对象发送了HttpServlet重载的service(HttpServletRequset req,HttpSerlvetRespone resp)方法。 3）HttpServlet重载的service方法接收到req和resp对象后，会从req对象中使用getMethod方法获得请求的请求方法，并对应请求方法调用HttpServlet用户重写的doGet、doPost等方法处理请求并返回响应（没有重写doGet或者doPost方法都是根据客户端请求的HTTP协议版本号返回不同的错误页面，所以必须重写这些doXXX方法）。 注：关联Tomcat源代码，查看Tomcat实现HttpServlet的源代码。 11、request、session、application等含有setAttribute方法的对象，这些方法的底层是通过HashMap来实现的。\n","date":"July 9, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%83%E8%AE%B0/","series":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/series/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javaweb","url":"https://www.qinxiandiqi.sbs/tags/javaweb/"},{"title":"jsp","url":"https://www.qinxiandiqi.sbs/tags/jsp/"},{"title":"servlet","url":"https://www.qinxiandiqi.sbs/tags/servlet/"},{"title":"tomcat","url":"https://www.qinxiandiqi.sbs/tags/tomcat/"}],"title":"JavaWeb学习笔记 第七记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、重定向ServletResponse.setRedirect(String location)：将转移到location路径代表的页面上，如果location以“/”开头则说明它从Servlet的容器目录中寻找，也就是http://host:port/的目录下查找转移目标文件；如果不是则从当前Servlet所在web应用的目录下寻找。\n2、请求转发和重定向的区别：\n1）请求转发的整个过程中，源页面和目标页面都在同一个请求中，使用的都是同一个request对象。\n2）重定向的过程是：Servlet使用ServletResponse.setRedirect(String location)转移到location页面，实际上是Servlet的这个方法已经向客户端返回响应Response，这个响应要求客户端访问location页面，客户端接收到这个响应后就会重新向服务器发送一个请求，访问location页面。也就是说，重定向的源页面和目标页面处于两个不同的请求中，所以重定向的目标页面中没有办法从request中取到源页面中的数据。\n3、JSP或HTML页面使用JavaScript的声明一般写在head标签中，JavaScript的代码就写在script标签中。\n4、JavaScript语言中方法function也是一个类，定义要写在script标签中，定义function的格式为function functionName(Element){}。调用function的时候，如果function有返回值要用“return functionName(Element)”调用；如果没有返回值则直接使用functionName(Element)调用。\n5、JavaScript语言是基于事件机制的。对应于JS的事件机制，HTML中form标签拥有JS事件属性onsubmit、onclick等。比如onsubmit=\u0026ldquo;retrun funtionName()\u0026ldquo;调用方法funtionName方法并返回一个值（一般是boolean值），当返回为true时则提交表单数据，返回为false时不提交表单数据。\n6、JavaScript内置对象document代表当前页面，可以帮助JS获取当前页面中的控件：\n1）getElementByID(String ID)：返回当前页面中ID代表的控件对象。\n2）getElementsByName(String name)：返回当前页面中属性name的所有控件对象组成的数组，JavaScript中的数组类似于Java中集合，长度可变。\n3）getElementsByTarget(String target)：返回当前页面中标签为target的所有控件对象组成的数组。\n7、JavaScript的alert()方法执行后将在浏览器弹出对话窗口。\n8、全选页面中所有checkbox按钮可以通过JavaScript脚本来实现。利用document的getElementsByName或者getElementsByTarget等方法获得所有checkbox控件对象进行设置checkbox的checked属性（boolean值）。\n9、JavaScript中所有判断是否相等的方法只有使用运算符“==”，包括比较字符串也是使用这个运算符。\n10、客户端通过JavaScript验证的结果是不安全，因为用户可能通过浏览器知道页面的JS脚本代码知道验证的过程，并通过在请求中附加数据的方法直接访问服务器。为确保安全，除了在客户端验证之外，一般都要在服务器进行再次验证。\n11、使用客户端验证的好处是可以降低服务器端的负担也可以提交响应速度。通过客户端的简单验证，当用户输入出现简单错误的时候就可以在客户端判断出来，不用将数据提交到服务器，服务器判断出错误后再返回响应提示错误，这样就提高了错误响应速度。\n12、MVC设计模式：指的是将程序分为Model（模型，负责处理数据）、View（视图、负责显示和描述）、Controller（控制器，负责逻辑转向）三大模块。在Web应用设计中，View角色通常用JSP担任，Controller角色通常由Servlet担任，而Model是各种处理数据的类。在这种MVC设计模式中，Servlet用于接收用户请求并根据请求的性质调用相应的模型处理请求中的数据（通常一个MVC中包含多个Model用于处理不同的数据）。调用对应模型处理数据后，Servlet根据模型的处理结果决定将使用哪个View来显示并将结果转发给对应的View返回给客户端。\n13、JavaBean是一种可重复使用并且跨平台的软件组件，分为具有用户界面和没有用户界面两种。没有用户界面的JavaBean主要用于负责处理事务，是JSP常访问的JavaBean。\n14、JavaBean实质上就是一个Java类，只不过它需要符合一定的规范，标准的JavaBean需要符合以下特点：\n1）JavaBean必须以public修饰符修饰，也就是public类。\n2）JavaBean至少必须具有一个不带参数的构造方法。\n3）JavaBean要将自己的属性暴露在外面以JavaBean的身份被访问，必须提供这些属性的setXXX和getXXX方法。\n15、JSP访问JavaBean的步骤：\n1）导入JavaBean类：通过\u0026lt;%@ page import=\u0026ldquo;TypeClass（类全名）\u0026rdquo; %\u0026gt;导入。\n2）声明JavaBean变量：使用标签\u0026lt;jsp:useBean id=\u0026ldquo;JavaBeanID\u0026rdquo; class=\u0026ldquo;TypeClass\u0026rdquo; scope=\u0026rdquo;\u0026rdquo; /\u0026gt;来声明。在这个标签中必须显示定义属性id和class，id代表声明的JavaBean对象，class代表声明JavaBean类型。实际上，JSP将jsp页面解析为Servlet后，这个标签new构造了一个TypeClass类型的JavaBean对象，这个对象的变量名就是id的属性值。同时也通过_jspx_page_context.setAttribute(\u0026ldquo;persion\u0026rdquo;,persion,int scope)方法设置该JavaBean对象的生命周期范围。因此，这个标签也相当于直接在JSP页面中使用\u0026lt;% TypeClass JavaBeanID = new TypeClass(); %\u0026gt;。\n3）访问JavaBean变量之取值：使用标签\u0026lt;jsp:getProperty name=\u0026ldquo;JavaBeanID\u0026rdquo; property=\u0026ldquo;number\u0026rdquo; /\u0026gt;来获取JavaBeanID对象的属性number的值，JSP解析为Servlet后，这个标签实际上解析为Tomcat利用反射机制提供的方法获得JavaBeanID对象，再使用这个对象的getXXX()方法获得number成员的值。因此，这个标签也相当于直接在JSP页面中使用\u0026lt;%= JavaBeanID.getXXX(); %\u0026gt;。\n4）访问JavaBean变量之设值：使用标签\u0026lt;jsp:setProperty name=\u0026ldquo;JavaBeanID\u0026rdquo; property=\u0026ldquo;numbet\u0026rdquo; value=\u0026ldquo;value\u0026rdquo; /\u0026gt;来设置JavaBeanID对象的属性number值为value。JSP解析为Servlet后，这个标签实际上解析为Tomcat利用反射机制提供的方法获得JavaBeanID对象，方法中也封装了使用getXXX方法。因此，这个标签也相当于直接在JSP页面中使用\u0026lt;% JavaBeanID.setXXX(value); %\u0026gt;。\n16、之所以可以在JSP页面中直接通过JSP脚本段使用Java语句访问JavaBean，但还是提倡使用JSP标签访问JavaBean，是因为这么做可以将Java代码与JSP的HTML代码分离。一方面使得JSP页面代码更加统一（全部是标签，与HTML很类似）；二是将Java代码分离后有利于维护JSP，利用JavaBean组件可重用性的特点提高网站的开发效率。\n17、使用JSP标签访问JavaBean的本质是生成了JavaBean对象，所以在JavaBean声明标签之后，可以在JSP脚本段\u0026lt;% %\u0026gt;中可以直接使用声明标签中JavaBean的id属性值来访问生成的JavaBean对象。\n","date":"July 9, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%85%AD%E8%AE%B0/","series":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/series/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javaweb","url":"https://www.qinxiandiqi.sbs/tags/javaweb/"},{"title":"javascript","url":"https://www.qinxiandiqi.sbs/tags/javascript/"},{"title":"javabean","url":"https://www.qinxiandiqi.sbs/tags/javabean/"},{"title":"jsp","url":"https://www.qinxiandiqi.sbs/tags/jsp/"},{"title":"html","url":"https://www.qinxiandiqi.sbs/tags/html/"}],"title":"JavaWeb学习笔记 第六记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、JSP内置页面上下文对象pagContext：代表当前页面运行的一些属性，常用方法有findAttribute、getAttribute、getAttributesScope、getAttributeNamesInScope等，一般很少使用这个对象，Servlet容器才会使用这个对象。\n2、JSP内置会话对象session：代表服务器和客户端所建立的会话，当需要在不同的JSP页面中保留客户信息的情况下使用，比如在线购物，客户轨迹跟踪等，只要规定的时间内浏览器没有关闭，它的生命周期就没有结束。主要方法有setAttribute(String name ,Object value)和getAttribute(String name).\n3、JSP内置应用程序对象application：负责提供应用程序在服务器运行时的一些全局信息，常用方法有getMimeType和getRealPath等。\n4、JSP内置输出对象out：与response对象不同，通过out对象发送的内容将是浏览器需要显示的内容，属于文本级别，可以通过out对象直接向客户端写一个有程序动态生成HTML文件。常用方法除了print和println之外，还有clear、clearBuffer、flush、getBufferSize和getRemaining等一些控制out数据缓冲区的方法。\n5、JSP内置配置对象config：提供一些配置信息，常用方法有getInitParameter和getInitParameterNames以获得Servlet的初始化参数。\n6、JSP内置页面对象page：代表正在运行的由JSP文件产生的类对象，不建议使用。\n7、JSP内置异常对象exception：代表了JSP文件运行时所产生的异常对象，只有当JSP页面使用了\u0026lt;%@ page isErrorPage=\u0026ldquo;true\u0026rdquo; %\u0026gt;命令后才能使用这个exception对象。\n8、request对象的getParameter方法与getAttribute方法的区别：getParameter方法获取的是客户端随着请求传递过来的数据，getAttribute方法获取的数据是服务器端通过setAttribute(String name,Object value)方法设置的数据（通常使用该方法都需要将结果进行向下具体类型的强制转换）。由于以上区别，所以getParameter方法没有对应的setParameter，客户端的数据通常都附加在请求后面或者由表单提交，服务器没办法决定客户端提交的数据是什么。\n9、request、session、application：它们都拥有getAttribute和setAttribute方法，区别在于：\n1）request通过这两个方法设置的数据只能存活于request生命周期的范围内。request的生命周期就是客户端发送一个请求的服务器，服务器接收到请求后就会创建一个request对象封装客户端的请求信息，服务器对请求处理完毕向客户端的返回响应对象response后，request的生命周期就结束，也就是request存活于一个请求和响应之间。\n2）session通过这两个方法设置的数据只能存活于session生命周期的范围内。一个现象是当客户端向服务器发出请求后服务器就会创建一个会话session，只要在一定时间内浏览器没有关闭，浏览器和服务器之间就只存在一个session，一旦超时或者浏览器关闭session生命周期结束。\n3）application（ServletContext对象）通过这两个方法设置的数据只能存活于application生命周期内。application的生命周期就是只要服务器没有关闭，application的生命周期就没有结束，无论是哪个客户端访问服务器，它所获得的application都是同一个对象。而一旦服务器重启，application将被销毁并重新构造一个新的application对象。\n4）request对象使用setAttribute方法存数据，并且当前JSP页面使用jsp:forward转移到另一个页面，在另一个页面中通过request对象的getAttribute可以取出原跳转页面设置的数据。原因在于使用jsp:forward标签请求转发到新的页面，客户端是不知道服务器进行页面的跳转的。由始至终，对于客户端来说只是发送了一个请求，服务器请求转发到新的页面后，新的页面也处于同一个请求中，使用的是同一个request对象。相对的，如果不是使用jsp:forward标签请求转发，而是使用超链接链接到另一个页面，对于客户端来说实际上是重新发送了一个请求，两个页面处于不同的请求使用不同的request对象，理所当然取不到另一个request对象中的数据。\n5）一个JSP页面向session对象使用setAttribute方法存入数据后，只要客户端浏览器在一定时间内一直没有关闭，那么这段时间内服务器都可以使用getAttribute方法取得数据，也就是session中的数据一直存在。\n10、Servlet中的请求转发：通过doGet或doPost等方法的HttpServletRequest参数的getRequestDispatcher(String url)方法构造一个RequestDispatcher对象，其中url是需要定向到的页面地址。获得RequestDispatcher对象后，使用它的forward(HttpServletRequst req,HttpServletResponse resp)方法就能将请求req和响应resp转发到url页面上。这种做法在Web应用中很常用，Web应用里面通常使用Servlet处理业务逻辑，而JSP用于显示页面（JSP编写HTML代码方便）。将Servlet业务逻辑处理的结果传递给JSP通常都是使用这种请求转发，将Servlet中的结果使用setAttribute方法存储到request对象中转发到显示页面JSP上，由JSP取出结果显示。\n11、application.getRealPath(String url)：用于返回url指向文件在服务器系统上的物理路径，这个方法对于上传下载文件需要使用的io流非常有用。\n12、表单类型hidden：。这种表单类型不会显示在浏览器页面上，但是在提交按钮提交的时候会将该表单类型的名字和值也一并提交，通常用于在提交数据中附加用户不需要知道但是服务器需要知道的数据。向导式的注册通常也使用这种hidden而不用session，在Web开发中处理登陆使用session保存登陆信息之外，能不用session就不用session，因为session占用服务器资源。\n","date":"July 8, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%94%E8%AE%B0/","series":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/series/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javaweb","url":"https://www.qinxiandiqi.sbs/tags/javaweb/"},{"title":"jsp","url":"https://www.qinxiandiqi.sbs/tags/jsp/"}],"title":"JavaWeb学习笔记 第五记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、JSP的执行过程：\n1）客户端发出JSP请求，Tomcat服务器查找对应的JSP文件，如果找不到则直接返回，发出404错误。\n2）Tomcat服务器判断客户端请求JSP文件是否被修改过或者第一次调用，如果是则调用JSP引擎解析JSP文件，生成对应的Servlet源代码（存放于Tomcat目录下的work目录中），并对Servlet源代码进行编译生成class文件，再将class文件加载入内存执行；如果不是则直接执行已经生成好的class字节码或者从Tomcat的work目录下加载class文件再执行。\n2、JSP的原始代码包含JSP元素和Template data两部分。\n1）JSP元素是JSP引擎直接处理的部分，这部分必须符合JAVA的语法，否则会编译错误，比如写在\u0026lt;% %\u0026gt;中的代码。\n2）Template data部分：JSP引擎不处理的部分，即标记在\u0026lt;% %\u0026gt;之外的部分，比如HTML标记等。\n3、JSP中一个Java语句可以跨越在不同的\u0026lt;% %\u0026gt;块之间，比如：\n\u0026lt;body\u0026gt; \u0026lt;% for(int i=0;i\u0026lt;2;i++){%\u0026gt; 循环两次 \u0026lt;%}%\u0026gt; \u0026lt;/body\u0026gt; 浏览器得到的响应代码为：\n\u0026lt;body\u0026gt; 循环两次 循环两次 \u0026lt;/body\u0026gt; 产生此结果的原因在于JSP引擎对JSP文件解析成Servlet的规则，它对JSP中\u0026lt;%%\u0026gt;中的部分直接处理，也就是直接放置到Servlet代码中；对Template data部分直接输出，也就是放置到out.writer(）中的字符串参数中，如以上代码解析的结果是：\nout.write(\u0026quot;\u0026lt;body\u0026gt;\\n\u0026quot;); for(int i=0;i\u0026lt;2;i++){ out.write(\u0026quot;\\t循环两次\\n\u0026quot;); } out.write(\u0026quot;\u0026lt;/body\u0026gt;\\n\u0026quot;); 因此，循环两次会被输出两次。\n4、JSP的语法分为三大部分：脚本语法、编译器指令、动作语法。\n5、脚本语法：\n1）HTML注释：这种注释会发送给客户端，注释的内容可添加JSP表达式，JSP会将表达式结果作为HTML注释返回给客户端。\n2）隐藏注释：\u0026lt;%\u0026ndash; comments \u0026ndash;%\u0026gt;。这种注释不会发送给客户端，也叫做的JSP注释，同样可以嵌入JSP表达式。\n3）脚本段：\u0026lt;% \u0026hellip; %\u0026gt;。JSP的Java代码主要位置，实现JSP的Java逻辑。\n4）表达式：\u0026lt;%= \u0026hellip; %\u0026gt;：JSP解析后会将表达式的结果返回给客户端。需要注意的是表达式的结尾不能添加“;”，因为JSP解析为Servlet之后表达式被解析为out.print(表达式内容);如果添加了分号就等于在out.print的参数中添加了分号，必将导致编译错误。相对的，脚本段中的Java语句之后就一定要添加分号，因为脚本段解析后直接将脚本段内容作为Servlet的代码。\n5）声明：\u0026lt;%! 声明语句 %\u0026gt;。将变量的声明放置于JSP的声明中，多个声明使用分号隔开，JSP解析后将把声明中的变量作为Servlet的成员变量声明，而将变量的声明放置于脚本段中，则JSP解析后将声明变量作为_jspService方法的局部变量（_jspService方法相当于自定义Servlet中的doGet和doPost方法）。由于Servlet使用单例模式设计，所以Servlet的成员变量将会被多个客户端请求共享，一个客户端对Servlet的成员变量进行修改会影响到其它客户端对该成员变量的取值，而局部变量不会，这是将变量声明写在JSP声明和脚本段中的区别。\n6、编译器指令：\n1）页指令：\u0026lt;%@ page 属性1=属性值1 属性2=属性值2 \u0026hellip; %\u0026gt;。页指令用于对当前JSP页面做一些设置，一个JSP页面可以有多个页指令，并且无论页指令写在JSP文档的哪个位置，作用域都是整个JSP文档。另外，除了import属性，其它属性最多只能在所有的页指令中出现一次。需要注意的是页指令不能作用于动态的包含文件，如jsp:include。常用属性有：\na）language=\u0026ldquo;java\u0026rdquo;：声明脚本段语言的种类，目前只能使用java。\nb）import=\u0026ldquo;package1，package2\u0026hellip;\u0026rdquo; ：导入需要的Java包，与Java源文件中的import功能一样。JSP默认导入了java.lang.、javax.servlet.、javax.servlet.jsp.*、javax.servlet.http.*四个类包，无需再对这个四个类包进行导入。\nc）errorPage=\u0026ldquo;relativeURL\u0026rdquo;：设置处理异常事件的JSP文件，属性值为JSP文件的URL。\nd）isErrorPage=\u0026ldquo;true|false\u0026rdquo;：设置此页是否为出错页，如果是就可以使用exception对象。\ne）pageEncoding：设置编码格式，一般使用UTF-8。\n2）包含指令：\u0026lt;%@ include file=\u0026ldquo;URL\u0026rdquo; %\u0026gt;。包含指令用于向当前页面中包含指令的位置插入一个静态文件的内容，这个文件就是file属性值URL指向的文件（可以为绝对地址，也可以为相对地址）。使用包含指令的相当于使用了一个变量，变量的内容是其它静态文件的内容，这么做的好处是可以将多个JSP文件重复的大量代码抽取出来成独立的静态文件，在需要使用到的JSP位置使用包含指令包含进来，就可以降低代码的冗余和统一管理。常将JSP输入的HEML头和尾等固定不变的代码作为包含指令。\n3）taglib指令：\u0026lt;%@ taglib uri=\u0026ldquo;URI\u0026rdquo; prefix=\u0026ldquo;tagPrefix\u0026rdquo; %\u0026gt;。用于引入定制的标签库。\n7、动作语法：\n1）\u0026lt;jsp:forward page=\u0026ldquo;URL|\u0026lt;%= expression %\u0026gt;\u0026rdquo; /\u0026gt;：请求转发动作，其中page属性的值可以是一个地址字符串或者表达式（表达式的结果也是一个地址字符串）表明请求转发到哪个文件，这个文件可以是JSP，也可以是程序段。当使用jsp:forward请求转发从一个JSP文件向另一个文件转移时，传递了一个包含了用户请求的request对象，并且jsp:forward标签之后的代码将不能执行，因为JSP解析为Servlet之后在该标签后添加了return。\n2）\u0026lt;jsp:include page=\u0026ldquo;URL|\u0026lt;%= expression %\u0026gt;\u0026rdquo; flush=\u0026ldquo;true|false\u0026rdquo; /\u0026gt;：包含一个静态或者动态文件进来，与包含指令功能类似，区别在于jsp:include可以包含动态文件，而包含指令不行。这个动态的特征在于jsp:include标签可以传递带一个或多个参数的request对象给要包含进来的动态文件，动态文件可以从request对象中取出传递的参数赋值后形成最终的静态代码，再将这些静态代码包含进jsp:include标签所在的位置。\n3）\u0026lt;jsp:param name=\u0026ldquo;paramName\u0026rdquo; value=\u0026ldquo;paramValew|\u0026lt;%= expression %\u0026gt;\u0026rdquo; /\u0026gt;：用于传递参数，jsp:forward和jsp:include标签通过request对象传递的参数需要使用jsp:param标签作为子标签。每个jsp:param标签中的name属性值和value属性值就是一个键值对，代表一对参数（参数名和参数值），需要传递多个参数需要使用多个jsp:param子标签。传递过去的文件通过传递过去的request对象方法getParameter(String name)就能取出对应的参数值。\n8、JSP内置九种对象（是服务器已经构造好的类对象，不是类本身）：\n1）请求对象request：javax.servlet.ServletRequest的子类（常用）\n2）响应对象response：javax.servlet.ServletResponse的子类\n3）页面上下文对象pageContext：javax.servlet.jsp.PageContext\n4）会话对象session：javax.servlet.http.HttpSession（常用）\n5）应用程序对象application：javax.servlet.ServletContext（常用）\n6）输出对象out：javax.servlet.jsp.JspWriter（常用）\n7）配置对象config：javax.servlet.ServletConfig\n8）页面对象page：java.lang.Objece\n9）异常对象exception：java.lang.Throwable\n9、JSP内置对象request：代表来自客户端的请求，比如表单填写的信息等，是JSP解析成Servlet后的方法_jspService的请求参数。主要方法有：\n1）getParameter(String name)：返回参数name的第一个值的字符串表现形式。\n2）getParameterNames(）：返回一个Enumeration对象，其中包含了request对象中所有参数名，Enumeration包含方法hasMoreElements()用于判断是否还有下一个参数名，以及方法nextElement()返回一个参数名并将游标移动到下一个参数名。\n3）getParameterValues(String name)：返回一个String数组，将name参数的所有值组合成一个String数组返回，比如多选按钮的返回值。\n10、JSP的内置对象response并不常使用，向客户端输出字符（字符组成HTML文档等）常直接使用内置out对象向客户端输出，response的用途在于文件的下载（out的字符输出难以满足文件大量字节的传输）。\n","date":"July 8, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E8%AE%B0/","series":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/series/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javaweb","url":"https://www.qinxiandiqi.sbs/tags/javaweb/"},{"title":"jsp","url":"https://www.qinxiandiqi.sbs/tags/jsp/"}],"title":"JavaWeb学习笔记 第四记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、MyEclipse创建web project后，创建的WebRoot目录：META-INF、WEB-INF、index.jsp。其中，META- INF目录的文件不用直接与其打交道，最重要的是WEB- INF目录，里面存放了应用的文件，包括classes目录（存放应用编译好的class文件）、lib目录（应用需要的第三方类库必须放在这个目录下）、web.xml（整个web应用的核心，用于配置web应用）。\n2、Tomcat第二种部署web应用方法：将WEB- INF文件夹拷贝到Tomcat的webapps目录下，此时web应用目录的名字就是浏览器请求格式的abs_path的根地址。相比第一种方法，比较麻烦，也不能映射地址。\n3、第二种方法部署的web应用可以是一个文件夹，也可以使一个war的web应用的压缩文件，Tomcat启动时会将war解压成可用的web应用。\n4、Servlet是Java的服务器编程，不同于SE的应用程序，Servlet程序是运行在服务器上。\n5、Servlet的特点是没有main方法，web应用中的servlet类需要继承Servlet类或者它的子类，一般是继承HttpServlet。HttpServlet中定义了doGet和doPost等对应HTTP协议请求行方法符号的方法，当用户使用某种方法发出对这个Servlet请求时就会调用Servlet对应的方法执行。\n6、用户能够访问Servlet需要对在web应用中WEB-INF目录下的web.xml配置文件中对Servlet进行配置：\nServletName\nServletClass\nServletName\nServletUrl\n其中ServletName是对Servlet类的一个别名，servlet和servlet-mapping两个标签中的servlet- name必须一致。ServletClass为Servlet类的完整类名。ServletUrl为Servlet类的Url标识符，浏览器的请求格式中abs_path的根目录后就是ServletUrl，通过这个ServletUrl才能访问到Servlet类这个资源。\n7、浏览器地址栏访问Tomcat服务器上Web引用Servlet详细过程：\n1）浏览器地址栏输入请求格式符：http://host:port/Webappname/resourcepath/Webappname/resourcepath即为abs_path）。（\n2）浏览器将请求格式符拆解为HTTP请求发送为host主机的port端口。\n3）Tomcat服务器与浏览器建立连接接收到浏览器请求，分析出请求目标资源的URL即abs_path。此时Tomcat服务器会查询它的server.xml配置文件是否存在Context标签，并且Context标签中的path属性值为/Webappname。如果存在且匹配，Tomcat则会定位到Context标签中docBase属性值指向的物理路径，也就是Web应用目录。要是没有找到匹配项，Tomcat会查找Tomcat下的Webapps目录中是否存在名为Webappname的Web应用，存在则定位到这个Web应用目录，不存在则向浏览器返回404错误。\n4）Tomcat能定位到Web应用目录后，对于Servlet，Tomcat会查询这个Web应用的web.xml配置文件中的所有servlet- mapping标签，如果能匹配到servlet-mapping标签子标签url- pattern值正好为resourcepath，则Tomcat会继续查找web.xml配置文件在的所有servlet标签，看是否存在servlet的servlet- name值为servlet-mapping的servlet-name值相同，相同的话就能对应servlet标签中的子标签servlet- class值，找到最终浏览器请求的Servlet类路径（Servlet的类全称）。如果这个过程失败，也就是找不到浏览器请求的Servlet资源，则返回404错误。\n5）Tomcat找到浏览器请求的Servlet后，会先查询这个Servlet类是否已经编译。如果已经编译，则直接去Web应用的classes目录中找到编译好的class文件直接执行；如果没有编译，则会进行编译后执行class文件。\n6）浏览器地址栏的请求默认使用GET方法请求，所以编译好的Servlet类执行时，Tomcat自动执行Servlet类的doGet方法，并将响应返回给浏览器，完成一次请求响应。\n8、Servlet中会使用到的方法：\n1）HttpServletResponse.getWriter()：获得响应的打印输出流PrintWriter对象，通过向这个PrintWriter流中写入数据，由于带缓冲，最后使用PrintWriter.flush()方法强制输出缓冲中所有内容，就能够将PrintWriter流中的数据输出到浏览器。\n2）HttpServletRequest.getParameter(String name)：获得请求中附加的数据中名字为name的字符串格式的值，通常用于提取表单提交的请求中的表单数据。\n9、表单form的属性action的值为浏览器地址栏请求格式符中的abs_path，当表单中的submit按钮点击后，就会将表单的数据封装成HTTP请求发送给当前服务器的资源abs_path。\n10、为了能够将表当提交后，接收表单请求处理数据的资源能够提取出请求中的表单数据，必须给表单的各个带值组件添加name属性，name的值将是HttpServletRequest.getParameter的参数值，比如文本框。\n11、如果Tomcat的server.xml配置文件中为某个web应用配置了Context，并且属性reloadable的值为true，那么当该web应用的源代码文件发生修改后，一般Tomcat都能够自动重加载，但是对于web.xml等配置文件的修改，Tomcat很大可能不会自动重新加载，需要手动重启服务器。\n12、JSP不需要配置web.xml文件，并且修改JSP文件后也不需要重启服务器，访问的时候会自动重新解析JSP文件。\n13、Servlet可以看做是嵌套了HTML代码的Java源文件，JSP可以看做是嵌套了Java代码的HTML文件。\n14、form表单的form标签的两个属性action和method。\n1）action的值为表单需要提交到的目标资源的url（如Servlet），如果url为abs_path则为绝对地址，而实际上action的值可以为相对地址，即直接写上Servlet的在web.xml中的servlet- mapping的url-pattern的值。提交的时候，Tomcat会自动在该表单所在的web应用中的web.xml中 搜索，需要注意的是相对地址的前面不能出现“/”符号，以该符号开头为绝对地址。使用相对地址的好处是Tomcat的server.xml文件中多web应用的配置别名随时修改，一旦修改就需要对所有绝对路径进行修改，而使用相对路径就不用。\n2）method属性的值为get时，表单以get方式提交请求；值为post时，表单以post方式提交请求。浏览器地址栏的请求一定是get方式提交。\n15、HTTP协议的get方法和post方法的区别：\n1）使用get方法提交表单，表单的数据会以?name1=value1\u0026amp;name2=value2\u0026hellip;的形式附加在abs_path后面，而post则不会。因此，使用get方法提交的表单数据可以在浏览器的地址栏上看到提交的表单数据内容。\n2）产生区别的原因在于get方法将附加的数据附加在请求的请求行中(GET abs_path?name1=value1\u0026amp;name2=value2\u0026hellip; HTTP/1.1）；而post方法是将附加的数据附加在请求的请求体中，它将附加的数据附加在请求体的末尾，也就是其它请求命令之后用两个CRLF隔开再附加数据。\n3）由于请求的请求行字符有限制，所以当提交文件的时候必须使用post方法，也提倡提交表单数据使用post增加安全性。\n4）服务器端不管浏览器使用的是哪一种请求方式，在服务器端都使用同一的方式对请求的附加数据进行处理（多态）。\n","date":"July 4, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E8%AE%B0/","series":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/series/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"javaweb","url":"https://www.qinxiandiqi.sbs/tags/javaweb/"},{"title":"tomcat","url":"https://www.qinxiandiqi.sbs/tags/tomcat/"},{"title":"web应用","url":"https://www.qinxiandiqi.sbs/tags/web%E5%BA%94%E7%94%A8/"},{"title":"servlet","url":"https://www.qinxiandiqi.sbs/tags/servlet/"},{"title":"jsp","url":"https://www.qinxiandiqi.sbs/tags/jsp/"}],"title":"JavaWeb学习笔记 第三记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、HTTP协议是基于请求/响应，无状态的协议。\n2、HTTP1.0协议的浏览器与服务区通讯过程：\n1）客户发起连接\n2）客户发起请求\n3）服务器响应请求\n4）服务器关闭连接\n3、HTTP1.1在HTTP1.0的基础上增加了持续连接功能改善HTTP1.0的性能。在HTTP1.0协议下，客户每发一个请求都要先建立一个连接，如果一个HTML页面上包含多个资源（图片，css文件等），那么有多少个资源就得建立多少次连接还有本身自己的一个连接。这么一来容易造成网络上的拥堵，HTTP1.1的持续连接为解决这个问题，可以将用户的连接保持一段时间（由服务器设置保留多长时间），在保持的这段时间内，用户发送的请求不需要重新建立连接，用户可以一次性将请求全部发出而不需要等到一个请求得到相应关闭连接后在发送一个请求。\n4、浏览器HTTP请求格式：http://host[: port][abs_path]\n1）http表示请求的协议名，不同的协议要用不同的协议名，如ftp。\n2）host表示请求的服务器IP地址，也可以使域名，域名将会通过DNS服务器解析为IP地址。\n3）:port：服务器监听的端口，默认为80端口。\n4）abs_ptah：请求服务器上的资源的URL统一资源定位符地址，如果没有指定资源，需要使用\u0026quot;/\u0026ldquo;代替（浏览器会自动添加）。\n5、HTTP请求三个组成部分：请求行、消息报头、请求正文。在浏览器中输入网址后，浏览器会自动将地址栏的内容进行分析，封装和组合成HTTP请求三部分向服务器发出请求。\n6、HTTP请求行格式：Method Request-URL HTTP-Version CRLF。其中，Method为请求方法符号，必须为大写；Request-URL，请求的资源统一定位符，也就是浏览器请求格式的中abs_path；HTTP- Version，HTTP协议的版本，一般为HTTP/1.1；CRLF，回车换行，在请求行中，各部分之间以空格分隔，并且除了结尾的CRLF之外，不允许出现单独的CR或者LF字符。请求行举例：GET /test.html HTTP/1.1 (CRLF).\n7、请求行中的主要方法符号：\n1）GET，请求获取有Request-URL所标识的资源，在浏览器的地之栏中直接输入网址的方式去访问网页的时候，浏览器使用GET方式向服务器获取资源。\n2）POST，在Request-URL所标识的资源后附加新的数据，也是用于向服务器发送请求，并要求服务器接受附加在请求后面的数据，常使用在表单的提交上。\n3）HEAD，请求获取Request- URL所标识的资源的相应消息报头，与GET方法几乎一样，不同在于HEAD方法只是请求消息的报头，通常用户测试超链接的有效性，是否可访问，已经最近是否更新等。\n8、HTTP的响应也由三部分组成：状态行、消息报头、响应正文。\n9、HTTP响应状态行格式：HTTP-Version Status-Code Reason-Phrase CRLF。其中HTTP- Version为服务器HTTP协议的版本，Status-Code表示服务器发回的响应代码，Reason- Phrase表示状态代码的文本描述，CRLF表示回车换行。\n10、HTTP状态行响应代码类别：\n1）1xx：指示信息，表示请求已经接收，继续处理。\n2）2xx：成功，表示请求已经被成功接收，理解，接收。\n3）3xx：重定向，要完成请求必须进行更进一步的操作。\n4）4xx：客户端错误，请求有语法错误或者请求无法实现。\n5）5xx：服务器端错误，服务器未能实现合法的请求。\n11、常见HTTP状态行响应代码和对应描述：\n1）200，OK：客户端请求成功。\n2）400，Bad Request：由于客户端请求有语法错误，不能被服务器所理解。\n3）401，Unauthorized：请求未经授权，这个状态代码必须和WWW-Auhtenticate报头域一起使用。\n4）403，Forbidden：服务器接收到请求，但是拒绝提供服务，服务器通常会在响应正文中给出不提供服务的原因。\n5）404，NotFound：请求的资源不存在，比如输入错误的URL。\n6）500，Internal Server Error：服务器发生不可预期错误，导致无法完成客户的请求。\n7）503，Service Unavailable：服务器当前不能够处理客户的请求，在一段时间之后服务器可能会恢复正常。\n12、telnet命令：telnet IP/主机域名 端口号，用于宣称登陆某主机端口。比如登陆百度主页：telnet www.baidu.com 80，登陆后出现黑窗口，此时输入HEAD /index.html HTTP/1.1 (LRCF） Host：www.baidu.com后，两次回车（第一次表示输入完毕，第二次表示发出请求），将得到百度服务器的响应。\n13、Tomcat服务器下主要目录说明：\n1）bin：存放Tomact的一些可执行程序，其中bat文件是在window系统下使用，sh文件是在Linux系统下使用。\n2）conf：存放一些XML等类型的配置文件。\n3）lib：Tomcat使用到的一些jar库文件，Tomcat本身也是由Java编写的。\n4）logs：Tomcat的日志文件存放目录。\n5）temp：Tomcat的临时文件目录。\n6）webapps：用于部署web应用程序，比如网站等。\n7）work：Tomcat编译用户的应用程序后产生的临时文件存放目录。\n8）其它文件：发布声明等。\n14、Tomcat原来的名字叫Catalina，这也是为什么Tomcat需要配置环境变量CATALINA_HOME（变量值为Tomcat的目录）的原因。另外Tomcat需要配置JAVA_HOME环境变量，因为Tomcat本身也是Java程序。\n15、telnet命令下连接使用HTTP的服务器，发送请求的时候，在请求行下可加Connection:Keep- Alive命令持续连接，HTTP1.1协议默认使用这个命令。相对的，Connection:close则发送请求响应后立刻中断连接。\n16、MyEclipse中创建Web Project后，生成两个目录src和WebRoot，src存放java源代码，WebRoot存放Web应用文件。访问Web应用，需要使用浏览器通过服务器来访问到服务器上的Web应用，所以需要将Web应用部署到服务器上才能查看Web应用的情况。\n17、部署Web应用到Tomcat服务器上最方便的方法：在Tomcat目录的conf目录下，打开server.xml服务器配置文件，找到文件倒数第四行，在上面添加XML元素：\n，其中path为浏览器请求格式中代表该web引用URL统一资源定位符abs_path的根目录，truepath为本地系统上web应用的WebRoot目录地址，这样在浏览器地址栏中通过端口号后添加“path/WebRoot下资源名字”就能访问到该资源，也就是说，用户使用path访问服务器就等于访问服务器的truepath路径，path和truepath之间是映射好的逻辑路径与物理路径的关系，这是出于安全考虑，用户不应该知道访问的资源在服务器上的物理路径。而reloadable表示当web应用的文件发生更改后是否自动刷新服务器，大部分时候会刷新，但有时需要手动刷新。\n","date":"July 3, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E8%AE%B0/","series":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/series/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"tomcat","url":"https://www.qinxiandiqi.sbs/tags/tomcat/"},{"title":"http协议","url":"https://www.qinxiandiqi.sbs/tags/http%E5%8D%8F%E8%AE%AE/"},{"title":"web","url":"https://www.qinxiandiqi.sbs/tags/web/"},{"title":"javaweb","url":"https://www.qinxiandiqi.sbs/tags/javaweb/"}],"title":"JavaWeb学习笔记 第二记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/categories/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、HTML超链接标签中设置属性target=\u0026quot;_blank\u0026quot;可以令超链接在新标签页中打开。\n2、HTML标签table子标签：\n1）tr：表格行标签，table row\n2）td：表格列标签\n3）th：表格列标题标签，table head\n4）属性align，控制文本的对齐方式，center为居中对齐。\n5）属性width，可接收百分数，表示占用比例。\n3、表单form标签的子标签：\n1）子标签input加属性type和属性值text，input标签的type默认属性值，表示一个文本框。\n2）子标签input加属性type和属性值password：密码框。\n3）子标签input加属性type和属性值checkbox：多选按钮。\n4）子标签input加属性type和属性值radio：单选按钮。将多个radio类型单选按钮组合到同一个组中，需要在input标签中添加属性name，只要name的值相同，radio单选按钮就在同一个组中。\n5）子标签select：下拉列表。\n6）option：select的子标签，每个option为select下拉列表的下拉选项。\n7）子标签testarea：多行文本框。\n8）子标签input加属性file：将显示一个按钮，点击可弹出文件选择框选择上传文件等操作。\n9）子标签input加属性submit：表单提交按钮，如果没有指定提交目标，默认将把表单数据提交给当前页面。\n10）子标签input加属性reset：将表单恢复到最初的状态。\n11）子标签input加属性button：一个普通的按钮，可再加onClick属性增加按钮相应操作，通常操作为一种JS动作。\n4、浏览器内核：\n1、靠近标准内核：webkit，速度比较快。\n2、非标准内核：trident，也叫IE内核。\n5、HTML空格： 6、HTML标签img，其属性src可以接收一个本地图片路径或者网络图片路径。\n7、最快的浏览器Chrome，可以利用CPU硬件加速。\n8、CSS基本语法：选择器{属性:属性值; \u0026hellip;}，选择器为需要定义样式的标签名；如果属性值由多个单词构成需要对属性值加双引号；多个属性属性值对之间需要用时“;”隔开。\n9、链接外部css文件方法：在HTML文件的head标签中添加便可链接到指定css文件。\n10、CSS支持同时多个选择器进行样式设置：选择器,选择器\u0026hellip;{属性:属性值;\u0026hellip;}。\n11、CSS支持选择器类：选择器.classname{属性:属性值;\u0026hellip;}；HTML文档中使用该选择器标签需要添加标签属性class，属性值为CSS中定义的选择器类classname。这样才能这种这个选择器类设置的显示样式。同一个标签中不能设置多个class。\n12、定义所有标签的选择器类：.classname{属性:属性值;\u0026hellip;}。这样定义的选择器类在所有的标签中都可以使用标签的class属性获得样式。\n13、CSS的id选择器，定义方法与class类选择器定义方法类似，不同点在于将类选择器中的.改为#。使用方法也与类选择器类似，但是不提倡同一个HTML文档多次使用一个id选择器，但是多次使用也不会造成什么问题，因为浏览器对HTML标签是宽容处理。\n14、class选择器和id选择器名字不要以数字开头，否则firefox浏览器无法识别。\n15、css中的属性值和属性值单位之间不要留空格，有些浏览器可能无法识别。\n16、html的标签hr，没有结束标签，用于画一条分割线。\n17、在css中，如果一个选择器的样式被定义了多次，那么最终应用的在html的样式是根据定义的选择器优先级，先选择优先级最高的选择器样式，再组合优先级低的选择器中高优先级选择器没有的样式进行组合，并将组合的样子作为最终使用的样式。简单说，就是css将样式向最丰富化使用。\n18、CSS设置超链接a标签的伪选择器：\n1）a:link：超链接没有被选择和没有鼠标放置在超链接上面状态时的样式。\n2）a:visited：访问过的超链接样式。\n3）a:hover：鼠标放置在超链接上面时的样式。\n4）a:active：鼠标点击超链接时的样式。\n","date":"July 2, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E8%AE%B0/","series":[{"title":"JavaWeb学习笔记","url":"https://www.qinxiandiqi.sbs/series/javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"html","url":"https://www.qinxiandiqi.sbs/tags/html/"},{"title":"css","url":"https://www.qinxiandiqi.sbs/tags/css/"}],"title":"JavaWeb学习笔记 第一记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/categories/android-wear/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n原文作者：Google\n原文地址：http://developer.android.com/design/wear/principles.html[](http://developer.android.com/design/wear/creative- vision.html)[](http://developer.android.com/wear/notifications/remote- input.html)[](http://developer.android.com/wear/design/user- interface.html#Stream)[](https://developers.google.com/maps/documentation/android- api/intro)\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-30版本翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n本篇设计原则提供了一些关于应该怎样规划和评估你的Android Wear应用程序设计的简单思路。\nFocus on not stopping the user and all else will follow（专注于不打算用户并让一切后续跟随上来）# 手表是非常完美的设备造型，让你能够在做其它事情的时候同时使用，例如做饭、吃东西、散步、跑步，甚至是在谈话的过程中。如果你的应用程序会导致用户中止他们正在做的事情，那么这是个好机会来考虑下应该如何使用本章节的原则升级程序。\n尝试一下：\n计算你的Wear应用一次典型使用的耗时。如果超过了5秒，那么你就应该考虑下让你的应用程序更加集中一点。同样尝试一下你在和别人对话的过程中，你的应用怎样影响你的意识思维和眼睛焦点。\n左边每一个操作花费的时间为5秒。\nDesign for big gestures（使用大手势设计）# 当你在手机上滑动浏览图片时，你拥有一个很大的显示区域，并且你根本不需要很精确操作。对于穿戴设备，这也是最好的交互方式。你的用户可能会在各种情况下使用你的应用程序，最近频繁使用的条目可能已经显示在桌面上。\n尝试一下：\n在各种日常情况下使用你的应用程序，比如走路、吃东西、与别人谈话或者订购咖啡。如果你必须走路的时候必须放慢脚步或者中断谈话来进行精确操作，那么你应该考虑如何加大你的手势范围。\n使用更少和更大的触控目标\nThink about stream cards first（第一时间考虑信息流卡片）# 穿戴设备上最好的体验是当用户需要的时候对应的内容刚好就显示在上面。你可以根据传感器或者云端上面的触发时间来指定显示你的卡片的时机。然而，在一些设备没办法预知用户正需要你的应用程序情况下，你可以依靠语音或者触摸操作来辅助。\n尝试一下：\n做一个列表列出所有用户可能需要你的应用程序的情况。这些情况都有什么共同点？是相同的地理位置？每一天里相同的时间？还是某些物理动作？你可能会列出一些不同的情况——这是好事情，因为这意味着你可以为这些情形指定特定的卡片。请记住，如果用户觉得这些卡片是不相关的，他们永远有机会设置你的信息流卡片为免打扰模式。\nDo one thing，really fast（每做一件事都很快）# 尽管用户每一次使用你的应用程序可能只有几秒钟，但是他们每一天可能会使用上很多次。一长好的信息流卡片应该只携带少量的信息，并且当用户滑动的时候只提供少量的操作按钮。\n尝试一下：\n在你的设计中，有多少信息是需要的？是否每一个信息都是必须的，或者你能不能将部分信息分解到另一张卡片上？如果你正在设计一张卡片，不要忘记你可以在一张卡片里面包含多个页面。\nDesign for the corner of the eye（为眼睛的余光而设计）# 用户需要注视你的应用程序时间越长，就等于你让用户从现实世界中脱离的更严重。多考虑如何增强你的应用程序的可浏览性，让用户能够从你的应用程序中获得足够的信息并快速返回到他们正在做的事情中。\n尝试以下：\n当你的手表正在显示你的应用程序时，尝试注意力集中在你的手指关节上，使用你的余光来查看你的应用程序。你能否感觉到设备想在运行什么？能否分辨出它来自什么应用程序？上面的背景图片对信息的表达有没有帮助作用？它有没有使用图片或者不同的图形和颜色？\nDon\u0026rsquo;t be a constant shoulder tapper（不要变成一个持续的振动器）# 手表会长时间贴着用户的皮肤。基于这种亲密关系，你在手表上设置的蜂鸣次数应该要比你习惯在手机上设置的次数少。\n尝试一下：\n当下一次你在谈话的时候，想象一下有人搭着你的肩膀，用你的应用程序推送的消息打断你。如果推送的消息没有理由中断对话，你就不应该让这条消息中断对话。\n","date":"June 30, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidwear-designprinciplesforandroidwear%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","series":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/series/android-wear/"}],"smallImg":"","tags":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/tags/android-wear/"},{"title":"可穿戴设备","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%AF%E7%A9%BF%E6%88%B4%E8%AE%BE%E5%A4%87/"},{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"Notification","url":"https://www.qinxiandiqi.sbs/tags/notification/"},{"title":"原则","url":"https://www.qinxiandiqi.sbs/tags/%E5%8E%9F%E5%88%99/"}],"title":"Android Wear - Design Principles for Android Wear（设计原则）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JUnit学习笔记","url":"https://www.qinxiandiqi.sbs/categories/junit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、JUnit4添加了新的方法用于在测试类中所有测试方法执行之前或者执行之后执行，具体使用方法是使用注解@BeforeClass或者@AfterClass注解注解在public static void修饰的并且没有参数的方法之前，这样，被注解的方法就会在所有测试方法启动之前或者都结束之后执行一次。\n2、@Test只能注解方法，并且它有两个可选属性：\n1）timeout：设定测试方法最多能够允许执行的毫秒数，一旦超出这个毫秒数则测试不通过。\n2）expected：该属性值是一个Class对象，一般是Throwable的Class，表示期望获得测试方法一个异常类的Class，只有测试方法中抛出符合该属性值的Class类异常，测试才能通过。在JUnit3.8中要完成这个功能需要在测试方法中手写捕捉异常和比较异常的代码，JUnit4的注解节省了这些过程。\n如：@Test(timeout = 500,expected = Exception.class)\n3、@Ignore可以注解方法也可以注解类，一旦被注解，则表示该测试方法或者测试类中的所有方法都忽略掉，不执行这些方法的测试。它可以接收一个value值，该值为一个给予用户的提醒信息。\n4、JUnit4增加的新功能：参数化测试。当对一个目标方法进行测试的时候，一般都需要设计目标方法的参数数据和目标方法的测试结果比较数据。如果目标方法可能存在多种临界情况，而这些临界情况仅仅是由参数数据和结果数据不同，在JUnit3.8中就需要针对每种不同的数据写一个测试方法，这将造成代码的冗余。在JUnit4中则提供了参数化测试的方法，为一个测试方法提供多组数据，测试的时候JUnit会自动根据每组数据进行测试。具体步骤为：\n1）测试类要使用注解@RunWith(Parameterized.class)表示该测试类将不使用JUnit内建的运行器运行，而使用参数化运行器运行（该注解只能注释类）。\n2）在参数化的测试类中提供@Parameters注解的提供参数方法，方法要使用pubic static修饰，并且返回类型为Collection。方法块中提供多组测试数据，可以使用Object[][]数组，每组测试数据作为其一维数据，再将Object数据转换为Collection。\n3）定义参数化测试类带参数的构造方法。步骤2中每组数据包含多少个数据，测试类就需要定义多少个对应类型的成员变量，构造方法的参数列表按照每组数据的排列顺序排列，构造方法块中对测试类的成员变量进行赋值。\n4）测试方法中使用测试类的成员变量完成测试的代码，一共有多少组数据，JUnit就会测试多少次，将每组测试数据都执行。\n5、在JUnit4中同样可以实现同时运行多个测试类，需要使用@RunWith(Suite.class)和@Suite.SuiteClasses(Class[] cla)两个注解同时注解一个测试类，这个测试类的内容没有多大意义，整个测试类的意义都在于两个注解上。其中@Suite.SuiteClasses()注解需要接收一个Class数组，在运行这个测试类的时候，Class数组中每个测试类都会被执行。特别的，Class数组中的元素也可以是另一个Suite，执行的时候，JUnit会将Class数组中每一个测试类一直链接寻找执行下去，直到找到所有可执行的TestCase执行为止。\n6、模板方法模式：定义了一些固定不变的算法骨架，但骨架的具体步骤实现由具体子类实现，这么做的好处是可以复用算法的结构。模板方法模式的角色分为父类角色（提供模板）和子类角色（为模板提供实现）。\n7、模板方法模式的设计步骤：\n1）设计父类角色，也就是模板，一般是一个抽象类，不能是接口。父类角色抽象类中要定义算法骨架各个步骤的抽象方法和调用这些抽象方法的具体方法。模板方法模式的模板就体现在这个调用抽象方法的具体方法上，用户只要调用具体方法就能按照具体方法中规定的调用抽象方法顺序完成一个算法功能。因为要定义具体方法，所以父类角色才不能是接口。\n2）继承父类角色，设计子类角色。继承父类，所以继承了父类的具体方法，同时也要实现父类中的抽象方法，这实现这些抽象方法就是对模板的具体实现。\n3）根据多态构造父类角色对象，调用父类角色的具体方法就能按照模板的算法顺序执行具体子类中对模板步骤的实现。\n8、JUnit3.8中的TestCase应用了模板方法设计模式：\npublic void runBare() throws Throwable{ setUp(); try{ runTest();} finally{ tearDown();} } 这就是为什么每个测试方法执行的时候一定要先执行setUp方法和测试方法执行之后一定会执行tearDown方法，原因就在于这是个模板方法模板。\nJUnit4中的注解@Before和@After也是运用模板方法设计模式。\n9、JUnit中每执行一个测试类中的测试方法，都构造了一个测试类对象，也就是说在本质上，JUnit为每一个测试方法构造了一个测试类对象。因此，即使是同个测试类中的测试方法一块运行，在运行时它们也是在不同的测试类对象中，所以除了测试类的静态成员变量，测试方法对其它成员变量的使用不影响其它测试方法。\n10、适配器模式：主要是将一个类的接口转换成用于需要的另外一个接口，适配器模式使得原本不能一起工作的类可以一起工作，通俗的讲就是将原有的但用户不能直接使用的代码进行适配器包装后就可以供用户使用。\n11、适配器的角色：\n1）目标抽象角色（Target）：一般都是一个接口，是抽象了用户能够直接使用的接口。\n2）适配器角色（Adapter）：一个具体类，实现目标抽象角色接口并能够调用Adaptee中的方法，以将其进行转换。\n3）被转换角色（Adaptee）：一个具体类，是原有的用户不能直接使用的，就是要被转换的接口。\n12、适配器模式的实现方式可分三类：\n1）类适配器（采取继承Adaptee的方式实现）。\n2）对象适配器（采取Adaptee对象组合的方式实现，推荐使用的方式）。\n3）缺省适配器（AWT、Swing中的事件适配器）。\n13、适配器模式之类适配器的实现步骤：\n1）设计目标抽象角色接口Target，定义用户能够直接使用的方法。\n2）设计要被转换的源适配器类Adaptee。\n3）设计适配器Adapter，Adapter要继承Adaptee类和实现目标抽象角色接口Target。类适配器模式转换的关键在于Adapter既继承了Adaptee又同时实现了Target接口，因此Adapter既拥有Adaptee中的方法又需要实现Target中的也就是用户可以直接使用的方法。只要Adapter在实现的Target方法体中调用Adaptee中的方法，那么用户通过Adapter调用用户可以直接使用的Target中的方法就能够间接转换成调用Adaptee中的方法，从而实现适配器的转换。\n14、适配器模式之对象适配器的实现步骤：\n1）设计目标抽象角色接口Target，定义用户能够直接使用的方法。\n2）设计要被转换的源适配器类Adaptee。\n3）设计适配器Adapter，Adapter不用继承Adaptee，但是也要实现Target接口中的方法，并且Adapter具有一个Adaptee类对象作为成员变量，Adapter的构造方法要接收一个Adaptee对象以初始化成员变量。之所以称为对象适配器，就是因为这个模式组合了一个Adaptee对象作为成员变量，这也是与类适配器模式最大的区别。在实现Target接口方法中，通过Adaptee成员变量来调用用户实际需要调用的方法，完成适配器的转换功能。\n15、适配器模式之缺省适配器的实现步骤：\n1）设计目标抽象角色接口Target，定义用户能够直接使用的方法。\n2）设计适配器Adapter类，需要实现接口Target，但是不用继承任何类。缺省适配器的缺省意义就在于它没有转换任何类的方法，仅仅是对Target接口中方法的一个空实现。\n3）使用缺省适配器需要设计一个实际使用的类继承Adapter，并重写其中需要使用的方法。\n16、适配器模式与代理模式非常类似，主要区别在于适配器模式中仅仅只是调用源对象中的方法，而代理模式在调用源对象方法的基础上加上了代理自己需要实现的一些代码。\n17、JUnit3.8中使用了适配器设计模式，比如使用了模板方法设计模式中的runTest方法。JUnit3.8不可能事先知道用户设计的测试方法，所以JUnit3.8用适配器模式做了适配器runTest方法，在runTest方法中调用了用户设计的testXXX测试方法。正如JUnit3.8不可能事先知道用户设计的测试方法，所以runTest方法要想调用用户设计的测试方法只能通过反射机制来获得。在runTest方法中会判断用户的测试方法参数是否为空和测试方法是否为public，具体代码见JUnit3.8中TestCase中的源代码。\n18、Eclipse中使用自带的JUnit库没有办法查看JUnit的源代码，需要在Eclipse中查看JUnit的源代码需要在Built Paths中使用外部JUnit的jar包和导入jar包的源代码。\n19、命令模式：一种类似于黑匣子思想的设计模式，将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。\n20、命令模式的角色：\n1）客户角色：创建出一个个具体的命令对象，并将其与确定的接收者关联。\n2）命令角色：一个接口或者抽象类，定义了所有具体命令类需要实现的方法。\n3）具体命令角色：继承或者实现了命令角色的类，实现了命令角色中的抽象方法，通过这些方法来调用接收者的相应操作。\n4）调用者角色：负责调用命令对象来执行请求（请求的最终是接收者来完成）。\n5）接收者角色：负责具体实施和执行一个请求。\n21、命令模式的设计步骤：\n1）设计命令角色，提供具体命令角色需要实现的调用接收者角色的抽象方法。\n2）设计接收者角色，完成接收者角色可以执行相应请求操作的处理方法，命令角色将通过调用接收者角色的这些方法最终完成请求的操作。\n3）设计具体命令角色：继承或实现了命令角色，一般需要包含接收者角色最为其成员变量，在具体命令角色的构造方法中接收一个接收者参数对其进行初始化。实现的命令角色方法中通过调用这个接收者角色成员变量的方法来实现相应请求的相关操作。具体命令角色的设计与对象适配器设计方法类似。\n4）设计调用者角色：调用者要调用命令角色，所有调用者角色中需要包含命令角色对象来做为调用者角色的成员变量，同样需要在构造方法中接收一个命令角色对象对其进行初始化。在调用者角色中设计相应方法，在方法体中调用命令角色的方法，借命令角色的方法最终调用的是接收者对象的操作方法。\n5）设计客户角色：客户角色创建具体命令对象提交请求。因此，客户角色要构造具体命令角色对象（隐含需要构造接收者对象传递给命令角色）来封装客户的请求，也要将封装了客户请求的命令角色对象提交给调用者，由调用者去调用这些命令角色对象。\n22、命令模式的过程类似于餐馆的点餐过程：厨师等同于接收者角色，菜单等同于命令角色，顾客等同于客户角色，顾客的订单等同于具体命令角色，服务员等同于调用者角色。\n23、JUnit使用命令模式的体现：\n1）JUnit的TestCase类就像命令模式的命令角色，而我们继承TestCase的具体测试类就像命令模式的具体命令角色。\n2）JUnit框架就像命令模式中的调用者角色和接收者角色，我们用户提交的请求封装成具体的TestCase测试类对象，提交给JUnit框架，由JUnit框架调用这些测试类（具体命令角色），最终由JUnite的相关实现具体操作的代码执行测试，并返回测试结果。\n24、组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，并使得用于对单个对象和组合对象的使用具有统一性，也就是忽略掉部分与整体之间的差异性。\n25、组合模式的角色组成：\n1）Component角色：抽象构建接口，是一个接口，定义了单个对象乃至管理多个对象的管理器的默认行为。\n2）Leaf角色：实现了Component角色接口，实现了“部分”的行为。\n3）Composite角色：实现了Component角色接口，是Leaf角色的管理器，能够容纳多个Leaf对象，并定义了操作Leaf的方法。在实现Leaf功能时，需要遍历Composite中的Leaf对象，逐个调用Leaf对象的处理方法。\n26、组合模式的实现步骤：\n方法一：\n1）定义Component接口，在接口中只定义Leaf角色需要实现的操作方法。\n2）定义Leaf类，实现了Component接口及接口中要求的Leaf需要实现的功能方法。\n3）定义Composite类，类中需要定义一个Component集合以存放Leaf对象或者Composite对象。类中也要定义操作Component集合的相关方法，同时，由于Composite也实现接口Component，所以也要实现Component中定义的Leaf方法。Composite对这个方法的实现，需要遍历Composite中Component集合的每个元素，转而逐个调用Leaf的方法。\n4）用户实现组合模式，组合对象需要定义为Composite类型，不能是父接口Component，因为Component中没有定义管理Composite中子元素的方法。\n方法二：\n1）定义Component接口，接口中不但要定义Leaf角色需要实现的方法，也要定义Composite中操作子元素Leaf对象的方法。\n2）定义Leaf类，同样需要实现Component中的所有方法，除了实现Leaf需要的具体方法之外，也要实现关于操作Composite子元素的方法，但由于Leaf类中没有子元素，所以需要将这些操作子元素的方法定义为空实现方法。\n3）定义Composite类，要实现Component接口中所有方法，除了自身的操作子元素方法之外，对为Leaf设计方法的实现要转成遍历Composite所有子元素调用它们的方法。\n方法一和方法二的区别在于将操作Composite子元素的方法定义到Component接口中，这么一来，用户创建Composite的时候就可以向上使用Component对象来接收，让Leaf和Composite统一使用Component。\n27、JUnit中对组合模式的使用：JUnit中Test相当于组合模式中的Component，用户自定义的测试类继承了TestCase相当于组合模式中的Leaf，而Suit可以包含多个测试类或者多个Suite相当于Composite。\n28、JUnit中的错误（error）和失败（failure）：\n1）错误实质代码中抛出了异常等影响代码正常执行的情况，比如抛出ArrayIndexOutOfBoundException等，这就叫做错误。\n2）失败是指我们断言所期待的结果与程序实际运行的结果不一致，或者是调用fail方法，这才叫做失败。\n29、JUnit的TestResult结果输出类运用观察者模式，见TestResult源代码。\n","date":"June 29, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/junit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/junit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E8%AE%B0/","series":[{"title":"JUnit学习笔记","url":"https://www.qinxiandiqi.sbs/series/junit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"JUnit","url":"https://www.qinxiandiqi.sbs/tags/junit/"},{"title":"测试","url":"https://www.qinxiandiqi.sbs/tags/%E6%B5%8B%E8%AF%95/"},{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"注解","url":"https://www.qinxiandiqi.sbs/tags/%E6%B3%A8%E8%A7%A3/"}],"title":"JUnit 学习笔记 第二记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"JUnit学习笔记","url":"https://www.qinxiandiqi.sbs/categories/junit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、在开发一个大型项目的时候，一般都会把项目实现逻辑分层由不同的开发人员各自实现，不同层次之间会发生互相的调用等等。这么一来，一旦一个部分出现错误，就可能导致其它部分的错误，为了查明错误的来源往往需要逐层排查，耗费很多时间和成本。因此，有必须保证不同开发人员提交的程序代码的正确性，至少是符合开发人员自己的要求。这个保证就需要开发人员对自己开发的代码进行测试，JUnit框架就是为了解决这个问题而出现。\n2、JUnit版本有3.8和4.x系列，两个系统之间差别比较大，4.x版本对JUnit进行很大的修改，包括很多类包的名字，而且增加注解，所以使用JUnit测试框架的时候的要明确使用的JUnit版本。\n3、JUnit的实现就是将目标代码与测试代码分开，由测试代码来测试目标代码执行过程是否符合开发人员的要求。分开的好处是测试通过后发布代码，只发布目标代码隐去测试代码，方便简洁。\n4、Eclipse内置了JUnit单元测试框架，包括3和4两个版本系列，对项目使用JUnit单元测试时，要先通过add Library选择JUnit版本，Eclipse会自动添加JUnit库到工程。\n5、JUnit的最佳实践方法：\n1）项目中对应默认源代码src文件夹，新建名为test的source folder源代码文件夹，该文件夹用于存放测试源代码。\n2）目标类与测试类应该放在同一个包下面，这样可以在测试类中不必导入源代码所在包。方法是在test源代码文件夹中建立与src目标源代码文件夹包名字相同的包，同个项目中不同源代码文件夹中名字相同的类包是等同于在同一个类包中的，虽然在物理上目标源代码文件和测试源代码文件夹不是同一个文件夹，但是他们生成的class文件都是存放在bin文件夹中。\n3）测试类的命名规则：在目标类的类名前或者类名后添加Test作为对应测试类的类名。\n6、JUnit单元测试的目的不是为了证明开发人员的代码是正确的，而是证明开发人员的代码没有错误。JUnit单元测试能通过只能说明目标代码通过了开发人员为其目的设计的测试代码，经得起测试代码的测试，但是不能保证经过测试的目标代码就一定正确，可能还存在开发人员测试代码没有涉及到的问题。\n7、JUnit3.8的测试类都必须继承junit.framework.TestCase类，该类是一个抽象类，继承了junit.framework.Assert和实现了接口junit.framework.Test。TestCase类中有两个重要方法：\n1）setUp()：测试类中每一个测试方法调用之前调用，测试类可以通过重写该方法来实现对每个测试方法都需要的一些初始化工作，比如：每一个测试方法都需要构造目标类对象，可以在setUp方法中构造目标类对象，这么一来，每个测试方法调用之前都能获得一个目标类对象，并且每个测试方法或的目标类对象都不相同（每个测试方法前都调用一次setUp，初始化一次目标类对象），以符合测试类每个测试方法都互相独立的要求）。\n2）tearDown()：与setUp()方法对应，每一个测试类方法结束后都会调用一次tearDown方法，可以通过重写tearDown方法来完成一些每个测试方法都需要的收尾工作。\n8、JUnit3.8中，所有的测试方法都必须满足以下原则：\n1）测试方法的属性必须都是public的。\n2）测试方法的返回类型必须都是void。\n3）测试方法必须没有方法参数。\n4）测试方法名必须以test开头。\n9、在测试方法的测试代码中，常用到的类是junit.framework.Assert，该类也是TestCase类的父类。Assert类中提供了大量重载的静态方法assertEquals，该方法用于比较各种类型的值，JUnit的判断就是根据这个方法来判断是否符合开发人员预想的要求。在测试代码中，通过对目标类对象的操作，获得一个结果，再调用assertEquals相应的重载方法比较结果与自己的预期值。这样，在使用JUnit运行的时候，JUnit会根据每个测试方法中的assertEquals的结果输出通过（green bar）还是错误（red bar）。\n10、JUnit3.8单元测试要求每个测试类都必须互相独立，每个测试方法都必须互相独立，各自之间不存在任何依赖关系，包括测试方法的执行顺序等等，因为每个测试方法都针对于一个问题来设计，如果存在依赖关系，出现错误的话，将很难排查。\n11、JUnit3.8单元测试的类Assert类中的静态方法fail（），一旦测试代码中调用此方法就 一定会在JUnit结果中输出测试失败，常将此方法用于测试抛异常。方法是在目标代码中可能会抛出异常的地方将异常throws，在测试代码中使用try- catch结构捕捉异常。当希望测试不抛出异常的时候，将fail方法放置到catch中，如果没有抛出异常则正常测试；当希望测试抛出异常的时候，将fail放置到try的测试代码后，并在try- catch结构外使用Assert.assertEquals比较抛出的异常（assertEquals方法可以比较Object），如果没有抛出异常就会在测试结果中显示测试失败。\n12、JUnit3.8单元测试的junit.textui.TestRunner.run(Class classtest)静态方法用于以命令行的方式测试类测试类classtest，传入参数是类对应的Class。该方法将以命令行的方式输出测试结果到控制台上，由于是命令行方式，所以测试效率比较高，一般都采用这种方法。\n13、JUnit3.8单元测试的junit.awtui.TestRunner.run(Class classtest)静态用于以可视化界面的方式测试测试类classtest，同样传入的参数是测试类的Class。该方法将以可视化图形界面的方法将测试结果输出。\n14、JUnit3.8单元测试的一个原则是测试类测试后对程序所有数据应该没有任何影响，也就是说测试之前是什么状态，测试之后应该就还是什么状态。比如，测试类需要用到数据库一些数据，在测试后之后这些数据库的数据应该没有任何印象，原来是什么样子，测试之后应该就还是什么样子。\n15、在JUnit3.8单元测试的测试代码中，由于测试代码测试目标代码的要通过创建目标类对象，再通过目标类对象调用目标代码来进行测试，所以在测试代码中无法直接测试目标类中的private方法。为了能够测试目标类中的private方法，可以由两种方法：\n1）将目标类中的private方法改为public方法，测试完后再改回来，不建议使用这种方法，不符合JUnit测试不影响目标代码的原则。\n2）通过反射机制调用目标类中的private方法，强烈建议使用的方法。\n16、JUnit3.8的测试套件测试自动化：当要执行多个测试类中的代码时，一个一个测试类进行JUnit运行测试的效率很低，所以JUnit3.8提供了测试套件可以一次执行多个测试类的测试。测试套件的使用方法需要构造junit.framework.TestSuite类对象，在这之前需要先设计一个与普通测试类一样继承TestCase的测试类，并在测试类中重写public static Test suite(){}方法，在该方法的方法块中构造TestSuite对象，并使用TestSuite对象的addTestSuite（Class TestClass)方法添加需要执行的测试类的Class对象，最后return构造的的TestSuite对象。这么一来，只要JUnit3.8执行这个测试类，就会自动调用suite这个方法，相当与一次将这个测试类中TestSuite包含的其它测试类都执行一遍，实现测试自动化。\n17、JUnit3.8单元测试的junit.extensions.RepeatedTest继承了TestDecorator类，使用了装饰设计模式。RepeatedTest的构造方法RepeatedTest(Test test,int repeat)可以构造一个连续将test测试类执行repeat次的RepeatedTest对象。需要注意的是，RepeatedTest重复执行的是测试类test中的某个测试方法，因此test测试类对象必须是使用Test(String str)方法构造的一个Test对象，这个对象代表了要执行的测试方法是test测试类中方法名为str的测试方法，这样，RepeatedTest对象才能知道要执行test对象中哪个方法repeat次。另外，TestSuite类中除了addTestSuite(Class class)方法之外，还有addTest(Test test)方法可以添加一个实现Test接口的测试对象，通过addTest(Test test)方法可以向TestSuite添加一个RepeatedTest对象。\n18、JUnit4全面引入注解Annotation来执行编写的测试，这是JUnit3.8与JUnit4最大的区别。\n19、JUnit4并不像JUnit3.8要求每个测试了都必须继承TestCase类，而且在测试类中的测试方法也不要求以test开头。JUnit4中确定一个方法为测试方法的标识是一个被public修饰且返回值为void类型的方法前是否有注解@Test。如果有，那么这个方法就是测试方法，可以被JUnit运行。（虽然JUnit4并没有要求测试方法名前添加test，但是为了是方法名具有表征性，推荐还是要在测试方法名前添加test）。\n20、JUnit4使用注解@Before代替JUnit3.8中的setUp方法，只要是被@Before注解的方法在每个测试方法运行之前都会先被调用；类似的，JUnit4使用注解@After代替JUnit3.8的tearDown方法。同样，虽然JUnit4没有限制方法名，但还是推荐使用setUp和tearDown方法名。\n","date":"June 29, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/junit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/junit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E8%AE%B0/","series":[{"title":"JUnit学习笔记","url":"https://www.qinxiandiqi.sbs/series/junit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"JUnit","url":"https://www.qinxiandiqi.sbs/tags/junit/"},{"title":"测试","url":"https://www.qinxiandiqi.sbs/tags/%E6%B5%8B%E8%AF%95/"},{"title":"单元测试","url":"https://www.qinxiandiqi.sbs/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"}],"title":"JUnit 学习笔记 第一记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/categories/android-wear/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n原文作者：Google\n原文地址：\u0026lt;http://developer.android.com/design/wear/creative- vision.html\u0026gt;[](http://developer.android.com/wear/notifications/remote- input.html)[](http://developer.android.com/wear/design/user- interface.html#Stream)[](https://developers.google.com/maps/documentation/android- api/intro)\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-27版本翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nAndroid Wear设备只在合适的时间提供合适的信息，以将用户在现实世界于虚拟世界之间联系的更加紧密。优秀的Android Wear体验应该如下：\nLaunched automatically（自动启动）# 大多数人习惯于点击一个图标来启动应用程序，但是Android Wear不一样。穿戴设备上的应用是根据用户的情境（上下文）来唤醒的，比如时间、地点、体力活动等等。当这些应用与这些情境相呼应的时候，应用程序会使用这些信息插入卡片到信息流中。这就让Android Wear具备了及时性，相关性和具体性特点。\nGlanceable（浏览性）# 一只传统腕表的设计是为了让你能够在几秒钟里看下时间，然后继续回到你正在做的事情中。Android Wear的设计也是类似的。能够花更少的时间来使用你的软件，那么用户就能有更多的时间继续完成当前正在做的事情。Android Wear是快速的，及时的。\nAll about suggest and deman（关于建议和需求的一切）# Android Wear就像一个非常机智的个人助手：它知道你的偏好，它只在有必要的时候打断你，并且它永远只在手上提供准好的答案。Android Wear是优越的，谦卑的和响应性的。\nZero or low interaction（零或者低交互）# 遵循更小的外形带来的优势，Android Wear关注于简单的交互，它只在有必要的时候要求用户输入。大部分输入都是基于触摸滑动或者语音输入，并且细粒度的手指移动操作是禁止的。Android是手势化，简单化和快速化的。\n通过提供与世界其它部分的智能连接同时又尊重用户的关注点，Android Wear让人感觉既个人化又全球化，简单又智能，不显眼又随时待命。遵循这些原则的应用程序在整个Android Wear体验中将会让人感觉就像在家里一样。\n扩展Android Wear的第三方应用将在日常使用中更具针对性和帮助性。安装这些应用程序是用户通知Android Wear如何操作的一种方法。\n","date":"June 27, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidwear-creativevisionforandroidwear%E5%88%9B%E6%84%8F%E8%A7%86%E8%A7%89/","series":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/series/android-wear/"}],"smallImg":"","tags":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/tags/android-wear/"},{"title":"可穿戴设备","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%AF%E7%A9%BF%E6%88%B4%E8%AE%BE%E5%A4%87/"},{"title":"体验","url":"https://www.qinxiandiqi.sbs/tags/%E4%BD%93%E9%AA%8C/"},{"title":"创意视觉","url":"https://www.qinxiandiqi.sbs/tags/%E5%88%9B%E6%84%8F%E8%A7%86%E8%A7%89/"},{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"}],"title":"Android Wear - Creative Vision for Android Wear(创意视觉）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/categories/android-wear/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n原文作者：Google\n原文地址：http://developer.android.com/design/wear/index.html[](http://developer.android.com/wear/notifications/remote- input.html)[](http://developer.android.com/wear/design/user- interface.html#Stream)[](https://developers.google.com/maps/documentation/android- api/intro)\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-27版本翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n前言# 设计Android Wear可穿戴设备应用程序与设计手机或者平板上的应用程序有很大的不同：各自有不同的优势和缺点、不同的适用情境、以及不同的人体工程学设计。在开始开发之前，你应该了解Android Wear的整体视觉体验，以及它适用于哪些应用程序和如何提升用户体验。\n由于Android Wear新的造型决定了需要使用一种新的界面。总的来说，Android Wear UI围绕着Suggest（建议）和Demand（需求）两个核心部分提供了两种主要的界面中心。你的应用程序将会在这两个界面中担任重要角色。\nSuggest：The Context Stream（上下文信息流）# Context Stream是一个垂直的卡片列表，每一张卡片显示一个有用的或者及时的信息。非常类似于Android手机或者平板上的Google Now，用户通过垂直滑动切换每一张卡片。在同一个时间里只有一张卡片能够显示，并且背景图片会显示另外附加的视觉化信息。你的应用程序可以创建卡片并且将卡片插入到信息流中，前提是这些卡片是有可能会被使用到的。\n这种界面模式确保了用户不需要启动很多应用程序来检查更新。用户可以通过简单浏览Context Stream来确定哪一些对他们来说是重要的。\n信息流中的卡片比起通知来说要更加简单。用户可以通过横向滑动卡片来查看附加的页面。横向滑动还有可能切换出一些按钮，这些按钮可以让用户对通知进行一些操作。卡片也可以通过由左边滑动到右边来从信息流中移除，直到下一次应用程序又有有用的信息需要显示为止。\nDemand：The Cue Card（提示卡）# 当Android Wear没有在信息流中主动提供一些建议回复时，Cue Card（提示卡）允许用户直接与google对话。提示卡可以通过语音“OK Google”或者点击Home界面的背景来打开。在提示卡上向上滑动可以打开一个预设的语音指令列表，里面每一项都可以通过点击执行。\n从技术角度来讲，每一个预设的语音指令都会激活一个指定类型的Intent。作为一个开发者，你可以将你的应用程序与其中一些Intent匹配，以便用户可以通过这些语音指令来完成一些任务。有些时候可能会有多个应用程序同时注册一个相同的语音Intent，那么用户将会有机会选择打开哪一个应用程序。\n如同应用程序可以在一个有规律的流操作按钮中响应点击一样，它们也可以使用相同的方式来响应语音指令：通过添加或者更新一章信息流开安，或者通过启动一个全屏应用程序。语音输入通常会使用一种命令格式，例如“remind me to get milk”。这种情况下，在自动返回上下文信息流之前会完整播放一段简单的确认动画。\nOther UI Features（其它界面功能）# 1、 Home screen 是设备默认的状态，包含了一下功能：\n* 背景取决于用户选择的手表界面，可以显示第一张卡片的相关内容或者一个自定义的手表界面。点击背景的任何地方或者说一句“OK Google”就可以启动语音查询。 * 状态提示：连接状态、充电状态、飞行模式，以及一些手表界面上的未读信息统计。 * Context Stream中排在顶部的卡片（称为偷窥卡片），它被半遮掩显示在屏幕的底部。这张卡片能够显示的面积有多大取决于当前的手表界面。 2、用户可以选择 Watch face （手表界面）作为Home界面的背景显示。手表界面显示时间以及包含排在顶部的偷窥卡片。用户可以通过长按当前手表界面来选择其它手表界面。\n3、一些设备当不使用的时候可能会进入低功耗的情境模式。这一般通过一些方式调节屏幕亮度。在这个状态下，偷窥卡片的内容将会自动优化后显示。用户可以通过点击屏幕，或者倾斜屏幕对着自己，或者点击任何物理键（如果设备有物理键）来退出这种模式。\n4、向下滑动Home界面可以显示时间和电池信息。再往下拉可以选择静音模式，以防止中断性通知震动和点亮屏幕。\n5、 Setting screen （设置界面）可以通过从提示卡或者物理键（有些设备可能会提供设置键）打开。在这是界面用户可以关机或者重启设备，可以设置屏幕亮度，可以打开或者关闭飞行模式，也可以查看设备信息。\n6、 Full screen apps （全屏应用）可以在主信息流的顶部启动，它要求一个相对更大的范围。尽管没有限制Context Stream模式的风格，但是应用程序应该遵循与系统其它部分一样的设计风格。更多相关的信息可以参考App Structure 指南。\n","date":"June 27, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidwear/","series":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/series/android-wear/"}],"smallImg":"","tags":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/tags/android-wear/"},{"title":"可穿戴设备","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%AF%E7%A9%BF%E6%88%B4%E8%AE%BE%E5%A4%87/"},{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"界面","url":"https://www.qinxiandiqi.sbs/tags/%E7%95%8C%E9%9D%A2/"},{"title":"ui","url":"https://www.qinxiandiqi.sbs/tags/ui/"}],"title":"Android Wear"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/categories/android-wear/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n原文作者：Google\n原文地址：http://developer.android.com/wear/notifications/stacks.html[](http://developer.android.com/wear/notifications/remote- input.html)[](http://developer.android.com/wear/design/user- interface.html#Stream)[](https://developers.google.com/maps/documentation/android- api/intro)\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-24版本翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n前言# 当在手持设备上创建通知的时候，你应该经常将一些类似的通知归并到一个单一的摘要通知中。比如，如果你的应用接收到信息后会创建通知，你不应该在手持设备上创建多条通知。当接收到多条信息的时候，你应该使用一条单一的通知并显示类似“2 new messages”这样的摘要信息。\n![](https://img- blog.csdn.net/20140624141528593)\n但是，一个摘要通知在Android Wear设备上就显得没那么有用，因为用户不能够在穿戴设备上详细阅读每条信息（他们必须在手持设备上打开你的应用程序来查看更多的信息）。因此，在穿戴设备上，你应该将所有通知归档到一个栈中。包含多个通知的栈将作为一张卡片显示，用户可以展开来查看每一条通知的详细信息。新的setGroup()方法让这一切成为可能，并且还能够同时在手持设备上只保持提供一条摘要通知。\n更多关于设计通知栈的内容，请参考Design Principles of Android Wear。\nAdd Each Notification to a Group（将每一条信息分组）# 创建一个栈，你需要为每条通知调用setGroup()方法，并指定分组的key。然后调用notfiy()方法将它发送到穿戴设备上。\nfinal static String GROUP_KEY_EMAILS = \u0026quot;group_key_emails\u0026quot;; // Build the notification and pass this builder to WearableNotifications.Builder NotificationCompat.Builder builder = new NotificationCompat.Builder(mContext) .setContentTitle(\u0026quot;New mail from \u0026quot; + sender1) .setContentText(subject1) .setSmallIcon(R.drawable.new_mail); Notification notif1 = new WearableNotifications.Builder(builder) .setGroup(GROUP_KEY_EMAILS) .build(); // Issue the notification NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this); notificationManager.notify(notificationId1, notif); 之后，当你创建其它通知的时候，只要你指定相同的分组key。那么你调用notify()方法之后，这条通知就会跟之前的通知一样出现在相同的通知栈里面，并替代成为一张新的卡片：\nbuilder = new NotificationCompat.Builder(mContext) .setContentTitle(\u0026quot;New mail from \u0026quot; + sender2) .setContentText(subject2) .setSmallIcon(R.drawable.new_mail); // Use the same group as the previous notification Notification notif2 = new WearableNotifications.Builder(builder) .setGroup(GROUP_KEY_EMAILS) .build(); notificationManager.notify(notificationId2, notif); 默认情况，通知的显示顺序由你的添加顺序决定，最近添加的通知将会出现在最顶部。你也可以为通知在栈中指定一个序号，只要你将序号作为setGroup()方法的第二个参数传递进去。\nAdd a Summary Notification（添加一条摘要通知）# 在手持设备上保持提供一条摘要通知是相当重要的。因此，除了将每一条通知添加到相同的栈中之外，还要添加一条摘要通知到栈中，只不过要把摘要通知的序号设置为GROUP_ORDER_SUMMARY。\n这条摘要通知不会出现在穿戴设备上的通知栈中，但是会作为一条通知出现在手持设备上。\nBitmap largeIcon = BitmapFactory.decodeResource(getResources(), R.drawable.ic_large_icon); builder = new NotificationCompat.Builder(this) .setSmallIcon(R.drawable.ic_small_icon) .setLargeIcon(largeIcon); // Use the same group key and pass this builder to InboxStyle notification WearableNotifications.Builder wearableBuilder = new WearableNotifications .Builder(builder) .setGroup(GROUP_KEY_EMAILS, WearableNotifications.GROUP_ORDER_SUMMARY); // Build the final notification to show on the handset Notification summaryNotification = new NotificationCompat.InboxStyle( wearableBuilder.getCompatBuilder()) .addLine(\u0026quot;Alex Faaborg Check this out\u0026quot;) .addLine(\u0026quot;Jeff Chang Launch Party\u0026quot;) .setBigContentTitle(\u0026quot;2 new messages\u0026quot;) .setSummaryText(\u0026quot;johndoe@gmail.com\u0026quot;) .build(); notificationManager.notify(notificationId3, summaryNotification); 这条通知使用了NotificationCompat.InboxStyle，它提供了一种为邮件或者信息类应用程序创建通知的简单方法。你可以采用这种风格，而其它的通知使用NotificationCompat来定义，当然你也可以完全不是用这种风格来定义摘要通知。\n提示：定义类似截图中的文字风格，可以参考[Styling with HTML markup](http://developer.android.com/guide/topics/resources/string- resource.html#StylingWithHTML)和[Styling with Spannables](http://developer.android.com/guide/topics/resources/string- resource.html#StylingWithSpannables).\n","date":"June 24, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidwearpreview-%E5%BD%92%E6%A1%A3%E9%80%9A%E7%9F%A5stackingnotifications/","series":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/series/android-wear/"}],"smallImg":"","tags":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/tags/android-wear/"},{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"可穿戴设备","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%AF%E7%A9%BF%E6%88%B4%E8%AE%BE%E5%A4%87/"},{"title":"分组","url":"https://www.qinxiandiqi.sbs/tags/%E5%88%86%E7%BB%84/"}],"title":"Android Wear Preview- 归档通知（Stacking Notifications）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/categories/android-wear/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n原文作者：Google\n原文地址：http://developer.android.com/wear/notifications/pages.html[](http://developer.android.com/wear/notifications/remote- input.html)[](http://developer.android.com/wear/design/user- interface.html#Stream)[](https://developers.google.com/maps/documentation/android- api/intro)\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-24版本翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n当你想要提供更多的信息又不想要求用户在手持设备上打开你的应用程序，你可以选择在Android Wear设备上为你的通知添加一个多个Page（页面）。附加的页面会立刻显示在主通知卡片的右边。更多关于如何使用和设计多页面的内容，请参考Design Principles of Android Wear。\n![](https://img- blog.csdn.net/20140624124514046)\n当创建一个多页面的通知，从创建主通知（第一个页面），也就是你希望显示在手机或者平板上的通知开始。然后，使用addPage()方法一次添加一个页面，或者使用addPages()一次传递一个包含过个页面的Collection集合进去。\n例如，下面的代码添加为通知添加了第二个页面：\n// Create builder for the main notification NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(this) .setSmallIcon(R.drawable.new_message) .setContentTitle(\u0026quot;Page 1\u0026quot;) .setContentText(\u0026quot;Short message\u0026quot;) .setContentIntent(viewPendingIntent); // Create a big text style for the second page BigTextStyle secondPageStyle = new NotificationCompat.BigTextStyle(); secondPageStyle.setBigContentTitle(\u0026quot;Page 2\u0026quot;) .bigText(\u0026quot;A lot of text...\u0026quot;); // Create second page notification Notification secondPageNotification = new NotificationCompat.Builder(this) .setStyle(secondPageStyle) .build(); // Create main notification and add the second page Notification twoPageNotification = new WearableNotifications.Builder(notificationBuilder) .addPage(secondPageNotification) .build(); ","date":"June 24, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidwearpreview-%E4%B8%BA%E9%80%9A%E7%9F%A5%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E9%A1%B5%E9%9D%A2addingpagestoanotification/","series":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/series/android-wear/"}],"smallImg":"","tags":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/tags/android-wear/"},{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"可穿戴设备","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%AF%E7%A9%BF%E6%88%B4%E8%AE%BE%E5%A4%87/"},{"title":"Notification","url":"https://www.qinxiandiqi.sbs/tags/notification/"},{"title":"多页面","url":"https://www.qinxiandiqi.sbs/tags/%E5%A4%9A%E9%A1%B5%E9%9D%A2/"}],"title":"Android Wear Preview- 为通知添加多个页面（Adding Pages to a Notification）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/categories/android-wear/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n原文作者：Google\n原文地址：\u0026lt;http://developer.android.com/wear/notifications/remote- input.html\u0026gt;[](http://developer.android.com/wear/design/user- interface.html#Stream)[](https://developers.google.com/maps/documentation/android- api/intro)\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-24版本翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n前言# 如果你的通知包括一个文字回复的操作，比如回复一封邮件，这通常需要在手持设备上启动一个Activity来处理。但是，当你的通知出现在Android Wear设备上时，你可以允许用户直接通过语音输入来回复。你也可以提供一些预设好的文字信息给用户选择。\n当用户使用语音或者选择一条预设的信息进行回复时，系统将会发送这个信息到你手持设备上的应用程序中。这个信息将会作为的你的通知操作所使用的Intent的extra附加数据。\n注意：当你使用Android模拟器进行开发的时候，你必须输入文字到那些语音回复的控件中来回复。因此，你要确保AVD设置中的Hardware keyboard present设置已经打开。\n![](https://img- blog.csdn.net/20140624122109234)\nDefine the Remote Input（定义远程输入）# 创建一个支持语音输入的操作，首先要使用RemoteInput.Builder的API创建一个RemoteInput对象实例。RemoteInput.Builder的构造器需要一个字符串参数，系统将这个字符串作为传递到手持设备上应用程序的Intent携带的extra中所附加的回复信息的key。\n例如，下面的代码中创建了一个RemoteInput对象，并给语音输入提示提供一个自定义的标签：\n// Key for the string that's delivered in the action's intent private static final String EXTRA_VOICE_REPLY = \u0026quot;extra_voice_reply\u0026quot;; String replyLabel = getResources().getString(R.string.reply_label); RemoteInput remoteInput = new RemoteInput.Builder(EXTRA_VOICE_REPLY) .setLabel(replyLabel) .build(); Add Pre-defined Text Responses（添加预定义的文字回复）# 除了允许语音回复之外，你也可以提供最多五条预定义的回复信息让用户快速选择回复。你只需要调用setChoices()方法并传递一个字符串数组。\n例如，你可以在数组资源文件中定义一些回复：\nres/values/strings.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;string-array name=\u0026quot;reply_choices\u0026quot;\u0026gt; \u0026lt;item\u0026gt;Yes\u0026lt;/item\u0026gt; \u0026lt;item\u0026gt;No\u0026lt;/item\u0026gt; \u0026lt;item\u0026gt;Maybe\u0026lt;/item\u0026gt; \u0026lt;/string-array\u0026gt; \u0026lt;/resources\u0026gt; 然后，获取字符串数组并添加到RemoteInput对象中：\nString replyLabel = getResources().getString(R.string.reply_label); String[] replyChoices = getResources().getStringArray(R.array.reply_choices); RemoteInput remoteInput = new RemoteInput.Builder(EXTRA_VOICE_REPLY) .setLabel(replyLabel) .setChoices(replyChoices) .build(); Receive Voice Input for the Primary Action（为主操作接收语音输入）# 如果“Reply”是你的通知主要操作（通过setContentIntent()方法定义），那么你可以使用addRemoteInputForContentIntent()方法将RemoteInput添加到主操作中。例如：\n// Create intent for reply action Intent replyIntent = new Intent(this, ReplyActivity.class); PendingIntent replyPendingIntent = PendingIntent.getActivity(this, 0, replyIntent, 0); // Build the notification NotificationCompat.Builder replyNotificationBuilder = new NotificationCompat.Builder(this) .setSmallIcon(R.drawable.ic_new_message) .setContentTitle(\u0026quot;Message from Travis\u0026quot;) .setContentText(\u0026quot;I love key lime pie!\u0026quot;) .setContentIntent(replyPendingIntent); // Create the remote input RemoteInput remoteInput = new RemoteInput.Builder(EXTRA_VOICE_REPLY) .setLabel(replyLabel) .build(); // Create wearable notification and add remote input Notification replyNotification = new WearableNotifications.Builder(replyNotificationBuilder) .addRemoteInputForContentIntent(remoteInput) .build(); 通过使用addRemoteInputForContentIntent()方法添加RemoteInput对象到通知的主操作中，这个按钮通常情况下作为“Open”按钮显示，知道用户在Android Wear设备上选中之后才会转变成“Reply”按钮并开始显示语音输入界面。\nReceive Voice Input for a Secondary Action（为次级操作接收语音输入）# 如果“Reply”操作不是你的通知主操作，并且你想要将语音输入作为次级操作。你可以使用Action对象定义一个新的操作按钮，并把RemoteInput对象传递进去。\n你应该使用Action.Builder()构造方法来实例化一个Action对象，这个构造方法需要一个图标和文字标签，还有PendingIntent对象作为参数来设置Action对象。其中，当用户选择了这个Action之后，系统将会通过这个PendingIntent来调用你的应用程序。例如：\n// Create the pending intent to fire when the user selects the action Intent replyIntent = new Intent(this, ReplyActivity.class); PendingIntent pendingReplyIntent = PendingIntent.getActivity(this, 0, replyIntent, 0); // Create the remote input RemoteInput remoteInput = new RemoteInput.Builder(EXTRA_VOICE_REPLY) .setLabel(replyLabel) .build(); // Create the notification action Action replyAction = new Action.Builder(R.drawable.ic_message, \u0026quot;Reply\u0026quot;, pendingIntent) .addRemoteInput(remoteInput) .build(); 当你将RemoteInput对象添加到Action中之后，你需要使用addAction()将这个Action添加到WearableNotifications.Builder中。例如：\n// Create basic notification builder NotificationCompat.Builder replyNotificationBuilder = new NotificationCompat.Builder(this) .setContentTitle(\u0026quot;New message\u0026quot;); // Create the notification action and add remote input Action replyAction = new Action.Builder(R.drawable.ic_message, \u0026quot;Reply\u0026quot;, pendingIntent) .addRemoteInput(remoteInput) .build(); // Create wearable notification and add action Notification replyNotification = new WearableNotifications.Builder(replyNotificationBuilder) .addAction(replyAction) .build(); 现在，当用户在Android Wear设备上选择“Reply”操作之后，系统将会提供用户语音输入（如果有同预定义回复还会显示预定义回复列表）。一旦用户完成回复响应，系统将会调用附加在操作上的Intent，并添加以EXTRA_VOICE_REPLY（也就是你在RemoteInput.Builder构造器中传递进去的字符串）为key，以用户输入信息为字符串值的extra到Intent中。\n","date":"June 24, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidwearpreview-%E4%BB%8E%E9%80%9A%E7%9F%A5%E4%B8%8A%E6%8E%A5%E6%94%B6%E8%AF%AD%E9%9F%B3%E8%BE%93%E5%85%A5receivingvoiceinputfromanotification/","series":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/series/android-wear/"}],"smallImg":"","tags":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/tags/android-wear/"},{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"可穿戴设备","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%AF%E7%A9%BF%E6%88%B4%E8%AE%BE%E5%A4%87/"},{"title":"语音输入","url":"https://www.qinxiandiqi.sbs/tags/%E8%AF%AD%E9%9F%B3%E8%BE%93%E5%85%A5/"},{"title":"Notification","url":"https://www.qinxiandiqi.sbs/tags/notification/"}],"title":"Android Wear Preview- 从通知上接收语音输入（Receiving Voice Input From a Notification）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/categories/android-wear/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n原文作者：Google\n原文地址：http://developer.android.com/wear/notifications/creating.html[](http://developer.android.com/wear/design/user- interface.html#Stream)[](https://developers.google.com/maps/documentation/android- api/intro)\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-20版本翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n前言# 当一个Android设备（比如手机或者平板）被连接到一部Android穿戴设备上，默认会将所有通知在设备之间共享。在Android穿戴设备上，每一条通知都会作为一张卡片出现在上下文信息流中。\n不需要做任何处理，你的应用通知就能在Android Wear上提供给用户。但是，你可以通过一些途径来提高用户体验。例如，如果用户能通过输入文字来响应一个通知，那么对于回复信息，你可以添加功能让用户能够直接在穿戴设备上通过语音进行回复。\n为了帮助你在Android Wear上为你的通知提供最好的用户体验，本篇指南将为你展示如何使用NotificationCompat.Builder APIs里面的标准模板创建通知，再加上如何扩展你的通知功能来提升穿戴设备用户的体验。\n注意：通知使用的RemoteViews被剥离了自定义视图 功能，系统只能使用Notification对象中的文字和icon显示在通知卡片上。但是，即将发布的正式版Android Wear SDK将支持自定义卡片布局。\nImport the Necessary Classes（导入需要的类）# 在开始开发之前，你必须先完成Get Started with the Developer Preview文档中的步骤。正如文档中提到的，你的应用需要包含v4 support Library和Developer Preview support Library。所以在开始之前，你应该在你的项目代码中进行以下导入：\nimport android.preview.support.wearable.notifications.*; import android.preview.support.v4.app.NotificationManagerCompat; import android.support.v4.app.NotificationCompat; 注意：Android Wear Developer Preview（Andorid Wear开发者预览版）中的API目的只是为了开发和测试，不能用于产品应用。Google可能会大量修改开发者预览版以发布正式版Android Wear SDK。你不用使用开发者预览版发布应用，因为开发者预览版在正式版SDK发布之后将不再支持（这可能会造成依赖于开发者预览版应用程序的一些错误）。\nCreateNotifications with the Notification Builder（使用Notification# Builder创建通知）\nv4 support library允许你使用最新的通知功能（比如操作按钮和大图标等）来创建通知，并且能够兼容Android 1.6及更高版本。\n例如，下面的代码使用了NotificationCompat API组合新的NotificationManagerCompat API来创建和报告一个通知：\nint notificationId = 001; // Build intent for notification content Intent viewIntent = new Intent(this, ViewEventActivity.class); viewIntent.putExtra(EXTRA_EVENT_ID, eventId); PendingIntent viewPendingIntent = PendingIntent.getActivity(this, 0, viewIntent, 0); NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(this) .setSmallIcon(R.drawable.ic_event) .setContentTitle(eventTitle) .setContentText(eventLocation) .setContentIntent(viewPendingIntent); // Get an instance of the NotificationManager service NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this); // Build the notification and issues it with notification manager. notificationManager.notify(notificationId, notificationBuilder.build()); 当这个通知显示在手持设备上时，用户可以通过触摸通知来调用使用setContentIntent()方法指定的PendingIntent。当这个通知显示在Android 穿戴设备上，用户可以通过滑动通知到左边来展现一个打开的Action，这个Action能够调用手持设备上的Intent。\nAdd Action Buttons# 除了使用setContentIntent()方法定义的主要内容action之外，你也可以通过传递一个PendingIntent到addAction()方法来添加其他的action。\n例如，下面的代码与上面代码中的通知类型一样，但是添加了一个action去地图上查看事件中的地点。\n// Build an intent for an action to view a map Intent mapIntent = new Intent(Intent.ACTION_VIEW); Uri geoUri = Uri.parse(\u0026quot;geo:0,0?q=\u0026quot; + Uri.encode(location)); mapIntent.setData(geoUri); PendingIntent mapPendingIntent = PendingIntent.getActivity(this, 0, mapIntent, 0); NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(this) .setSmallIcon(R.drawable.ic_event) .setContentTitle(eventTitle) .setContentText(eventLocation) .setContentIntent(viewPendingIntent) .addAction(R.drawable.ic_map, getString(R.string.map), mapPendingIntent); 在手持设备上，这个action作为一个额外的按钮附加在通知上。在Android穿戴设备上，当用户将通知滑动到左边的时候，这个action作为一个大按钮出现。用户点击这个action之后，这个组合的Intent将会在手持设备上被调用。\n提示：如果你的通知包含一个“回复”按钮（例如信息应用），你可以直接在Android穿戴设备上用语音回复来增强这个功能。更多信息，可以参考Receiving Voice Input from a Notification。\n更多关于action按钮的设计（包括图标规格），可以参考Design Principles of Android Wear。\nAdd a Big View# 你可以通过为你的通知添加一个“big view”类型来插入扩展的文字内容。在手持设备上，用户可以通过展开通知来查看big view的内容。但是在Android穿戴设备上，big view的内容将会按照默认显示。\n为你的通知添加扩展内容，调用NotificationCompat.Builder对象的setStyle()方法，传递给它一个BigTextStyle或者InboxStyle实例。\n例如，下面代码添加了一个NotificationCompat.BigTextStyle实例到事件通知中，以包含事件完成的描述（里面包含了比setContentText()提供的能够填满空间还要多的文字）。\n// Specify the 'big view' content to display the long // event description that may not fit the normal content text. BigTextStyle bigStyle = new NotificationCompat.BigTextStyle(); bigStyle.bigText(eventDescription); NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(this) .setSmallIcon(R.drawable.ic_event) .setLargeIcon(BitmapFractory.decodeResource( getResources(), R.drawable.notif_background)) .setContentTitle(eventTitle) .setContentText(eventLocation) .setContentIntent(viewPendingIntent) .addAction(R.drawable.ic_map, getString(R.string.map), mapPendingIntent) .setStyle(bigStyle); 注意你可以使用setLargeIcon()方法为通知添加一个大的背景图片。获取更多关于使用大图片设计通知的内容，请参考Design Principles of android Wear.\nAdd New Features for Wearables# Android Wear预览版支持库提供了一些新API来帮助提升穿戴设备上的用户通知体验。例如，你可以添加额外的内容页面让用户向左滑动来查看，或者为用户添加使用语音输入来回复你的应用程序的文字响应功能。\n使用这些新API，需要传递你的NotificationCompat.Builder实例到WearableNotifications.Builder()构造方法中。然后你可以使用WearableNotifications.Builder的方法来为你的通知添加新功能特性。例如：\n// Create a NotificationCompat.Builder for standard notification features NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(mContext) .setContentTitle(\u0026quot;New mail from \u0026quot; + sender.toString()) .setContentText(subject) .setSmallIcon(R.drawable.new_mail); // Create a WearablesNotification.Builder to add special functionality for wearables Notification notification = new WearableNotifications.Builder(notificationBuilder) .setHintHideIcon(true) .build(); setHitHideIcon()方法将你的应用程序图标从通知卡片上移除。这个方法只是一个WearableNotifications.Builder类中提供的新通知功能的例子。\n当你想要提供你的通知，请确定使用的是NotificationManagerCompat的API：\n// Get an instance of the NotificationManager service NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this); // Build the notification and issues it with notification manager. notificationManager.notify(notificationId, notification); 如果你使用的是框架提供的NotificationManager实例，那么一些WearableNotifications.Builder的功能可能不能正常工作。\n在穿戴设备上使用WearableNotifications.Builder或者其它预览版支持库中的API来继续增强你的通知功能，请参考一下开发指南：\nReceiving Voice Input from a Notification\n添加一个接收语音输入的操作并且转发输入的信息给你的应用程序。\nAdding Pages to a Notification\n添加一个额外的信息页面让用户可以通过向左滑动来查看。\nStacking Notifications\n归档你的应用程序中所有类似的通知到一个栈中，使得可以在不添加多个卡片到卡片信息流的情况下逐个查看。\nYou Might Also Want to Read（你可能也想要阅读）：# [\nNotifying the User](http://developer.android.com/training/notify- user/index.html)\n学习更多关于如何创建通知。\nIntents and Intent Filters\n学习所有你需要了解的关于Intent的API，用于通知的Action。\n","date":"June 20, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidwearpreview-%E5%88%9B%E5%BB%BA%E9%80%9A%E7%9F%A5creatingnotificationsforandroidwear/","series":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/series/android-wear/"}],"smallImg":"","tags":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/tags/android-wear/"},{"title":"可穿戴设备","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%AF%E7%A9%BF%E6%88%B4%E8%AE%BE%E5%A4%87/"},{"title":"Notification","url":"https://www.qinxiandiqi.sbs/tags/notification/"},{"title":"通知","url":"https://www.qinxiandiqi.sbs/tags/%E9%80%9A%E7%9F%A5/"}],"title":"Android Wear Preview- 创建通知（Creating Notifications for Android Wear）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/categories/android-wear/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n原文作者：Google\n原文地址：http://developer.android.com/wear/design/index.html[](http://developer.android.com/wear/design/user- interface.html#Stream)[](https://developers.google.com/maps/documentation/android- api/intro)\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-19版本翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n前言# Android可穿戴设备只在对的时间提供对的信息，让你处在现实世界中也能连接到虚拟世界。\n本章你将学习如何Android Wear平台上设计良好的用户体验。Android Wear的设计与手机或者平板上的设计有很大的不同，因此我们将从阐述你的信息内容是如何连接到Android Wear的整体视图上来开始。为了更好的了解Android Wear上的用户体验，你应该先阅读UI Overview。\n1.1 Android Wear体验如下：# Contextually aware and smart（上下文关联和智能） 。这些设备将计算机交互提到到一个新层次。相对于请求焦点并让用户输入的交互模式，Android可穿戴设备能够意识它们自己的情境和状态，然后在正确的时间显示有用的信息。及时，相关，具体。 Glanceable（可浏览） 。可穿戴设备的使用是全天性的，尽管有时设备在我们的视线范围之外。有效的应用程序会在最大有效承载范围内，全天性提供以最简单的方式并优化信息片段。简短，重点，及时。 Zero/low interaction（零/低交互） 。忠于更小的外形所带来的优势，Android Wear专注于更简单的交互，它只在必要的时候要求用户输入。大部分输入都是基于触摸滑动和语音，并且复杂的输入操作是应该要避免的。手势，简单，快速。 Helpful（有用的） 。Android Wear就像一个强大的个人助理：它了解你这个人和你的喜好，它只在有必要的时候打断你，它总是能够随时为你提供一个现成的答案。高效，友好，敏感。 ![](https://img- blog.csdn.net/20140619160504968)\n在尊重理解用户的兴趣情况下，通过提供智能的连接到世界各地，Android Wear即能私人化也能全球性，简单又智能，不显眼又能随时待命。在整个Android Wear的体验中，遵循这些规则的通知就像感觉在家一样。\nNotification UI Patterns（通知的UI图案）# Android通知在主要信息流中作为卡片显示，并构成了Android Wear的核心体验。Android通知设计指南中的大部分原则也应用到了Android Wear上。能否遵从用户的兴趣和清楚什么是不必要的干扰将会体现在用户对你的应用程序的感受上。\n将你的通知上不必要的信息忽略掉。要设计成不需要详细阅读信息，通知看一眼就能明白。要使用单词或者短语，不要使用句子。要的是显示，不是阐述：在可能的情况下尽量使用图标，字形和可视化效果来传达你的信息。\n在一些情况下，尤其是信息类应用，卡片可能会包含一个动态内容，并且没办法一次填满一个屏幕。在这种情况下，内容将会被自动拆分以填满卡片，用户可以通过点击来扩展查看，因此你应该提供完整的信息。\n通知的优先级应该要反应出通知的迫切性，对时间敏感的通知应该赋予高优先级。活跃的通知，也就是那些能引起设备震动的通知，应该是那种迫切需要得到用户的关注和响应的通知（例如，一个基于时间的信息提示，一条来自朋友的信息）。不是很紧急的通知（例如，一张中转时间卡片，每日计步器的计数，社会网络更新）应该静默添加到卡片信息流中。\n2.1 Actions（操作）# Action的出现出现取决于你的通知，它允许用户来操作你的通知。最多能够允许三个Action。最常用的Action应该放在首位，所以它是一个在你的通知内容之外的简单滑动。\nAction包括一个图标和标题。图标必须是PNG文件，使用白色透明背景，32×32dp（其中内边距为8dp）尺寸，与[Iconography](http://developer.android.com/design/style/iconography.html#action- bar)设计指南中的action bar图标规则很类似。标题应该是一个动词而且要简短，并且一行不够显示时会自动被截断。\nAction是可选的。很多有用的通知都不需要包含Action。\n更多关于开发action按钮的细节，请参考Creating Notifications for Android Wear。\n2.2 Images（图片）# Image出现在信息流中卡片的背后，它提供了背景和附加的浏览。你的Image应该支持通知中的核心信息；例如，一个关于体育队伍的卡片应该包含这个队伍的颜色和logo，一条通讯录中的信息应该显示对应联系人的头像。\n记住卡片将会覆盖Image的底部。Image的大小应该适应手机上通知的外形，尺寸为64*64dp。横向滑动的时候Image背景会滑动，因此横向导向的Image更适合包含多个page和action的通知。\n添加大图片，可以使用通知的setLargeIcon()，参考Creating Notifications for Android Wear。\n2.3 Application Icons# 你的应用程序启动图标将会自动显示在卡片上，用来标识你的通知。不要使用通知标题或者背景图片来标识或者区分你的应用。相反的，应该允许你的图标来标识它本身，并专注于提供一个清晰的简洁的信息在卡片和图片上。你可以使用setHintHideIcon()方法来选择不显示这个图标。\n2.4 Pages（页面）# Page是一些附加的卡片，出现在信息流中主卡片的右边。如果你的信息比一个简短片段还要长，不要牺牲可浏览性来将所有信息都打包进你的主通知中。相反的，使用多个page来提供附加内容。\n![](https://img- blog.csdn.net/20140619162413015)![](https://img- blog.csdn.net/20140619162419968)\nPage会立刻出现在主通知卡片的右边。它们通常被用来提供附加的细节或者主卡片内容的附加视图。例如：\n一张当前的天气卡片可能会提供一个附加的page来显示未来三天的天气预报。 一张下一班火车发车信息卡可能会提供一个附加page来显示后续的发车时间。 一张日常计步器卡片可能会提供一个附加page显示同一个测量中的卡路里和距离。 Page没有限制可以添加的最多数量。但是，提供Action的通知不应该显示超过三个page以保证操作依然容易使用。\nPage是可选择的，很多有用的通知可能不需要包含page。\n更多page的开发细节，请参考Adding Pages to a Notification。\n2.5 Notification Stacks（通知栈）# Stack可能用于将同一个应用程序的多个通知收集到一个卡片栈中。相对于page用于提供一个通知的附加细节，Stack被用来收集多个同一级别的通知。一个Stack可以通过用户访问Stack中每一个卡片来展开。\nStack是一种可以添加多个有用的通知而不用破坏用户的数据流的方法。如果你的应用可能在同一时间里会产生多个通知，可以考虑将它们添加到一个Stack中。\nStack中每一个通知都可以包含关联于这个通知的多个独立page和多个独立Action。用户可以在展开Stack中通知之后访问这些action。\n更多关于开发Stack的细节，请参考Stacking Notifications。\n![](https://img- blog.csdn.net/20140619162759531)\n2.6 Voice Replies(语音回复）# 语音回复主要用于消息类型应用程序，提供了一种通过口述简短消息的免提方式。大多情况下，你可以提供最多五个建议答复或者“固定回答”。这些“固定回答”可以被用户点击，以便于在某些不适合语言的情况提供一种快速发送简单回复的方法。\n你应该在你提供的选择中尝试覆盖简单和中性的答复。在语音回复界面中，较长的语音回复可能会被自动截断。\n更多关于使用语音回复的开发细节，请查看Receiving Voice Input from a Notification.\n![](https://img- blog.csdn.net/20140619162848062)\n","date":"June 19, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidwearpreview-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83designprinciplesofandroidwear/","series":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/series/android-wear/"}],"smallImg":"","tags":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/tags/android-wear/"},{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"设计规范","url":"https://www.qinxiandiqi.sbs/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"},{"title":"可穿戴设备","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%AF%E7%A9%BF%E6%88%B4%E8%AE%BE%E5%A4%87/"}],"title":"Android Wear Preview - 设计规范（Design Principles of Android Wear）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"XML学习笔记","url":"https://www.qinxiandiqi.sbs/categories/xml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"2012-08-09\n1、 Schema元素list：用于从一个特定数据类型集合中选择一个或多个数据，常用于simpleType中，作为其子元素。主要属性有itemType，其属性值是一个简单类型，表示指定的数据类型集合。例如：\n\u0026lt;xs:list itemType=\u0026ldquo;xs:date\u0026rdquo;/\u0026gt;表示取值只能取一个或多个date类型的数据，多个数据之间用空格隔开。\n2、Schema元素union：用于组合多种简单数据类型，常用于simpleType元素中做其子元素。主要属性有memberType，其值为一个或多个简单数据类型，多个简单数据类型之间用空格隔开。例如\u0026lt;xs:union memberType=\u0026ldquo;type1 type2\u0026rdquo;/\u0026gt;表示取值只能取type1类型或者type2类型。与元素enumeration的区别在于，union组合的是数据类型，而enumeration组合的是具体数据类型的一些具体值。\n3、Schema元素simpleType：用于定义一个简单类型，它决定了元素和属性值的约束以及相关信息，主要属性有name，表示该用户自定义数据类型的名字。其主要类内容通过Schema三种元素来使用：\n1）restrict元素：用于限定一个范围。如：\n\u0026lt;xs:simpleType name=\u0026ldquo;MyType\u0026rdquo;\u0026gt;\n\u0026lt;xs:restriction base=\u0026ldquo;xs:integer\u0026rdquo;\u0026gt;\n\u0026lt;xs:minInclusive value=\u0026ldquo;0\u0026rdquo;/\u0026gt;\n\u0026lt;/xs:restriction\u0026gt;\n\u0026lt;/xs:simpleType\u0026gt;\n2）list元素：用于从指定列表中选择一个值。如：\n\u0026lt;xs:simpleType name=\u0026ldquo;MyType\u0026rdquo;\u0026gt;\n\u0026lt;xs:list itemType=\u0026ldquo;xs:date\u0026rdquo;/\u0026gt;\n\u0026lt;/xs:simpleType\u0026gt;\n3）union元素：用于组合一定的数据类型。如：\n\u0026lt;xs:simpleType name=\u0026ldquo;MyType\u0026rdquo;\u0026gt;\nxs:union\nxs:simpleType\n\u0026lt;xs:list itemType=\u0026ldquo;xs:string\u0026rdquo;/\u0026gt;\n\u0026lt;/xs:simpleType\u0026gt;\nxs:simpleType\n\u0026lt;xs:list itemType=\u0026ldquo;xs:date\u0026rdquo;/\u0026gt;\n\u0026lt;/xs:simpleType\u0026gt;\n\u0026lt;/xs:union\u0026gt;\n\u0026lt;/xs:simpleType\u0026gt;\n4、Schema元素complexType：用于定义一个复合类型，也是能决定一组元素和属性值的约束和相关信息，主要属性有name，标识该符合类型的名字。\n5、simpleType和complexType的区别：\n1）simpleType的定义中不能包含element和attribute，它相当于是对Schema的内置数据类型进行重新的包装，本质上它还是一个Schema内置数据类型，只是对这些内置数据类型做了约束或者合并。在element中使用type引用定义的simpleType，只能作为element的内容，并且element不能再包含子元素或者属性。也就是说，声明的element如果引用或者包含了一个simpleType，那么这个element只能是一个无属性无子元素只有简单类型数据内容的元素；在attribute中使用type引用定义的simpleType，只能作为attribute的属性值，可以看出它的使用方法和作用与使用内置数据类型没什么区别。\n2）complexType的定义中可以包含element和attribute，当然也可以包括内置数据类型以及simpleType，它相当于是能将element、attribute、数据类型进行封装的容器。引用complexType的element将会根据complexType中包含的内容将其过度给引用的element。\n6、Schema元素simpleContent：只能作用于complexType中，用于对它的内容进行约束和扩展。一个complexType元素包含了一个simpleContent，就不能再包含其它元素。同时，simpleContent的内容也只能包含一个extension元素或者一个restriction元素或者一个annotation元素，extension元素可再包含一个或多个attribute属性元素。若声明的元素使用包含simpleContent的complexType，则该声明元素不可以再包含除了unique、key、keyref之外的其它元素，simpleContent下的extension会过渡为声明元素的内容，extension的子元素attribute会过渡委声明元素的属性，也就是说该声明元素最多只能拥有多个属性或多个内容（complexType外部的unique可组合简单类型）。如果simpleContent的extension中不定义attribute，则包含simpleContent的complexType与simpleType没有区别。由此可以看看出，simpleContent实际上就是为了弥补simpleType只能拥有内容不能拥有属性而产生的，它可以比simpleType多包含属性。\n7、Schema元素extension：可以作为simpleContent的子元素，主要属性有base，其值为一个数据类型，用于表示引用包含simpleContent的complexType的声明元素的内容的数据类型。如：\u0026lt;xs:extension base=\u0026ldquo;xs:string\u0026rdquo;/\u0026gt;。extension可以包含多个子元素attribute，它们将过渡为element的属性。\n8、java.lang.Desktop类的静态getDesktop（）方法可以获取一个Desktop对象。该对象的open（File file）可以调用本地系统关联的程序打开file指向的文件，就跟在系统上直接打开该文件的效果一样，如果无法找到关联的程序打开文件就会抛出异常。\n9、Schema元素choice：用于包含一个或多个定义或引用的element，并且只能定义在complexType里面。它有两个属性，一个是minOccurs，一个是maxOccurs，属性值都是整数类型。整个choice用于表示choice包含的所有element最少要出现minOccurs次，最多不能超过maxOccurs次，至于出现的是哪个element则只要是choice里面的element就行，次数符合要求就可以。\n10.Schema元素sequence：同choice类似，也是用于包含一个或多个定义或引用的element，通常也是定义在complexType里面，也有两个属性minOccurs和maxOccurs，属性值为整数。与choice的区别在于，sequence中的所有element必需按照定义在sequence中排列的先后顺序成组出现，并且最少出现minOccurs次，最多出现maxOccurs次。也就是说，sequence中的次数单位是sequence中所有element按顺序排列的组，choice的次数单位是choice中单个element。\n11、Schema文档的后缀名为“.xsd”。\n12、Schema文档不像DTD可以使用DOCTYPE指定哪一个是根元素，它并没有指定文档中定义的哪一个元素是根元素。凡是使用Schema校验的XML文档，其根元素可以使Schema文档中定义的任何一个根元素。选定一个根元素后，Schema文档中没有包含在该元素下的元素在XML文档中都不能出现。因此，设计Schema文档的时候，通常都会设计一个根元素包含文档中其它所有元素，并在校验的XML文档中使用该元素作为根元素已使用文档中定义的其它元素。\n","date":"June 18, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/xml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/xml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E8%AE%B0/","series":[{"title":"XML学习笔记","url":"https://www.qinxiandiqi.sbs/series/xml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"schema","url":"https://www.qinxiandiqi.sbs/tags/schema/"},{"title":"xml","url":"https://www.qinxiandiqi.sbs/tags/xml/"}],"title":"XML学习笔记 第三记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"XML学习笔记","url":"https://www.qinxiandiqi.sbs/categories/xml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"2012-08-07\n1、XML实体可分为普通内部外部实体和内部外部参数实体。普通内部外部实体用在XML文档中，而内部外部参数实体用在DTD声明中。\n2、DTD声明普通内部实体语法：，调用时用格式“\u0026amp;实体名;”。\n3、DTD声明普通外部实体语法：，表示使用URI或者URL指向文件的全部内容替换实体名，比较少用，调用时用格式“\u0026amp;实体名;”。\n4、DTD声明内部参数实体语法：，调用时用格式“%实体名;”。\n5、DTD声明外部参数实体语法：，表示使用URI或者URL指向文件的全部内容替换实体名，比较少用，调用时用格式“%实体名;”。\n6、XML的命名空间，当文档中相同元素名或属性名但定义内容部一致时，为了区分，需要使用命名空间。定义XML命名空间的语法为在首次使用该命名空间的地方使用xmlns：name=\u0026ldquo;URL\u0026rdquo;，定义后在元素名或属性名前使用“name：”前缀就能标识该元素或属性是name命名空间的内容。命名空间使用全球唯一的URL作为命名空间的值，为的是保证命名空间的唯一性，但实际上URL只是一个标识字符串，URL是否有实际意义是没有关系的。XML的命名空间类似于Java中的package。\n——————————————————————————————————————————————\n2012-08-08\n1、Schema：与DTD一样，用于验证XML文档的有效性，并且比DTD提供更强大的功能和更细粒度的数据类型，还支持自定义数据类型，所以，Schema文档就是用来声明XML文档规则的。最重要的是，Schema本身也是一个XML文件，遵守XML规范，而DTD不是。\n2、Schema作为XML文档的一种，自然要遵循XML文档的基本语法，也需要验证它的有效性。Schema文档由DTD验证，所以Schema的本源也是DTD。\n3、Schema元素schema：Schema文档的根元素，属性有xmlns和targetNamespace。Schema文档的根元素规定必须为shemale，并且来自URL为http://www.w3.org/2001/XMLSchema的命名空间，Schema文档中使用的Schema元素和数据类型都来自于该命名空间，这个地址也标识了用于验证Schema的DTD文档。另外，这个命名空间的名字可以随便起，但是整个Schema文档中使用的Schema元素和数据类型都必须使用该命名空间名字标注。比如：\u0026lt;xs:schema xmlns:xs=\u0026ldquo;http://www.w3.org/2001/XMLSchema\" targetNamespace=\u0026ldquo;http://mynamespace/myschema\u0026rdquo;\u0026gt;，则文档中所有Schema元素和数据类型都必须用xs标注xs:元素或类型名。targetNamespace命名空间用于标识本Schema文档中自定义的元素和数据类型，其URL值可以自己定义。\n4、使用Schema文档校验XML文档方法：在被校验的XML文档根元素使用\u0026lt;根元素 xmlns:xsi=\u0026ldquo;http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation(Schema文档中没有定义targetNamespace的情况)/targetNamespace(有定义targetNamespace情况)=\u0026ldquo;Schema文档地址\u0026rdquo;\u0026gt;。\n5、Schema的数据类型分为简单类型和复杂类型（通过complexType定义）。简单类型又分为内置数据类型和用户自定义数据类型（通过simpleType定义）。内置数据类型又可再分为基本数据类型和扩展数据类型。\n6、Schema元素element：用于声明被校验XML文档的一个元素，主要属性有：\n1）name：声明元素的名字；\n2）type：声明元素的数据类型，可以使用Schema的数据类型，也可以使用自定义的数据类型。该类型要么是声明元素的属性，要么是声明元素标签之间的内容或者子元素。\n3）ref：用于引用一个声明好的元素，如\u0026lt;xs:element ref=\u0026ldquo;cat\u0026rdquo;/\u0026gt;，cat是本文档中已经声明的一个元素，该语句表示这里需要填充一个cat元素，常用于声明自定义数据类型中使用。\n4）minOccurs：该属性值为一个整数，表示该声明元素最少要出现的次数。\n5）maxOccurs：该属性值为一个整数，表示该声明元素最多能出现的次数，如果值为unbounded，则表示无限制。\n6）substitutionGroup：属性值是一个已经定义的元素名字，表示可以使用属性值对应的元素替换属性归属的元素，比较少使用。\n7、Schema元素group：用于定义一个元素组，将过个元素进行捆绑，元素组中的元素要么全部使用，要么全部不使用，主要属性有：\n1）name：元素组的名字；\n2）ref：引用一个元素组，属性值为已经定义的元素组名。\n8、Schema元素attribute：用于声明一个属性，子元素只能是simpleType或者annotation，主要属性有：\n1）name：声明属性的名字；\n2）type：声明属性的数据类型，只能的简单类型，不能是复杂类型，因为属性不能再包含一个属性，没有属性的属性，只有属性的类型；\n3）ref：引用一个声明过的属性，值为声明过的属性名，常用在complexType元素中；\n4）use：申明属性的特点，属性值有optional（可以出现或者不出现）、prohibited（不准使用）、required（必须使用）。\n9、Schema元素attributeGroup：用于定义一个属性组，将多个属性捆绑在一起，调用一个属性组等于同时调用属性组里的所有属性。主要属性有：\n1）name；属性组的名字；\n2）ref：引用一个属性组，属性值为已经定义的属性组名。\n10、Schema元素restriction：用于将对已存在的简单类型取值限定在一个范围内，主要属性有base，其属性值为一个简单类型，常用于simpleType元素中做其子元素。限定范围的方法借用在restrict元素首尾标签之间使用Schema其它相关元素来限定：\n1）\u0026lt;xs:minInclusive value=\u0026ldquo;value\u0026rdquo;/\u0026gt;，限定值必须等于或大于value。\n2）\u0026lt;xs:maxInclusive value=\u0026ldquo;value\u0026rdquo;/\u0026gt;，限定值必须等于或小于value。\n3）\u0026lt;xs:minExclusive value=\u0026ldquo;value\u0026rdquo;/\u0026gt;，限定值必须大于value。\n4）\u0026lt;xs:maxExclusive value=\u0026ldquo;value\u0026rdquo;/\u0026gt;，限定值必须小于value。\n5）\u0026lt;xs:enumeration value=\u0026ldquo;value\u0026rdquo;/\u0026gt;，可使用多次来定义一个枚举类型，限定值\n必须为多个值中的一个。\n\u0026hellip;\n11、在元素首尾标签之间定义的类型或者声明的元素和属性，类似于Java中的匿名内部类，所以这些类型或者元素和属性不需要name属性，它们只能被包含它们的元素使用。这种做法也相当于将元素首尾标签之间定义的内容用simpleType或complexType元素定义后，再以该元素的type属性指定。\n12、声明元素的type属性或者元素首尾标签之间定义的东西，将根据它们的特点作为声明元素的特定组成部分。如果是元素，则作为声明元素的子元素；如果是数据类型，则作为声明元素首尾标签之间的内容；如果是属性，则作为声明元素的属性。另外，如果type类型或标签之间的内容是complexType类型的话，则将complexType再拆分，然后根据以上规则将complexType内容作为声明元素特定的组成部分。\n","date":"June 18, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/xml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/xml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E8%AE%B0/","series":[{"title":"XML学习笔记","url":"https://www.qinxiandiqi.sbs/series/xml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"xml","url":"https://www.qinxiandiqi.sbs/tags/xml/"}],"title":"XML学习笔记 第二记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"XML学习笔记","url":"https://www.qinxiandiqi.sbs/categories/xml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"2012-08-05\n1、XML：eXtensible Markup Language，可扩展元标记语言。\n2、DTD：Document Type Definition，文档类型定义，用于规范XML的语法要求，XML常通过DTD文档来验证XML的语法是否符合对应DTD的要求。\n3、XML描述的是结构和语义，注重的是内容，而不是单纯的强调格式化（如HTML），不决定文档的内容应该怎样显示。\n4、XML中每一个元素都是成对出现的，开始元素标签和结束元素标签的区别在于结束元素标签名前多了一个正斜杠“/”，如果不成对则出现基本的语法错误。元素的开始和结束标签之间为元素值，元素值可以是其他元素集合（即元素的嵌套），也可以是具体类型值。\n5、XML元素嵌套的时候，必须遵循嵌套顺序，内部元素必须先结束之后，才能结束外部元素。\n6、一个XML文档有且只有一个顶层元素，即根元素，一个XML中除了根元素之外，其它元素都必须被嵌套在根元素中。\n7、嵌套其它元素的元素叫做父元素，被嵌套的元素元素叫做子元素，同一个父元素下并列的子元素叫做兄弟元素。\n8、目前浏览器都很好的支持XML文档，使用浏览器打开XML文档，浏览器会在XML文档的每个元素前添加“+或-”标签，用于打开或收缩元素的具体内容。\n9、目前XML的标准为1.0。\n——————————————————————————————————————————\n2012-08-06\n1、XML的树形结构：一个XML文档根据文档中元素的嵌套关系可以形成一颗关系树，这种树形结构可以支持面向对象编程。XML元素的树形结构信息通常保存在DTD文档中，作为XML的规范。\n2、XML与HTML比较：\n1）可扩展性：HTML不具有扩展性，只有固定的几个标签；而XML是元标记语言，可以定义新的标记语言。\n2）侧重点：HTML侧重于如何变现信息，即显示信息的格式；而XML侧重于如何结构化地描述信息。\n3）语法要求：HTML不要求标记的嵌套、配对等，不要求标记之间具有一定的顺序；而XML严格要求嵌套、配对，和遵循DTD的树形结构。\n4）可读性和可维护性：HTML难于阅读和维护；而XML结构清晰，便于阅读、维护。\n5）数据和显示关系：HTML的内容描述与显示方式整合为一体；而XML内容描述和显示方式向分离，XML只注重结构化的描述信息，如何显示这些信息需要通过外部部件来确定。\n6）保值性：HTML不具有保值性；而XML具有保值性。\n3、XML提供了将不同来源的结构化数据集成的强大功能，通过XML可以实现数据在不同软件、不同数据库、异构语言和异构平台上进行交互。比如一个C++程序需要调用以一个Java程序的方法，C++程序可以通过XML文档将要调用的方法名和参数等信息发送给Java程序，Java程序收到XML文档后从中提取信息执行方法，并将结果再以XML发送回去。基本每一种语言都提供了对XML支持的组件，每一种语言都提供了对XML文档解析的机制。Java中提供了DOM和SAX两种接口用于XML编程。\n4、XML解放了一些只能在服务器端运行的高端软件：服务器将XML格式的数据发送给客户端，并允许客户端通过使用XML文档对象DOM用脚本语言或其它编程语言处理，从而数据不需要返回服务器就能在本地进行计算处理。\n5、由于XML支持的显示模式和数据内容分开，所以只要客户的显示配置不同就可以产生不同的显示方式，从而实现同一个XML文档的个性化显示。\n6、XML在web上传递可以像HTML一样发送数据，所以传递XML文档不需要对现有网络做任何变化。\n7、XML可以根据需求定义一套适合的标准在适合的范围里使用。\n8、XML文档的第一行是XML声明，用XML的处理指令进行声明。XML的处理指令放置在之中，“\u0026lt;?”问号之后接指令名（如xml），指令名后空格接指令对应的参数值。XML对指令的语法要求很严格，每条指令必须顶格写，即“\u0026lt;”之前不允许有任何空白和其它字符，并且指令中“\u0026lt;”之后的“?”前后也不允许有空格，否则语法错误。XML的所有处理指令都放在文档首，处理指令写完后才能写XML文档元素。\n9、xml指令：version指定XML版本（目前只有1.0版本）。encoding指定XML的编码方式，该属性必须放置在standalone之前，否则语法错误；当XML文档中的字符不能完全转换为指定的编码方式时也会产生语法错误，推荐使用UTF-8编码方式可以涵盖所有语言的字符，并且不指定encoding属性时默认也为UTF-8编码方式。standalone属性当值为yes时表示不需要外部文档支持，当为no时表示需要外部文档支持，比如DTD。没有添加standalone属性时默认其值为yes。需要外部文档DTD时，XML解析器会先分析XML文档语法是否符合XML指定版本规范，除此之外还要分析XML文档是否也符合指定DTD文档规范，如DTD文档中树形结构包含的元素必须有，没有包含的元素不能出现等。\n10、XML元素可以具有属性，跟在元素标签名后，用空格隔开，属性采用“属性名=属性值”的格式，属性值用双引号或者单引号包围（当属性值中有单引号时属性值用双引号，当属性值中有双引号时属性值用单引号），多个属性使用一个或多个空格隔开，同一个属性在同一个元素中最多只能出现一次，并且属性值不能包括\u0026lt;,\u0026gt;,\u0026amp;等符号。\n11、XML中的元素名严格区分大小写！！\n12、类似于css样式表可以定义HTML标签的显示样式，同样css样式表也能够定义XML元素的显示样式，编写css的时候将XML的元素当做HTML标签一样定义就可以了。另外，还要将css样式表文件关联到XML文档上，在XML文档添加处理指令。其中，xml- stylesheet为指令名，type为指定关联样式文件的类型（text/css，表示样式文件类型为css文件类型），href为关联的样式文件地址。使用了CSS样式表的XML文档，浏览器显示的时候将以CSS定义的样式显示，因为此时浏览器已经知道每个元素的显示方式，由此可见XML的显示格式与XML内容是分离的。\n13、另一种定义XML显示样式的方法是使用XSL文档，XSL即eXtendable style language，是专为显示XML开发的样式语言。使用时同样需要处理指令声明。\n14、XML只有一种注释\u0026lt;?\u0026ndash; --\u0026gt;，注释不能写在元素尖括号中，注释也不能嵌套。\n15、当XML的元素没有内容的时候，可以将起始标签与结束标签合并为一个标签表示一个空元素，方法是在起始标签名后加“/”。\n16、实体：XML中的变量。XML中定义了5个常用实体，\u0026lt;表示符号\u0026lt;，\u0026gt;表示符号\u0026gt;，\u0026amp;表示符号\u0026amp;，\u0026quot;表示符号\u0026quot;，'表示符号\u0026rsquo;，在XML中不能使用以上符号的地方可以使用它们的实体代替。\n17、定义实体的方法：\n\u0026lt;!ENTITY 实体名 实体值\u0026gt; ... ]\u0026gt;\n18、调用实体的方法：在根元素内调用实体，只要使用“\u0026amp;实体名;”的格式就能调用相应实体的值，在显示的时候会使用实体值代替。\n19、CDATA节：即使用，XML会把CDATA节中的数据都当做纯文本字符处理，也就是对于任意字符都能能在CDATA节中出现而不会出现语法错误（除了]]之外），该标记对于大量使用\u0026lt;\u0026gt;%等字符特别方便。另外CDATA节也不能互相嵌套。\n20、DOCTYPE：文档类型声明，紧跟在XML声明之后，包含了所有实体的声明，语法间实体的定义。\n21、格式正规（wellformed）的XML文档，即符合以下规则的XML文档：\n1）必须由XML声明语句\n2）必须只有一个根元素\n3）标记必须大小写敏感\n4）属性值使用引号\n5）标记成对出现\n6）空标记关闭\n7）元素正确嵌套\n22、格式正规的XML文档不一定是符合逻辑的文档，也就是文档的实现逻辑不一定就是用户需要的逻辑。\n23、XML的元素命名：元素名可以由字母、数字或者其它字符组成，但是不能用数字和XML/xml/Xml/等开头，并且名称中也不能有空格和冒号（冒号是给命名空间使用的）。\n24、有效的XML文档：满足对应DTD要求的格式正规的XML文档。\n25、DTD与XML的关系类似于面向对象语言的类与对象的关系，XML是堆DTD的一个具体实现。\n26、DTD文档的声明与使用：\n1）内部DTD文档：在XML文档内部使用\n2）外部DTD文档：\n3）内外部DTD文档结合（用的很少）：\n27、无论是使用内部还是外部还是内外部结合的DTD文档，它们在本质上都是一样的，完成DTD声明的语法都是一样，区别只是声明语句的位置不一样而已（其中，内外部就是内部和外部的声明进行组合，但根元素的声明在内外部都必须有）。\n28、外部DTD文档格式：同样需要语句的声明，声明自后写入符合DTD声明语法的语句就可以了。\n29、DTD声明元素语法：。\n30、ELEMENT的元素类型有：EMPTY表示一个空元素，即元素不能包含内容，但可以有属性；ANY表示可以包含任何在DTD中定义的元素类型，使用ANY类型的元素包含的子元素数量和类型都不受限制，一般不常用，使用了跟不定义DTD没什么区别；#PCDATA表示字符串类型，使用此类型的元素不能再包含其它子元素，即此元素的内容只能是一个字符串，不能再嵌套其它元素；纯元素类型，表示内容只有元素，除了元素之外没有其它文本；混合类型，表示既包含子元素和文本数据。\n31、DTD声明中可用的修饰符号：“()”，用于给元素分组，如括号将(apple,pear),banana分成了两组；“|”，使用它分隔的多个对象中必须并且只能出现其中的一个，如(man|woman)中只能出现man或者woman；“+”，表示修饰的对象至少要出现一次，可以出现一次到多次，如(member+)中member至少需要出现一次；“”，表示修饰的对象可以出现零到任意多次，爱出现多少次就出现多少次，如(爱好)中爱好可以出现任意次；“?”，表示修饰的对象要么不出现，要么只能出现一次，也就是最多只能出现一次，如(id?)中id最多只能出现一次；“,”，用将对象分隔并且要求对象必须按照指定的顺序出现，如(apple,pear,banana)中出现的顺序只能是apple然后pear然后banana。\n32、ELEMENT声明举例：\n以上定义了一个poem元素，元素中包含三个子元素author、title、context，每个子元素都是一个包含字符串的元素。XML文档中定义poem元素的时候必须定义它的三个子元素，而且子元素的定义顺序只能是author、title、context。\n33、DTD声明元素属性语法：。\n34、DTD属性语法-元素名：元素名指定该属性是哪个元素的属性。\n35、DTD属性语法-属性名：属性名指定元素某属性的名称。\n36、DTD属性语法-属性类型：指定该属性对应的数据类型。主要有：\n1）CDATA，任意字符串类型（与#PCDATA不同，它是修饰元素的）；\n2）NMTOKEN是CDATA的一个子集，表示属性值必须是由英文字母、数字、句号、破折号、下划线或冒号组成，并且不能出现空格；\n3）NMTOKENS，与NMTOKEN一样，区别在于可以包含由多个空格分隔的字符；\n4）ID，表示该属性值在XML文档中相同的元素中取值必须是唯一的；\n5）IDREF，表示该属性值必须是文档中其它元素已经定义的ID属性值；\n6）IDREFS，表示该属性是可以具有由空格分隔开的多规格文档中其它元素已经定义的ID属性值；\n7）Enumerated枚举类型，表示属性值必须在实现定义好的一些值范围内，使用格式为：。\n37、DTD属性语法-属性特点：指定该属性是必须出现还是可省略等一些特性。主要有： 1）#REQUIRED，指定该属性必须出现；\n2）#IMPLIED，指定该属性可以出现也可以不出现；\n3）#FIXED value，指定该属性的值必须时value；\n4）value，指定该属性的默认值为value，如果该属性出现但不提供值，则默认值为value。\n","date":"June 18, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/xml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/xml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E8%AE%B0/","series":[{"title":"XML学习笔记","url":"https://www.qinxiandiqi.sbs/series/xml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"xml","url":"https://www.qinxiandiqi.sbs/tags/xml/"}],"title":"XML学习笔记 第一记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/categories/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、java.lang.ClassLoader抽象类中的方法若使用String类型作为参数表示一个类的话，需要使用类的二进制名称。每个Class对象都包含一个定义它的ClassLoader的引用。\n2、java.lang.ClassLoader抽象类的方法loadClass(String name)接收一个类的二进制名字，用于加载这个类，并由Java虚拟机创建这个类的Class对象作为结果返回（如果没有找到这个类的话就会抛出ClassNotFoundException异常）。需要注意的是，使用loadClass方法加载一个类并不是对这个类的主动使用，因此加载这个类后并不会对这个类进行初始化，必须等到程序对这个类首次主动使用时才会初始化。\n3、java.lang.ClassLoader抽象类的很多方法不能直接使用，但是ClassLoader类中提供了静态方法getSystemClassLoader()可以直接使用，返回结果是委托的System ClassLoader加载器对象，系统加载器通常是用来启动应用程序的类加载器。\n4、java.lang.ClassLoader类的方法defineClass(String name,byte[] b,int off,int len)：该方法可以将b二进制数据转换为一个Class实例，b数组一般从类的class中读取获得。\n5、Java虚拟机自带三个类加载器详解：\n1）根类加载器（Bootstrap）：该类加载器没有父加载器，它负责加载虚拟机的核心类库，如java.lang.*等。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，没有继承java.lang.ClassLoader类，由C++编写。\n2）扩展类加载器（Extension）：它的父加载器为根类加载器，从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jrelibext子目录（扩展目录）下加载类库，如果用户把自己创建JAR文件放在这个目录先，也会自动使用扩展类加载器加载。扩展类加载器由纯java编写，是java.lang.ClassLoader类的子类。\n3）系统类加载器（System）：也称为应用类加载器，它的父加载器为扩展类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中加载了，他是用户自定义类加载器的默认父加载器。系统类加载器是纯java类，是java.lang.ClassLoader类的子类。\n6、用户自定义类加载器：用户自定义的类加载器都必须继承java.lang.ClassLoader类。ClassLoader的构造方法ClassLoader(String name)可以构造一个以系统类加载器为父加载器的类加载器；ClassLoader(ClassLoader loader,String name)可以构造一个以loader加载器为父加载器的类加载器。ClassLoader类是一个抽象类，但是类中却没有抽象方法，所以继承后不重写任何方法也没有问题，但是从逻辑上都必须重写findClass(String name)。findClass方法会在loadClass方法中被调用，用于加载一个类（需要自己写加载一个类的代码）。默认的findClass方法永远抛出一个ClassNotFoundException异常，将会导致使用该自定义类加载器永远无法加载一个类。\n7、类的加载器用来把类加载到Java虚拟机中，从JDK1.2版本开始，类的加载器过程采用父亲委托机制以更好的保证Java平台的安全。父亲委托机制中，各个加载器按照父子关系形成了属性结构，除了根类加载器之外，其它的类加载器都有且只有一个父加载器。\n8、父亲委托机制的过程：一个类加载器加载一个类是使用该类加载器的loadClass方法。在loadClass方法中会首先调用findLoadedClass(name)方法检测要加载的类是否已经加载，如果没有加载就会判断是否存在父加载器，要是存在父加载器就会调用parent.loadClass(name,false)执行父加载器的loadClass方法，父类加载器中的loadClass执行同样的逻辑检查，也就是递归。它一直追寻到没有父加载器的类加载器，也就是根类加载器，之后就会执行根类加载器的findbootstrapClass0(name)方法加载这个类。要是父类加载器无法加载这个类，就会抛出ClassNotFoundException异常被catch捕获，执行findClass方法。在findClass方法中若仍然无法加载，就会继续往回抛出这个异常，由子类加载器的findClass方法处理，一直到有一个类加载器能够加载为止。如果所有的类加载器都无法加载就只能抛出ClassNotFoundException异常了。简单来说，父亲委托机制的过程就是从该类加载器开始，一直往上找父加载器，直到往上没有父加载器为止，之后就开始使用最顶层的父加载器尝试加载这个类，无法加载则返回尝试使用子类加载器加载，直到父加载器中加载了这个类或者最终自己加载或者抛出异常都无法加载。\n9、如果一个类加载器成功加载了一个类，那么这个类加载器就被称为定义类加载器，而定义类加载器以下的子加载器都能够获得定义类加载器返回的Class对象，它们和定义类加载器都被称为初始类加载器。\n10、父子加载器之间的关系实际上是包装关系，子加载器组合了一个父加载器，所以父子加载器之间不一定是继承关系（但也可以使继承关系，只要子加载器组合了一个父加载器就可以）。\n11、父亲委托机制的优点：能够提高软件系统的安全性，在这个机制下，用户自定义的类加载器不可能加载应该由父加载器加载的可靠类，从而防止不可靠甚至恶意代码代替由父加载器加载的可靠代码。\n12、加载器的命名空间：每个类加载器都有自己的命名空间，命名空间由该加载器以其所有父加载器所加载的类组成（但是父加载器的命名空间不能访问到由子加载器加载的类）。在同一个命名空间中，不会出现类的完整名字完全相同的两个类；在不同的命名空间中有可能会出现类的完整名字相同的两个类。\n13、运行时包：由同一个类加载器加载的属于相同包的类组成了运行时包。决定两个类是不是属于同一个运行时包，不仅要看它们的包名是否相同，还要看定义类的加载器是否相同，只有属于同一运行时包的类才能互相访问和包可见的类和类成员。这样做的目的是为了防止用于自己定义的类冒充核心类库的类去访问核心类库的包可见成员。\n14、一个类被一个加载器加载，那么这个类中使用到的其它类也会使用这个加载器去加载，当然，这个加载过程也要符合父亲委托机制。\n15、如果两个加载器之间没有直接或者间接的父子关系，那么它们各自加载类相互不可见。\n16、一个类被加载、连接和初始化之后就开始了它的生命周期，当代表这个类的Class对象不再被引用（即不可触及）时，Class对象就会结束声明周期，Class对象对应的类在方法区内的数据也会被卸载，从而结束了加载类的声明周期。也就是说，一个类结束生命周期取决于代表它的Class对象是否结束了生命周期。\n17、只有用于自定义的类加载器所加载的类可以被卸载，而由Java虚拟机自带的三个类加载器加载的类，在虚拟机的生命周期中都不会被卸载，一旦被Java虚拟机自带的的类加载器加载，它的Class对象将始终可触及。\n18、卸载一个类的方法就是取消所有对这个类Class对象的引用，Java虚拟机会根据一定的回收机制给这个Class对象进行标识，并在合适的时间进行回收和卸载。引用Class对象的地方主要有三个：\n1）类加载器。类加载器每加载一个类就可以返回被加载类的Class对象，并且不会对这个类进行重复加载，说明在类加载器对象中肯定存在一个集合用户存放所有被它加载过的类的Class对象引用。另外，每一个Class对象总会引用它的类加载器（加载它需要加载的其它类等），说明每个Class对象也拥有一个加载它的ClassLoader对象的引用，使用Class的getClassLoader() 可以获得加载它的类加载器对象。\n2）类对象。一个类构造出的所有对象都只有一个共同的Class对象，并且可以通过getClass方法获得这个Class对象，说明所有的类对象都拥有对它的Class对象的引用。\n3）直接的Class引用变量引用。\n","date":"June 17, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E4%B8%83%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"虚拟机","url":"https://www.qinxiandiqi.sbs/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"title":"class","url":"https://www.qinxiandiqi.sbs/tags/class/"},{"title":"classloader","url":"https://www.qinxiandiqi.sbs/tags/classloader/"},{"title":"类加载器","url":"https://www.qinxiandiqi.sbs/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"}],"title":"Java SE 学习笔记 第十七记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/categories/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"content":"1、Dom4J的document.asXML();将document的XML文档转换为字符串。\n2、InputStream的read方法在输入数据可用，或者检测到流末尾以及抛出异常之前，read方法一直处于阻塞状态。\n3、Java虚拟机：当应用程序执行的时候会先创建一个JVM虚拟机进程以及一个主线程来执行应用程序。\n4、Java虚拟机结束生命周期的情况：\n1）执行了System.exit()方法，参数为0时表示正常结束，否则为非正常结束。\n2）应用程序正常执行结束。\n3）应用程序在执行过程中遇到了异常或者错误而终止，JVM也会终止。\n4）由于操作系统出现错误而导致Java虚拟机进程终止。\n5、JVM装载类的过程：\n1）加载：查找并加载应用程序的类的二进制数据，也就是类的class文件。\n2）连接：\n——验证：检查确保加载的类的正确性，保证类符合JVM虚拟机运行数据结构规范。\n——准备：为类的静态变量分配内存，并将它们初始化为默认值。\n——解析：把类中的符号引用转换为直接引用。\n3）初始化：按照类文件中上下顺序为类的静态变量赋予用户设计类静态变量的正确初始值。\n比如：public static int a = 1；在装载时，实际上是在连接准备阶段先赋给a值0，之后在初始化阶段再赋给a值1.\n6、Java程序对类的使用分两种方式：主动使用和被动使用。\n7、Java虚拟机在每个类或者接口被Java程序首次主动使用的时候才会初始化它们。除了主动使用的情况之外，Java都不会对使用的类做初始化。\n8、Java程序对类主动使用的六种情况：\n1）new，创建了类的实例。\n2）访问了某个类或者接口的静态变量，或者对静态变量赋值。\n3）调用了类的静态方法。\n4）使用反射机制。\n5）初始化一个类的子类时，父类也会被初始化。\n6）Java虚拟机启动时被标明为启动类的类，也就是一个java源文件中与源文件相同名字的类。\n9、类加载本质：类的加载是将类的class文件中的二进制数据读入到内存中，放置到运行时的数据区的方法区内，然后在堆区创建一个java.lang.Class对象用来封装这个类在方法区内的数据接口，并提供了访问方法去内数据结构的接口（反射机制就是通过这些接口进行反射），类Class对象反映描述了类的内容。因此，每一个类无论有多少个对象都只有一个对应的Class对象，并且每个类的Class对象只能由JVM自己在加载class文件时创建。\n10、Java虚拟机支持加载class的方式：\n1）从本地系统中直接将class加载\n2）通过网络下载class文件\n3）从zip或者jar等归档文件中加载\n4）从专有数据库中提取class文件\n5）从java源文件动态编译为class文件。\n11、类加载器：\n1）Java虚拟机自带加载器：\na）根类加载器（Bootstrap）：使用C++编写，程序员无法获得该类对象。\nb）扩展类加载器（Extension）：Java编写。\nc）系统类加载器（System）：也叫应用加载器，Java编写。\n2）用户自定义类加载器：继承抽象类java.lang.ClassLoader，用户可以定制类的加载方式。\n12、Class类的方法getClassLoader()方法可获得该Class对象的类加载器，当该Class对象的加载器为根类加载器时，返回值为null，因为Java不允许用户访问根类加载器。\n13、JVM允许类加载器在预料到某个类将要被使用的时候就预先加载这个类，与类初始化必须等到该类被首次主动使用不同。如果在预先加载的过程中遇到了class文件缺失或者存在错误，类加载器要报告LinkageError错误必须等到这个类被首次主动使用的时候才报告，要是这个类一直没有被程序主动使用，那么类加载器就一直不报告错误。\n14、类的连接就是将已经读入到内存的类的二进制数据合并到虚拟机运行时环境中。\n15、类连接阶段的验证内容：\n1）类文件的结构检查：确保类文件遵从Java类文件的固定格式。\n2）语义检查：确保类本身符合Java语言的语法规定，比如验证final类型的类有没有子类等。\n3）字节码验证：确保字节码流可以被Java虚拟机安全执行。字节码流代表Java方法（包括静态方法和实例方法），它是由被称作操作码的单字节指令组成的序列，每个操作码后都跟着一个或多个操作数。字节码验证步骤会检查每个操作码是否合法，即是否有着合法的操作数。\n4）二进制的兼容验证：确保互相应用的类之间协调一致。比如worker类要调用Car类的run方法，Java虚拟机就会验证方法区内是否存在Car类的run方法，如果不存在就会抛出NoSuchMethodError错误。又比如当JDK版本由1.6转为1.5时，程序也可能二进制验证不通过。\n16、类连接阶段的准备：Java虚拟机为类的静态变量分配内存，并设置默认的初始值，对象静态成员变量的默认值为null。\n17、类连接阶段的解析：Java虚拟机把类的二进制数据中的符号引用替换为直接引用。比如Worker类调用Car类方法run，在Worker类的二进制数据中就存在一个run方法的符号引用，这个引用由run方法的全名和相关描述符组成，而解析阶段就是把这个符号引用替换为Car的run方法在方法区的内存位置，这个内存位置就是直接引用。\n18、类的初始化阶段：Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。静态变量的初始化有两种途径：一是在静态变量声明时进行初始化；二是在静态代码块中进行初始化。类的初始化过程按照程序中初始化语句的先后顺序初始化。\n19、类的初始化步骤：\n1）假如这个类还没有被加载和连接，就会先进行类的加载和连接。\n2）假如类存在直接父类，并且这个父类还没有被初始化，那么就会先对父类进行初始化后再初始化子类。\n3）假如类中存在初始化语句，那么依次执行这些初始化语句。\n20、一个类的变量使用static final修饰，那么它是一个静态常量。如果静态常量的值在编译时就能够确定（如具体数值或者数学表达式），则即使是首次主动使用这个静态常量也不会导致类的初始化；相反，如果静态常量的值需要在运行时才能确定（比如常量值需要new一个对象），那么首次主动使用这个静态常量时会导致类的初始化。\n21、子类初始化的时候不会导致父接口的初始化，接口的初始化只有在首次主动使用接口的静态变量时才会导致接口的初始化。\n22、加载一个程序时，最先初始化的是启动标志类。\n23、同一个类加载器加载一个类后不会再对这个类二次加载，但不同的类加载器可以对同一个类加载。\n24、程序首次主动使用静态变量或者静态方法会进行初始化的前提是主动使用的静态变量或静态方法必须定义在当前的类或者接口中，比如首次主动使用子类的中定义在父类里的静态变量或者静态方法，子类不会被初始化，但父类会初始化。\n25、二进制名称：指的是一个类名的全称，包括包名和类名，内部类和匿名内部类的二进制名称中带有$字符，也就是说有效类的二进制名称实际上就是该类编译后生成的class文件的文件名（除去.class），这种命名方法是Java Language Sepcification规范定义的。\n","date":"June 17, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E5%85%AD%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"jvm","url":"https://www.qinxiandiqi.sbs/tags/jvm/"},{"title":"虚拟机","url":"https://www.qinxiandiqi.sbs/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"title":"class","url":"https://www.qinxiandiqi.sbs/tags/class/"},{"title":"类加载","url":"https://www.qinxiandiqi.sbs/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"}],"title":"Java SE 学习笔记 第十六记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/categories/android-wear/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n原文作者：Google\n原文地址：\u0026lt;http://developer.android.com/wear/design/user- interface.html#Stream\u0026gt;[](https://developers.google.com/maps/documentation/android- api/intro)\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-15版本翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n前言# 一种新的表现形式是值得使用一种新的UI模型的。总的来说，Android Wear UI围绕着Suggest（建议）和Demand（需求）两个核心部分包含了两种主要的界面中心。你的应用在这两种界面中扮演着重要角色。\nSuggest：The Context Stream# Context Stream是一个垂直的卡片列表，每一张卡片显示一个有用或者及时的信息。非常类似于Android手机或者平板上的Google Now，用户通过垂直滑动来切换每一张卡片，以更新显示对用户来说很重要但简短又全面信息。在同一个时间里只有一张卡片能够显示，并且背景图片会显示附加的视觉化信息。你的应用程序可以创建卡片，只要它们是有用的就能够插入到信息流中。\n信息流中的卡片可以不单只是简单的信息。它们可以通过横向滑动来打开附加的页面。进一步横向滑动可能可以打开一个可点击的按钮，这个按钮允许用户对该通知进行操作。卡片也可以通过从左滑到右边来取消，从信息流中移除直到它们再一次拥有有用的信息显示为止。在模拟器中，把鼠标悬停在屏幕的顶部会点亮设备顶部的一个蓝色条，点击后可以返回到Home界面。\nDemand：The Cue Card# 当Context Stream无法判断用户想要做什么的时候，cue card（提示卡）允许用户与设备对话。Cue card可以通过语音“Ok google”或者点击Home界面上的“g”图标来打开。向上滑动提示卡片可以获得一个操作列表，列表的操作项可以点击执行。\n操作列表中包括了针对语音操作的Android intent（意图）。即将推出的Android Wear SDK将允许开发者将他们的应用程序与这些intent匹配，用户就可以通过语音指令来执行这些操作。可能会有多个应用程序注册了同一个语音intent，那么用户将有机会来决定选择使用哪一个应用程序。\n","date":"June 15, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidwearpreview-ui/","series":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/series/android-wear/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/tags/android-wear/"},{"title":"ui","url":"https://www.qinxiandiqi.sbs/tags/ui/"},{"title":"google now","url":"https://www.qinxiandiqi.sbs/tags/google-now/"}],"title":"Android Wear Preview - UI"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/categories/android-wear/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n原文作者：Google\n原文地址：http://developer.android.com/wear/preview/start.html[](https://developers.google.com/maps/documentation/android- api/intro)\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-15版本翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n前言# Android Wear开发者预览版包含了tools和APIs，你可以通过它们在可穿戴Android设备上提供优秀的用户体验来增强你的应用程序的信息通知功能。\n使用Android Wear开发者预览版，你可以：\n在Android模拟器上运行Android Wear平台。 把你的Android设备和模拟器连接，并将Android设备上的信息作为Android Wear上的一张卡片来查看。 试用预览版支持库中的新API来增强你的应用程序通知功能，例如语音回复和信息通知页。 获取开发者预览版工具，你需要点击一下注册按钮，然后按照注册流程提示操作。\nSign Up for the Developer Preview\n注册之后，你将可以使用：\n预览版支持库中的新通知API 使用新通知APIs的示例应用 安装到你移动设备上的Android Wear Preview app（Android Wear预览版应用），这个应用用于连接你的设备和Android Wear模拟器。 注意：当前的Android Wear开发者预览版只是用于开发和测试目的，不能用于发布产品。Google可能会大量修改该开发者预览版作为正式发行的Android Wear SDK。你不用使用这个开发者预览版来公开发行你的应用。同样，当正式版SDK发行之后开发者预览版将不再被支持，这可能会导致使用开发者预览版的应用程序无法使用。\nPrerequisites（基本要求）# 在你开始使用之前，你必须：\n1、安装Android SDK：\nAndroid SDK包含了所有构建一个Android项目需要的所有开发工具（同样提供了可使用的IDE工具）\n2、注册Android Wear开发者预览版\n你必须使用一个Gmail或者其它Google账号登记注册才能够下载预览版支持库和在Google Play Store上接收到Android Wear Preview app。\n注意：如果你使用ADT插件的Eclipse，你必须将ADT插件升级到22.6.1或者更高的版本。如果你使用的是Android Studio，你必须更新到0.5.1或者更高版本。\n1、Install the Android Wear System Image（安装Android Wear系统映像）# 1、启动Android SDK Manager。\n如果是Eclipse，选择Window \u0026gt; Android SDK Manager 如果是Android Studio，选择Tools \u0026gt; Android \u0026gt; SDK Manager 2、Tools下面，确认你使用ADT是22.6或者更高版本。\n如果您的ADT版本低于22.6，你必须进行更新：\n选择Android SDK Tools 点击Install package 同意license并点击Install 安装完成之后，重启Android SDK Manager 3、Android 4.4.2下面，选择Android Wear ARM EABI v7a System Image\n注意：Android Wear的设计支持多核心系统架构。\n4、Extra下面，确认你拥有最新版本的Android Support Library。如果有一个更新是用的，请选择Android Support Library。如果你使用的的是Android Studio，请同时选择Android Support Repository。\n5、点击Install package。\n6、同意License并点击Install。\n2、Set Up the Android Wear Emulator（配置Android Wear模拟器）# 1、启动Android Virtual Device Manager（Android AVD Manager）\n如果是Eclipse，选择Window \u0026gt; Android Virtual Device Manager 如果是Android Studio，选择Tools \u0026gt; Android \u0026gt; AVD Manager 2、点击New按钮\n3、在AVD Name一栏中，根据你要创建一个方形显示界面还是圆形显示界面，输入“AndroidWearSquare”或者“AndroidWearRound”。\n4、Device一栏中，选择Android Wear Square或者Android Wear Round\n5、Target一栏中，选择Android 4.4.2 - API Level 19（或者更高版本）\n6、CPU/ABI一栏中，选择Android Wear ARM（armeabi-v7a）\n注意：Android Wear的设计支持多核心处理器架构。\n7、Skin一栏中，选择AndroidWearSquare或者AndroidWearRound。\n8、其他的选项使用默认设置，然后点击OK按钮。\n尽管真正的Android可穿戴设备没有提供键盘作为输入方法，你也应该保持勾选Hardware keyboard present选项，以便你能够替代语音输入方法使用键盘输入文字到屏幕中。\n9、在AVD列表中，选择你刚刚创建的条目，点击Start按钮。接下来弹出的窗口中，点击Launch按钮。\n现在Android Wear模拟器已经启动，在开始测试你的应用通知之前，你必须在你的开发设备上安装Android Wear Preview app（Android Wear预览版应用）并配对模拟器。\n提示：为了提升模拟器的启动时间，你可以编辑你的AVD，在模拟器选项中打开Snapshot共鞥。当你启动模拟器的时候用，勾选Save to snapshot再点击Launch按钮。一旦模拟器在运行的时候被关闭，这将会保存一个系统快照。再一次启动AVD，但是选择Launch from snapshot并取消Save to snapshot。\n注意：不要在Android Wear模拟器上安装应用。Android Wear系统不支持传统的Android应用，如果运行可能导致不可预知的错误。\n3、Set Up the Android Wear Preview App（配置Android Wear预览版应用）# 在Android Wear模拟器中查看你的应用通知信息，你必须在你的Android设备上（手机或者平板）安装Android Wear Preview应用。\n获取Android Wear Preview app，你必须使用与Google Play Store相同的Gmail或者其它google账号注册开发者预览版。\n注意：Android Wear Preview app使用Android4.3或者更高版本编译的，并且不能安装在Android模拟器上。\n当你注册了开发者预览版之后，你将会收到一封确认邮件，里面包含了一个关于Android Wear Preview app测试用程序的确认链接。一旦你确认，你有24小时的时间从Google Play Store上安装这个应用。\n当你安装了Android Wear Preview app之后，你可以配置你的设备与Android Wear模拟器互相通信。\n1、打开Android Wear Preview app。你可以看到一个通知信息表明这个应用当前没有打开通知监听功能。点击这个信息打开系统设置，选择Android Wear Preview，授予它访问通知的权限。\n2、使用USB将你的设备连接上的你开发机器（计算机）。确认没有其它设备连接这台机器（计算机）。\n3、确认Android Wear模拟器（前面章节创建的模拟器）已经运行。模拟器应该会显示时间和一个图标来显示当前没有设备连接。\n4、打开一个命令行终端，将当前路径导航到Android SDK的platform-tools/目录下，然后运行\nadb -d forward tcp:5601 tcp:5601\n注意：每次使用USB连接你的设备都需要运行这行命令。\n5、返回到Android Wear Preview app。它应该会显示已经连接到模拟器上。Android Wear模拟器应该会显示一个‘g’图标，说明模拟器已经连接上你的设备。\n现在，你设备上的通知也会显示在Android Wear模拟器上。\n4、Add the Support Library to Your Project（添加支持库到你的项目中）# Android Wear perview support library（Android Wear预览版支持库）包含了一些一些API可以帮助你优化你的应用的通知功能来获得更好的Android Wear用户体验。\n获取预览版支持库，你必须注册开发者预览版。你注册后收到的确认邮件中包含了一个下载ZIP文件的链接，这个ZIP包含了预览版支持库和一些实例应用。\n当你下载并解压了包之后，将preview support library（预览版支持库）添加到你的Android项目中。\n如果你使用的是Eclipse：\n在你的Android应用项目中，在项目根部目录下（即与AndroidManifest.xml文件相同的路径下）创建一个libs/目录。 将你的Android SDK目录中的v4支持库（例如extras/android/support/v4/android-support-v4.jar）复制到你项目中的libs/目录中。 同样添加wearable-preview-support.jar文件到libs/目录中。 右键点击每一个JAR文件并且选择Build Path \u0026gt; Add to Build Path. 如果你使用的是Android Studio：\n1、在你的Android应用项目中，在项目根部目录下（即与AndroidManifest.xml文件相同的路径下）创建一个libs/目录。\n2、添加wearable-preview-support.jar文件到libs/目录下。\n3、打开你的应用module下面的build.gradle文件。\n4、添加包括v4支持库和Android Wear预览版支持库的依赖规则：\ndependencies { compile \u0026quot;com.android.support:support-v4:18.0.+\u0026quot; compile files('../libs/wearable-preview-support.jar') } 5、点击工具栏中的Sync Project with Gradle Files按钮。\n为Android Wear优化你的应用通知功能，请参考Creating Notifications for Android Wear。\n","date":"June 15, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/androidwearpreview-getstartedwithdeveloperpreview/","series":[{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/series/android-wear/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"Android Wear","url":"https://www.qinxiandiqi.sbs/tags/android-wear/"},{"title":"可穿戴设备","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%AF%E7%A9%BF%E6%88%B4%E8%AE%BE%E5%A4%87/"},{"title":"google","url":"https://www.qinxiandiqi.sbs/tags/google/"}],"title":"Android Wear Preview - Get Started With Developer Preview"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n原文作者：Google\n原文地址：https://developers.google.com/maps/documentation/android-api/intro\n原文版权：Creative Commons 3.0 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-12版本翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n前言# 通过使用Google Maps Android API，你可以添加依赖于Google Maps数据源的地图到你自己的应用上。Google Maps API会自动执行连接Google Maps服务器，下载地图数据，显示地图，并且响应地图手势等过程。你也可以通过API去添加地图标识，多边形以及添加地图上的覆盖层来修改地图界面以展现特殊的地图需求。这些对象提供了指定地点附加信息，并且允许用于与地图进行互动。Google Maps API允许你添加以下图标到地图上：\n地图上指定地点的标识图标（Markers）\n一系列的线段（Polylines）\n闭合的线段（Polylines）\n地面上指定地点的图片（Ground Overlays）\n基础地图标题上显示的图片（Title Overlays）\n1\\. Audience（适用人群）# 本文档适用于熟悉面向对象开发概念以及Android开发的开发人员。同样的你也需要从用户的角度熟悉Google Map的使用方法。\n本文档的目的是帮助你快速学习Google Maps Android API并且使用它来开发应用程序。你也可能希望去参考具体类和方法的帮助文档。\n1.1 Google Maps Mobile SDK for Business# Google Maps Mobile SDK for Business为Google Maps SDK for IOS和Google Maps Android API 提供了更加强大的功能。如果你使用了商业版的Google Maps Mobile SDK，请额外参考Google Maps API for Business documentation以获取更多的信息。\n2\\. Attribution Requirements（权责声明）# 如果你在你的应用程序中使用Google Maps Android API，你必须将Google Paly Services的权责声明作为你应用程序中法律生命的一部分。推荐把法律声明作为一个独立的菜单，或者是添加到“About”菜单中。\n获取权责声明内容的方法可以通过调用GooglePlayServicesUtil.getOpenSourceSoftwareLicenseInfo方法获得。\n3\\. Accessibility（无障碍使用）# Google Maps Android API v2为无障碍使用提供了内建的支持。本章节对包含了使用这些API的应用程序会自动启用的无障碍功能的高度概括。\n当用户打开了他们移动设备上的对讲无障碍功能，在屏幕上的每一次单点滑动都会将焦点从一个UI元素移动到下一个元素上（另一个替代单点滑动的方法是通过手指拖拽UI元素）。当一个UI元素获得焦点，对讲辅助功能将会读出UI元素的名字。如果用户双击屏幕的任何地方，焦点动作时间将会执行。\n更多在你的应用程序上增强无障碍辅助功能的方法，请参考Android accessibility documentation。特别的，给地图添加一个声明描述是一个很好的实践。指定声明的文本，可能调用view的setContentDescription()方法。\n4\\. Sample Code（示例代码）# 这个Demo app依赖于Google Play services SDK，你可以跟使用示例代码一样使用和查看。\n以下说明假设你的使用的是Eclipse的ADT插件：\n首先你需要按照以下步骤添加Google Play services作为一个android库：\n选择File \u0026gt; Import \u0026gt; Android \u0026gt; Existing Android Code Into Workspace，然后选择Next. 选择Browse,选择 /extras/google/google_play_services/libproject/google-play-services_lib,然后点击Open. 选择Copy project into workspace，然后点击Finish。 标记Google Play services作为库: 右键google-play-services_lib项目菜单,选择Properties \u0026gt; Android.然后勾选Is Library选项。 导入示例项目：\n选择File \u0026gt; New \u0026gt; Other \u0026gt; Android Sample Project，然后点击Next。 选择最新版本的Android SDK然后点击Next。 滑动到示例项目列表的底部，选择Maps[Google Play Services]，点击Finish。 配置依赖关系并运行demo项目：\n将Google Play services library链接为demo app的依赖库：右键打开Map项目的菜单，然后选择Properties \u0026gt; Android.检查library列表中是否已经将google-play-services_lib项目作为外部依赖库。如果没有，请根据Referencing a Library Project的步骤添加依赖库。 添加你自己的Google Maps Android API Key。Demo app 的包名为com.example.mapdemo。Demo App已经包含了一个API Key在它的manifest文件中，你需要将其替换为你自己的API Key。 如果你还没有完成以上步骤，请将你的手机设备设置为开发者模式，然后再连接你的电脑。 选择Mapsxiangmu，然后选择Run \u0026gt; Run 去运行demo app。 成功运行后你将会看到一个可在你的手机设备上运行的demo列表：\n","date":"June 12, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/googlemapsandroidapiv2%E8%AF%B4%E6%98%8E/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"google maps","url":"https://www.qinxiandiqi.sbs/tags/google-maps/"},{"title":"Google Play services","url":"https://www.qinxiandiqi.sbs/tags/google-play-services/"},{"title":"map","url":"https://www.qinxiandiqi.sbs/tags/map/"}],"title":"Google Maps Android API V2说明"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"IDE","url":"https://www.qinxiandiqi.sbs/categories/ide/"}],"content":"一直以来都是用Eclipse IDE for Java and DSL Developers版本，这个版本没有集成J2EE的一些内容。官方提供另一个针对J2EE的版本，Eclipse IDE for J2EE Developers。想要使用服务器等Web的一些内容就需要使用J2EE的版本，或者自己安装J2EE的一些插件，比如很出名但要收费的MyEclipse插件。MyEclipse插件很强大，功能很齐全，但是也会导致启动速度慢（也可能是我电脑硬件比较低的问题），所以不太想用MyEclipse。找了其它开源J2EE插件，很多都是直接绑定在Eclipse IDE中以完整版提供下载。我想继续用我一直在使用的Eclipse IDE for Java and DSL Developers版本，但又想用Eclipse IDE for J2EE Developers版本的功能，于是想能不能直接将这两个版本合并！基于内核和插件模式的Eclipse理论上应该是行得通的，网上查了很多资料（这方面资料很少），最后看到这网页比较全，而且方法试验后证明是对的，现在我的Eclipse集成了两个Eclipse安装包，妥妥的！\n原文链接：\u0026lt;http://stackoverflow.com/questions/6251063/how-to-combine-all-the- packages-of-the-eclipse\u0026gt;\n原文内容：\nHow to merge several setup packages of Eclipse?\n如何合并多个Eclipse安装包？\nWhom this is for?\nThe ones that can not hold back their temper any longer when trying to install another Eclipse function package. Right the installation speed from some countries is too slow to bear, also the Equinox P2 always try to connect the Download.Eclipse.org. Much to damn.. when your Internet connection closed or reset all of a sudden and got all downloaded files broken. Also OSGi based Eclipse plugins is chaos \u0026ndash; always have some conflict errors.\nOh that is another problem..\n此文谨献给那些想要在现有的Eclipse中安装其他Eclipse包，但是却被某些国家的Eclipse更新体验逼疯的人。\nDo the following steps:\n方法就是以下几步：\n1 Download the Install Packages that you need from www.eclipse.org. Also please remember verify to see if that is correct package. I choosed J2EE with C/C++.\n首先下载从Eclipse的下载官网想要安装的安装包，记得检查下包是否完整。我这里选择了J2EE和C/C++。\n2 Unpack one package with uncompress softwares, such as 7-zip and WinRAR. unzip all the files to a directory you wanna install to. for example \u0026ldquo;D:\\Eclipse\u0026quot;.\n将其中一个包用压缩软件，比如7-zip和WinRAR，解压到要安装位置。\n3 open Configurations. Files \u0026ldquo;\\configuration\\org.eclipse.equinox.source\\source.info\u0026rdquo; and \u0026ldquo;\\configuration\\org.eclipse.equinox.simpleconfigurator\\bundles.info\u0026rdquo; in the installation directory is the ones that need to be merged. also you need \u0026ldquo;\\configuration\\org.eclipse.update\\platform.xml\u0026rdquo;.\n打开所有安装包的文件，从所有的安装包寻找\u0026rdquo;\\configuration\\org.eclipse.equinox.source\\source.info\u0026quot;、\u0026quot;\\configuration\\org.eclipse.equinox.simpleconfigurator\\bundles.info\u0026quot;、\u0026quot;\\configuration\\org.eclipse.update\\platform.xml\u0026quot;三个文件。\n4 open the other packages and fetch their configuration files, and merge files.\n将这些文件复制到某个地方开始合并。\nto Bundles.info:\nOpen the bundle.info with any Functional Text Editor, copy all text begin from the line after \u0026ldquo;#version={Number}\u0026rdquo; and paste it to another. [{Number} means any Integer number.]\nBundles.info文件：\n使用稍微高级点的编辑器[别用Word之类的]，将里面所有从\u0026quot;#version={Number}\u0026ldquo;的下一行开始的文本全部复制到某一个里面[某一个是说其中一个你拿来做最后结果的文件]。[这里{Number}是说任何数字。]\nto Source.info:\nSimiliar with what you did with the bundle.info. If not modified, that line should be the 3rd line in the text file.\nSource.info文件：\n跟上一个的方法差不了多少。如果没修改过的话，应该是从第三行开始。\nto Platform.xml:\nOpen the file, then find where \u0026ldquo;\u0026lt;feature id=\u0026rdquo; starts just after the \u0026ldquo;\u0026rdquo; node. Find the \u0026ldquo;\u0026rdquo; tag and copy all the text between them, paste to another file just before the \u0026ldquo;\u0026rdquo; tag.\n[You can do the similiar also marked tags with artifacts.xml]\nPlatform.xml文件：\n打开，寻找在\u0026lt;site..\u0026gt;标签后第一个\u0026lt;feature id = 一直到，全部复制，贴到另一个里面。\n如果你需要处理artifacts.xml，也是这么一个办法。\n5 when merging i suggest you to make a new directory and when finished please remember copy the merged file to the one where should it be and overwrite. [I mean where it comes from]\nAlthough not merge \u0026ldquo;platform.xml\u0026rdquo; will not cause any functional errors, it will make the About dialog with no button \u0026ndash; to ugly yeah?\n[= =|||]Ugly is caused by the artifacts.xml in the installation directory\u0026hellip;\n我建议你在进行合并时候先准备一个文件夹存放那大堆的文件，然后合并完成之后再将合成的结果覆盖到原来的位置[这里指的是从ZIP包里面获得哪些文件的地方。]\n虽然platform.xml不合并也不会造成功能性问题，但是About窗体可能会因此变得很丑。\n[囧]发现其实是安装目录下的artifacts.xml导致的这个问题。\n6 Open all the package, find \u0026ldquo;plugins\u0026rdquo; and \u0026ldquo;features\u0026rdquo; directories.now extract!\nfirst extract the one you want most. I extracted JEE package.\nthen extract the other ones. I don\u0026rsquo;t see any problem whether Overwrite the ones or not.\n现在打开所有的安装包，找到里面的plugins和features目录，全部解压到安装位置的对应地方。\n比方说，我就先解压J2EE的包，然后才是其他的包。\n其实，如果你下载的都是同时候出的，比方，全是3.6M2，那么覆盖不覆盖看你自己心情吧。\n7 do open a console window, and locale in the installation directory, and then execute \u0026ldquo;eclipse.exe\u0026rdquo;.\n最后打开一个命令行，在安装目录输入eclipse.exe然后执行。\nWell, somebody ask me why i paid no attention to the Artifacts.xml in the installation directory. That\u0026rsquo;s because Eclipse will never check the file. It seems to be when you want to update using zip files \u0026ndash; however this way is blocked for lacking site.xml file now.\n好吧，有人问我为什么不理会安装目录下的某个artifacts.xml……这个文件Eclipse根本就不管……实际上我就算是删了那文件，该打开的IDE还是照开不误……本来是为了之前版本的使用安装包更新，但是由于现在平台的Equinox更新，导致site.xml缺失——结果是这个方法不能用了。\nThen guys, wait a several minutes for eclipse to do some sorting and cleaning job for the merged configurations.. and install your plugins!\n好吧，我记得刚搞完这段花了不少时间。还得等待几分钟才能看到第一次Eclipse的打开，因为Eclipse不得不处理下我们之前合并过的设置文件。等他打开，你就安装插件吧！\nINFO: if you face some problems after install a new plugin and restart.. that is because you haven\u0026rsquo;t finish a complete artifacts.xml merging.\nYou may delete all the artifacts.xml \u0026rsquo;s header [document start to the ] and its bottom [from to document end]. just merge the left content. and make one file just contains the header and bottom, paste the merged one in.\nEh..maybe you can calculate the {Number}s\u0026rsquo; sum and correct the one in the final document.\n——————————————————————————\n总结方法：主要是四个参数文件：Bundles.info、Source.info、Platform.xml、artifacts.xml，把不同安装包版本的这4个文件合并最后最后合并版本的参数文件。其中Bundles.info、Source.info两个文件同一个版本号的不同安装包中都包含了一些相同的参数，直接合并在一起也不会有太大的问题，但是我有代码洁癖。。所以写了几行代码来合并（原理是以行为单位比较筛选），源代码如下：\nimport java.io.BufferedReader; import java.io.BufferedWriter; import java.io.File; import java.io.FileReader; import java.io.FileWriter; import java.io.InputStreamReader; import java.util.Vector; public class CleanFiles { private static Vector\u0026lt;String\u0026gt; stringlist; public static void main(String[] args) throws Exception { String filePath1; String filePath2; String filePath3; String item; stringlist = new Vector\u0026lt;String\u0026gt;(); BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\u0026quot;请输入文件1路径和文件名：\u0026quot;); filePath1 = buffer.readLine(); System.out.println(\u0026quot;请输入文件2路径和文件名：\u0026quot;); filePath2 = buffer.readLine(); System.out.println(\u0026quot;请输入合并后文件路径和文件名\u0026quot;); filePath3 = buffer.readLine(); File file1 = new File(filePath1); File file2 = new File(filePath2); File file3 = new File(filePath3); buffer.close(); buffer = new BufferedReader(new FileReader(file1)); while((item=buffer.readLine())!=null){ addString(stringlist,item); } buffer.close(); buffer = new BufferedReader(new FileReader(file2)); while((item= buffer.readLine())!=null){ addString(stringlist,item); } buffer.close(); // 搜索结果是经过排序的，根据此规律删除不合要求File for (int i = 0; i \u0026lt; stringlist.size()-1; i++) { if(stringlist.get(i).equals(stringlist.get(i+1))){ stringlist.remove(i); if(i!=0)i--; } } BufferedWriter bufferWriter = new BufferedWriter(new FileWriter(file3)); for(String temp:stringlist){ bufferWriter.write(temp); bufferWriter.newLine(); } bufferWriter.close(); } public static void addString(Vector\u0026lt;String\u0026gt; allStrings, String str) { if (allStrings.isEmpty()) { allStrings.add(str); } else { // 二分查找法 int left = 0, right = allStrings.size() - 1, middle, compare; if (str.compareToIgnoreCase(allStrings.get(right)) \u0026gt;= 0) { allStrings.add(str); return; } if (str.compareToIgnoreCase(allStrings.get(0)) \u0026lt;= 0) { allStrings.add(0, str); return; } while (true) { middle = (left + right) / 2; compare = str.compareToIgnoreCase(allStrings.get(middle)); if (compare == 0 || middle == left) { allStrings.add(middle + 1, str); return; } else { if (compare \u0026lt; 0) { right = middle; } else { left = middle; } } } } } } Platform.xml文件合并后，也有很多重复的节点，写了另一段代码来处理（当然不处理应该也是没问题的），原理是标记每一行节点的顺序，再进行筛选，最后再按原顺序排序，同样直接把代码贴这里（备注：我用这段代码处理的时候不知道为什么最后第二个会被删除，研究很久没想明白，最晚弄太晚就没弄，自己手工加上去）：\nimport java.io.BufferedReader; import java.io.BufferedWriter; import java.io.File; import java.io.FileReader; import java.io.FileWriter; import java.io.InputStreamReader; import java.util.Vector; public class CleanXMLFiles { private static Vector\u0026lt;XMLElement\u0026gt; xmllist; public static void main(String[] args) throws Exception { String filePath1; String filePath2; String element; String item; xmllist = new Vector\u0026lt;XMLElement\u0026gt;(); BufferedReader buffer = new BufferedReader(new InputStreamReader( System.in)); System.out.println(\u0026quot;请输入xml文件路径和文件名：\u0026quot;); filePath1 = buffer.readLine(); System.out.println(\u0026quot;请输入清理后文件路径和文件名\u0026quot;); filePath2 = buffer.readLine(); System.out.println(\u0026quot;请输入清理的节点名称：\u0026quot;); element = buffer.readLine(); File file1 = new File(filePath1); File file2 = new File(filePath2); buffer.close(); buffer = new BufferedReader(new FileReader(file1)); int fileId = 0; while ((item = buffer.readLine()) != null) { StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(item); if (item.trim().startsWith(\u0026quot;\u0026lt;\u0026quot; + element)) { do { if((item = buffer.readLine())!=null){ stringBuffer.append(item); } } while (!(item.trim().endsWith(\u0026quot;\u0026lt;/\u0026quot; + element + \u0026quot;\u0026gt;\u0026quot;))); } addString(xmllist,new XMLElement(fileId++,stringBuffer.toString())); } buffer.close(); // 搜索结果是经过排序的，根据此规律删除不合要求File for (int i = 0; i \u0026lt; xmllist.size() - 1; i++) { if (xmllist.get(i).getElementString().trim().equals(xmllist.get(i + 1).getElementString().trim())) { xmllist.remove(i); } } XMLElement big; for(int i=0;i\u0026lt;xmllist.size();i++){ for(int j=i+1;j\u0026lt;xmllist.size();j++){ if(xmllist.get(i).getId()\u0026gt;xmllist.get(j).getId()){ big = xmllist.get(i); xmllist.set(i, xmllist.get(j)); xmllist.set(j, big); } } } BufferedWriter bufferWriter = new BufferedWriter(new FileWriter(file2)); for (XMLElement temp : xmllist) { bufferWriter.write(temp.getElementString()); bufferWriter.newLine(); } bufferWriter.close(); } public static void addString(Vector\u0026lt;XMLElement\u0026gt; allStrings, XMLElement elementTemp) { if (allStrings.isEmpty()) { allStrings.add(elementTemp); } else { // 二分查找法 int left = 0, right = allStrings.size() - 1, middle, compare; if (elementTemp.getElementString().compareToIgnoreCase( allStrings.get(right).getElementString()) \u0026gt;= 0) { allStrings.add(elementTemp); return; } if (elementTemp.getElementString().compareToIgnoreCase( allStrings.get(0).getElementString()) \u0026lt;= 0) { allStrings.add(0, elementTemp); return; } while (true) { middle = (left + right) / 2; compare = elementTemp.getElementString().compareToIgnoreCase( allStrings.get(middle).getElementString()); if (compare == 0 || middle == left) { allStrings.add(middle + 1, elementTemp); return; } else { if (compare \u0026lt; 0) { right = middle; } else { left = middle; } } } } } } class XMLElement { private int id; private String elementString; public XMLElement(int id, String elementString) { super(); this.id = id; this.elementString = elementString; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getElementString() { return elementString; } public void setElementString(String elementString) { this.elementString = elementString; } } 至于artifacts.xml文件，我查的时候貌似没有多少重复的节点，就没有处理。\n以上折腾纯属个人手贱，仅供有需要人士参考。\n","date":"June 12, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/ide/%E5%90%88%E5%B9%B6%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84eclipse/","series":[{"title":"IDE","url":"https://www.qinxiandiqi.sbs/series/ide/"}],"smallImg":"","tags":[{"title":"eclipse","url":"https://www.qinxiandiqi.sbs/tags/eclipse/"},{"title":"合并","url":"https://www.qinxiandiqi.sbs/tags/%E5%90%88%E5%B9%B6/"},{"title":"merge","url":"https://www.qinxiandiqi.sbs/tags/merge/"},{"title":"plugins","url":"https://www.qinxiandiqi.sbs/tags/plugins/"}],"title":"合并不同版本的Eclipse"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":"关于升级到Win8.1之后，发现Android SDK中的工具一打开就闪退的问题。\n网上能搜到的说法大都是因为find_java.bat批处理获取不到正确的jdk路径导致的问题，解决方法是修改android.bat这个批处理文件，但是在我的机子上这种方法一直没有成功过。\n在我的电脑上导致这个问题的原因是由于权限问题，所以解决方案是右键点击“Android SDK Manager.exe\u0026quot;等SDK工具的菜单，选择”以管理员身份运行“即可以正常打开。如果嫌每次都要打开右键菜单麻烦的话，可以直接修改exe文件的属性。右键菜单\u0026gt;属性\u0026gt;兼容性\u0026gt;勾选以管理员身份运行，如下图：\n点击确定即可正常双击打开程序。\n","date":"June 12, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/win8.1%E4%B8%8Bandroidsdkmanager%E7%AD%89sdk%E5%B7%A5%E5%85%B7%E9%97%AA%E9%80%80%E9%97%AE%E9%A2%98/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"win8","url":"https://www.qinxiandiqi.sbs/tags/win8/"},{"title":"sdk","url":"https://www.qinxiandiqi.sbs/tags/sdk/"},{"title":"解决方案","url":"https://www.qinxiandiqi.sbs/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"批处理文件","url":"https://www.qinxiandiqi.sbs/tags/%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/"},{"title":"闪退","url":"https://www.qinxiandiqi.sbs/tags/%E9%97%AA%E9%80%80/"}],"title":"Win8.1下Android SDK Manager等SDK工具闪退问题"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n原文作者：Google\n原文地址：\u0026lt;http://developer.android.com/tools/projects/projects- cmdline.html#ReferencingLibraryProject\u0026gt;\n原文版权：Creative Commons 2.5 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-11版本开始翻译，基于2015-10-23版本重新翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n前言# Android Tool支持通过命令行创建三种类型的项目。一个Android项目包括了打包成.apk安装文件所需要的一切文件和资源。\n一个Android项目包括了打包成.apk安装文件所需要的一切文件和资源。你需要为你最终安装到设备上的应用创建一个Android项目。\n你可以将Android项目项目设计成一个库项目，以便能够给其它依赖于它的项目共享。一旦一个Android项目被设计成库项目，它将不能直接安装到设备上。\n测试项目扩展了JUnit测试特性，并且提供Android项目测试功能。更多关于创建一个测试项目内容，可以参考Testing from other IDEs。\n1\\. Creating an Android Project（创建一个Android项目）# 你需要使用Android tool来创建Android项目。当你创建了一个Android项目，它将生成一个项目文件夹，里面包含了默认的程序文件，子文件，配置文件和构建文件等。\n创建一个新的Android项目，你需要打开一个命令行终端，将路径导航到你的SDK目录中的tools/路径下，然后运行：\nandroid create project \\ --target \u0026lt;target_ID\u0026gt; \\ --name \u0026lt;your_project_name\u0026gt; \\ --path path/to/your/project \\ --activity \u0026lt;your_activity_name\u0026gt; \\ --package \u0026lt;your_package_namespace\u0026gt; target指的是你项目的“build target”。它指明你想要重新构建项目所要使用的Android平台（包括一些扩展的平台，比如Google APIs）。获取可使用的target和它们对应的ID，可以运行android list targets命令查看。\nname指的是你的项目名称。这是个可选的选项，如果提供，当你编译你的项目时候，这个名字将作为打包出来的.apk文件名。\npath指定你的项目文件夹路径。如果指定路径上的文件夹不存在，它将会自动创建。\nactivity指明你项目中默认的Activity类名。这个类将会被创建在\u0026lt;path_to_your_project\u0026gt;/src/\u0026lt;your_package_namespace_path\u0026gt;/下。如果你没有设置name属性，这个属性也会作为你的.apk文件名。\npackage是你项目的包命名空间，遵循Java程序设计语言的包命名规范。\n以下是示例：\nandroid create project \\ --target 1 \\ --name MyAndroidApp \\ --path ./MyAndroidAppProject \\ --activity MyAndroidAppActivity \\ --package com.example.myandroid 一旦你创建好了项目，你就可以开始进行开发。你可以将项目移动到任何你想要进行开发的方法，但是你还是需要使用Android SDK的platform- tools/目录下的adb工具来将你的应用发送到模拟器中（稍后会讨论）。因此，你可能需要在你的项目和platform-tools两个文件夹之间互相切换。\n小提示： 你可以将platform-tools/和tools/路径添加到环境变量PATH中。\n注意： 你最好不要移动SDK的路径，因为这将会导致项目local.properties文件中SDK路径属性出错。如果你需要更新SDK路径，可以使用android update project命令，详细参考下章节Updating a Project。\n2\\. Updating a Project（更新项目）# 如果你想要为你的项目升级Android SDK版本，或者是想要从以后的代码中构建新项目，你可以使用android update project命令来更新项目到新的开发环境中。你同样可以使用这个命令为已存在的项目更新build targe（对应创建时的--target选项）和项目名（对应创建时的--name选项）。android tool将会自动创建一些丢失的，或者需要更新，或者Android项目必须的文件（前面章节提到的文件）。\n更新一个已存在的android项目，需要打开一个命令行终端，导航到SDK的tools/目录下，然后运行以下命令：\nandroid update project --name \u0026lt;project_name\u0026gt; --target \u0026lt;target_ID\u0026gt; --path \u0026lt;path_to_your_project\u0026gt; target指的是你项目的“build target”。它指明你想要重新构建项目所要使用的Android平台（包括一些扩展的平台，比如Google APIs）。获取可使用的target和它们对应的ID，可以运行android list targets命令查看。\npath指的是你的项目路径。\nname指的是项目名称。这个选项是可选的，如果你不需要更新项目名称，则不需要提供这个参数。\n下面是示例：\nandroid update project --name MyApp --target 2 --path ./MyAppProject 3\\. Setting up a Library Project（配置一个库项目）# 一个库项目也是一个标准的Android项目，所以你可以使用创建一个新Android项目的方法来创建一个库项目。特别的，你可以使用android tool来生成一个新的库项目以及所需要的文件和文件夹。\n创建一个库项目，你需要导航到/tools/路径下，然后使用以下命令：\nandroid create lib-project --name \u0026lt;your_project_name\u0026gt; \\ --target \u0026lt;target_ID\u0026gt; \\ --path path/to/your/project \\ --package \u0026lt;your_library_package_namespace\u0026gt; create lib- project命令将会创建一个标准的项目结构，其中包含了预设的属性值来向编译系统说明这个项目是个库项目。它通过在project.properties文件中添加以下属性行：\nandroid.library = true\n一旦命令执行完，库项目将会被创建。之后，你可以根据以下章节所说的添加源代码和资源进去。\n如果你想要将一个已经存在的Android应用项目转换成库项目，好让其它应用能够使用。那么你同样可以在Android应用项目的project.properties文件中设置android.library=true属性来完成转换。\n3.1 Creating the manifest file（创建manifest文件）# 跟标准的Android项目一样，库项目的manifest文件必须声明所有它包含的共享出去的组件。更多信息可以参考[AndroidManifest.xml](http://developer.android.com/guide/topics/manifest/manifest- intro.html)说明文档。\n例如，TicTacToeLib示例库项目声明了GameActivity：\n\u0026lt;manifest\u0026gt; ... \u0026lt;application\u0026gt; ... \u0026lt;activity android:name=\u0026quot;GameActivity\u0026quot; /\u0026gt; ... \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 3.2 Updating a library project（更新库项目）# 如果你想要更新库项目的构建参数（build target，location），可以使用以下命令：\nandroid update lib-project \\ --target \u0026lt;target_ID\u0026gt; \\ --path path/to/your/project 4\\. Referencing a Library Project（引用一个库项目）# 如果你开发的项目需要从一个库项目中引入共享的代码和资源，你可以很简单的在项目的构建参数中添加一个库项目的引用。\n添加一个库项目的引用，你需要在命令行中导航到/tools/路径下，然后使用下面命令：\nandroid update project \\ --target \u0026lt;target_ID\u0026gt; \\ --path path/to/your/project --library path/to/library_projectA 这个命令更新了应用项目的构建参数，添加了一个库项目的引用。特别的，它会添加一个android.library.reference.n属性到项目的project.properties文件中。例如：\nandroid.library.reference.1=path/to/library_projectA 如果你添加了多个库项目引用，你可以通过编辑project.properties文件，为每个引用的.n设置合适的值来设置它们的相对优先级（组合顺序），假设当前有一下引用：\nandroid.library.reference.1=path/to/library_projectA android.library.reference.2=path/to/library_projectB android.library.reference.3=path/to/library_projectC 你可以重新排序这些引用的优先级，给library_projectC最高优先级：\nandroid.library.reference.2=path/to/library_projectA android.library.reference.3=path/to/library_projectB android.library.reference.1=path/to/library_projectC 注意应用的.n序号必须从“1”开始，并且排序中间不能有“漏号”（即不能有类似1,2,4这样的排序情况）。排在“漏号”后面的引用会被忽略掉。\n在编译期间，所有依赖库将会一次性按照从最低优先级到最高优先级的顺序组合进应用项目中。注意一个库项目本身不能依赖于其他库项目，因为，在编译期间库项目库项目组合进应用项目之前，它们之间不会不互相组合。\n4.1 Declaring library components in the manifest file（在manifest文件中声明库项目的组件）# 在应用想用的manifest文件中，你必须将所有从依赖库从导入进来使用到的组件进行声明。例如，你必须声明使用到的\n,,,等等组件，也包括,已经类似的标签。\n声明使用到的依赖库组件必须使用它们的完整包名声明。\n例如，TicTacToeMain示例应用项目声明库项目中的GameActivity：\n\u0026lt;manifest\u0026gt; ... \u0026lt;application\u0026gt; ... \u0026lt;activity android:name=\u0026quot;com.example.android.tictactoe.library.GameActivity\u0026quot; /\u0026gt; ... \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 更多关于manifest文件的信息，可以参考[AndroidManifest.xml](http://developer.android.com/guide/topics/manifest/manifest- intro.html)说明文档。\n4.2 Building a dependent application（编译一个依赖的应用）# 编译一个依赖一个或多个库项目的应用项目，你可以使用Building and Running文档中描述的标准Ant构建命令和编译模式来构建。工具将会编译并且组合所有依赖库作为编译项目的一部分。不需要额外的命令或者步骤。\n","date":"June 11, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%AE%A1%E7%90%86android%E9%A1%B9%E7%9B%AEmanagingprojectsfromthecommandline/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"command","url":"https://www.qinxiandiqi.sbs/tags/command/"},{"title":"library","url":"https://www.qinxiandiqi.sbs/tags/library/"}],"title":"使用命令行工具管理Android项目（Managing Projects From the Command Line）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":" NameNodeMap接口：org.w3c.dom.NameNodeMap，其中保存了一个字符串名字与一个Node对象的映射，一般是Attr属性Node。虽然可以通过正常的索引访问NameNodeMap中的Node，但NameNodeMap中的Node实际是没有顺序的。NameNodeMap中主要方法：\nitem（int index）：返回索引值为index的Node。 getNamedItem（String name）：返回对应字符串为name的Node对象。 Comment接口：org.w3c.dom.Comment，继承Node，代表一个注释。主要方法有：getData（）：返回该Comment注释内容的字符串。\nSAX（Simple APIs for XML）：即XML简单应用程序接口，另一种解析XML文档的一种接口规范。\nSAX的工作模式：SAX提供的访问模式是一种顺序访问模式，并且是基于观察者模式的事件驱动机制来解析访问XML文档。SAX在解析一个XML文档的时候，它并不把整个XML文档都读进内存，而是按照XML文档的“行”为单位来解析。一行XML语句解析完后就继续解析下一行，被解析后的XML语句并不将其数据保存在内存中，所以SAX的解析无法再返回读取解析过的内容，除非重新解析整个XML文档，因此SAX的解析不是随机而是顺序性的。SAX在逐行解析的时候，会分析XML语句的语法，判定当前字节是XML与语法中的哪一部分，是否符合XML的语法要求，然后就会根据解析到的信息触发相应的事件给监听 器或适配器捕捉，XML数据的处理交给监听 器或适配器处理。类似于GUI的事件机制，SAX解析时触发的事件给监听 器或适配器捕捉后，处理方法的具体代码是由应用程序提供的，监听 器或适配器只是提供了相应事件处理方法的接口。之所以说SAX是简单应用程序接口也正是因为它只做了分析XML的一些简单工作，具体怎么处理交由应用程序自己控制。\nDOM与SAX的区别：DOM对XML文档的解析是可以实现数据的随即存取的，因为DOM把整个XML文档一次性读取到内容中构建了一个DOM对象树，基于DOM这个实现模式，DOM比较损耗内存，当XML过于庞大的时候可能会导致内存溢出。SAX对XML的解析是顺序访问的，基于事件处理机制，并不把整个XML文档都读取进内存，基于SAX的实现模式，SAX分析器实现比较简单，对内存的要求比较低，是实现的效率比较高，对于只读取XML文档中的数据而不对其进行更改的应用程序来说，SAX显然更加适合。\nJava对SAX的实现过程：\n同样需要先构造SAX解析器工厂对象，与DOM相似，也是基于简单工厂模式来构造SAX解析器工厂对象。Java提供了抽象类javax.xml.parsers.SAXParserFactory的静态方法newInstance()来返回一个根据当前系统环境变量参数构造的SAXParserFactory解析器工厂对象，也就是说SAXParserFactory类同样承担了既是工厂类又是产品类的角色。 通过SAXParserFactory的静态方法newSAXParser()返回一个具体的SAX解析器对象javax.xml.parsers.SAXParser。 通过SAXParser对象的parse()方法解析一个XML文档，SAXParser类提供了多个重载parse方法（详见JDK帮助文档），常用parse(File file ,DefaultHandler dh)方法解析XML文档file。 parse方法中的org.xml.sax.helpers.DefaultHandler类实现了ContentHandler、DTDHandler、EntityResolver、ErrorHandler等监听 器接口，是捕捉SAX解析器触发事件的适配器。类似于GUI的各种Adapter适配器的使用方法，其中提供了多个相应事件的处理方法供用户重写，如：遇到文档开始时促发startDocument()方法，遇到元素开始标签的时候触发startElement()方法，遇到元素之间字符内容时候触发characters()方法，遇到元素结束标签时候触发endElement()方法，遇到文档结束的时候触发endDocument()方法，详细见JDK帮助文档。 Stack栈类的peek方法是取出栈顶的值，但是不从栈中弹出该值。\n见张龙老师毕生心血之Schema学习总结pdf文档！！\nJAXP是用于对XML语法分析的Java APIs，包含了三个包：\norg.w3c.dom，W3C推荐的用于XML标准规范的文档对象模型的Java工具。 org.xml.sax，用于对XML进行语法分析的事件驱动的简单API。 javax.xml.parsers，工厂化的工具，允许应用程序开发人员获得并配置特殊的语法分析器工具。 JAXP对Java的缺点：\n可以说JAXP是完全按照DOM和SAX的规范在Java语言上的实现，DOM和SAX规定什么接口以及接口有什么功能，JAXP就完全按照这些固定在Java语言下进行实现。然而，DOM和SAX规范根据接口定义语言来写的，它们的任务是在不同语言实现中定义一个最低的通用标准，也就是不是专为Java设计的。这种设计方法虽然能够保留了在不同语言中非常相似的API，但是在Java中会让程序员感觉到麻烦，因为DOM和SAX的规则并不完全对应Java语言的规则，比如Java对于字符串有String类，但是DOM规范定义自己的Text类。 在实际应用中，SAX没有文档修改、随机访问以及输出的功能；DOM的树形层次结构非常严格，对应XML在DOM中每个元素都是一个节点，几乎都扩展与Node接口和返回Node的一系列方法，但是在Java语言中应用部方便，比如Node向叶类型做向下类型转换需要的代码冗长并难以理解。 W3C DOM是接口驱动的，公共的DOM API仅由接口组成，使用时w3c标准大量使用工厂化的类和类似的灵活性但不直接的模式，例如解析器需要工厂模式创建。 JDOM：专为Java语言开发的一个使用XML的工具，是一个开源项目，为解决Java直接使用DOM和SAX接口的JAXP带来的不方便而研发。在具体使用上是一个第三方开发的类包。\nJDOM基于树形结构，用纯Java的技术对XML文档实现解析、生成、序列化以及其它多种操作，是直接为Java编程服务的。相比较JAXP，它利用Java语言强有力的诸多特性（方法重载、集合概念等），把SAX和DON的功能有效的结合起来，提供了用Java语言读写和操作XML的新API。这些API函数在直接、简单和高效的前提下，尽可能的隐藏了原来DOM和SAX使用XML过程中的复杂性，进行了最大限度的优化。\nJDOM的优点：\nJDOM是Java平台专用的，给Java程序员提供丰富并且和Java语言类似的环境。比如，JDOM基本都使用String类处理XML中的文本值，使用JDOM还可以利用Java的一些累计，如List等。 JDOM没有层次性，对应XML中的各个部分，元素就是Element类对象，属性就是Attribute类对象，XML文档本身就是Document类对象。也就是说，在JDOM中，每一种XML部分都有具体类对应，而不是作为一个含糊的Node。 JDOM是类驱动的，JDOM的对象就是像Document、Element和Attribute这些类的对象，所以创建一个新的JDOM对象就跟Java语言中用new构造一个对象那么容易，使用起来比使用工厂化接口配置更来得直接。 JDOM类包的组成：\norg.jdom，包含了所有xml文档要素的java类，如Document等。 org.jdom.adapters，包含了与dom适配的java类。 org.jdom.filter，包含了xml文档的过滤器类。 org.jdom.input，包含了读取xml文档的类。 org.jdom.output，包含了写入xml文档的类。 org.jdom.transfrom，包含将jdomxml文档接口转换为其它xml文档接口。 org.jdom.xpath，包含了对xml文档xpath操作的类。 方法链编程风格：基于调用一个对象的方法后，方法的返回值是调用的对象。这么做的好处就是可以在方法后面直接继续调用该对象的其它方法，JDOM中类的方法大都支持这种风格。如：element.addContent(elementother).setAttribute(\u0026ldquo;name\u0026rdquo;,\u0026ldquo;value\u0026rdquo;)。\nJDOM常用org.jdom.output.XMLOutputter类的output方法来将程序新建或更改的内容写入到指定的XML文档中。\nJDOM的org.jdom.output.Format类用于设置输出XML文档的格式，XMLOutputter类的构造方法可以接收一个Format对象。\nJDOM的org.jdom.input包下的SAXBuilder类、DOMBuilder类、ResultSetBuilder类常用与解析XML文档。\nJDOM解析一个XML文档后，并在程序中进行了修改，这些修改只是保存在内存中相应的对象里，并没有直接修改到解析的XML文档中。如果要将修改保存到XML文档中，需要使用XMLOutputter对象将Document对象写会才会保存到文档中。\nJDOM的Format类的getRowFormat方法可以去除XML文档中不必要的空白，这也是XMLOutputter类默认的格式，这种格式可以减少XML在网络上传输的数据量，从而提高传输效率。\ndom4j：由第三方开发的另一种专为Java语言处理XML文档的类包，同样提供了大量符合Java语法习惯的API供开发者使用，而且大部分API的使用方式与JDOM类似（开发dom4j的成员很多是开发JDOM的成员）。与JDOM不同的是，Document、Element、Attribute等不是类，而是接口。创建Document、Element、Attribute等接口对象是由org.dom4j.DocumentHelper类对象的静态成员方法闯将，DocumentHelper类提供了大量创建这些接口对象的static方法，可以说，DocumentHelper类就是一个辅助类。\ndom4j将Document输出到XML文档是通过org.dom4j.io.XMLWriter类来实现，其中有多种构造方法，可以接收XML文档的输出流，如果输出流是一个Writer流的话，在使用write(Document document)之后，需要调用XMLWriter的flush方法或者close方法将缓冲输出才会将document的XML数据输出到文档上。\ndom4j解析一个XML文档通过org.dom4j.io.SAXReader类的read方法解析，read方法返回一个Document接口对象，通过Document可以访问XML文档中的各种部件。\norg.dom4j.io.DOMReader类同样用于解析XML文档，该类的read方法可以接收一个org.w3c.dom.Document对象，并返回一个org.dom4j.Document对象，也就是将一个JAXP的Document对象转换成dom4j的Document对象，由于在同个源文件中使用两个同名类，所以类名需要使用全名。\n开发dom4j应用程序详见dom4j帮助文档。\n","date":"June 11, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E4%BA%94%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"xml","url":"https://www.qinxiandiqi.sbs/tags/xml/"}],"title":"JavaSE学习笔记第十五记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":" 简单工厂模式：是一种创建类对象的模式，由一个工厂类根据传入的参数动态决定创建哪一个产品类的实例。\n简单工厂模式的角色：\n工厂类角色：与用户直接打交道的角色，通常是一个具体类。该角色中包含一个静态工厂方法，用户通过该静态工厂方法传入一定的参数，静态工厂方法根据传入的参数创建对应的具体产品对象返回。 抽象产品角色：简单工厂模式要创建所有对象的父类，通常是一个接口或者抽象类。在工厂类的静态工厂方法中的返回类型就是抽象产品类。 具体产品角色：实际要创建的类对象，都继承或者实现抽象产品类，是一个具体类，一个简单工厂模式中一般具有多个具体产品类。 XML文档解析的两种接口规范：DOM和SAX。接口需要实现，不同编程语言对这两种接口规范的实现代码不同，但是实现的结果是一样的，实现完成的功能必须符合接口的规范。因此，可以说这两种接口规范是与语言无关，也与平台无关的。这也导致XML可作为不同语言、不同应用程序、不同平台之间交换数据的载体。\nDOM是W3C指定的一套XML分析器的标准接口规范，全称为Document Object Model，即文档对象模型。基于DOM的XML分析器将一个XML文档转换为一个树形对象模型的集合，模型中的每一个节点都是一个对象。在应用程序中，就是通过DOM的XML分析器将XML文档进行树形结构的对象化，再通过DOM提供的接口来操作XML文档对象。可以说，XML文档代表的是数据，而DOM代表的是如何去处理这些数据。\n通过DOM接口可以在任何时候访问XML文档中的任何一部分数据（因为它们都读取到内存中），所以DOM接口的机制也称为随机访问机制。但另一方面，由于DOM是根据树形结构将XML的数据对象化，如果XML数据很多的时候，将会特别占用内存，遍历树的耗时也会比较高，这也是DOM的缺点。\nDOM树模型结构：\n文档，即根节点：文档节点是整个文档中所有其它节点的父节点，文档节点是整个文档的入口。备注：根节点不等于根元素节点，根节点之后才是根元素节点。 元素节点：跟据XML文档中对应的元素创建，元素节点可以拥有其它子元素节点，以及属性节点和文本节点。同时，元素节点也是唯一拥有属性节点的节点类型。 属性节点：根据XML文档中的属性创建，实际上也不认为它是元素节点的子节点。 文本节点：包含数据的节点，一般是对应XML文档中的元素内容。 其它不常见节点：CDATA、注释、处理指令。 DOM的四个基本接口：Node、Document、NodeList、NameNodeMap。其中Document接口是堆XML文档操作的入口，从Node接口中继承过来。Node是其它大多数接口的父接口，像Document、Element、Attribute、Text、Comment等代表一个XML元素或属性和内容的接口都是从Node中继承过来，因为DOM中把XML中的每个标签和属性都当做一个Node处理。NodeList接口是一些节点的集合，包含了某个节点的所有子节点。NameNodeMap接口也是一些节点的集合，可以建立节点名和节点之间的一一对应关系，一般用于元素和属性之间的对应关系。\nNode接口：org.w3c.dom.Node，是其它XML树结构对应节点的父接口，在DOM树结构中具有重要地位，它定义一整套处理DOM节点的基本方法。Node借口中的主要方法：\ngetElementsByTagName(String name)：该方法将返回一个NodeLise对象，对象中是该Node下所有名字为name的标签Node集合。 getFirstChild（）：返回该Node下的第一个子节点的Node，如果不存在则返回null。 getNodeValue（）：返回该Node的值，取决于其类型（见JDK帮助文档Node固定值表）。 getNodeType（）：返回该Node类型代表的short值，Node类型与short对应表详见JDK帮助文档。 getTextContent（）：返回该Node节点及其子节点的文本内容，根据Node具体类型的不同将采用不同的内容拼接方法（见JDK帮助文档），特别的，子节点之间的空格当做一个空白的Text节点。 Document接口：org.w3c.dom.Document，继承Node接口，代表了整个XML文档，XML其它Node都按照一定的顺序包含在Document节点对象内，并排雷成一个树形结构。因此，要对XML文档进行操作总是要先通过解析XML文档获得该文档的而一个Document对象才能继续后续操作。由于Document接口中定义了大量创建其它DOM节点对象的工厂方法，也提供了大量操作其它DOM节点对象的方法，从而实现成为访问XML文档的入口。Document接口中的主要方法：\ngetDocumentElement（）：获得该XML文档的根元素Element对象返回。 NodeList接口：org.w3c.dom.NodeList（没有继承Node接口）。NodeList相当于一个Node的集合，该接口中只提供了两个方法：\ngetLength（）：获取NodeList中Node的个数。 item（int index）：获取NodeList中索引号为index的Node对象，索引从0开始计算起。 Element接口：org.w3c.dom.Element，继承Node，代表XML文档中的元素，是DOM中唯一可以包含属性的节点。主要方法有：\ngetTagName（）：获得该Element元素的标签名返回。 getChildNodes()：获得该Element的子元素Node的集合NodeList返回，需要注意的是该方法将Element下子元素标签之间的空格也当做一个空Text的Node，所以此时使用NodeList的getLength方法返回值包括空格数在内。 getAttributes（）：返回一个NameNodeMap对象，其中包含该Element的Attr节点对象。 Attr接口：org.w3c.dom.Attr，继承Node，代表XML文档中元素的属性。虽然它是Node，严格来说，它不能作为一个DOM树中的节点，因为Attr实际上是包含在Element中，所以并不能看做是Element的子对象。也正是因为这原因，它从Node继承来的getparentNode（）、getpreviousSibling（）、getnextSibling（）方法的返回值都是null。\nText接口：org.w3c.dom.Text，继承Node接口，代表XML文档中元素的文本内容，在DOM树结构中，元素的文本内容也使用Node，并且它不能有子节点，继承Node的相关操作不能使用。Text节点的NodeName为“#text”。\n接口都需要实际类的实现，所以以上Node等接口在实际上是需要通过java其它包下的一些实际类来实现，而用于一般不需要直接与这些实际实现类打交道，通过接口及工厂模式的方法来实现DOM接口。\nXML解析器实质上就是一段代码，它能够读入一个XML文档并分析文档的结构。DOM的解析器通过解析XML文档就能为XML文档在逻辑上建立一个树模型，其树的节点是一个个对象，通过DOM接口存取这些对象就能存取XML文档的数据内容。\nJAXP（Java API for Parsing）：用于XML解析的Java API，由SUN公司提供。\nJava应用程序使用XML的一般步骤：\njavax.xml.parsers.DocumentBuilderFactory抽象类：通过DocumentBuilderFactory解析器工厂类的静态newInstance()方法创建一个DocumentBuilderFactory解析器工厂类对象dbf（DocumentBuilderFactory既是工厂类角色又是抽象产品角色）。newInstance()方法能根据一个系统变量（决定构建哪一种具体产品类的参数）来决定创建哪一种解析器工厂对象，只要该系统变量改变就能创建出不同的解析器。这种做法的好处是：无论最终生成的是哪一种解析器，它都符合JAXP的规范，所以只要改变系统变量就能创建出不同的解析器工厂对象，最终创建出另一种解析器，而程序照常可以使用新解析器（JAXP接口不变），不需要改变任何代码。 通过DocumentBuilderFactory类对象dbf，通过它的newDocumentBuilder()方法创建一个它对应的具体DocumentBuilder解析器对象db，也就是这个db就代表了一个具体的DOM解析器。 通过DocumentBuilder对象db的parse（type）解析一个XML文档，该方法将返回一个Document对象，也就是该XML文档的根节点。parse是重载方法，有多种类型参数可选，一般使用parse（String url）。 通过Document对象以及它提供的各种Node方法实现对XML的操作。 ","date":"June 11, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"工厂模式","url":"https://www.qinxiandiqi.sbs/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"xml","url":"https://www.qinxiandiqi.sbs/tags/xml/"},{"title":"DOM","url":"https://www.qinxiandiqi.sbs/tags/dom/"},{"title":"SAX","url":"https://www.qinxiandiqi.sbs/tags/sax/"}],"title":"JavaSE学习笔记 第十四记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n原文作者：Google\n原文地址：\u0026lt;http://developer.android.com/tools/projects/projects- eclipse.html#ReferencingLibraryProject\u0026gt;\n原文版权：Creative Commons 3.0 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-11版本开始翻译，基于2015-10-18版本重新翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n简介# 使用Eclipse和ADT插件可以提供可视化界面和向导来创建三种类型的项目（Android项目，库项目，以及测试项目）：\n一个Android项目包含了将项目打包成.apk安装文件所需要的全部文件和资源。你需要为你最终要安装到设备上的应用创建一个Android项目。\n你也可以设计一个Android项目作为库项目，它给其它需要依赖于它的项目共享。一旦一个Android项目被设计成库项目，它将不能被直接安装到设备上。\n测试项目继承了JUnit的测试功能并提供了Android测试项目特有的功能。更多创建一个测试项目信息，可以参考 Testing from Eclipse with ADT。\n1\\. Creating an Android Project（创建一个Android项目）# ADT插件提供了一个创建新项目的向导，以便你能够快速创建一个新的Android项目（或者从已有代码上创建一个项目）。创建一个新项目的步骤：\n1.1 选择 File \u0026gt; New \u0026gt; Project. 1.2 选择 Android \u0026gt; Android Application Project，然后点击Next。 1.3 为新项目填写基本设置： 1.3.1 输入Application Name（应用名）。这个名称将会在应用安装到设备上之后作为应用图标的标题。 1.3.2 输入Project Name（项目名）。当你的项目创建的时候，这个名字将作为你项目的文件夹名。 1.3.3 输入Package Name（包名）。这个类包命名空间将为你的应用源代码文件创建初始化包结构，并且也会添加你应用的Android manifest文件中座位package的属性值。当你发布你的应用程序时，这个manifest值将会提供作为一个唯一识别码以标识你的应用。这个包名必须遵循Java程序设计语言的包名命名规范。 1.3.4 选择一个Minimum Request SDK（最低要求的SDK版本）。这个设置说明了你的应用程序支持的最低Android系统版本。你的manifest文件中，它将座位\u0026lt;uses-sdk\u0026gt;标签的minSdkVersion属性值。 1.3.5 选择一个Target SDK（目标SDK）。这个设置说明了你的应用需要测试的最高Android系统版本。同时，manifest文件中的targetSdkVersion属性值将会被设置为这个值。 注意：你可以随时更改你项目的target SDK：在Package Explorer视图中右键点击你的项目打开菜单，选择Properties，选择Android，然后修改期望的Project Build Target. 1.3.6 选择一个Compile With API version（编译版本）。这个设置指定了用于编译你的项目的目标SDK版本。我们强烈建议使用最新的API版本。 1.3.7 选择Theme（主题）。这个设置指定了应用到你项目上的视觉样式。 1.3.8 点击Next 1.4 在Configure Project（配置项目）页面， 选择期望的设置并且点击Next下一步。不要修改Create activity选项，以便你能够从一些主要部件启动你的应用。 1.5 在Configure Launcher Icon（配置启动图标）页面，创建一个图标并点击Next下一步。 1.6 在Create Activity（创建Activity）页面，选择activity模板并选择下一步。更多关于Android模板的信息，可以参考Using code Templates. 1.7 点击Finish，向导将创建一个根据你刚才配置的新项目。 提示：你同样可以从工具栏的New![eclipse-new.png](125ebb08dd19a8c28ec01cc00fdc3815.png)按钮启动创建新项目向导。 2.Setting up a Library Project（配置一个库项目）# 库项目也是一个标准的android项目，所以你可以像创建一个新android项目一样创建一个库项目。\n创建库项目的步骤：\n2.1 选择File \u0026gt; New \u0026gt; Project。 2.2 选择Android \u0026gt; Android Application Project，然后点击Next下一步。 2.3 为项目设置基础配置，包括Application Name，Project Name，Package Name和SDK设置。 2.4 在Configure Project页面，选择Mark this project as a library选项以标记项目为库项目。 2.5 设置其他你期望的选项并点击Next下一步。 2.6 根据提示完成创建想到，并创建新的库项目。 你同样也可以配置一个已经存在的应用项目作为库项目。你只需要打开项目的Properties配置菜单，并且勾选is Library选项。如下图1：\n![adt-props-isLib.png](https://img- blog.csdn.net/20140612085650484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlueGlhbmRpcWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n具体步骤如下：\n1\\. 在Package Explorer视图中，打开项目右键菜单，选择Properties。 2\\. 在Properties窗口中，左边侧边栏中选择Android属性组进入右边栏中Library属性。 3\\. 勾选is Library，并点击Apply。 4\\. 点击OK关闭Properties窗口。 一旦你创建了一个库项目或者将一个已存在的项目配置为库项目，那么你就可以在其他android项目中引用它。更新信息可以参考下面Referencing a library project章节。\nCreating the manifest file# 跟标准的android项目一样，库项目同样需要在项目的manifest文件中声明所有使用到的组件。更多信息可以参考[AndroidManifest.xml](http://developer.android.com/guide/topics/manifest/manifest- intro.html)文档。例如，TicTacToeLib示例库项目中声明GameActivity：\n\u0026lt;manifest\u0026gt; ... \u0026lt;application\u0026gt; ... \u0026lt;activity android:name=\u0026quot;GameActivity\u0026quot; /\u0026gt; ... \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 3.Referencing a Library Project（链接一个库项目）# 如果你开发的项目需要包含外部库项目共享的代码和资源，你可以很方便的在项目的Properties中添加一个依赖库。\n添加一个依赖库需要按照以下步骤：\n3.1 首先确定你的应用程序项目和库项目都在你的工作空间中。如果其中一个不在你的工作空间中，先将其导入。 3.2 在Package Exploer视图中，右键打开需要依赖的项目菜单，选择Properties。 3.3 在Properties窗口中，左边栏中选择Android属性组，右边栏将像是Library属性。 3.4 点击Add按钮打开Project Selection对话框。 3.5 在可选择的库项目列表中，选择需要的库项目后点击OK。 3.6 对话框关闭后，点击Properties窗口中的Apply按钮。 3.7 点击OK按钮关闭Properties窗口。 一旦Properties窗口关闭之后，Eclipse将会重新构建项目以包含依赖的库项目进来。\n图2显示了Properties窗口，你可以添加库项目依赖并且上下调整它们的优先级。\n![adt-props-libRef.png](https://img- blog.csdn.net/20140612085713468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlueGlhbmRpcWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n如果你添加了多个依赖库，你可以通过选择依赖库并且通过Up和Down按钮来调整它们的优先级。这个工具将从低优先级（列表底部的库项目）到高优先级（列表顶部的库项目）顺序混合这些依赖库到你的项目中。如果多个库项目定义了同一个资源ID，那么工具将会选择优先级最高的项目中的资源。另外，项目自己本身拥有最高优先级，它的资源永远都会优先于其它依赖库被使用。\nDeclaring library components in the manifest file（manifest文件中配置依赖库的的组件）# 如果你使用了依赖库中的组件，你必须在你应用程序项目的manifest文件中声明这些使用到的组件（没有使用的可以不声明）。例如，你必须声明,,,等等，也包括,等等类似的标签。\n声明依赖库中的组件，必须包括它们完整的包名。\n例如，TicTacToeMain示例项目组中声明依赖库中的GameActivity：\n\u0026lt;manifest\u0026gt; ... \u0026lt;application\u0026gt; ... \u0026lt;activity android:name=\u0026quot;com.example.android.tictactoe.library.GameActivity\u0026quot; /\u0026gt; ... \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 更多关于manifest文件的信息，可以参考[AndroidManifest.xml](http://developer.android.com/guide/topics/manifest/manifest- intro.html)文档。\n","date":"June 11, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/%E4%BD%BF%E7%94%A8eclipse%E5%92%8Cadt%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86android%E9%A1%B9%E7%9B%AEmanagingprojectfromeclipsewithadt/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"ADT","url":"https://www.qinxiandiqi.sbs/tags/adt/"},{"title":"eclipse","url":"https://www.qinxiandiqi.sbs/tags/eclipse/"},{"title":"library","url":"https://www.qinxiandiqi.sbs/tags/library/"}],"title":"使用Eclipse和ADT插件管理Android项目（Managing Project From Eclipse With ADT）"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":"-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n原文作者：Google\n原文地址：http://developer.android.com/google/play-services/setup.html\n原文版权：Creative Commons 3.0 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-09版本开始翻译，基于2015-10-17版本重新翻译\n译文版权：[CC BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc- nd/4.0/)，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n一、前言# 开发一个使用Google Play services API的应用，你需要为你的项目配置Google Play services SDK。如果还没有你还没有安装Google Play services SDK，现在你可以按照[Android SDK Packages](https://developer.android.com/sdk/installing/adding- packages.html)指南来获取。\n为了能够测试使用Google Play Services的应用，你需要具备：\n一个运行Android2.3或者更高系统版本，并且包含google Play stroe的Android设备\n一个运行基于Android4.2.2或者更高版本google APIs平台系统的Android虚拟机\n二、添加Google Play Services到你的项目中（Add Google Play Services to Your Project）# 根据你的开发环境选择下个面的步骤添加Google Play Services到你的项目中：\n2.1 Android Studio# 2.1.1 配置你的app可使用Google Play Services API：# 2.1.1.1、打开你的应用module中的build.grade文件。\n注意：Android Studio项目包含一个顶级build.gradle文件以及每个module中各包含一个build.grade文件。确认编辑的是你的应用module中的文件。参考Building Your Project with Gradle获取更多耿玉Gradle的内容。\n2.1.1.2、在dependencies下面添加一个play-services最新版本的构建规则。例如\napply plugin:'android' ... dependencies{ compile 'com.google.android.gms:play-services:8.1.0' } 当你每次更新Google Play services版本之后，你需要取保更新这里的版本号。\n注意：如果你的app中引用的的方法数量超过了65K限制，你的app可能会编译失败。为了解决这个问题，你可以通过只选择你的app需要的Google Play services API去参与编译，而不是全部api都包含进去。更多关于此做法的信息请参考下面 选择性编译API到你的可执行程序中 章节。\n2.1.1.3、保存修改，并且点击工具栏中的Sync Project with Gradle Files![sync- project.png](https://img- blog.csdn.net/20140612085144156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlueGlhbmRpcWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)按钮。\n现在你开始使用Google Play services API的功能进行开发了。\n2.1.2 选择性编译API到你的可执行程序中（Selectively compiling APIs into your executable）# 在Google Play Services 6.5之前的版本，你必须将整个api的包全部编译到你的app里面去。在一些情况下，这么做很难保持app中全部方法的数量在65536这个限制之下（包括framework的api，依赖库的api，以及你自己项目的代码）。\n从6.5版本开始，你可以有选择的编译部分Google Play service API到你的app中。例如，如果只是需要Google Fit和Android Wear API，那么你可以在build.grade文件中做以下替换：\n原来是：\ncompile 'com.google.android.gms:play-services:8.1.0' 替换成：\ncompile 'com.google.android.gms:play-services-fitness:8.1.0' compile 'com.google.android.gms:play-services-wearable:8.1.0' 表1展示了一个分离的API列表，表中描述了你可以独立选择编译到你的app中的模块，以及如何在build.gradle文件中声明。有部分API没有一个单独的library，它们被包含在基础library里面（当你需要用到一个没有分离出来的API时，这个基础library会自动包含进来。）\n表1：独立的API模块以及相应的build.grade描述\nGoogle Play services API 在build.grade中的描述 Google+ com.google.android.gms.play-services-plus:8.1.0 Google Account Login com.google.android.gms.play-services-identity:8.1.0 Google Actions,Base Client Library com.google.android.gms.play-services- base:8.1.0 Google App Indexing com.google.android.gms.play-services-appindexing:8.1.0 Google App Invites com.google.android.gms.play-services-appinvite:8.1.0 Google Analytics com.google.android.gms.play-services-analytics:8.1.0 Google Cast com.google.android.gms.play-services-cast:8.1.0 Google Cloud Messaging com.google.android.gms.play-services-gcm:8.1.0 Google Drive com.google.android.gms.play-services-drive:8.1.0 Google Fit com.google.android.gms.play-services-fitness:8.1.0 Google Location,Activity Recognition,and Places com.google.android.gms.play- services-location:8.1.0 Google Map com.google.android.gms.play-services-maps:8.1.0 Google Mobile Ads com.google.android.gms.play-services-ads:8.1.0 Mobile Vision com.google.android.gms.play-services-vision:8.1.0 Google Nearby com.google.android.gms.play-services-nearby:8.1.0 Google Panorama Viewer com.google.android.gms.play-services-panorama:8.1.0 Google Play Game services com.google.android.gms.play-services-games:8.1.0 SafetyNet com.google.android.gms.play-services-safetynet:8.1.0 Google Wallet com.google.android.gms.play-services-wallet:8.1.0 Android Wear com.google.android.gms.play-services-wearable:8.1.0 注意：在Google Play services的library中已经包含了ProGuard指令用于保留需要的类。Android Gradle Plugin会自动添加一个AAR（Android压缩包）包中的ProGuard配置文件，并将这个包添加到你的ProGuard配置里面。在项目的创建过程中，Android Studio会自动创建这个ProGuard配置文件以及build.grade属性供ProGuard（程序）使用。在Android Studio中使用ProGuard，你必须在build.grade文件中的buildTypes里面启用ProGuard设置。更多信息，请参考ProGuard指南。\n2.2 Eclipse(ADT插件)或其它方式# 2.2.1 配置你的app可使用Google Play services API：# 2.2.1.1、将/extras/google/google_play_services/libproject/google- play-services_lib路径下的项目复制到你维护你的app项目的目录下。\n2.2.1.2、将这个library项目导入到你的Eclipse工作空间。点击File\u0026gt;Import，选择Android\u0026gt;Existing Android Code into Workspace，然后浏览选择复制过来的library项目并导入。\n2.2.1.3、在你的app项目里面，链接引入Google Play services项目。参考使用Eclipse和ADT插件管理Android项目或者[使用命令行链接library项目](https://developer.android.com/tools/projects/projects- cmdline.html#ReferencingLibraryProject)获取更多相关信息。\n注意：你必须链接复制到你开发工作空间的库项目，不能直接链接到Android SDK目录下的库项目（译者注：SDK Manager更新的Google Play Services版本的时候可能会有变化，所以不建议）。\n2.2.1.4、当你将Google Play services库项目作为依赖库链接到你的应用项目之后，你需要打开你项目中的manifest文件，并且添加以下子标签到标签下：\n\u0026lt;meta-data android:name=\u0026quot;com.google.android.gms.version\u0026quot; androdi:value=\u0026quot;@integer/google_play_services_version\u0026quot;/\u0026gt; 一旦你将库项目链接到你的项目，你就可以开始使用Google Play service APIs提供的功能进行开发。\n2.2.2 添加Proguard排除# 为了防止ProGuard剥离了一些需要的类，需要在/proguard-project.txt文件中添加以下内容：\n-keep class * extends java.util.ListResourceBundle { protected Object[][] getContents(); } -keep public class com.google.android.gms.common.internal.safeparcel.SafeParcelable { public static final *** NULL; } -keepnames @com.google.android.gms.common.annotation.KeepName class * -keepclassmembernames class * { @com.google.android.gms.common.annotation.KeepName *; } -keepnames class * implements android.os.Parcelable { public static final ** CREATOR; } 三、确保设备安装了Google Play services APK（Ensure Devices Have the Google Play# services APK）\n正如Google Play services概述中所说的，在Android 2.3或者更高版本中，Google Play通过Google Play Store应用为用户提供升级服务。但是，可能不是所有用户都能立刻收到更新。因此，在你尝试使用API之前，你应该确认当前版本是可用的。\n重要：由于很难确定每一台设备的情况，你应该经常在使用Google Play services功能之前检查Google Play services APK的版本是否兼容。 由于每个应用对Google Play services的使用不同，你可以根据需要决定检查Google Play services版本的时机。例如，如果你的应用在各种情况下都需要使用到Google Play services，你可能就需要在应用一启动的时候就做检查。如果Google Play services只是你应用的一个可选部分，那么可以只在用户进入到需要使用Google Play services部分的时候再做检查。\n强烈建议你使用GoogleApiClient类来连接Google Play services的功能。这种方法允许你添加一个OnConnectionFailedListenter到你的GoogleApiClient，实现其中的onConnectionFailed()回调方法就能判断当前设备是否有安装合适版本的Google Play services APK。如果由于Google Play APK没有安装或者版本过时就会导致连接失败，回调可能会收到类似SERVICE_MISSING、SERVICE_VERSION_UPDATE_REQUIRED，或者SERVICE_DISABLED这样的错误码。学习更多关于如何创建自己的GoogleApiClient并处理这样的连接错误，请参考连接Google APIs.\n还有其它方法就是通过使用isGooglePlayServicesAvailable()方法。你可以在主Activity的onResume()方法中调用这个方法。如果返回的结果是SUCCESS，说明Google Play services APK的版本是最新的，你可以继续创建一个连接。如果返回的结果是SERVICE_MISSING,SERVICE_VERSION_UPDATE_REQUIRED或者SERVICE_DISABLED，那么用户将需要去安装更新。在这种情况下，可以调用GooglePlayServicesUtil.getErrorDialog()方法并且将错误码传递进去。这个方法会返回一个对话框，它会显示对应的错误信息，并且提供一个操作将用户引导去Google Play Store安装更新。\n接下来开始一个Google Play service的连接（大部分Google API，如Google Drive、Google+、Games等，都需要这个连接）。请参考连接Google APIs。\n","date":"June 9, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/%E8%AE%BE%E7%BD%AEgoogleplayservicessdksetupgoogleplayservicessdk/","series":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/series/android/"}],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"Google Play services","url":"https://www.qinxiandiqi.sbs/tags/google-play-services/"}],"title":"设置Google Play Services SDK(Set Up Google Play Services SDK)"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":" 原文作者：Google\n原文地址：http://developer.android.com/google/play-services/setup.html\n原文版权：Creative Commons 3.0 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-09版本开始翻译，基于2015-10-17版本重新翻译\n​译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n​\n一、前言# 开发一个使用Google Play services API的应用，你需要为你的项目配置Google Play services SDK。如果还没有你还没有安装Google Play services SDK，现在你可以按照Android SDK Packages指南来获取。\n为了能够测试使用Google Play Services的应用，你需要具备：\n一个运行Android2.3或者更高系统版本，并且包含google Play stroe的Android设备 一个运行基于Android4.2.2或者更高版本google APIs平台系统的Android虚拟机 二、添加Google Play Services到你的项目中（Add Google Play Services to Your Project）# 根据你的开发环境选择下个面的步骤添加Google Play Services到你的项目中：\n2.1 Android Studio# 2.1.1 配置你的app可使用Google Play Services API：# 打开你的应用module中的build.grade文件。 注意：Android Studio项目包含一个顶级build.gradle文件以及每个module中各包含一个build.grade文件。确认编辑的是你的应用module中的文件。参考Building Your Project with Gradle获取更多耿玉Gradle的内容。\n在dependencies下面添加一个play-services最新版本的构建规则。例如\napply plugin:\u0026#39;android\u0026#39; ... dependencies{ compile \u0026#39;com.google.android.gms:play-services:8.1.0\u0026#39; } 当你每次更新Google Play services版本之后，你需要取保更新这里的版本号。\n注意：如果你的app中引用的的方法数量超过了65K限制，你的app可能会编译失败。为了解决这个问题，你可以通过只选择你的app需要的Google Play services API去参与编译，而不是全部api都包含进去。更多关于此做法的信息请参考下面选择性编译API到你的可执行程序中章节。\n保存修改，并且点击工具栏中的Sync Project with Gradle Files按钮。\n现在你开始使用Google Play services API的功能进行开发了。\n2.1.2 选择性编译API到你的可执行程序中（Selectively compiling APIs into your executable）# 在Google Play Services 6.5之前的版本，你必须将整个api的包全部编译到你的app里面去。在一些情况下，这么做很难保持app中全部方法的数量在65536这个限制之下（包括framework的api，依赖库的api，以及你自己项目的代码）。\n从6.5版本开始，你可以有选择的编译部分Google Play service API到你的app中。例如，如果只是需要Google Fit和Android Wear API，那么你可以在build.grade文件中做以下替换：\n原来是：\ncompile \u0026#39;com.google.android.gms:play-services:8.1.0\u0026#39; 替换成：\ncompile \u0026#39;com.google.android.gms:play-services-fitness:8.1.0\u0026#39; compile \u0026#39;com.google.android.gms:play-services-wearable:8.1.0\u0026#39; 表1展示了一个分离的API列表，表中描述了你可以独立选择编译到你的app中的模块，以及如何在build.gradle文件中声明。有部分API没有一个单独的library，它们被包含在基础library里面（当你需要用到一个没有分离出来的API时，这个基础library会自动包含进来。）\n表1：独立的API模块以及相应的build.grade描述\nGoogle Play services API 在build.grade中的描述 Google+ com.google.android.gms.play-services-plus:8.1.0 Google Account Login com.google.android.gms.play-services-identity:8.1.0 Google Actions,Base Client Library com.google.android.gms.play-services-base:8.1.0 Google App Indexing com.google.android.gms.play-services-appindexing:8.1.0 Google App Invites com.google.android.gms.play-services-appinvite:8.1.0 Google Analytics com.google.android.gms.play-services-analytics:8.1.0 Google Cast com.google.android.gms.play-services-cast:8.1.0 Google Cloud Messaging com.google.android.gms.play-services-gcm:8.1.0 Google Drive com.google.android.gms.play-services-drive:8.1.0 Google Fit com.google.android.gms.play-services-fitness:8.1.0 Google Location,Activity Recognition,and Places com.google.android.gms.play-services-location:8.1.0 Google Map com.google.android.gms.play-services-maps:8.1.0 Google Mobile Ads com.google.android.gms.play-services-ads:8.1.0 Mobile Vision com.google.android.gms.play-services-vision:8.1.0 Google Nearby com.google.android.gms.play-services-nearby:8.1.0 Google Panorama Viewer com.google.android.gms.play-services-panorama:8.1.0 Google Play Game services com.google.android.gms.play-services-games:8.1.0 SafetyNet com.google.android.gms.play-services-safetynet:8.1.0 Google Wallet com.google.android.gms.play-services-wallet:8.1.0 Android Wear com.google.android.gms.play-services-wearable:8.1.0 注意：在Google Play services的library中已经包含了ProGuard指令用于保留需要的类。Android Gradle Plugin会自动添加一个AAR（Android压缩包）包中的ProGuard配置文件，并将这个包添加到你的ProGuard配置里面。在项目的创建过程中，Android Studio会自动创建这个ProGuard配置文件以及build.grade属性供ProGuard（程序）使用。在Android Studio中使用ProGuard，你必须在build.grade文件中的buildTypes里面启用ProGuard设置。更多信息，请参考ProGuard指南。\n2.2 Eclipse(ADT插件)或其它方式# 2.2.1 配置你的app可使用Google Play services API：# 将\u0026lt;android-sdk\u0026gt;/extras/google/google_play_services/libproject/google-play-services_lib路径下的项目复制到你维护你的app项目的目录下。 将这个library项目导入到你的Eclipse工作空间。点击File\u0026gt;Import，选择Android\u0026gt;Existing Android Code into Workspace，然后浏览选择复制过来的library项目并导入。 在你的app项目里面，链接引入Google Play services项目。参考使用Eclipse和ADT插件管理Android项目或者使用命令行链接library项目获取更多相关信息。\n注意：你必须链接复制到你开发工作空间的库项目，不能直接链接到Android SDK目录下的库项目（译者注：SDK Manager更新的Google Play Services版本的时候可能会有变化，所以不建议）。 当你将Google Play services库项目作为依赖库链接到你的应用项目之后，你需要打开你项目中的manifest文件，并且添加以下子标签到标签下： \u0026lt;meta-data android:name=\u0026#34;com.google.android.gms.version\u0026#34; androdi:value=\u0026#34;@integer/google_play_services_version\u0026#34;/\u0026gt; 一旦你将库项目链接到你的项目，你就可以开始使用Google Play service APIs提供的功能进行开发。 2.2.2 添加Proguard排除# 为了防止ProGuard剥离了一些需要的类，需要在/proguard-project.txt文件中添加以下内容：\n-keep class * extends java.util.ListResourceBundle { protected Object[][] getContents(); } -keep public class com.google.android.gms.common.internal.safeparcel.SafeParcelable { public static final *** NULL; } -keepnames @com.google.android.gms.common.annotation.KeepName class * -keepclassmembernames class * { @com.google.android.gms.common.annotation.KeepName *; } -keepnames class * implements android.os.Parcelable { public static final ** CREATOR; } 三、确保设备安装了Google Play services APK（Ensure Devices Have the Google Play services APK）# 正如Google Play services概述中所说的，在Android 2.3或者更高版本中，Google Play通过Google Play Store应用为用户提供升级服务。但是，可能不是所有用户都能立刻收到更新。因此，在你尝试使用API之前，你应该确认当前版本是可用的。\n重要：由于很难确定每一台设备的情况，你应该经常在使用Google Play services功能之前检查Google Play services APK的版本是否兼容。\n由于每个应用对Google Play services的使用不同，你可以根据需要决定检查Google Play services版本的时机。例如，如果你的应用在各种情况下都需要使用到Google Play services，你可能就需要在应用一启动的时候就做检查。如果Google Play services只是你应用的一个可选部分，那么可以只在用户进入到需要使用Google Play services部分的时候再做检查。\n强烈建议你使用GoogleApiClient类来连接Google Play services的功能。这种方法允许你添加一个OnConnectionFailedListenter到你的GoogleApiClient，实现其中的onConnectionFailed()回调方法就能判断当前设备是否有安装合适版本的Google Play services APK。如果由于Google Play APK没有安装或者版本过时就会导致连接失败，回调可能会收到类似SERVICE_MISSING、SERVICE_VERSION_UPDATE_REQUIRED，或者SERVICE_DISABLED这样的错误码。学习更多关于如何创建自己的GoogleApiClient并处理这样的连接错误，请参考连接Google APIs.\n还有其它方法就是通过使用isGooglePlayServicesAvailable()方法。你可以在主Activity的onResume()方法中调用这个方法。如果返回的结果是SUCCESS，说明Google Play services APK的版本是最新的，你可以继续创建一个连接。如果返回的结果是SERVICE_MISSING,SERVICE_VERSION_UPDATE_REQUIRED或者SERVICE_DISABLED，那么用户将需要去安装更新。在这种情况下，可以调用GooglePlayServicesUtil.getErrorDialog()方法并且将错误码传递进去。这个方法会返回一个对话框，它会显示对应的错误信息，并且提供一个操作将用户引导去Google Play Store安装更新。\n接下来开始一个Google Play service的连接（大部分Google API，如Google Drive、Google+、Games等，都需要这个连接）。请参考连接Google APIs。\n​\n​\n","date":"June 9, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/%E8%AE%BE%E7%BD%AEgoogleplayservicessdk/","series":[],"smallImg":"","tags":[{"title":"android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"翻译","url":"https://www.qinxiandiqi.sbs/tags/%E7%BF%BB%E8%AF%91/"},{"title":"Google Play Service","url":"https://www.qinxiandiqi.sbs/tags/google-play-service/"}],"title":"设置Google Play Services SDK(Set Up Google Play Services SDK)"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-08-02# 单例模式的两种实现方法中，如果将构造单例对象的方法放置到获取单例对象的方法中，在多线程的情况下有可能违反单例模式的要求产生不同的单例对象。而在定义的单例对象成员时就构造对象则不会出现这种情况。\nURL包装的URL值必须包含协议名称，即使是HTTP也要包含，不同于浏览器会自动添加。\njava.net.InetAddress类：用于封装IP地址和主机名的类。该类没有明显的构造函数，是采用工厂模式设计的类，构造一个InetAddress类需要通过类中的getLocalHost（）、getByName（）、getAllByName（）等static方法获得。getLocalHost（）用于获取封装本机IP的InetAddress对象，getByName(String name)用于获取主机名为name的InetAddress对象（一般name是用主机的域名），getAllByName（String name）用于获取主机名为name的一个InetAddress对象数组（有些主机有多个网卡可以拥有多个IP）。这些静态方法一旦获取失败会引发UnknowHostException异常。\nSocket：是连接运行在网络上的两个程序间的双向通讯端点，分为服务器端Socket和客户端Socket。\njava.net.ServerSocket类：实现服务器套接字的类，基于TCP协议！用于等待通过网络传入的请求，并可能想请求者返回结果。关闭ServerSocket需要使用close方法。\n主要的构造方法有ServerSocket（int port），创建一个用于监听port端口的服务器套接字，如果port为0就会随机分配一个端口并创建监听这个端口的服务器套接字。 public Socket accept（）throws IOException：启动该ServerSocket对象监听port端口，在有连接请求传入之前一直处于阻塞状态，有连接请求传入时能够创建一个新端口号的Socket用于连接请求。 java.net.Socket类：两台机器之间通讯的端点，基于TCP协议！用于实现客户端套接字（实际上服务端套接字接收请求后也会在服务器端创建Socket）。Socket之间通过io流传送数据，当Socket要发送数据时要通过输出流，当Socket要读取数据时要通过输入流。关闭Socket需要使用它的close方法。\n主要构造方法有Socket（String address，int port）：用于创建与IP为address，端口号为port相连的流套接字。一旦创建成功，就表示已经于该IP主机的port端口正常连接上。 通过getOutputStream（）获取套接字的输出流（对方Socket的输入流），通过getInputStream（）获取套接字的输入流（对方Socket的输出流）。 使用Socket进行网络通讯的一般过程：\n服务器程序创建一个ServerSocket对象绑定到一个特定的端口，并通过ServerSocket的accept方法启动等待监听客户的连接请求功能，一般将accept方法放置于死循环中，这样每当监听到客户连接请求时才能执行一次。 客户程序根据服务器程序所在主机名或IP以及端口号，创建Socket对象向服务器程序的ServerSocket监听的端口发出连接请求。 如果服务器接收到客户端程序的连接请求后，将会创建一个新的绑定到不同端口地址的Socket与客户端的Socket通过读写（getOutputStream和getInputStream）套接字进行通讯。同时服务器程序的ServerSocket仍然继续监听其端口的连接请求。 127.0.0.1和localhost都代表本机。\n当服务器端和客户端已经各自建立起Socket连接后，如果通过Socket直接通讯的话，只能按照程序已经规定的格式依次使用读写流通讯（比如使用InputStream输入流读取数据多少次后再通过OutputStream输出多少次，顺序不能修改），而大多数情况下，什么时候读数据什么写数据是无法确定的。为了解决这个问题，需要为服务器端每一个Socket创建一个读取InputStream线程和输出OutputStream线程，也要为客户端每一个Socket创建一个读取InputStream线程和输出OutputStream线程，这么一来，读写操作分开又交由线程去处理，可以并发执行，无论服务端还是客户端在什么时候要进行读写都能正确接收。\nJava提供了java.net.DatagramSocket类和java.net.DatagramPacket类来实现基于UDP协议的网络编程。在UDP编程中，没有严格区分服务端和客户端，其通讯方法类似于信件传送，UDP数据报中包含了发送方和接收方法的IP和端口与信息，发送方和接收方的角色是相对的。\njava.net.DatagramSocket类：基于UDP协议的两台机器间的通讯端点。关闭DatagramSocket对象需要使用close方法。\n主要构造方法有DatagramSocket（int port），用于创建监听prot端口的DatagramSocket对象，如果没有数据报接收就会进入阻塞状态，不往下执行。 sent（DatagramPacket p），用于将数据报DatagramPacket对象发送出去。 receive（DatagramPacket p），用于接收数据报DatagramPacket对象。 java.net.DatagramPacket类：封装UDP数据报的类。\n主要构造方法有DatagramPacket（byte[] buf，int offset，int length，InetAddress address，int port）：创建一个DatagramPacket对象，其中buf为该对象封装的字节数组数据信息，offset表示封装buf数组数据的起始位置，length表示封装的字节数据长度，address表示该对象将要发送到的机器地址，port表示该对象将要发送往的机器上的端口位置。 setData（byte[] buf，int offset，int length）：设置DatagramPacket对象封装的字节数组buf，offset为封装的起始位置，length表示封装的字节长度。 getData（）：放回一个byte[]数组，获取DatagramPacket对象中封装的字节数组数据。 getLength（）：获取DatagramPacket对象中封装的字节数组长度。 getAddress（）：当DatagramSocket接收到一个DatagramPacket对象后，可使用此方法获取该对象是从哪个机器发过来的。 getPort（）：当DatagramSocket接收到一个DatagramPacket对象后，可使用此方法获取该对象从发送机器的哪个端口发送出来的。 使用DatagramSocket和DatagramPacket进行UDP通讯的一般过程：\n创建DatagramSocket对象和DatagramPacket对象，用DatagramPacket封装需要发送的数据和接收方的InetAddress和端口。 使用DatagramSocket对象的sent方法将DatagramPacket方法发送出去。 接收方同样需要创建DatagramSocket对象和DatagramPacket对象，以及接收数据的byte[]空数组。DatagramSocket对象需要指定发送方DatagramPacket对象设置的端口。DatagramPacket对象使用空数组byte[]构造。 接收方使用DatagramSocket的receive方法将接收的DatagramPacket对象，便可以通过DatagramPacket对象的各种方法获取发送方发送的byte数组，以及发送方InetAddress和端口等信息。 反过来，接收方向发送方发送数据时，将发送方当做接收方，将接收方当做发送方按照以上步骤便可。 同样类似于Socket，可以使用两个线程分管DatagramSocket的发送和接收。\n","date":"June 9, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"socket","url":"https://www.qinxiandiqi.sbs/tags/socket/"},{"title":"Java网络编程","url":"https://www.qinxiandiqi.sbs/tags/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"title":"JavaSE学习笔记 第十三记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-08-01# wait（）：Object定义的方法，不能被重写。当一个线程调用该方法时，该线程必须拥有对象的锁，所以wait（）必须包含在synchronized方法或者代码块中才能保证调用wait方法是线程拥有一个对象的锁。当线程调用wait方法后，线程会自动放弃对上锁对象的锁，并进入等待重新获得锁的状态，重新获得锁后线程将从wait之后的代码继续运行。重新获得锁的方法由其它拥有该对象锁的线程调用notify（）方法。\nnotify（）：Object定义的方法，不能被重写，与wait配套使用，同样调用该方法的线程必须拥有该对象锁，所以notify方法也必须在synchronized方法或代码块中调用。当一个线程调用notify方法后，将会唤醒因与当前对象拥有同个锁，并调用wait方法进入等待的线程。如果存在多个wait线程，则会通过线程竞争的方法选择唤醒哪个线程。然而，并不是当前线程调用notify方法后就能立即唤醒被wait方法进入等待的线程，而是得等到向前线程结束或抛出异常而对上锁对象解锁后才能调用被wait进入等待的线程。\n多个线程中，有一个对象的wait出现，就一定有该对象的notify出现，但是两者在数量上可能不一致。并且，wait方法前一般有一个条件判断，当条件满足时才调用wait。通常情况下，使用while包装wait，让每次线程被唤醒后都要再检查一次条件是否满足，因为在并发线程比较多的时候，线程被唤醒时，可能由于其它线程干扰导致条件改变，若不检查容易出现并发错误。\nThread.sleep方法也能令线程暂停，并且能指定暂停多长时间。与wait不同的是，sleep方法暂停时不会释放掉对象的锁，并且当暂时时间过去后，线程能自动被唤醒（wait需要notify方法唤醒）。因此sleep线程被唤醒时已经拥有对象的锁，所以才能继续马上继续进行（wait唤醒后还要重新等待获取到对象锁才能继续运行）。\n由于wait和notify，线程对象多了wait阻塞状态。当线程调用了wait方法后，线程便进入wait阻塞状态，并进入等待池（wait pool），直到其他线程调用同锁对象的notify方法，线程便进入上锁阻塞状态，也就是进入锁池（look pool）。\n线程组：一些线程的集合，一个线程被创建后不能再修改其隶属的线程组，创建一个线程时若没有指定线程组，则新线程与创建其的父线程隶属于同一个线程组。线程组比较少用到。\n对象的浅拷贝：当对一个对象进行浅拷贝后，拷贝出来的对象会提供一套新的对象成员变量来复制接收原对象的各个成员变量值。因此，如果是原对象的原生数据类型成员变量，则直接将值复制过来，但如果是对象引用类型变量，由于对象类型引用变量的值只是个地址，所以复制过来的也是对象的对象成员地址，导致浅拷贝后对象的对象成员变量指向原对象的对象成员。一旦原对象或新对象任何一方的对象成员内的成员变量值发生改变，将会互相影响。但是，如果是对原对象或新对象任何一方的对象成员赋予另一个对象引用值的话，由于不再指向同一个对象，所以原对象和新对象之间不再互相影响。\n对象的深拷贝：在基于对象浅拷贝的基础上，除了对象原生数据类型成员的复制方法一样之外，对于对象成员，深拷贝是重新构造一个对象成员再将新对象成员的引用赋给新对象的对象成员变量。因此，深拷贝之后，原对象和新对象的对象成员变量都不指向同一个对象，它们之间互不影响。\n实现浅拷贝和深拷贝的方法：\n浅拷贝：Object类提供了clone（）方法，其作用是进行浅拷贝，但由于其修饰符是protected，在外包中不可见，Java要求对需要进行拷贝的类要重写这个clone方法，并且要实现接口Cloneable（Cloneable是一个标识性接口，里面没有定义任何方法，只是声明而已，类似于serializable接口）和将方法声明修饰符改为public（对外包可见）。在重写的clone方法中要调用Object的方法（super.clone()），便可以进行浅拷贝。Object的clone浅拷贝的结果符合x.clone()!=x为true、x.clone().getClass()==x.getClass()为true、x.clone().equals(x)为true。 深拷贝方法一：将需要深拷贝对象类在浅拷贝基础上，重写clone方法中调用super.clone()之后，调用每个对象成员的clone方法。因此，每个对象成员的类都要实现浅拷贝的方法，若对象成员又包含自己的对象成员，则它们也要编写浅拷贝，以此类推。 深拷贝方法二：利用对象序列化和反序列化。当一个对象包含多个对象成员时需要对每个对象成员都进行拷贝会很繁琐，但是借助对象序列化和反序列化能够复制对象和它对象链上的所有内容到流上，又能将所有对象信息充流上读回来的特点，可以间接的实现深拷贝。当然，前提是对象的每个对象成员都可以序列化。（序列化要点：实现Serializable接口，利用ObjectOutputstream和ObjectInputstream包装流）。这种方法是最常用的深拷贝方法。 当类实现Serializable接口表明可序列化时，定义long静态成员变量serialVersionUID的作用在于：当该类对象序列化后反序列化回来时，若此类的定义已经发生改变（删除了一些成员变量或者增加了一些成员变量），如果没有定义这个serialVersionUID就会抛出Exception，无法进行序列化。而如果有定义serialVersionUID，反序列化若遇到类已经改变的情况，不会直接抛出Exception，而是查找类的serialVersionUID值是否相同，相同话就还是可以反序列化回来，对于被删除或者增加的成员将会以成员类型的默认属性赋值。可以说，serialVersionUID提供了对象向后兼容的可能。\nIP用于确定数据包需要送达的主机位置，端口用于确定数据包需要交付给主机上哪一个程序。端口使用一个16位数字表示，范围0-65535。http协议默认使用80端口，用户程序使用的端口最好选择1024之后的端口。\n在网络分层模型中，对等层协议之间交换的信息单元统称为PDU，下层把上层的PDU当做本层PDU的数据部分封装。\nJava提供了对网络编程的支持，与网络编程相关的类包含在java.net包中。\nURL：统一资源定位符的简称（Uniform Resource Locator），表示Internet上某一资源的地址，通过URL可以访问Internet上的各种网络资源。使用URL进行网络编程，不需要对协议本身有太多的了解，功能也比较弱，相对而言比较简单。一个URL主要包括协议标识符和资源名字两个部分。\njava.net.URL类：URL类对象用于封装一个URL地址，并提供了相关URL操作方法。可以通过URL地址字符串直接创建URL对象，也可使用其它构造方法构造，如果构造失败会抛出MalfformedURLException异常。使用getProtocol（获取协议）、getHost（主机名）、getPort（端口）、getFile（文件名）、getRef（URL锚点）等方法可以获取URL对象相关属性。\n构造一个URL对象并不等于连接了URL指向的文件，需要使用URL的openConnection（）方法返回一个URLConnection对象（可能引发IOException异常），获得该URL的连接，再利用URLConnection对象的getInputStream（）方法可以获取该URL指向的文件的输入流，继而通过对输入流的操作可以获取该URL指向的文件。URL类也提供了openStream（）方法可返回URL对象指向文件的InputStream输入流，本质上是对以上两个方法的综合调用。\njava.net.URLConnection类：访问远程资源属性的一般用途类。当建立了与远程服务器之间的连接后，可以在传输它到本地之前用URLConnection对象来检察远程对象的属性，只对HTTP协议的URL对象有意义。\n","date":"June 6, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"线程","url":"https://www.qinxiandiqi.sbs/tags/%E7%BA%BF%E7%A8%8B/"},{"title":"对象拷贝","url":"https://www.qinxiandiqi.sbs/tags/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"},{"title":"Java网络编程","url":"https://www.qinxiandiqi.sbs/tags/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"title":"JavaSE学习笔记 第十二记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":" 线程的实现方法：\n继承Thread类，并重写run方法。 Thread类是专门用来创建线程和对线程进行操作的类，其中定义了许多方法对线程进行操作。继承Thread的子类线程类要把线程需要实现的代码写到run（）方法中，线程对象实现线程的时候执行的线程内容就是run方法中的内容。由于Thread类的run方法中只是个判断是否存在实现Runnable接口对象的语句，继承Tread类的子类没有传入Runnable对象，所以什么都不做，因此要求每个继承Thread的线程类都必须重写run方法，否则继承的线程类对象什么都不做。 另外，启动线程的方法只有使用线程对象的start（）方法一种，调用start方法会先为线程准备好线程需要的系统资源，然后再启动线程并运行线程的run方法。如果直接调用线程对象的run方法则跟调用一个普通类的普通方法一样，不会形成新的线程执行。另外，一个线程对象只能使用start方法启动一次，多次使用start方法不允许，将抛出异常，即使是该线程对象的run方法已经执行完毕，线程也已经结束，也不能使用start方法重新启动。 将实现Runnable接口的类对象以参数的形式传递给Thread的构造方法Thread（Runnable target），构造一个Thread对象，并使用Thread的start方法启动线程。Runnable接口只定义了一个run方法，所以实现Runable接口的类必须实现这个run方法，线程启动后也是运行这个run方法。常见的形式是使用匿名内部类的形式实现Runnable接口：new Thread（new Runnable（）{public void run（）{}}；。 Thread类和Runnable接口的联系：Thread类本身就是一个实现Runnable接口的类，所以Thread类中实现了run方法。Thread类中也包含一个Runnable接口对象target，当使用Thread（Runnable target）构造方法接收一个Runnable接口对象构造一个Thread对象时，底层代码实际是调用init方法，将接收的Runnable接口对象赋给Thread内部的target成员变量。Thread类的run方法为if（null ！= target）{target.run()}，所以，使用Thread（Runnable target）方法构造的Threa对象实际运行的是Runnable接口对象中的run方法。而继承Thread类的子类重写run方法，所以Thread子类对象实际运行的run方法是子类重写的run方法。\n构造Thread对象或者其子类对象的时候，如果没有指定线程对象的名字，默认会使用“Thread-threadInitNumber”作为线程对象的线程名。其中threadInitNumber是Thread的static整型成员变量，nextThreadNum（）方法会对其自动增加。\n线程的实现方法中，如果线程类已经继承了其他类，那么只能使用Runnable接口方法。\n线程的结束方法不建议使用Thread的stop（）方法，因为该方法非常不安全，安全的结束就是让run方法运行完毕自动结束。推荐的方法是设置一个boolean变量，并在在run方法中设置一个以boolean变量为判断依据的循环，再使用另一个方法设置boolean变量的值，通过这个方法来决定线程的运行。例如采用以下结构：\npublic class MyThread extends Thread{ private boolean flag=true; @Override public void run(){ while(flag){ ... } } public void stopRunning(){ flag=false; } } 线程的生命周期（状态）：\n创建状态：使用new构造线程对象时的状态，此时系统不为它分配资源，只是一个空的线程对象而已。 可运行状态：使用Thread的start方法后，系统为线程分配需要的系统资源（除了CPU），并调用run方法，但是此时的线程还是没有进入运行状态，只是可以随时被运行而已。 运行状态：可运行状态的线程获得CPU资源后就可以立即执行，即进入运行状态。 不可运行状态：运行状态中的线程调用了sleep方法，或者调用了wait方法等待特定条件满足，或者是线程输入或输出阻塞时，线程会放弃占有CPU进入不可运行状态，直到条件满足后再进入可运行状态。 消亡状态：当线程的run方法执行结束后，线程自然消亡。 线程的优先级：线程创建时，子线程继承父线程的优先级；线程创建后，可通过调用setPriority（int）方法改变优先级，接收的优先级参数是1-10的整数，Thread类中定义了三个优先级常量MIN_PRIORITY(1)/MAX_PRIORITY(10)/NORM_PRIORITY(5)，没有指定优先级的情况下，使用默认优先级NORM_PRIORITY。\n一般情况下，线程调度器会调用优先级最高的线程运行，但是也要根据具体操作系统的线程调度策略决定，不同操作系统的策略可能不同，线程的调度顺序可能不同。因此，最保险的方法是通过向线程代码中添加条件控制来确保线程的执行。\n当线程中调用了yield（）方法时，线程会让出CPU让其他线程先执行；当线程中调用了sleep方法时，线程会进入睡眠状态；线程也会由于I/O操作而受到阻塞，停止执行；当另一个更高优先级的线程出现是，线程也有可能阻塞；在支持时间片的系统中，线程的时间片用完后也会停止运行。\n当多个线程访问同一个对象的成员变量或者类的静态成员变量时，多个线程对该对象的成员变量或类的静态成员变量的影响是相互的，因为它们共用同一份对象的成员变量或类的静态成员变量。如果多个线程访问的是同一个对象的局部变量，则每个线程都拥有一份局部变量的拷贝，多个线程之间的局部变量互不影响。如果多个线程访问的是不同对象的成员变量，理所当然多个线程之间互不影响，它们不共同操作一份数据。\n多个线程共享同一个数据可能会由于并发性导致数据的错误，解决的方法是每个线程访问该数据之前对该数据进行加锁，加锁后的数据不能再被其他线程访问，直到加锁的线程执行完毕或者抛出异常后解锁，此方法又叫多线程的同步。\nJava中为实现多线程的同步，让每个对象都带有一个锁（Lock，也叫监视器monitor），并提供了多线程同步关键字synchronized，可用于修饰方法或者代码块：\nsynchronized修饰方法：当线程调用被synchronized修饰的方法时，会将该方法归属的对象进行上锁。对象一旦上锁，对象中所有被synchronized修饰的方法都不能被其它线程调用（没有被synchronized修饰的方法仍然可以被其它线程调用），直到上锁线程将该方法执行完毕或抛出异常后解锁。另外，对于被synchronized修饰的static方法，由于static方法归属于类，线程调用被synchronized修饰的static方法时，加锁的对象是该类的Class对象，此时由于类的所有对象都共享同一个Class对象，所以其他线程调用该类其它对象的static方法也无法进行（一般也没有利用类的对象调用类的static方法）。 synchronized修饰代码块：此方法必须在synchronized（Object obj）{}中显示指定要上锁的对象obj（只要是对象都可以）。当一个线程运行到synchronized修饰的代码块时就会将obj上锁，此时其它线程如果运行到需要将obj上锁的synchronized代码块或者方法时都无法运行，直到synchronized代码块执行完毕或者抛出异常才将对象obj解锁。代码块中必须使用obj对象来调用notify或者wait方法，否则会抛出没有获得相应对象锁但却要操作锁相关方法的异常。当obj参数为this，并且代码块中为整个方法代码时，功能与使用synchronized修饰方法一样。 synchronized修饰方法的同步是粗粒度的，synchronized修饰代码块的同步是细粒度的，适合精细控制同步。当一个方法中代码比较多，而且可能会引起并发错误的代码只有少量时，适合使用同步代码块以提高并发度提升效率。同步率越高，并发性越差，效率越低，多线程的优势就体现不出来。\n受synchronized保护的数据应该是private的，否则如果是public，外部同样可以通过对象来直接访问，那么同步保护就没有意义。\n由于同步机制，线程声明周期的状态多了上锁阻塞状态。当运行中的线程由于需要的数据被其它线程上锁时，线程就会转入上锁阻塞状态，进入锁池（Lock pool），直到该线程需要的数据解锁时，才会重新进入可运行状态。\n","date":"June 5, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"线程","url":"https://www.qinxiandiqi.sbs/tags/%E7%BA%BF%E7%A8%8B/"}],"title":"JavaSE学习笔记 第十一记 —— 线程"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-30# 装饰模式：又叫包装模式，能够在不创造更多子类的情况下动态地将对象的功能加以扩展，是继承的一种替代方案。一个类对象装饰另一个类对象，就可以以装饰对象的方法处理被装饰对象，而整个处理过程对客户端是透明的，实际的过程是装饰对象的处理方法调用被装饰对象的处理方法，并在被装饰对象的处理方法上添加新的功能，也就是说最终是把客户端的调用委托到被装饰类。这种模式的好处就是在不造成类数量增加的情况下，构造更多功能的对象。\n装饰模式与继承的区别：装饰模式用来扩展特定对象的功能，并且是动态的，在运行时分配添加的职责，因此灵活性比较好；而继承是扩展类的功能，一旦扩展就不能修改，是静态的，在编译时分配添加的职责，因此灵活性比较差。另外，一个规定的对象同时能被对个装饰对象装饰，客户端可以通过选择合适的装饰对象操作被装饰对象。\n装饰模式的角色：\n抽象构建角色（Component）：一般是一个抽象类或者接口，用来规范被装饰对象的结构。如：InputStream和OutputStream。 具体构建角色（Concrete Component）：也就是真实对象，继承或实现了抽象构建角色。如：节点流FileInputStream和FileOutputStream。 装饰角色（Decorator）：继承或实现抽象构建角色的抽象类或者接口或者类，以实现客户端对象可以使用和具体构建角色相同的方式与装饰对象进行交互。装饰角色接收客户端对象的所有请求，装饰角色内部持有一个抽象构建角色的引用变量，通过这个引用才能最终将客户端的请求转发给构建角色，由构建角色去完成。如：过滤流FilterInputStream和FileOutputStream。 具体装饰角色（Concrete Decorator）：继承或实现抽象装饰角色的类，具体实现对被装饰对象的附加功能添加在这个类中，而不是装饰角色中。如：过滤流DataInputStream和DataOutputStream。 new DataInputStream（new BufferedInputStream（new FileInputStream（“C：\\test.text”）））；\nJava中采用Unicode字符，一个字符16位，字符流Reader和Wrider处理的都是Unicode字符，一次至少两个字节16位。\nInputStreamReader直接继承Reader，是字节流通向字符流的桥梁。构造方法有InputStreamReader（InputStream in）、InputStreamReader（InputStream in，String cs）等，用于接收一个InputStream对象，并使用cs编码格式编码，如果没有cs参数则使用系统默认编码格式。类中提供了getEncoding（）方法可以返回该流使用的字符编码格式名称。可以将InputStreamReader看做是把InputStream装饰成处理字符流的过滤流。\nOutputStreamWriter直接继承Writer，是字节通向字符流的桥梁。构造方法有OutputStreamWriter（OutputStream out）. OutputStreamWriter（OutputStream out，String cs）等，用于接收一个OutputStream对象，并使用cs格式编码，如果没有cs参数则使用系统默认的编码格式编码。类中提供了getEncoding（）方法可以返回该流使用的字符编码格式名称。flush（）方法可以强制刷新该流的缓冲。可以将OutputStreamReader看做是把OutputStream装饰成处理字符流的过滤流。由于继承了Writer，所以继承了其中的writer（String str）方法，可以一次写入一个字符串。\nBufferedReader直接继承Reader，类比于BufferedInputStream，只是类中的字节缓冲数组变更为字符缓冲数组，其类中其他方法使用方式与BufferedInputStream中方法使用几乎相同，是一个接收Reader的过滤流。类中提供了一个readLine（）方法读取Reader流中的一个文本行，并将游标转移到该行的行尾，如果游标已经到行尾，则会返回null。\nBufferedWriter直接继承Writer，类比于BufferedOutputStream，只是类中的字节缓冲数组变更为字符缓冲数组，其类中的方法使用方式与BufferedOutputStream中的方法几乎相同，是一个接受Writer的过滤流。由于继承了Writer，所以继承了其中的writer（String str）方法，可以一次写入一个字符串。\nFileReader继承InputStreamReader，类似于FileInputStream，只是处理的对象是字符。\nFileWriter继承OutputStreamWriter，类似于FileOutputStream，只是处理对象是字符。如果FileWriter依赖的文件不存在则会自动创建这个文件，如果FileWriter试图打开一个只读文件就会抛出一个IOException异常。\nCharArrayReader继承Reader，类似于ByteArrayInputStream，只是字节数组更改为字符数组。\n13.CharArrayWriter继承Writer，类似于ByteArrayOutputStream，只是字节数组更爱为字符数组。\nSystem.in其实是一个InputStream标准输入流，通常是从键盘输入；System.out其实是一个PrintStream标准输出流，一般是输出到控制台。\nString的getChars（int srcBegin，int srcEnd，char[] dst，int dstBegin）方法用于将原字符串中的srcBegin到srcEnd的字符以字符数组的方式复制到字符数组dst的dstBegin位置开始。\nASCII（American Standard Code for Information Interchange）：美国信息互换标准代码，采用8位二进制位编码，将英文中常用的字符、数字符号与最高位为0，相应十进制数为0-127的数值对应进行编码。另外还有128个扩展ASCII编码，其最高位为1，用于编制一些指标附后和其它符号。\nGB2312：信息交换用汉字编码字符集-基本集，使用两个字节表示一个中文字符，并且每个字节的最高位都是1.\nGBK：GB2312的扩展，完全兼容GB2312，并且多容纳了繁体中文和一些不常用的汉字。\n19.ISO-8859-1：西方国家使用的字符编码集，属于单字节的字符集，其中英文只用了其中数值小于128的部分。不兼容汉字。\nUnicode：通用字符集，可以对所有语言文字进行编码，每个字符都使用两个字节，Java中采用这个编码方式以实现字符的跨平台。这种编码的缺点在于在internet上传输的效率比较低，因为一些使用一个字节就能表示的字符也使用两个字节表示，高字节填0。\nUTF-8：不定长字符编码方式，根据字符需要的字节长度分配字节，有些字符用一个字节，有些两个，有些三个。互联网上常用这种编码方式，传输效率高，字符容量大。\njava.io.RandomAccessFile：随即访问文件类，直接继承Object，并实现了DataInput和DataOutput接口。构造方法有RandomAccessFile（File file，String access）或者RandomAccessFile（String name，String access），其中file或者name表示依赖的File对象或者文件名，access表明使用文件的方式是“r”（只读）还是“rw”（读写）。另外，由于类中包含一个long变量pos作为流的游标，使用该类的getFilePointer（）可以获得当前游标的位置，使用该类的seek（long pos）可以将游标定位到pos位置，使用skipBytes（int n）可以将游标向后移动n个字节。由于该类实现了DataInput和DataOutput接口，所以类中提供了大量读写各种数据类型的方法，特别的有readUTF（）和writeUFT（String str）方法以UFT的格式读写数据。该类的特点在于类中包含了输入流方法和输出流方法，相当于输入流和输出流的合体。\njava.nio.Charset类中的availableCharsets（）方法可以返回一个SorteMap\u0026lt;String，Charset\u0026gt;排序映射。其中的Key为当前系统所支持的字符集名。\n序列化/反序列化：将对象转换为字节流（因为对象不是字符，转换成字符流没有意义）保存起来，并在以后从字节流中还原这个对象的机制。若把一个对象序列化后保存到永久存储设备上，这个过程也叫做持久化。\n声明对象可序列化：一个对象能够序列化的前提是对象必须实现Serializable或者Externalizable接口。其中Serializable接口只是一个标识性接口，接口中没有定义任何方法，实现该接口仅是表示这个类可以被序列化而已。继承一个可序列化的类，其子类也可序列化，即序列化特性可以被继承。\n被序列化的对象中如果存在其它对象的引用，则其它对象的引用也会被序列化，并且引用的对象又包含其它对象的引用也会被序列化，也就是序列化会根据对象中的引用一层一层连接下去序列化。\n对象序列化的时候，如果对象中的某成员无法序列化，则会抛出NotSerializableException异常。此时，若将该无法被序列化的对象使用关键字transient（瞬间）修饰，则序列化的时候不会序列化该成员，对象的序列化能够正常进行。\n对象序列化的时候，不会序列化对象中的static变量和方法（因为它们属于类，不属于对象），也不会序列化被transient修饰的成员。只会将对象中的成员变量序列化，写入到字节流中（通过字节流可写入到存储设备上永久保存）。如果成员变量是一个对象的引用，则会按照同样序列化的规则序列化引用的对象，以此类推各个对象引用。\nObjectOutputStream类：继承了OutputStream类，并且实现了ObjectOutput接口，ObjectOutput接口又实现了DataOutput接口。构造方法有ObjectOutputStream（OutputStream out），可接收一个输出字节流，是一个过滤流，主要用于实现对象的序列化。另外，由于实现了DataOutput接口，所以类中包含大量写入各种类型数据的方法。\n将对象序列化的方法：使用ObjectOutputStream类的writeObject（Object obj）方法。默认会将obj的类、类的签名、以及类和其所有超类的非transient非static成员变量写入到输出流中，即实现了序列化。\nObjectInputStream类，继承了InputStream类，并且实现了ObjectInput接口，而ObjectInput接口又实现了DataInput接口。构造方法有ObjectInputStream（InputStream in），可接收一个输入字节流，也是一个过滤流，主要用于实现对象的反序列化。另外，由于实现了DataInput接口，所以类中包含了大量读取各种数据类型的方法。\n对象反序列化的方法：使用ObjectInputStream类的readObject（）方法，返回一个Object对象。由于对象在序列化的时候保存了对象的类信息，所以readObject方法无需参数，就能将当前游标所在位置后边的对象按该对象序列化时的类信息恢复出来。恢复的时候，并不会调用该对象类的任何构造方法，仅是根据保存的状态信息在内存中重新构建对象而已。又由于对象序列化的时候不会序列化transient修饰的成员变量，但保存的类信息中存在该成员的信息，所以反序列化后，被transient由于序列化时没有将值保存下来，其值只能是其数据类型的默认值。\n序列化和反序列化过程中，如果需要对对象进行特殊处理，不按照java提供的默认序列化和反序列化方法进行，可自定义序列化和反序列化的处理方法。方法为在需要被序列化和反序列化的类中实现两个方法： 1）序列化方法：private void writeObject（java.io.ObjectOutputStream stream）throws IOException{}；在方法体中写入自己的处理对象成员变量与写入ObjectOutputStream流的代码，当对该类对象进行序列化的时候便会调用这个方法进行序列化，不再使用默认序列化方法。 2）反序列化方法：private void readObject（java.io.ObjectInputStream stream）throws IOException，ClassNotFoundException{}；在方法体重写入自己处理对象成员变量与ObjectInputStream流的代码，当对该类对象进行反序列化的时候就会自动调用这个方法进行反序列化，不再使用默认的反序列化方法处理。\n进程：进程是一个运行中的程序，每一个程序运行的时候都需要在进程中执行代码，操作系统会为一个程序分配该程序进程所需要的资源，包括内存空间等。进程与进程之间的内部数据和状态都是完全独立的，所以进程与进程之间的切换代价比较高。\n线程：每个进程至少包含一个线程，一个进程可以包含多个线程，每个线程可独立完成进程中的一个工作，是程序内的一个顺序控制流，只能使用分配给程序的资源和环境。并且线程运行时只需要很少的资源，通常只有寄存器数据以及程序执行时的堆栈，所以线程与线程之间的切换代价比较小。同一个进程之间的线程共享一块内存空间和系统资源，它们有可能会互相影响。\n多任务处理包括基于进程和基于线程两种对任务处理，它们都是为最大限度使用CPU资源，以提高CPU效率。\nJava语言内置支持多线程变成，其他大多数编程语言都需要通过外部库链接来实现多线程编程。\nJava程序中，每当程序启动的时候都会自动启动一个线程，main方法就运行在这个自动启动的主线程上，因此这个线程也叫做main thread。每个Java程序至少都有一个线程，这个线程就main线程。\n","date":"June 4, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"装饰模式","url":"https://www.qinxiandiqi.sbs/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"title":"io","url":"https://www.qinxiandiqi.sbs/tags/io/"},{"title":"字符集","url":"https://www.qinxiandiqi.sbs/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"title":"序列化和反序列化","url":"https://www.qinxiandiqi.sbs/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"title":"JavaSE学习笔记 第十记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-29# Java的I/O系统主要由java.io包和java.nio包构成。\njava.io.File类对象表示了磁盘上的一个文件或者目录，在java的io系统中，文件和目录都统一使用File类对象表示，其父类是Object。File类只是对磁盘上的文件或目录的抽象表示，提供了与平台无关的对文件或目录的操作方法，比如获取路径或者文件及目录的相关信息，并对他们进行创建. 删除、改名等管理工作。然而File只是抽象描述了文件或目录的属性和操作方法，但并没有提供怎样从文件读取和向文件存储等方法。\n路径分隔符：由于java中反斜杠\\用作转义字符，所以路径中的反斜杠需要用双反斜杠\\转义表示。特别的，处理window系统中使用反斜杠做文件路径分隔符之外，其他系统都是使用正斜杠/做路径分隔符。因此，java中使用正斜杠/做抽象路径分隔符，无论什么系统使用正斜杠做路径分隔符，java都能自动转成系统适应的分隔符，所以推荐使用正斜杠/做java中的路径分隔符。\nFile的构造方法常用的有：File（String path）、File（File file，String str）、File(String str1,String str2)。值得注意的是，使用File构造方法构造一个File对象并不等于创建了这个File对象指向的文件或者目录，其中第二三个构造方法需要组合后能拼成一个正常的文件路径才不会影响到File对象对该文件或路径的操作。\nFile创建文件方法：createNewFile（）。只要File构造方法的参数路径存在，并且路径指向的文件不存在，就能够创建对应的文件。如果参数路径存在，且指向的文件也存在，则创建失败，返回false。如果参数路径不存在，则会抛出路径找不到的异常。\nFile创建目录的方法：mkdir（），该File指向的路径中，要创建的目录上一级路径不存在，则无法创建目录，返回false。mkdirs（），该File指向的路径中，要创建的目录上一级或上几级路径不存在，也能够正常创建目录，并把不存在的路径目录都创建出来。如果要创建的目录已经存在，则返回false。\nFile的isFile（）用于判断File是否指向一个文件；File的isDirectory（）用于判断File是否指向一个目录。\nFile的list（）用于将File指向目录内的所有内容的名字以字符串数组返回，包括文件和目录。File的listFiles（）方法用于将File对象指向的目录内所有File以File数组的形式返回。使用以上两个方法时，File对象必须时一个目录对象。\nFile的getName（）获取File对象指向文件的名字；File的getParent（）用于获取父目录名；File的getParnetFile（）用于获取父目录File对象；File的exists（）用于判断文件是否已经存在。File的delete（）用于删除File对象指向的文件（只有文件或者空目录才能删除，不为空的目录需要将目录内的所有文件都删除才能删除，一般是由递归算法）。\nFileNameFilter接口，常用作list（FileNameFilter filter）或listFiles（FileNameFilter filter）方法的参数，以返回目录下符合一定条件的文件名或文件File对象。一般是在参数列表中使用匿名内部类实现这个接口，该接口只包含一个方法accept（File dir，String name），筛选目录下文件的筛选方法就写在这个accept方法体中。\nFile.separator静态常量，用于表示与系统有关的默认名称分隔符，在路径中可以始终File.separator代替路径的分隔符以组成完整的路径字符串。单独的File.separator表示根目录，即盘符。\n递归：方法内部再调用自己，或者一个方法调用另一个方法，而另一个方法又调回原来的方法。递归的特点就是循环嵌套调用，并且使用递归的方法中必须提供一个结束递归的出口（一般是一个if条件判断）。递归的过程分为递进和回归，先一层一层调用到出口层，返回确定结果后再一层一层将结果返回到最顶层。\nJava的流（Stream）：Java的程序通过流来完成输入和输出，是生产或者消费信息的抽象，它通过java的输入和输出系统与物理设备连接，并且屏蔽掉设备之间的差异性，对于不同的物理设备，流都具有同样的行为方式。\n输入流和输出流：根据程序在使用数据时扮演的角色不同，流可以分为输入流和输出流。当程序从外部读取数据时，也就是程序是数据流的目的地，此时的数据流为输入流；当程序输入数据到外部时，也就是程序是数据流的源头，此时的数据流为输出流。总的来说，输出流和输入流是一种以程序为中心的相对概念。\n字节流和字符流：根据流结构上的不同，将流分为字节流和字符流。字节流以字节为处理单位，即八位二进制数据，一般用于读写图像或者声音等二进制数据。字符流以采用了统一编码标准的16位字符为单位，因此字符流可以国际化，在某些场合下，字符流具有比字节流更高的效率。\n综合输入输出流和字节字符流，可以将流再细分为：输入字节流（以InputStream抽象类为父类）、输出字节流（以OutputStream抽象类为父类）、输入字符流（以Reader抽象类为父类）、输出字符流（以Writer抽象类为父类）。\nJava 1.0只存在字节流，Java 1.1开始出现字符流。字符流的出现只是为了处理字符提供方便有效的办法，但是字符流的底层本质上还是以字节的形式处理。\n流读取数据的逻辑：\n打开一个输入流 循环判断是否还存在数据信息，如果还有数据信息，则读取一定单位的数据信息并继续循环，直到没有剩余数据信息为止。 关闭输入流 流存储数据的逻辑：\n打开一个输出流 循环判断是否还有需要存储的数据信息，如果还有数据信息，则存储一定单位的数据信息并继续循环，直到所有数据信息都存储完毕为止。 关闭输出流。 根据流是否与目标直接打交道，可以将流分为节点流和过滤流。节点流直接与需要从中读取数据或者需要从中输出数据的目标打交道，比如从硬盘上某文件读取数据的流、程序输出数据到硬盘某个文件的输出流。过滤流是与节点流或者其他过滤流打交道的流，也就是它不直接与数据目标打交道，它的作用在于将节点流或者过滤流再封装以增加更多的数据信息和处理方法，并且它是同步的。\n所有流的关闭方法都是close（）。\nInputStream的三个read方法：\nread()，三个read方法中唯一的一个抽象方法，规定从输入流中读取数据的下一个字节。因为不同子类read的具体需要不同，所以设计此read抽象方法以供子类实现时设计符合自己具体要求的read（）方法。 read（byte[] b，int off，int len），本质上是方法体内通过对read（）方法的调用，来实现从数据流中读取不超过len个字节到以off索引为起始位置的b字节数组中去，返回值为实际读取的字节个数，如果没有字节可读取则返回-1。因为每个子类的read（）实现方法不同，所以子类继承这个方法就能根据子类read（）的读取规则完成这个方法的逻辑。 read（byte[] b），本质上是调用read（b，0，b.length）。 String类具有一个将字节数组转换为字符串的构造方法：String（byte[] b，int off，int length），可以构造一个b数组中以off索引为其实位置，长度为length的字符串。String类也提供了getbyte（）方法将字符串转换为byte数组。\nOutputStream的三个write方法（类似于InputStream三个read的原理）：\nwrite(int b)，三个write方法中唯一的一个抽象方法，规定将b个字节写入到输出流中。因为不同子类write的具体需要不同，所以设计此read抽象方法以供子类实现时设计符合自己具体要求的write（int b）方法。 write（byte[] b，int off，int len），本质上是方法体内通过对write（int b）方法的调用，来实现将b字节数组中从off索引为起始位置的len个字节写入到输出流中，没有返回值。因为每个子类的write（int b）实现方法不同，所以子类继承这个方法就能根据子类write（int b）的写入规则完成这个方法的逻辑。 write（byte[] b），本质上是调用read（b，0，b.length）。 FileInputStream继承了InputStream，是关于File的字节输入流。构造方法有FileInputStream（String url）、FileInputStream（File file）等，用于获取file指向的文件或者url路径指向的文件的字节输入流。\nFileOutputSteam继承了OutputStream，是File的字节输出流。构造方法有FileOutputStream（File file，boolean append）和FileOutputStream（String url，boolean append），file或者url表示输出流要写入的file或者url指向的文件，如果文件不存在则会自动创建这个文件；append为true则当文件已经存在的情况下，使用write会将写入字节追加到文件尾，若为false则会删除文件的全部内容，然后写入。FileOutputStream（File file）和FileOutputStream（String url）的本质是对应前两个构造方法，append值为false的构造方法。\nByteArrayInputStream继承了InputStream，以byte数组为输入源的字节流，内部包含一个buf字节数组缓冲区（即要读取的数据）。构造方法有ByteArrayInputStream（byte[] buf，int off，int length），构造一个buf为缓冲区数组的字节数组输入流，并且将要读取的开始索引位置为off，读取的字节个数为length。另一个构造方法ByteArrayInputStream（byte[] buf）的本质为ByteArrayInputStream（buf，0，buf.length）。\nByteArrayOutputStream继承了OutputStream，以byte数组为输出对象的输出流，内部包含一个buf字节数组缓冲区（存放写出的数据）。构造方法有ByteArrayOutputStream（）和ByteArrayInputStream（int size）。使用它的write方法可以将一个byte数组写入到它的六种buf字节数组缓冲区，再使用它的toByArray（）方法创建一个新的byte数组存储流中的buf字节数组，也可以使用它的writeto（OutputStream out）方法将buf的全部内容写到输出流out中去。\nFilterInputStream是继承InputStream的输入字节过滤流抽象类，输入字节过滤流都必须继承这个类，java提供的子类有DataInputStream（常用）、BufferedInputStream（常用）、LineNumberInputStream、PushbackInputStream。\nFilterOutputStream是继承OutputStream的输出字节过滤流抽象类，所有输出字节过滤流都必须继承这个类，java提供的子类有DataOutputStream（常用）、BufferedOutputstream（常用）、PrintStream。\nDataInputStream：数据字节输入流，构造方法为DataInputStream（InputStream in），相当于将in输入流再进行包装成DataInputStream。内部提供了大量读取基本数据类型的方法，这些方法将按照对应数据类型的字节长度依次读取in中的数据。例如：readBoolean（）、readByte（）、readChar（）、readDouble（）等等。\nDataOutputStream：数据字节输出流，构造方法为DataOutputStream（OutputStream out），相当于将out输出流再进行包装称DataOutputStream。内部提供了大量写入基本数据类型的方法，这些方法会按照对应的基本类型占用的字节长度，以二进制的形式写入到out中。例如：writeBoolean、writeByte、writeBytes、writeChar、writeChars等。\nBufferedInputStream：字节缓冲输入流，内部具有buf字节数组缓冲区，构造方法有BufferedInputStream（InputStream in）和BufferedInputStream（InputStream in，int size），用于将in输入流包装称BufferedInputStream，带有size时可指定内部buf缓冲区数组长度为size。使用它的read读取in数据，并不会直接将读取的数据存入到接收数据的数组b中，而是先存到内部buf数组中，等到buf数组满了后再一次把数据读回，使用close关闭流之前会强制将buf中数据返回。\nBufferedOutputStream：字节缓冲输出流，内部具有buf字节数组缓冲区，构造方法有BufferedOutputStream（OutputStream out）和BufferedOutputStream（OutputStream out，int size），用于将out输出流包装称BufferedOutputStream，带有size时可指定内部buf缓冲区数组长度为size。使用它的write并不会直接将数据写出去，而是等到buf数组满了后再一次性写出去，或者调用flush（）时强制将buf中数据写出去，使用close关闭流时也会强制写出去。\n","date":"June 2, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B9%9D%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"io","url":"https://www.qinxiandiqi.sbs/tags/io/"},{"title":"文件系统","url":"https://www.qinxiandiqi.sbs/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}],"title":"JavaSE学习笔记 第九记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-27# AWT：Java第一代的GUI，是重量级的，将实际生成界面组件的操作委托给具体的操作系统GUI相关的API去完成，所以不同的操作系统生成的界面外观和感官是不同的。\nSwing：Sun推出的GUI组件，属于轻量级，可以屏蔽掉操作系统实现的细节。\nAWT中所有的容器类都继承与java.awt.Container，主要包含Window和Panel两个子类。Window主要包含Frame和Dialog框架类，是顶级窗口容器，相当于图形界面程序的最外层。Panel主要是包含各种组件面板容器（所有组件必须包含到一个容器中），并且Panel无法单独显示，必须添加到一个容器中。每个Panel都有自己的布局管理器，即使是添加到其他Panel中的Panel。\n布局管理器：能够根据相应布局管理器的规则自动管理容器中组件的大小和位置，通过setLayout（）设置容器的布局管理器。使用布局管理器后，容器中组件的setLocation（）、setSize（）、setBounds（）方法的设置都会被屏蔽。\nFrame必须设置setVisible（Boolean bool）方法为true，窗口程序才可见。Frame的pack（）方法调用后会以正常显示Frame内所有组件最佳的比例显示窗口。\nBorderLayout布局管理器：将组件分为东南西北中五个区域，是Frame默认的布局管理器。其中每个区域只能加入一个组件，如果加入过个组件，则后加入的组件会覆盖之前的组件。当容器发生大小变换的时候，南北区域只能在水平方向上缩放，东西区域只能在垂直方向上缩放，中间区域可再垂直方向和水平方向上一起缩放。当一个区域没有填充组件的时候，其他区域会自动延伸。\nFlowLayout布局管理器：流布局管理器，Panel默认的布局管理器，将组件按顺序排列，默认是按行排列，不会改变组件大小，但是当一行容不下所有组件时，会自动换行。\nGridLayout布局管理器：网格布局管理器，组件按行从左到右添加，行满换行继续添加。一个组件可以跨越多个网格。\nCardLayout布局管理器：将界面看做一系列卡片的布局，并且在一个时刻只能显示一个卡片的内容，使用show（）方法切换卡片。\n事件模型包括：事件（事件也是一个对象，集成了相关事件的信息，通过传递事件将事件信息给处理方法）、事件源、事件处理器（接收事件、解释事件并处理用户交互的方法）。\nJDK1.0的事件模型是层次模型，事件产生后会在产生事件的组件类处理，如果处理不了则会由包含组件的容器处理器，知道到Frame也无法处理的话，则不处理。这种模型的弊端是会造成事件处理方法的混乱，很难辨清事件到底会在哪里被处理，故从JDK1.1开始不再使用这种事件模型，而是委托模型，将事件处理委托给指定的监听器处理，一个组件的某个事件对应一个监听器，如果没有对应的监听器则不会由上层容器的监听器处理，即不会处理这个事件。\n典型的事件类型：MouseEvent（鼠标事件，包含了关于鼠标位置等鼠标操作信息）、WindowEvent（窗口事件，包含窗口关闭等窗口操作信息）、ActionEvent（动作事件，包含相应组件基本操作的信息）。\n委托模型的处理过程：当一个组件产生一个事件后，该组件对应这个事件所注册的监听器addXxxListener（XxxListener l)，即参数XxxListener e（一般XxxListener是一个接口，使用的时候需要使用该接口的实现类）的事件处理器方法处理事件。以Button为例，单击Button后产生一个ActionEvent事件，ActionEvent事件会传递给被其注册的所有ActionListener（Button的addActionEListener（）所注册）的actionPerformed（ActionEvent e）方法接收，并执行这个方法。\nActionEvent类的getActionCommand（）方法可放回与动作相关联的命令名称，比如Button返回的Button的标签名。另外，该类中还有方法getWhen（）返回发生该事件的事件。\n委托模型使用步骤： 1）编写监听器XxxListener中相关事件处理方法：一般AWT提供相应监听器XxxListener接口，事件的处理方法需要自定义监听器类实现这个接口，并重写这个接口中所有方法（可通过JDK帮助文档获得接口中所有的方法），把事件的处理代码放置到重写的方法中。特别的，JDK提供了适配器Adapter，Adapter适配器是实现了一个或多个接口的类，但是实现的接口方法体为空，什么事情也不做。JDK中提供了大量事件监听器接口的适配器XxxAdapter，因此，只要继承相应监听器适配器，就可以只重写监听器接口中需要用到的几个方法，以提升开发效率（如果自定义的监听器已经继承了其他类，那么只能实现接口这种方法）。 2）为组件注册相应的监听器：可通过查询JDK文档得知该组件能够注册的监听器类型的方法。一般注册方法的格式为addXxxListener（XxxListener l），只要将自定义的监听器实例引用作为该方法参数即可向该组件注册监听器。同一个组件可以注册多个XxxListener类型的监听器。 3）当组件接收到相应操作产生相应事件后，会根据该组件注册的监听器匹配处理该事件的监听器，并将事件对象发送给注册的处理这个事件类型的所有监听器，存在次事件的多个监听器时，它们都会接收到事件和执行处理。 4）特别的，经常将步骤1和2合并，使用内部类监听器作为addXxxListener（）的参数。\nInput is evil！\n观察者模式（Observer）：该模式定义了一种一对多的依赖关系，使多个观察者对象同时监听某一个主题对象。只要主题对象在状态上发生了变化，主题对象就会通知所有的观察者对象，让它们更新自己的状态。\n观察者模式的组成： 1）抽象主题角色：主题角色之所以能被观察者角色监听，原因在于主题角色中存在一个保存了该主题角色对所有观察者对象的应用的集合。抽象主题角色一般是一个抽象类或者接口，并且至少要提供增加或删除观察者角色对象应用的方法，以及通知观察者对象主题角色状态发生改变的方法。 2）具体主题角色：是抽象主题角色的子类或者实现对象，具体包含了一个或多个观察者类型的集合，并且实现了抽象主题角色中的方法，同时也具有具体自我特征的成员变量和方法。 3）抽象观察者角色：一般也是一个接口，定义了更新自己的方法以供主题角色的通知观察者方法调用。 4）具体观察者角色：实现抽象观察者角色接口的类，实现了具体供主题角色通知方法调用的更新自己状态的方法，以便与主题角色状态相协调。在需要的情况下，还可以保存一个指向具体主题角色的引用。\n观察者模式的基本使用步骤： 1）定义抽象主题角色和抽象观察者角色：一般都是接口。抽象主题角色添加或删除观察者角色方法的参数类型是观察者接口类型；它的通知观察者方法参数一般是一个对象（在事件处理机制中，一般是一个事件对象），并且会调用观察者接口中更改观察者状态的方法。抽象观察者角色更改自己状态方法的参数一般是抽象主题角色通知方法的参数类型。 2）定义具体主题角色和具体观察者角色：都是实现了抽象主题或观察者的类。具体主题角色类中要定义抽象观察者类型的集合，增加或删除观察者方法负责把参数观察者添加或删除到集合中；通知观察者的方法中要遍历每一个集合，调用每个集合中元素及观察者类的更改自己状态的方法。观察者类中要具体实现更改自己状态的方法。 3）new具体主题角色类和具体观察者类，使用主题角色的添加观察者方法添加观察者对象（也就是常说的注册观察者）。\n观察者模式运行过程：当部署好主题角色和观察者角色后，一旦主题角色触发通知观察者的方法（可以是主题角色对象显示调用，或者是主题角色上定义了某些操作可以调用这个方法），观察者的更改自己的状态方法就会被调用。由此，实现了多个观察者对主题角色对象的依赖关系。\nGUI程序的事件机制实质上就是观察者模式的运用，其中每个组件是一个具体主题对象，每个监听器是一个具体观察者对象。一旦某些操作触发了组件，底层实质是调用了通知观察者方法通知注册到组件上的每一个监听器，让它们调用更改自己状态的方法，而实现了事件处理。\n2012-07-28# Swing组件主要存放于Javax.swing和Javax.swing.event两个包中。\nSwing的三个顶层容器：JFrame、JDialog、JApplet。每一个顶层容器都默认包含一个content pane，用于包含顶层容器中所有的组件，但是不包括菜单。也就是说，顶层容器主要包括两个元素：content pane和菜单。\n菜单的三级元素：MenuBar、Menu、MenuItem。\nSwing提供的便捷关闭方法：Frame.setDefaultCloseOperation（JFrame.EXIT_ON_CLOSE）。\nJDK对观察者模式提供了内置的支持：JDK提供了java.util.Observable主题类和Observer抽象观察者接口。\nObservable主题类：该类提供了主题类应该具有的所有方法，类中存在保存Observer接口类型的观察者Vector集合。定义的主要方法有：addObserver（Observer o），当o与已有的观察者对象不同时，向集合中添加；deleteObserver（Observer o），向集合中删除观察者o；setChanged（），当主题类状态发生改变时，通过该方法记录已经发生了改变；notifyObservers（Object arg），通知所有观察者主题对象状态发生改变，会调用每个观察者对象中的update方法，并将参数arg传递过去。前提是Observable状态发生了改变，因为notifyObservers方法体中存在if语句判断状态改变常量changed是否为true，true的时候才会调用观察者中的update（如果changed为true，那么if的else最后会调用clearChange方法将changed改回false）。因此，在调用notifyObservers之前必须调用setchanged才会执行观察者中的update。\nObserver观察者接口：接口中只定义了一个方法update（Observable o，Object arg），具体的观察者需要实现这个接口。当主题类Observable的notifyObservers方法被调用时，会调用观察者这个update方法，其中o是观察者观察的主题对象，arg是被观察主题对象notifyObservers方法传递过来的参数。update实现对观察者自身状态的修改，以协调主题对象状态的改变。\n内部类：一般的类都是定义在package下，属于package级别类；而内部类是定义在类或方法内部的类。内部类分四种类型：静态内部类、成员内部类、局部内部类、匿名内部类。\n静态内部类：定义在类内部，并且被static修饰，可以访问外部类的静态成员变量和静态方法。\n静态内部类相当于外部类的一个静态成员变量，属于类的静态成员，只是这个成员是外部类内部自己定义的一个类。在外部类的内部使用静态内部类，可以直接像使用普通类的方法使用静态内部类即可。在外部类外部，由于静态内部类类似于外部类的静态成员，所以外部类外部使用静态内部类与使用外部类静态成员方法相同，格式为“外部类名.静态内部类名”，也可以看做静态内部类的实际类名为“外部类名.静态内部类名”。因此，在外部类外部构造静态内部类实例，使用“new 外部类名.静态内部类名()”格式构造（括号内参数由静态内部类的构造方法决定）。 对于静态内部类使用外部类静态成员变量和方法，只要外部类存在该静态成员和方法，在静态内部类中就可以直接调用。但如果静态内部类内部存在和外部类相同名字的静态成员变量和方法，则根据java的就近原则，静态内部类使用的是静态内部类的静态成员变量和方法。要是非得使用外部类的静态成员变量和方法，则需要在变量名和方法名前加“外部类名.”前缀来强制使用外部类的静态成员变量和方法。 含有静态内部类的类编译后，除了生成外部类的class文件之外，同样会生成静态内部类的class文件，文件名为“外部类名$静态内部类名.class”。 成员内部类：定义在类内部，与静态内部类的区别在于少了static修饰，可以访问外部类的任何成员变量和方法。\n成员内部类，相当于外部类的一个成员，只是这个成员是由外部类中自己定义的类。在外部类内部，可以像使用普通类的方法直接使用成员内部类（构造的时候，new 内部类名的new前默认存在“this.”)。在外部类外部，由于成员内部类相当于外部类的一个成员，而访问类的成员必须通过类对象访问。所以要先构造一个外部类对象才可以构造一个成员内部类的对象。成员内部类的类名依然可以看做是“外部类名.成员内部类类名”，构造成员内部类的方法本质是：外部类名.成员内部类类名 成员内部类引用变量名 = 外部类对象.new 内部类名（）。通常的做法是：外部类名.成员内部类类名 成员内部类引用变量名 = new 外部类名（）.new 内部类名（）。 对于成员内部类使用外部类成员变量和方法，只要外部类存在该成员变量和方法，成员内部类就可以直接使用。如果成员内部类定义了和外部类成员变量和方法相同名称的变量和方法，那么根据java就近原则，成员内部类将使用自己的变量和方法。但要是非得使用外部类的变量和方法，则需要在变量名和方法名之前加前缀“外部类名.this.”以表示使用的是外部类变量和方法。 含有成员内部类的类编译后，同样除了生成外部类的class文件之外，也会以“外部类名$内部类名.class”的形式生成成员内部类的class文件。 局部内部类：定义在方法内部的类，只能访问方法中final修饰的变量，外部类外部无法访问到局部内部类，局部内部类是给方法是用的，一般很少是用局部内部类。\n局部内部类，相当于类的局部成员，存在于方法中，只能被方法使用。在方法中可以像普通类使用方法一样使用。 对于局部内部类使用方法中局部变量的方法，只要是方法中存在的final修饰的局部变量，局部内部类就可以直接使用。如果方法中存在final修饰的局部变量与局部内部类中的成员变量同名，则根据就近原则，局部内部类将访问到局部内部类自己的变量，并且此时没有方法访问方法的局部变量。如果局部内部类要访问外部类的成员变量和方法，同样可以使用“外部类名.this.”前缀加外部类成员变量或者方法访问到。 包含局部内部类的类编译后，除了生成外部类的class文件之外，同样也生成“外部类名$1局部内部类名.class”的局部内部类class文件（相比前两种内部类class文件，文件名$之后多了“1”）。 匿名内部类：定义在方法内部，没有类名，没有构造方法，不需要class关键字定义，只能访问方法中final修饰的局部变量，可以说是局部类的变形，是一种比较常用的内部类，比如事件机制中的监听器常用匿名内部类定义。\n匿名内部类的使用：匿名内部类默认要继承一个类或者实现一个接口，使用“new + 默认要继承的类名或者接口名(参数由继承的类或实现的接口构造方法决定){匿名内部类代码}”的方式定义并构造一个匿名内部类对象。 同局部内部类一致，只能访问方法中final修饰的局部变量，如果局部变量名与匿名内部类变量名相同，根据就近原则使用匿名内部类变量。如果要使用外部类变量，同样加前缀“外部类名.this.”。 包含匿名内部类的类编译后，除了生成外部类的class文件之外，也同时也生成内部类“外部类名$+阿拉伯数字.class”的class文件，$后的阿拉伯数字由1向上递增。 ","date":"June 2, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%85%AB%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"AWT","url":"https://www.qinxiandiqi.sbs/tags/awt/"},{"title":"Swing","url":"https://www.qinxiandiqi.sbs/tags/swing/"},{"title":"Java内部类","url":"https://www.qinxiandiqi.sbs/tags/java%E5%86%85%E9%83%A8%E7%B1%BB/"}],"title":"JavaSE学习笔记 第八记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-25# 每一个动态代理类都对应一个动态调用处理器InvocationHandler，因为动态代理类不具备方法的实现，动态代理类的方法依赖于动态调用处理器InvocationHandler的invoke方法来实现。\n静态代理的真实类和代理类关系是：真实类和代理类都是抽象角色的子类或者实现，并且代理类含有真实类的引用，通过代理类操作真实类。而策略模式对抽象角色子类的使用都是通过抽象角色来使用，策略模式的子类之间不能互相使用，因为一个子类没有包含另一个子类的引用。\n动态代理的真实类和代理类关系与静态代理的真实类和代理类关系类似，区别在于动态类的定义和实现逻辑与静态代理类不同。静态代理每一个真实类都必须手动定义一个代理类，并且每一个静态代理类中都必须重写真实类中的每一个方法（即抽象角色中的方法），这么一来，一旦真实类的数量多起来，需要手动定义的类数量将急剧上升，造成类数量的臃肿。而动态代理类的实现是通过InvocationHandler动态调用管理器和Proxy类在运行时动态定义和构造，定义一个包含Object引用变量的InvocationHandler实现类，就可以动态定义和构造任意真实类的代理，并且由于动态代理类的方法实现是交付给InvocationHandler的invoke方法实现，而InvocationHandler的invoke方法又是由这个方法中接收的参数method的invoke实现，所以动态代理类不需要对应真实类的每一个方法重写，一律使用InvocationHandler的invoke动态实现真实类方法的重写和调用。如此一来，动态代理的好处就是不用手动定义每一个代理类和代理类中的方法，被代理的独享可以在运行时动态改变，动态代理类实现的接口也可以在运行时改变，从而实现了灵活的动态代理关系，降低了定义类的数量。\nJava Annotation：Java注解，JDK1.5新增的特性。\nJDK1.5提供的三个常用注解：\n@Override（位于java.lang.Override），只能注解方法，在方法定义前使用该注解表示这个方法必须重写一个父类或接口的方法，如果没有则编译不通过，该注解可达到在编译时检查有无重写方法的作用。 @Deprecated（位于java.lang.Deprecated），在方法定义前使用该注解表示该方法不建议被使用（一般是有更好的替代方法，或者该方法不够安全），注解后该方法名会被删除线划上，并且在调用该方法时会有不建议使用的警告。 @SuppressWarnings（String[]）（位于java.lang.SuppressWarning），可注解除了注解类型之外的其它所有类型，接收一个字符串数组，可注解一个类或者方法。注解的功能由接收的字符串数组决定，常用的参数有“unchecked”表示压制检查警告，“Deprecated”表示压制使用不建议使用方法警告等等。当一个类被一个@SuppressWranings注解后，类中每一个方法都默认被这个注解注解，当类中方法还被自己的注解注解时，这个方法同时被两个注解注解。 定义自己的注解类型：与定义接口类似，但是使用@Interface标志代替Interface，如public @Interface MyAnnotation{注解内容}。\n当自定义注解中包含定义属性时，要在属性名后加（），如“public String value（）；”，否则编译错误。如果要设定注解的默认值，要在属性名的()后使用“default + 属性值”的方式设置属性的默认值。\n使用带属性的自定义注解时，要在注解名后加（），并在括号内传递注解属性值，如@MyAnnotation（“myAnnotation”）。同时，若注解的属性名为value时，使用注解的括号内可直接写属性值，否则必须使用name=value的形式对应传递注解的属性参数，当属性有多个的时候，按照这个形式用逗号隔开就可以。\n自定义注解的方法只有使用@Interface一种，使用这个方法自定义的注解编译器默认会继承java.lang.annotation.Annotation接口。但是如果手动写一个接口继承这个java.lang.annotation.Annotation，这个接口也不是注解，就算是原来的这个java.lang.annotation.Annotation接口也不是一个注解。\n如果自定义的注解与使用注解的类不在同一个包中，那么同样需要把包含注解的包导入到使用注解的类中，导入方法与导入类包的方法相同。\n自定义的注解不能继承其它的Annotation类型（其它已定义的注解）或者接口，但是可以使用其它已定义的注解来注解自定义的注解。\n注解@Retention（位于java.lang.annotation.Retention):，只能用于注解注解类型，使用@Retention注解自定义注解类型可以告知编译器如何处理自定义的注解类型信息。\n枚举类型RetentionPolicy（位于java.lang.annotation.RetentionPolicy）：包含三个枚举常量SOURCE、CLASS、RUNTIME。SOURCE常量表示编译程序只在编译时使用注解信息，但不将注解信息保存到class文件中，所以不会在JVM中被读取；CLASS枚举常量表示编译器会在编译的时候使用注解信息，并且会将注解信息保存到class文件中，但是在VM加载class文件时不读取；RUNTIME枚举常量表示编译器在编译时会使用注解信息，并且会将注解信息保存到class文件中，在JVM运行时加载class文件会通过反射机制的API获取注解信息。\n@Retention注解中包含一个RetentionPolicy枚举类型的属性（属性名为value，所以使用这个注解时可以直接传递参数），并且属性值默认是CLASS枚举常量。通过使用@Retention注解并制定其枚举常量来注解自定义注解类型，以此达到控制编译器处理自定义注解类型信息方法的目的。\n通过实现反射机制的相关类获取@Retention（RetentionPolicy.RUNTIME）注解的注解类型信息：实现反射机制的相关类Class、Method、Constructor、Field、Package等都直接或间接实现了AnnotatedElement接口，AnnotatedElement接口中提供了四个与Annotation相关的方法。因此，使用反射机制的相关类调用实现了的AnnotatedElement接口方法，可以获得该反射相关类代表的部分上是否存在@Retention（RetentionPolicy.RUNTIME）注解的注解类型以及其注解信息。\nAnnotatedElement接口四个方法：\n\u0026lt;T extends Annotation\u0026gt; getAnnotation(Class\u0026lt;T\u0026gt; annotationClass\u0026gt;，如果存在annotationClass（该参数为注解的.class）注解类型的注解，则返回这个注解。 Annotation[] getAnnotations（），如果存在注解则以注解数组形式全部返回。 Annotation[] getDeclaredAnnotations()返回直接存在于此元素上的所有注释。 boolean isAnnotationPresent\u0026lt;Class\u0026lt;? extends Annotation\u0026raquo;，接收一个Annotation类型，如果该元素上存在这个Annotation注解类型，则返回true，否则返回false。 通过反射机制相关类获取注解引用变量后，可以利用这注解引用变量获取该注解中属性的值，获取方法为“注解引用变量.注解属性名()”，与对象获取属性值的方法后多加一个括号。\n注解@Target（ElementType[]），只能用于注解其它注解类型，接收一个ElementType枚举常量数组，表示被注解的注解类型能用于注解什么元素，由ElementType数组值决定。\nElementType枚举类型常量值：ANNOTATION_TYPE（只能注解注解类型）、CONSTRUCTOR（注解构造方法）、FIELD（注解属性）、LOCAL_VARIABLE（注解局部变量）、METHOD（注解方法）、PACKAGE（注解包）、PARAMETER（注解参数）、TYPE（注解类、接口、注解类型、枚举声明）。\n@Documented只能用于注解注解类型，被它注解的注解类型所注解的元素在生成JavaDoc帮助文档的时候，会在相应元素上显示这个注解类型。如果没有使用@Documented注解的注解类型在生成JavaDoc帮助文档的时候不会保存到文档上。\nEclipse生成JavaDoc方法：Project-Generation Javadoc\n@Inherited注解只能注解注解类型，当一个元素被它注解的注解类型注解后，继承该元素的元素能够被继承这个注解类型，反之则不会继承。\n2012-07-26# JUnit：Java单元测试，经典版本有JUnit3.8（完全基于反射机制设计）和JUnit4.x（基于反射机制和注解设计）\n使用JUnit需要导入JUnit库（JUnit.jar）。\n使用JUnit3.8的类需要导入包import junit.framework.TestCase，并且使用的类需要继承TestCase类，同时需要进行单元测试的方法名必须以test开头，如果不以test开头则进行JUnit测试的时候不会测试这个方法。\n使用JUnit4.x的类需要导入包org.junit.Test，并且在需要测试的方法前添加注解@Test，那么使用JUnit测试的时候就会测试这个方法，否则不会测试。\nJUnit原理（执行步骤）：\n先获得需要测试类的Class对象。 通过Class对象获取测试类中所有public类型方法的Method数组。 遍历Method数组，取出每一个Method对象。 如果是JUnit3.8，则判断Method对象对应的方法名是否是test开头，是则执行这个方法，否则不执行；如果是JUnit4，则会调用每一个Method对象的isAnnotationPresent（Test.class），判断方法是否被@Test注解，是则调用method.invoke（）执行该方法，否则什么都不做。 异常类：java.lang.Exception，java中所有的异常类都直接或间接的继承Exception。\n异常和错误：即Exception和java.lang.Error，它们都继承与java.lang.Throwable类，Exception异常是指可以处理的程序错误，而Error错误是不可处理的程序错误。\n运行时异常：也叫unchecked异常，java.lang.RuntimeException（直接继承Exception）或者直接及间接继承RuntimeException的异常，是运行期间抛出的异常，此类异常可以不必进行自行处理，JVM会自行处理，一般也不建议进行自行处理。\n非运行时异常：也叫checked异常，所有直接或间接继承Exception但非继承RuntimeException的异常都叫非运行时异常，此类异常必须自行进行异常处理，可以通过try-catch-finally处理，也可以使用throws处理。\n异常抛出的位置：\n当程序运行的代码行出现异常时，会自动生成相应的异常类并抛出。 new一个异常类，并使用throw关键字抛出。 处理异常的方法：\ntry{}catch（Exception e）{}finally{}： 将可能出现异常的代码放置到try后的{}代码块中，如果其中代码出现异常，则会在出现异常的代码行生成一个对应的异常对象并抛出和不再执行try中出现异常之后的代码。此时会按照catch排列顺序遍历try之后的catch（try之后可以跟多个catch，也可以将catch省略，但省略后必须跟finally），当其中一个catch参数异常类类型与抛出异常类类型符合时，则执行这个catch代码块中的方法。不存在抛出类型与所有catch不匹配的情况，因为若存在可能抛出的异常与所有catch不匹配时，程序在编译的时候根本不能编译通过。另外，匹配catch参数的时候也只会有一个catch匹配，因为每次最多只有一个异常抛出。特别的，由于匹配catch是按照前后顺序匹配，如果多个catch的异常参数类型中存在继承关系，那么必须要将父类异常类型参数的catch排在子类catch之后，否则子类catch异常将永远没有机会调用，编译时不能通过并会提示子类catch无法到达，而没有继承关系的catch则先后顺序没有关系。try-catch之后，无论异常是否处理，都会执行finally中的代码，即使是try代码块中存在return，也会在return语句调用之前先执行finally代码块。但是如果try代码块中存在System.exit（0）语句，则不会执行finally代码块，因为exit（0）是结束JVM的语句。整个try-catch-finally执行完毕后，会继续执行这个处理结构之后的代码（如果处理结构中没有catch则不会执行结构之后的代码）。注：一般不将声明变量的代码放置到try代码块中，如果在try代码快中声明变量，那么在try-catch-finally结构之外使用声明的变量将会出现编译错误。 定义类时使用throws抛出相应异常：如果定义一个类的时候，类中代码可能抛出异常，可以在定义类的参数列表括号后使用“throws+对应异常类[,对应异常类]”来将异常抛出但是不处理这个异常。处理异常的方法在于调用该类方法的方法中，要用try-catch-finally结构处理，如果调用该类方法的方法没有处理，继续使用throws将异常抛出到上一级调用方法。如果都没有提供处理方法，继续用throws抛出知道main方法都继续throws，那么这个异常会JVM处理。 try-catch-finally结构和throws组合：在catch代码块中再使用throw抛出一个异常，并用throws将异常抛到方法外。这种做法通常用于捕获代码自动生成的异常，并将这个异常重新包装成自定义的异常类，再以自定义的异常类抛出去处理，有利于形成具有特定处理信息的异常类。 常见的运行时异常：NullPointerException，空指针异常，由于调用了某个对象的方法，但是该对象引用的值为null所导致。\n自定义异常类需要继承一个异常类，一般是Exception，也有继承RuntimeException，但比较少。Exception中含有一个带参数的构造方法Exception（String str），str为异常的描述信息，使用Exception继承的printStackTrace（）方法可以打印出异常描述信息和异常出现位置（JVM处理异常一般也是调用这个方法）。\n使用自定义异常类的方法通常是利用一些判断结构，如if结构，在判断出出现自定义异常的地方使用new，构造一个自定义异常类，并用throw将其抛出，同时在该方法声明后面使用throws抛出。之后处理自定义的方法与其他异常类的处理方法一致。\n","date":"June 1, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%83%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"Java注解","url":"https://www.qinxiandiqi.sbs/tags/java%E6%B3%A8%E8%A7%A3/"},{"title":"Java异常","url":"https://www.qinxiandiqi.sbs/tags/java%E5%BC%82%E5%B8%B8/"},{"title":"JUnit","url":"https://www.qinxiandiqi.sbs/tags/junit/"}],"title":"JavaSE学习笔记 第七记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-23# 枚举类型(JDK1.5增加的新特性）：严格来说并不是类，但是具有跟类相同的级别。类似于类定义，使用与类class相同级别的关键字enum来定义枚举类型，例如：public enum Color{RED, BLUE}。可以单独用一个java源文件定义一个枚举类型。定义声明之后，使用枚举的方法都与类的使用方法一致。\n枚举类型提供了两个静态方法：values()和valueOf()。values()返回枚举类型的数据数组。valueOf()方法将一个与成员变量名称相同的字符串自动转换成对应的枚举成员。\n枚举类型的本质是一个继承java.lang.Enum的类，枚举类型的每一个枚举成员实质上就是一个枚举类，并且这个枚举成员是final和static以及public修饰的，所以枚举成员可以直接用“枚举类型.成员”使用。从本质上，在枚举类中照样可以定义普通类成员变量和方法，包括构造方法，一旦定义了构造方法，那么定义枚举成员的时候也要使用构造方法的形式（本质是构造枚举对象）。而且，枚举类型中的成员（类）不同于普通类，它们是在编译的时候直接生成，编译后在运行时不能再改变，也就是说在编译后枚举类型就已经完全确定下来了。\nJDK1.5增加了类似C语言的格式化输出，System.out.printf(\u0026quot;%d,%s\u0026quot;,a,b)。\n泛型EnumSet集合，只能接收Enum类或者其子类的类型参数，如：EnumSet\u0026lt;Color\u0026gt;。向EnumSet枚举集合添加元素可使用of(element)，of的参数列表element只能接收对应枚举类的枚举成员。EnumSet的complementOf(EnumSet enumset)方法返回接收的枚举类型中除了enumset包含的枚举成员之外的枚举成员集合。EnumSet的noneOf(Enum)方法创建一个空的Enum枚举类型的集合，使用add方法添加的时候只能添加Enum枚举类型的成员。\n普通的集合同样可以将枚举类型当成类型参数接收。\n静态导入（JDK1.5增加新特性）：使用import static导入其他包内的静态成员变量或者静态方法，路径要一直指定到具体的静态成员和静态方法上，那么在使用的时候可以直接使用不需要具体类名.成员。与普通import的区别在于普通导入的路径指定到具体类就可以了，静态导入要一直指定到成员和方法上，并且只能导入静态的成员变量和方法，另外静态导入使用时无需写具体类名。\njava的反射机制：使用new构造类实例和通过类调用类的方法等过程，在编译器编译的时候就已经知道会构造类或使用类的方法，但是反射机制不一样，反射机制强调是在运行时动态创建类对象和动态调用类方法，也就是说，编译时并不知道要创建什么类，调用什么类方法，直到运行时才能知道代码要创建类或调用类。通过反射机制，能够调用类的私有成员和方法。\n反射机制主要通过5个类来实现：\nClass\u0026lt;T\u0026gt;类，位于java.lang包中，代表了一个类，每一个类中都已有一个成员变量class保存该类所属的Class类，一个程序中的多个同类型对象都共享同一个Class。 Field类，位于java.lang.reflect包中，代表该类的成员变量，在反射机制中使用类的成员变量需要通过Field类使用。 Method类，位于java.lang.reflect包中，代表类的方法，在反射机制中使用类的方法需要通过Method类使用。 Constructor类，位于java.lang.reflect包中，代表类的构造方法，在反射机制中通过该类使用类的构造方法。 Array类，位于java.lang.reflect包中，提供了动态创建数组，以及访问数组元素的静态方法。 动态机制之所以能够在运行时实现，在于这五个类提供动态实现的方法，在运用动态机制的时候，必须通过以上五个类来间接操作。 反射机制的相关使用过程：\n首先要获取一个类的Class，Class类中提供了一个static方法forName（String）方法，参数为要获取具体的类完整类名，能够返回要获取具体类的Class，如Class classType = Class.forName(\u0026ldquo;java.lang.Object\u0026rdquo;)；另一种获取Class的方法是通过每一个类的都具有的成员变量class，直接从“类名.class”中获取；还有一种方法是利用从Object类继承下来的final方法getClass()方法返回调用该方法对象的Class，此方法需要用对象调用。 反射机制创建类实例，Class类中提供了方法newInstance()借用该Class对应类中不带参数的构造方法创建类实例，并返回对象引用。如果要使用带参数列表的构造方法，则需要借助Constructor的newInstance（Object\u0026hellip;）方法——首先利用Class的getConstructor(Class\u0026hellip;)方法获取带相应参数构造方法的Constructor（通常用Class[]数组做参数，如果是使用不带参数构造方法，要传递Class[]{}空数组），再利用该Constructor的newInstance（Object\u0026lt;T\u0026gt;\u0026hellip;）构造新实例（通常newInstance参数为Object数组，即使是不带参数也要使用空Object[]{}数组表示空），需要注意的是可变参数数组的元素要前后对应。 反射机制使用类成员变量，通过Field获取。Class提供了getDeclaredFields()返回代表所有成员变量的Field[]数组，或者通过getDeclaredField(String）返回指定变量名的Field对象。Field的方法getName()可以返回该Field代表成员变量的名称。 反射机制使用类方法，通过获取Method操作，Class类中提供了getDeclaredMethod()方法获取该类中所有方法的数组，即返回值为Method[]；Class提供的getMethod(String，Class\u0026hellip;)接收一个方法名字符串和可变参数Class（可变参数接收多个Class，通常用Class[]数组传递），可以返回一个方法名为String，参数为Class\u0026hellip;的Method。获取Method对象后，Method类中提供了方法invoke(String，Object\u0026hellip;)，String表示调用的是哪个对象，Object\u0026hellip;可变参数接收一个或多个Object类型参数（通常以Object数组传递），返回值是一个Object类型（具体使用返回值时可再强制转换）。 反射机制构造数组，通过Array的newInstance()方法。Array重载了两个newInstance静态方法，其中newInstance(Class\u0026lt;T\u0026gt; componentType,int length)构造一个一维数组，长度为length，元素类型为Class\u0026lt;T\u0026gt; componentType关联的类。如果创建的是多维数组，要使用newInstance(Class\u0026hellip; componeneType,int\u0026hellip; dimensions)，componentType表示数组的比较类型对应的Class（已知数组可通过Class的getComponentType()返回该数组的比较类型，实际也就是数组的元素类型，三维数组的比较类型是二维数组，二维数组的比较类型是一维数组，不是数组的比较类型为null），dimensions使用散列int或者int数组表示多维数组各维度的长度（从左到右为高维度到低维度）。Array的get(array，int\u0026hellip;)方法可获取数组array对应维度的值。 Class对象在构造该类的实例之前就已经存在，一个Class对象是JVM在加载一个类的时候自动创建的，里面包含了该类的所有信息，包括成员变量和方法，是java语言至关重要的类。\n原生数据类型的包装类.TYPE返回的是包装类对应的原生数据类型，.class返回的是class+包装类的完整类名。\n2012-07-24# Class中getDeclaredXxx与getXxx的区别：getXxx只能返回public修饰的成员变量和方法，getDeclaredXxx可以返回任意修饰符修饰的变量和方法。反射机制可以破坏类的封装性，使用类的私有成员和私有方法，此时要使用getDeclaredXxx获取相应的Method、Field、Constructor才有可能。\nMethod、Field、Constructor都继承于AccessibleObject，该类中提供了一个方法setAccessible（boolean），当boolean为true时，表示强制取消检查访问限制，当boolean为false时，则正常检查访问限制。只有通过setAccessible()设置为true取消访问检查，才有可能破坏类的封装性，使用类的私有成员和私有方法。\n类中定义的set和get方法，本质上也是使用反射机制才有可能实现。\nField中的set（Object obj，Object value）可以设置对象obj中该Field关联的成员变量值为value。如果是私有成员，也需要先用setAccessible（true）强制取消访问权限检查才可实现。\nnative修饰的方法表示本地方法，即不是使用java来实现，而是由C或C++来实现。\nClass的构造方法为private修饰，所以Class不能手动创建。\n类调用类对象的getSuperclass可以获取父类的Class。\n代理模式：为其它对象提供一个代理以控制这个对象的访问，代理相当于客户端与目标对象之间的中介，并带有自己附加的一些功能。\n代理模式设计的角色：\n抽象角色：声明真实对象和代理对象的共同接口或抽象类。 真实角色：即真实对象，是代理角色所代表的对象，是客户端最终要 引用的对象。 代理角色：代理角色内部包含对真实对象的引用，从而能够操作真实对象。同时，代理对象提供与真实对象相同的接口以便能够在任何时刻代替真实对象和使用真实对象。并且，代理对象可以在执行真实对象操作的时候附加自己的操作，相当于代理对象是对真实对象的封装。 静态代理设计过程：\n定义抽象角色，一个真实对象和代理对象共同要实现的抽象类或者接口。 定义真实角色，也就是要被代理的类，此类要继承或实现抽象角色的抽象类或者接口，实现里面的抽象方法。 定义代理角色，也就代理类。此类也要继承或实现抽象角色的抽象类或接口，并且实现里面的抽象方法。同时，代理类中还要声明一个真实类的引用变量，并通过相关方法从外部传递一个真实类对象引用进来，或者代理类内部new一个真实类对象。另外，代理类中实现抽象类或者接口中的方法体中，利用代理类中的这个真实类对象引用调用真实类中相应的方法，也就是代理类的方法最终实现是由它代理的真实类的方法类实现，但是此时，在调用真实类的方法前后可以插入代理类自己的一些方法，完成捆绑代理类的一些操作。 客户端使用代理类操作真实类，可以使用抽象角色引用变量接收代理类对象引用，使用抽象角色中方法时，根据多态会调用代理类中的方法，而代理类中的方法由是对真实类中相应方法的封装，由此间接操纵了真实类。 动态代理需要java.lang.reflect包下的接口InvocationHandler和类Proxy来实现。\n动态代理实际过程：\n定义抽象角色，动态代理的抽象角色只能是一个接口，不能是抽象类。 定义真实角色，也就是被代理的类，要实现抽象角色接口中的方法。 定义实现InvocationHandler接口的类。动态代理中不再需要手动定义代理角色（代理类由运行过程中生成），但是将代理类需要包含的一个真实类对象引用变量转移到实现InvocationHandler的类中，所以这个实现InvocationHandler类要定义一个可以接收真实类对象引用的引用变量（一般是Object引用变量，这样就可以代理任意类型的真实类，动态代理的特点也就在于此，可以动态生成代理类，不需要每使用一个代理类就要定义一个代理类），并在构造方法或者定义其他方法给这个变量赋真实类对象引用值。其次，这个类中最重要的是实现InvocationHandler接口中的方法public Object invoke（Object obj，Method method，Object[] args），其中第一个参数一般是指调用该方法的代理类对象（一般情况下用不到），method是被代理的方法，args是被代理的方法的参数列表。动态代理的客户端运行代理类方法的时候，实际上使用的是这个类的invoke方法，invoke方法中接收的method参数是动态代理底层利用反射机制自动生成的被调用方法对应的Method对象，args参数是动态代理将被调用方法传递的参数组合起来的数组。因此，实现InvocationHandler接口的类中invoke方法要根据传回来的Method对象使用Method对象的invoke方法，所以Method的invoke方法要接收被调用对象（一般是本类InvocationHandler中接收真实类引用的成员变量，它通过它才能调用真实类的对应方法达到通过代理控制真实类的目的）和被调用方法的参数（本类invoke方法接收到的args参数），并且代理类方法中要附加自己的代码要插入到调用Method的invoke方法前后。 客户端动态生成代理类和构造代理类对象。动态代理的客户端要构造真实类对象和实现InvocationHandler接口的类对象，然后使用Proxy.newProxyInstance（ClassLoader loader，Class[] interfaces，InvocationHandler h）动态生成代理类（类名为“$Proxy+阿拉伯数字”）和代理类对象，并将生成的代理类对象返回（Object类型，使用时可以强制转换）。该方法中loader参数接收实现InvocationHandler类的类加载器ClassLoader，可以通过Class类的getClassLoader方法获得，可以使用真实类的ClassLoader或者实现InvocationHandler类的ClassLoader，一个类的ClassLoader可以装载很多类；第二个参数interfaces接收一个接口数组，自动生成的代理类会实现interfaces数组中所有的接口，一般要接收真实类实现的接口，因为代理类要实现与真实类的共同接口；第三个参数要接收InvocationHandler，也就是实现InvocationHandler接口的类，使用生成的代理类方法时，动态代理底层会传递参数h中的invoke方法所需要的参数，将代理类的方法实现转移给h中的invoke方法。 Proxy.newProxyInstance返回的代理类对象Object可以强制转换成接收的参数interfaces数组中的任意一种接口类型（多态特性，代理类是interfaces数组中所有接口的实现类），便可以调用强制转换后的接口中拥有的每一个方法，代理都会自动包装调用过程中的方法参数传递给InvocationHandler中的invoke，让invoke实现代理方法。 ","date":"October 14, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%85%AD%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"枚举","url":"https://www.qinxiandiqi.sbs/tags/%E6%9E%9A%E4%B8%BE/"},{"title":"反射","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%8D%E5%B0%84/"},{"title":"代理模式","url":"https://www.qinxiandiqi.sbs/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}],"title":"JavaSE学习笔记 第六记 —— 代理模式"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-21# Vector与ArrayList基本类似，不同的是Vector是同步的。HaseTable与HaseMap类似，只是HaseTable是同步的，不常用HaseTable，但常用HaseTable的子类Properties。\nProperties的键值通常为String，用于Java的属性配置。System.getProperties()可以发返回一个系统配置的Properties对象。\n泛型（JDK1.5新添加的特性，之前版本的编译器无法识别泛型）：将数据类型参数化，通常使用T作为数据类型的参数，可接受多个参数，编写泛型类的时候把T当成具体数据类型来使用就可以了。泛型适用于逻辑结构完全相同，只是数据类型不相同的情况，相当于泛型提供了一个逻辑结构模板，接收不同的数据类型后模板会转换为具体数据类型的逻辑结构。例如：class Test\u0026lt;T\u0026gt;，使用类Test的时候接收一个数据类型参数T，Test类内部将T当成一个具体的数据类型使用，此时Test就是一个处理T类型的类。泛型的好处是在编译的时候就能知道调用泛型类的接收类型，不使用泛型则编译的时候无法知道具体接收的是什么数据类型，只能在运行赋值的时候才能知道使用的具体类型。由此，泛型可以在编写代码的时候明确知道调用泛型类的具体类型，从而降低抛出类型转换错误的异常。\n所有的集合都使用泛型，构造集合的时候如果不传递泛型集合类要接收的具体数据类型，则默认接收的具体类型为Object，同时编译器会提出需要具体指定接收类型的警告，但能通过编译。传递了具体制定类型的泛型类只能接收制定类型的对象，否则编译不通过，所以当给集合类传递具体数据类型后，集合类只能接收和处理这种数据类型的对象。Java提倡使用集合类的时候传递具体的数据类型，默认的Object类型虽然可以接收各种类型对象，但是带来的问题是没法直接从集合中取出一个元素，要想做关于该元素的相关操作必须强制转换为该元素原有的数据类型，也就是说使用Object的时候必须知道集合中每一个元素的数据类型，一旦数据类型指派错误，就会抛出类型转换错误的异常。\n默认泛型类的类参数T可以接收各种数据类型，如果要限制T接收的数据类型，可以在T后面\u0026lt;\u0026gt;内部使用extends +只能接收的数据类型或者接口（无论限制的是类还是接口，规定一律使用extends），那么T只能接收extends该类型或接口，以及其子类，除此之外的其他类型都不能接收。默认情况下是T extends Object，所以使用泛型类的时候没有传递具体数据类型，则会默认接收Object类型。\n2012-07-22# 使用泛型的时候，一旦明确在声明泛型引用变量时的类型参数，那么声明的引用变量类型也就确定，不能指向其他类型参数的泛型。然而，可以只用通配符?声明可以指向多种类型参数的泛型引用变量。具体实现方法：在声明引用变量的时候，使用代替具体参数类型即可，则声明后的泛型引用变量可以指向任何泛型类型参数的对象。如果要限制引用变量指向的类型参数范围，可以使用实际是引用变量可以指向任何类型对象。特别的，一旦使用通配符定义的引用变量在赋予具体对象地址后，只能使用读取或者删除对象的数据而不能修改该对象。原因在于从java设计者的角度出发，一旦可以修改，那么程序运行时在使用该引用变量的数据时，必须知道该数据的具体类型然后强制转换过来，这种做法不符合泛型的思想，失去了泛型的意思，因此java规定使用通配符的泛型引用变量只能读取或删除对象数据，而不能修改。\n泛型同样可以被继承或用于接口，但是在继承泛型类或实现接口的时候必须同时继承类型参数，也就是说在子类或者实现类中必须也有父类或接口的类型参数，因为根据继承和实现的顺序原理，实现子类或接口时传递给父类或接口的类型参数只能从子类或实现类传入。\n遍历for循环（JDK1.5新增加特性），用于遍历数组或集合中的元素，for(type element：array){}。多维数组的遍历for循环需要使用多个遍历for循环嵌套使用，内嵌for中array使用上层element表示。\n自动装箱和自动拆箱：JDK1.5针对八种原生数据类型和包装类之间的自动转换提供的新特性，因此，在JDK1.5以后的版本中，可以直接将原生数据类型直接赋值给对应包装类，或者在需要原生数据类型的地方直接使用对应包装类的对象，JAVA会自动使用相应的valueOf方法转换后再使用。\nInteger包装类中存在一个长度为255的Cache数组，其中包含了数值在-128~127这255个Integer对象作为缓冲数组。当使用valueOf()方法时，如果数值在-128到127之间时，不会生成新的Integer对象，而是直接返回Cache数组中对应值对象的引用，所以，自动装箱形成的Integer对象数值只要在这个缓冲范围内，使用==比较的结果是true。另外，如果Integer对象是使用new构造的话，那么无论数值是否在缓冲范围内都将重新构造新的对象，与构造普通对象的过程一样，不受缓冲数组的影响。\n可变参数（JDK1.5新增加的特性）：方法的参数可以不明确指定有多少个，在调用的时候才能知道究竟有多少个参数。可变参数只能是同种类型的多个参数，并且可变参数只能出现方法参数列表的最后一个，使用时在参数类型后边加3个点，例如：void method（String str,int\u0026hellip; arr）{}。可变参数的实质是一个数组，调用带可变参数方法时，运行时会自动将参数转换为相关数组再传入方法中，所以调用带可变参数方法时的参数可使用离散参数，也可用数组参数，但是如果定义方法的时候使用数组做参数，调用方法时的参数也只能是数组。基于这个原因，为了能够知道调用方法时那些参数是要形成可变参数数组，所以决定了可变参数的位置只能在参数列表的最末尾，并且一个方法中最多只能有一个可变参数。\n","date":"October 10, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%94%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"泛型","url":"https://www.qinxiandiqi.sbs/tags/%E6%B3%9B%E5%9E%8B/"},{"title":"包装类","url":"https://www.qinxiandiqi.sbs/tags/%E5%8C%85%E8%A3%85%E7%B1%BB/"},{"title":"可变参数","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"}],"title":"Java SE 学习笔记 第五记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-19# java中的链表节点使用封装的类，节点类包括节点数据和前驱后继节点的引用，java中没有指针的概念，所以使用链表只能使用引用，也就是引用类型变量做“指针”。\nLinkedList链表的底层实现实质上是由数据类型为Object和前驱后继Entry引用变量组成的Entry节点类的双向链表，所以LinkedList链表可以添加任意类元素（Object的子类）。添加新元素的时候，LinkedList会将对象封装成Entry类实例后插入到LinkedList链表中。基于链表的特性，LinkedList无长度限制，添加删除链表节点会关系到节点上下引用值的改变。\nclass Entry{ Entry previous; Object element; Entry next; } JDK提供了Stack类和Queue接口，可以通过LinkedList类的方法构造Queue类。\nJava中的Set集合与数学意义上的集合是一致的，集合中不能有相同的元素。\nHaseSet中的元素没有顺序性，符合数学集合的无序性。使用add向HaseSet添加已存在元素会返回false，表明添加不成功。\nObject类的equals()方法的特点：\n自反性，x.equals(x)的值为true，x不为null； 对称性，x.equals(y)与y.equals(x)的值一致； 传递性，x.equals(y)的值为true，且y.equals(z)的值为true，则有x.equals(z)的值也为true； 一致性，只要x和y没有改变，无论调用多少次x.equals(y)，结果都不会改变； 对于非空引用x.equals(null)的结果必定为false。 Object类的haseCode()方法特点：\n在java引用的一次执行过程中，同一个对象只要没有修改，无论调用多少次haseCode()，返回值都相同； 如果两个对象用equals比较的结果为true，那么这两个对象的haseCode()返回值一致； 如果两个对象用equals比较的结果是false，那么这两个对象的haseCode()返回值可以相同，也可以不同，Java推荐使用不同值可以提高程序的性能； Object默认的haseCode()返回值是对象的地址，所以Object的haseCode()对于不同对象的返回值是不同的。 HaseSet集合不允许存在相同的元素是通过以下机制实现：当向HaseSet添加新元素的时候，HaseSet会首先调用要添加对象的hashCode()方法，并与HaseSet已存在元素的HaseCode进行比较，如果都不相同，则直接添加新元素进集合；如果HaseCode的比较结果存在相同的元素，则进一步调用equals比较要添加的元素和HaseCode相同的元素，equals的结果为true的话，则拒绝添加新的元素，若为false，则将新元素添加进HaseSet集合。因此，如果使用Object的hashCode()和equals()，添加内容相同的对象时，由于HaseCode值相同，所以即使对象内容相同也能一起添加进去。而对于重写了hashCode()和equals()方法的子类要根据具体重写的方法决定是否能添加进内容相同的对象，比如String类的hashCode()返回采用字符串的内容进行计算获得，所以内容相同的String对象的HaseCode值也相同，自然不能添加进HaseSet。\n一般重写equals()方法的时候，最好也重写hashCode()方法。在Eclipse里可以通过Source-Generate hashCode()和 equals()命令选择一定类属性自动重写hashCode()和equals()方法。\nHaseSet没有get方法，要想从HaseSet中取出元素，需要使用迭代器来使用。利用HaseSet的iterator()可以返回一个该HaseSet的迭代器，再使用循环结构配合iterator的hasNext()方法判断是否存在下一个元素和next()返回下一个元素，返回后hasNext位置会自动指向下一个元素。当然，由于HaseSet元素是无序的，所以返回的结果顺序不一定就是元素添加进HaseSet的顺序。\nSortedSet接口继承了Set接口，同样不能存在相同的元素，但是增加了排序功能，主要的实现类由TreeSet。\n向TreeSet添加元素的时候，TreeSet会根据元素自动升序排序添加，如果添加的元素无法与已存在元素进行比较，则会抛出类型转换异常。此时的解决方法可以是在构造TreeSet的时候使用带Comparator参数的构造方法，指定一个Comparator实现类，这个类里提供了元素之间比较的方法compara()。\n指定自定义Comparator的TreeSet构造方法为TreeSet（Comparator comparator），所以实现自定义排序方法，需要自定义实现Comparator接口的类，类中必须实现方法int comparator（Object arg0，Object arg1）（默认是arg0\u0026gt;arg1时返回整数，小于时返回负数，相等时返回0）。利用自定义的比较类，在TreeSet构造方法参数中new一个自定义的Comparator实现类实例就能创建按照自定义比较规则排序的TreeSet。默认的TreeSet使用升序排序，要修改为降序也要通过以上方法重新定义降序的Comparator实现类来完成。\n类似于Arrays类为数组提供了大量static操作方法，Collections类为集合提供了大量static操作方法，例如：reverseOrder()为目标集合返回一个与目标集合排序相反的Comparator；sort（Collection，Comparator）为集合Collection进行Comparator规则的排序；shuffle（List list）为列表List打算元素顺序；min()和max()获取集合中的最小和最大值。。。。方法详见JDK开发文档Collection类。\n2012-07-20# 映射Map是一个接口，元素是一对Key和Value对象，且不能存在相同的Key，一个Key最多映射到一个值上。\nHaseMap是Map接口常用的实现类，同样HaseMap中元素是无序的，用put向HaseMap添加元素，如果先后添加的元素Key值相同，则会修改原Key的Value，不会再添加一个元素。使用get(Key)获取HaseMap中Key的值。使用KeySet()方法可以获得HaseMap中Key的集合，并且返回的Set集合是由HaseMap维护的，即当HaseMap中Key发生变化会关联到Set中元素的变化，反过来也一样；使用value()可以返回HaseMap的Value集合Collection，同样返回的Collection也是由HaseMap维护的，值的改变会互相影响。之所以返回的Key集合用Set和Value用Collection，是因为Key在HaseMap中是唯一的，使用Set则不存在相同的元素，但是value却不一定是唯一，所以使用Collection。\nHaseMap每一对映射的实质在底层上就是一个HaseMap内部类Entry实例，Entry类封装了一对Key和Value，并提供了get和set方法。使用HaseMap的entry()方法可以返回HaseMap的Entry的Set集合，利用Set和Set的迭代器iterator可以遍历整个HaseMap。\nTreeMap类似于TreeSet，可以实现元素自动排序，默认的排序方法是根据Key进行升序排序。添加自定义排序方法的TreeMap与TreeSet类似。\n策略模式（Strategy Pattern）:策略模式的实现根据是多态。\n策略模式的组成有三大部分抽象策略角色（通常是接口或者抽象类）、具体策略角色（具体的实现接口或抽象类的实现类）、环境角色（即环境类，具有接口或者抽象类的引用作为环境类的成员变量，并且提供set和get设置接口或抽象类的方法，以及其他封装接口或者抽象类的方法，以供客户类使用）。\n策略模式的实现步骤分3步：1）编写抽象策略角色，一般是公共接口，设定接口的方法；2）编写具体策略角色，即策略类，封装相关算法和行为的接口实现方法；3）在环境角色即环境类中，保存一个接口的引用，并完成环境类的set和get或者构造方法，以对接口引用的赋值。\n策略模式的使用过程：定义了公共接口和相关接口的实现类，整个策略模式的关键在于环境类中保存的成员变量是接口的引用，而不是接口实现类的引用，并且环境类中所有需要接口做参数的方法，参数类型和方法中调用接口的方法都是依据接口的引用，而不是接口具体实现类的引用。由此，只要在客户类使用环境类的时候，为环境类的接口成员赋予具体的实现类引用，在环境类中，依据多态的特征，环境类就能知道将调用哪个具体实现类对接口的实现方法。也就是说，在客户类中，传入环境类中的具体实现类不同，环境类使用的方法过程不同，虽然方法名相同（实现接口的类中必须实现接口的方法）。\n策略模式的优点：策略模式中各个组成部分是弱连接的，只要接口类型不改变，各个组成部分中实现代码可以改变而不会影响其他部分。各个策略类实现接口的代码不同，环境类中使用的是接口的方法，而非具体实现类的方法，只要客户端传入具体实现类的引用，环境类就能根据多态知道使用的是哪个实现类的方法。好处是：环境类只需要根据接口引用和接口的方法名就能编写相应的业务逻辑方法，而只要传入的实现类引用不同，环境类的方法自然就变成了另一种业务逻辑，从而提升了软件的可重用性。\nHaseSet底层实质上是一个HaseMap，HaseSet中的元素实质上是HaseMap中的Key，而每一个Key的Value都是同一个Object，所以使用add向HaseSet中添加元素本质上是向HaseMap中put一个Key为HaseSet元素，值为一个final的Object元素。\nHase负载因子：表明达到负载因子比例的时候就认为哈希数组将近满，另外开辟一个更大的数组以满足要求。\nHaseMap的在底层上的实质是一个HaseMap内部类Entry的数组，HaseMap类内部有一个成员变量table就是一个HaseMap的Entry数组，使用默认HaseMap构造方法构造的HaseMapEntry数组长度为16，hase负载因子为0.75。并且，由于Entry类内部有一个成员变量next，可以指向一个Entry对象，所以table数组每个Entry元素实际上也是一个Entry链表。根据这个本质和Hase的特点，HaseMap就是一个封装了Entry数组的类，并且具有Hase数组元素添加方式的特征。\nHaseMap添加put新元素（一对键值，实质是一个Entry类对象）的过程本质：HaseMap根据新键值的Key的HaseCode和table数组的长度，通过Hase算法计算出新键值要添加进table数组的索引号。此时，HaseMap会判断该索引号位置上是否已经存在HaseMap元素，如果不存在，则直接将新键值（Entry）添加进table数组。如果该位置已经存在一个Entry，则HaseMap会遍历这个Entry链表，将添加的新Entry与链表上的每一个Entry进行equals比较。当链表上存在一个Entry比较后的返回值是true时，说明这个Entry的Key与将要添加的Entry的Key相同，根据HaseMap规则，HaseMap会取出原有Entry的Value返回，并将新添加的Entry的Value替换这个旧的Value。当遍历整个Entry链表后无true返回值，HaseMap则会为要添加的Entry调用addEntry方法，该方法会new一个新的Entry对象存放要添加的键值，并将这个新Entry的next指向原本该table数组位置上的Entry对象，再将这个新建的Entry对象插入到table数组这位置上，形成该位置上新的Entry链表，新的Entry对象为该链表的表头（之所以要将新Entry对象作为链表的表头，是因为操作系统认为刚使用的数据在不久的将来有很大的概率会再次使用，所以将新Entry对象作为表头可以提高效率）。 注：由于put新键值的数组位置是由Key根据Hase算法计算获得，所以Key值相同的键值获得的插入位置一定在同一个位置，因此只要遍历该位置上的Entry对象就能知道HaseMap中是否已经存在相同Key的键值。另外，同一个位置上的Entry链中可能存在不同的Key值，因为不同的Key值也可能得出相同的位置。\n","date":"October 9, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"Set","url":"https://www.qinxiandiqi.sbs/tags/set/"},{"title":"List","url":"https://www.qinxiandiqi.sbs/tags/list/"},{"title":"map","url":"https://www.qinxiandiqi.sbs/tags/map/"},{"title":"Tree","url":"https://www.qinxiandiqi.sbs/tags/tree/"},{"title":"策略模式","url":"https://www.qinxiandiqi.sbs/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}],"title":"Java SE 学习笔记 第四记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-17# java.lang包在编译的时候会自动导入，无需显示导入。此包内包含object类还有一些常用类。\nObject的equals方法实质是判断两个引用值是否一致，相当于==，即两个对象是否是同一个对象。String的equals方法是比较两个字符串的每个字符是否一样，而不是两个字符串对象的引用值。\n“==”比较的是值，无论是原生数据类型还是对象引用都是比较值，只是对象引用的值是引用地址，因此比较的结果是同一个对象才会返回true。\nString是一种特殊的对象，除了可以用new创建新对象之外，还可以使用字面值直接创建新对象，字面值就是类似于原生数据类型一样赋值，如String string=\u0026ldquo;abc\u0026rdquo;，只有String可以使用字面值创建对象。并且，String字面量对象是一种常量对象，java通过字符串池来管理这些常量。当使用字面值创建对象后，字符串池内会创建相应的String对象，而且创建后的String内容不能再改变。因此，字符串池类会有很多不能再改变的字符串对象，如“abc”是不能再改变的，所以，当使用字面值创建String的时候，会先在字符串池内搜索是否存在要创建的字符串对象，如果存在则不用再创建，直接返回该对象的引用。也就是说，字符串池内的字符串对象只创建一次，并且创建后不能再改变值，可以供多个字符串引用使用。基于这个原理，当使用字面值创建相同内容的字符串对象时，用==比较这些对象的结果是true，因为它们的值都是字符串池中同个字符串对象的引用地址。而使用new创建的字符串对象不同，因为new是在堆中创建新对象，字符串池存在于栈中，new无论怎样都会在堆中创建新的对象，并返回对象的引用。如果字符串池中已经存在要创建的字符串，则new直接在堆中创建新对象；如果字符串池中不存在要创建的对象，则java会先在字符串池中创建要创建的字符创对象后，堆中也会创建这个要创建的对象，并返回堆中这个对象的引用。因此，即使String内容相同，但是不同对象引用地址不同，==比较的结果也是false。\nString的intern()方法，如“abc”.intern()，该方法会在字符串池中查询abc是否存在，如果不存在，则会在字符串池中创建abc对象，并返回字符串池中这个对象的引用，如果字符串池中已存在，则直接返回字符串池中这个对象的引用。因此，s.intern()==q.inern()为true的必要条件是s.equals(q)为true。\nString和StringBuffer的区别：String对象是常量，定义后值不能再改变；StringBuffer是变量对象，值可以修改，修改后StringBuffer引用变量还是指向原来的StringBuffer对象（String修改的实质是String引用变量指向一个新的String对象），常用append()方法追加字符，可以用toString()方法返回当前字符串内容。\n+号不能直接用于布尔值的拼接。\n字符串字面量的拼接，返回值也是字符串池中字面量的引用，如“abc”+“def”，返回的结果是字符串池中的“abcdef”引用；而字符串字面量和字符串引用变量的拼接，其过程是在堆中创建新的对象，返回值是堆中该对象的引用。\njava中对应8个原生数据类型，有8个包装类：Boolean、Integer、Short、Long、Byte、Float、Double、Character。\n数组是一种由相同类型的变量组成的集合的特殊类，类名为数组元素类型+[]（一个或多个），如int[]。创建数组相当于创建对象，用new创建，需指明数组的长度，特别的，可以{}指定数组元素的同时创建数组，此时不用指明数组的长度。每一个数组元素相当于数组对象的成员变量，而且数组含有一个final类型的public成员变量length，表示数组的长度。\n对于二维数组type[][]（行列），实质上相当于数组的数组，可以分隔为\u0026rsquo;type[]\u0026rsquo;[]：以type[]数组作为一维数组元素类型，type类型作为二维数组元素类型，分成两层形成最终复合二维数组，所以type表示的整个二维数组（值为地址，二维数值也是对象，其length值是二维数组中一维数组的个数），type[i]表示的是第i个一维数组（值为地址，因为数组是对象，其length值是第i个一维数组的长度）。二维数组每一行的列数可以不相同，也正是因为这个原因。类比二维数组，高维数组也遵循同样的道理。\n数组声明的元素的类型可以是interface，因为数组创建后的元素interface是引用类型，但是具体每个元素赋值时使用new的必须是interface的实现子类。\njava的java.util.Arrays类提供了各种静态数组辅助操作方法，包括数组比较，排序等，详见jdk文档。\n2012-07-18# java.lang.System类包含许多辅助方法，如数组拷贝方法arraycopy()。\n冒泡排序是交换排序的一种。\njava中约定常量命名规则：全部由大写字母组成，多个单词之间用下划线隔开。\n修饰常量成员常用final与static并用，因为final不允许修改，static为类常量，节省内存。\nEclipse中快捷键Alt+/，自动补充相关代码。Ctrl+/，自动注释掉光标所在行。Ctrl+D，删除光标所在行。将鼠标放置在一个类名上，再按Ctrl，类名将变成一个超链接指向定义该类的代码。\njava提供了集合的概念，集合也就是一堆元素的集合体。集合在java以接口的形式定义为Collection，但是JDK并没有提供Collection的实现类，而是提供了向下继承了Collection的另外两个接口Set和List，并且提供了Set和List的一系列实现类。\n实现List接口的一个实现类ArrayList（数组列表），类似于数组，但是元素可以是各种类（只要是Object的继承类）（数组是同一类类型的集合），定义的时候也不用指定数组列表的长度，使用add()向数组列表添加元素，使用get()向数组列表获取指定索引值的元素（索引顺序与数组一样，从0计数），使用clean()清除数组列表所有元素，使用remove()以元素索引或元素值删除指定元素。详细方法查询JDK文档。\n使用get获取ArrayList数组列表元素后，需要将元素强制转换为该元素的类型，如果强制转换的类型不符合元素类型，编译的时候不会报错，在运行时会把抛出类型转换错误异常。\n使用ArrayList的toArray()方法，将ArrayList数组类表元素转换为数组，返回的数组类型是Object[]，Object[]不能强制转换为具体类型数组，原因在于具体数组类型并不是Object[]的子类。\nArrayList的toString()方法是按照ArrayList元素的顺序分别调用各个元素类型的toString（）方法，并将返回结果使用[]括起来，元素之间的返回结果用，号隔开。\n集合的元素依然是对象的引用，不是对象本身。\nArrayList的底层实际是一个Object[]数组，所以数组列表元素可以是任意类型的对象，因为任何类都继承Object类。使用ArrayList默认构造方法会实际会在ArrayList底层生成一个长度为10的Object[]数组。当使用add方法向ArrayList添加新元素的时候，add方法会先判断Object数组长度够不够，如果够则直接将新元素添加进Object数组；如果长度不够，则会创建新的Object数组，长度为原来数组长度的1.5倍+1，然后将原数组的内容复制到新数组当中。如此循环，直到数组长度不够的时候，再按照以上方法增加数组长度。\n","date":"October 8, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"String","url":"https://www.qinxiandiqi.sbs/tags/string/"},{"title":"集合","url":"https://www.qinxiandiqi.sbs/tags/%E9%9B%86%E5%90%88/"},{"title":"List","url":"https://www.qinxiandiqi.sbs/tags/list/"},{"title":"数组","url":"https://www.qinxiandiqi.sbs/tags/%E6%95%B0%E7%BB%84/"}],"title":"Java SE 学习笔记 第三记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-15# 同一个类中的多个重载构造方法的互相调用，要用this(params)调用，不能直接显示调用构造方法，并且调用的时候this()必须放在构造方法中的首行，也就是this()之前不能存在其他代码。params为重载构造方法的参数列表。\n创建子类实例的时候，new子类的构造方法，实际默认的构造方法的调用顺序为调用父类不带参数的构造方法，若不存在不带参数的父类构造方法则编译出错，若存在则调用该父类构造方法，之后再调用带相应参数的子类构造方法。也就是说，创建子类实例的时候永远都是要先调用父类的构造方法再调用子类的构造方法。如果需要指定调用的具体父类构造方法，需要在子类构造方法使用super（params）来表明调用父类中带有相应参数列表的构造方法，并且super之前不能出现任何可执行的代码。\n对于内存来说，创建子类实例的时候，先调用父类构造方法，说明在内存中创建了一个父类实例（包括该父类实例的属性和父类方法引用，注：方法不创建，因为一个类的所有实例共享所有类方法），之后再调用子类的构造方法，这个时候并不像创建普通类一样从头到尾在内存中完完整整的创建一个单独的类实例，而是在该父类实例连续下来的内存空间里再创建子类增加的属性和方法引用，如果子类重写了父类相关属性和方法，则在连续下来的内存中创建重写的属性和重写的方法引用。换句话说，创建子类实例的时候，子类实例和父类实例共用一块连续的内存空间，并且子类实例内存空间包含父类实例内存空间，所以父类引用变量可以指向子类实例，使用多态的父类实例引用可以强制转换为子类引用。\n重载方法和重写方法的区别：重载方法是方法名一样，参数列表不一样，返回类型可以一样也可以不一样，重载方法出现在同一个类中；重写方法是方法名、参数类表、返回类型都完全一样，是子类重新定义父类中相应的方法，重写方法不能出现在同一个类中。\n多态就是父类对象引用可以指向子类对象引用。\n父类的构造方法不能被子类继承。\n当使用多态方式调用方法时，也就是父类引用变量指向子类实例，此时，java会先查询父类中是否存在需要调用的方法，如果不存在则编译错误，如果存在则再检查子类是否重写了这个方法，如果重写则调用子类的该方法，如果没有重写则直接调用父类的这个方法。而多态的父类引用，如果使用重写的属性值，则使用的属性值是父类的属性值，因为此时是父类实例引用，指向的是父类实例内存中的属性。\n可以通过强制转换的方式将使用多态方式的父类引用变量转换为子类引用变量。\n2012-07-16# 确定引用类型是否是多态是在运行时确定的，编译的时候只能确定引用类型引用的是什么类，也就是说多态是在编译后进行的，是晚绑定的。\n抽象类定义： abstract class 类名；抽象方法定义：修饰符 abstract 返回类型 方法名（params）;（没有花括号）。抽象方法必须定义在抽象类中。抽象类中可以包含具体方法，也可以不包含具体方法，抽象方法也可包含或者不包含。\n继承抽象类的子类必须实现父类中所有的抽象方法，如果没有全部实现，则该子类还是一个抽象类，需要使用abstract关键字，同样不能实例化。\n接口定义：关键字 interface 接口名{}；接口中所有方法都是抽象方法，所以在接口中的方法不能出现方法体，并且方法的abstract抽象关键字可以省略，因为默认都是抽象的。接口可以看成是特殊的抽象类，但是一个子类只能继承一个父类，而对于接口，一个类可以实现多个接口。实现接口用关键字implements，继承类用关键字extents。接口中所有方法也都是public关键字修饰的，所以public关键字在接口中省略。\n实现一个接口必须同时实现接口中所有的方法，否则要将类定义为抽象类。\n接口多态：接口类型引用指向实现接口类的实例，具有多态特征。\n静态关键字static，当用于修饰类属性时，表明该属性为静态类属性，所有的实例都共享一份静态属性，如果一个实例修改了静态属性，那么其他实例使用的静态属性值也会改变，使用静态属性可以用实例名.属性名，但是推荐使用类名.属性名；当用于修饰方法时，可以使用类名.方法名来调用。\n静态方法只能继承，但不具备多态特征，也就是不能被子类重写，只能被隐藏。即，只能使用静态方法隐藏静态方法，不能使用静态方法覆盖非静态方法，也不能使用非静态方法覆盖静态方法。被隐藏后调用的是父类还是子类的静态方法，取决于是使用什么类型的引用。\nfinal修饰的类不能被继承，final修饰的方法不能被子类重写，final修饰的属性不能被修改（属性为原生数据类型时，则数值不能改变；属性为引用类型时，则引用指向的对象不能改变，但对象属性可以改变）。\nfinal属性定义时必须显式赋予初值，如果定义时没有赋初值则只能在构造方法中赋初值，并且所有构造方法都必须赋初值，否则编译不通过，因为此时不赋初值将没有其他机会再定义值。\nfinal{}静态代码块，是在编译器编译后的class类文件加载进虚拟机时执行的代码，一个类中的静态代码只运行一次，在加载进虚拟机的时候。所有静态代码块在构造方法之前执行，构造方法是在生成新实例的时候才执行的，此时class文件已加载进虚拟机。对于继承的静态代码跟构造方法差不多，也是父类的先执行，再执行子类的静态代码，所有静态代码执行完毕后有创建实例才按构造方法顺序调用构造方法。\nclass类文件在类被使用的时候才会加载进JVM，而且只加载一次。\nstatic静态方法中只能调用静态属性，原因在于静态方法可以通过类名调用，如果调用的是非静态属性，那么每个实例的非静态属性都不同，静态方法会无法辨认使用的是哪个实例的属性，因此编译的时候不允许。反过来，非静态方法可以调用静态属性，因为静态属性时唯一，方法知道调用的是哪个属性。\n不能在静态方法中使用关键字this，同使用非静态属性的道理一样，this只当前的实例对象，在静态方法中使用this，java会无法辨认是哪个实例对象，因此编译不通过。\n接口中的成员变量都是public、final、static关键字修饰的，可以省略。因此，接口中的成员变量必须在定义的时候赋初值。\nfinal和abstract关键字不能同时使用，因为abstract抽象定义要求继承实现，而final是终止继承，互相矛盾。\n单例模式：一个类只有唯一的一个实例，即无论创建多少个类实例，它们实际上都是同一个实例。实现的方法是：首先，将类的构造方法关键字设为private，这么一来构造方法只能在类内部调用，在类外无法调用也就无法在类外创建类实例；其次，将创建类实例转移到类内部创建，并且使用static关键字修饰创建的类实例；最后，创建static的返回类内创建类实例引用的方法，使用static的原因是无法在类外创建类实例也就无法在类外调用类的任何一个非静态方法，只能通过静态方法来获取类内创建的类实例，类实例也用static修饰也是因为它要被static方法调用。由此三个步骤决定一个类由始至终只能创建一个类实例。\n包相当于目录，用于分类管理类文件，包名推荐使用反顺序的域名，并且全部小写。\n当java源文件中使用package引入包名，则表明此源文件中的类全名为：包名.类名，调用类的时候时候必须使用类的全名，即必须将类的class文件放置到包名指示的文件路径下，虚拟机才能找到相应的类执行，否则运行出错。\n当java源文件没有使用package引入包名，则使用默认的包default，调用的时候无需包名，即无包名。\n编译java源文件使用命令时，javac -verbose 文件名，可以追踪编译器的运行情况；javac -d 路径 文件名，可以将class生成到指定路径下。\n导入包和类的时候使用import关键字，导入类要使用类的全名，即指定到类名下，导入包则在包名后加“.*”，*号是通配符的意思，即该包下所有的类文件都导入，但是没有包含子包，如果需要导入子包则要将子包当成另外一个包，按导入包的方法导入。\n源文件中，必须遵循package、import、class的顺序声明。\n同个包内的类在关键字允许下，可以直接调用。\n访问修饰符：public，所有包的类都可访问，可以被所有包的类继承；private，只有在定义为private的类内部才可访问，不能被继承；不带访问修饰符即默认访问修饰符，可以被该类内部和该类所在包内的类可以访问，可以被所在包的其他类继承，不能被其他包的类访问和继承；protected，可以被类内部、相同包内其他类访问，可以被其他包的类继承，但不能被其他包的类访问。\n包和类的导入跟访问修饰符没有直接联系，导入是关于能不能找到类，访问修饰符是关于找到的类有没有权限访问。\n关键字instanceof用于判断某实例是不是某类或其子类的实例，引用名 instanceof 类名或接口名，返回一个布尔值。\n","date":"October 7, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"面向对象","url":"https://www.qinxiandiqi.sbs/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"多态","url":"https://www.qinxiandiqi.sbs/tags/%E5%A4%9A%E6%80%81/"},{"title":"单例模式","url":"https://www.qinxiandiqi.sbs/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}],"title":"Java SE 学习笔记 第二记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-12# bin目录：binary二进制缩写 windows环境变量：用户变量只对当前用户起作用，系统变量对所有用户都起作用。 javac的c是compile缩写，编译的意思，所以javac是编译命令程序。 java.exe是java运行字节码class命令程序。 java编译后的class文件名为java源文件的类名，并非java源文件名。 java是跨平台语言在于真正执行的不是二进制代码而是字节码，并且字节码由JVM执行，也就是说java程序可以不考虑程序将在什么操作系统上运行，因为运行java程序是的JVM虚拟机，只要有虚拟机就可以执行java程序。但是JVM虚拟机不是跨平台的，它是由c语言编写的，不同平台下的JVM虚拟机不一样。 java包含8中原生数据类型：整型int（32位）、字节型byte（范围-128-127，是整型的一个子集）、短整型short（16位）、长整型long（64位）、单精度浮点型float、双精度浮点型double、字符型char、布尔型boolean（true\u0026amp;false）。 java变量名可以包含下划线、字母、美元符号、数字，但是变量名不能以数字开头。 java中有三种注释方式：单行注释，//；多行注释，/* /；java doc帮助文档注释，/* */。 java中的布尔型只允许true和false两个值，不同于c语言和C++可以将数值当做布尔型。 java中所有浮点型默认情况下都是double类型，所以将任意一个浮点值赋给float变量将会抛出损失精度错误，所以将浮点值赋给float需要将浮点值强制转换为float（加括号和类型名），或者借助java语言的支持性在浮点值后加F（大写或小写），如：float a=1.2F。 赋值准则：赋值等号左右两边类型一致或者左边类型范围大于右边类型范围，并且值大小不溢出该类型。 变量在使用之前必须声明类型和赋值，并且只能声明定义一次。 2012-07-13# 若干个数据类型参与运算，运算结果类型为参与运算类型中表值范围最大的类型。 当运算结果为int时，java舍弃结果的所有小数部分，只保留整数部分。 强制转换，如a为int，“（double）a”整个部分的结果为double类型，但是a本身还是int类型。 取模运算（%）的结果正负与被除数的符号一致。 逻辑运算与\u0026amp;\u0026amp;：当左边的值为false时，java得出结果为false，不再执行\u0026amp;\u0026amp;右边的表达式。 逻辑运算或||：当左边的值为true时，java得出结果为true，不再运行右边的表达式。 条件运算符（三目运算符）：type d=布尔表达式？a：b switch的变量类型只允许short、byte、int、char四种类型和枚举类型。 继承 inheritance；封装encapsulation；多态polymoruphism 定义类：修饰符 class 类名字 定义方法：修饰符 返回类型 方法名称（参数） java类中的方法不能嵌套定义，也就是不能在一个方法中定义另一个方法，并且java中的方法只能定义在类中，即方法是属于类的。 类的命名约定：首字母大写，如果由多个单词组成则每个单词首字母都大写并且直接拼接在一起形成类名。 方法的命名约定：首字母小写，如果由多个单词组成则第一单词首字母小写，其余单词首字母都大写，然后直接拼接在一起。 属性的命名约定：命名约定与方法的命名约定方式相同。 成员变量和局部变量在使用前都需要定义，成员变量在使用前可以不初始化，但是局部变量在使用前必须初始化，否则程序出错。成员变量使用前未初始化，则会使用java默认值：byte、short、int、long默认值为0；boolean默认值为false；float、double默认值为0.0；char默认值为\u0026rsquo;\\u0000\u0026rsquo;。 引用类型是专门使用在对象上的，相当于一个指向对象的指针变量。一个对象可以被多个引用变量引用，但是同一个时刻一个引用变量只能引用一个对象。 用new实例化一个类创建对象的实质是在内存类堆上开辟一块空间创新对象，此时若有引用类型赋值，则会返回对象地址给引用类型（引用类型存在于内存栈中）。 方法的参数是对象，实际上是对象的引用类型，因为java中对对象的操作都是通过引用类型来实现，所以当实参（引用类型）传递给形参的值实际上只是对象的引用变量，并没有生成一个新的对象，也就是说，此时实参和形参两个引用类型都指向同一个对象。 同一个类的多个对象都拥有自己的属性，但是同一个类的多个对象共同拥有类的方法。 方法参数为原生数据类型，则参数传递的是值，方法中形参值的改变不影响实参的值。方法参数参数传递都是值传递，引用类型传递的是引用类型值，即地址。 什么类型的引用只能指向什么类型的对象或者对象的父类。 构造方法的名字必须与类名完全一致，因此构造方法以大写字母开头；构造方法没有返回值，因此构造方法没有返回类型，连void也不能出现；如果没有定义构造方法，类会自动添加默认不带任何参数且方法体为空的构造方法，如果定义了构造方法，则不会自动生成默认构造方法；类的构造方法不能显示调用，由new隐式调用。 new关键字生成对象时完成三件事：为对象在内存堆内开辟内存空间；调用类的构造方法；返回对象的地址。new关键字后类名小括号内容为响应构造方法的参数列表。 2012-07-14# 一个java源文件中最多只有一个public类。且main存在的话，只能存在于这个public类中。换句话说，一个java源文件中可以存在多个不是public的类。 一个java源文件中含有多少个类，编译后就生成多少个class文件，并且文件名为相应类名。 方法重载：两个多或多个方法的名字相同，参数列表不同，包括参数个数不同和参数类型不同。不能根据方法的返回值类型来重载方法，即不能有参数列表相同，唯独返回类型不同的方法重载。 ","date":"October 6, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"float","url":"https://www.qinxiandiqi.sbs/tags/float/"},{"title":"虚拟机","url":"https://www.qinxiandiqi.sbs/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"title":"Java SE 学习笔记 第一记"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/en/contact/","series":[],"smallImg":"","tags":[],"title":"Contact Me"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/en/offline/","series":[],"smallImg":"","tags":[],"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/offline/","series":[],"smallImg":"","tags":[],"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/contact/","series":[],"smallImg":"","tags":[],"title":"联系我"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/search/","series":[],"smallImg":"","tags":[],"title":"搜索"}],"series":["opengl","Kotlin","Linux","Java","libGDX","libGDX手册","Android Tips","Android","IDE","go","OS","spring","RaspBerry","路由器","MySQL","Python","Gson","Beacon","Android Gradle","Android Wear","Ant","JavaScript学习笔记","JavaWeb学习笔记","JUnit学习笔记","XML学习笔记","Java学习笔记"],"tags":["python","博客搬家","glsl","opengl","git","Windows","ssh","kotlin","Setter","属性初始器","linux","wifi","java","transient","serializable","libgdx","游戏引擎","线程","线程安全","日志","查询","运行时环境","跨平台","启动类","初始化","模块","生命周期","open GL","截屏","尺寸","帧缓冲区","android","抽屉式菜单","滑动效果","侧滑菜单","格式化","进程","优先级","属性动画","动画","定位","策略","地理位置","permission","权限","使用技巧","动态申请","golang","intellij idea","ide","插件","ChromiumOS","ChromeBook","u盘","操作系统","注解处理器","源代码","自动生成","屏幕","碎片化","兼容","布局","win10","开始菜单","任务栏","无法点击","修复","Annotation","注解","textview","html","超链接","a","spring","Properties","配置文件","atom","中文自动换行","编辑器","android studio","layer-list","shape","Element","Declared","node.js","arm架构","RaspBerry","树莓派","tftp","buffalo","dd-wrt","刷系统","Volley","网络","idea","maven","xml","src","classes","sonatype","企业","私有仓库","go语言","工作空间","GOPATH","go","二进制包","安装","mysql","数据库","迁移","ubuntu","easy_install","BeautifulSoup4","爬虫","arm","编译安装","jvm","mac","无法启动","bash","脚本","空格","期待一元表达式","wi-fi","p2p","对等网络","apk","应用程序","安装位置","外部存储","bluetooth","BLE","蓝牙","低功耗","socket","通讯","命令行",".bashrc",".bash_aliases","rc.local","开机启动","shell","apt","软件","管理","sudo","超级用户","home","备份","Sonic Pi","音乐","声音","rsync","同步","cron","crontab","定时任务","filezilla","sftp","文件传输","vnc","desktop","远程控制","图形","SSH远程登录","无密码","rsa","视频","音频","mp3","raspi-config工具","audio","用户管理","user","network","自动连接","远程登录","桌面","安装系统","无显示器","gson","json","iBeacon","工作原理","Android Gradle","gradle","flavor","variant","多版本输出","Android Wear","结构","桥接通知","上下文通知","全屏应用","自动化测试","单元测试","合并","依赖关系","库项目","多项目配置","项目结构","Build Task","Build Type","签名配置","groovy","文档","ant","eclipse","javascript","jquery","选择器","替代对象","ajax","xmlhttprequest","JsUnit","function","对象","继承","object","类","javaweb","tomcat","虚拟主机","servlet","servlet listenter","EL表达式","JSP标签","filter","listener","session","cookie","web应用","jsp","javabean","http协议","web","css","可穿戴设备","Notification","原则","JUnit","测试","体验","创意视觉","界面","ui","分组","多页面","语音输入","通知","设计规范","schema","虚拟机","class","classloader","类加载器","类加载","google now","google","google maps","Google Play services","map","merge","plugins","win8","sdk","解决方案","批处理文件","闪退","command","library","工厂模式","DOM","SAX","ADT","翻译","Google Play Service","Java网络编程","对象拷贝","装饰模式","io","字符集","序列化和反序列化","文件系统","AWT","Swing","Java内部类","Java注解","Java异常","枚举","反射","代理模式","泛型","包装类","可变参数","Set","List","Tree","策略模式","String","集合","数组","面向对象","多态","单例模式","float"]}