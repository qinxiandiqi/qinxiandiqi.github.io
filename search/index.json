{"authors":["Jianan"],"categories":[],"pages":[{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"Window系统# 新建ssh密钥# 打开Terminal（Power Shell终端），使用ssh-keygen生成新密钥： $ ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 提示新密钥保存位置，直接回车保存到默认位置：%USERPROFILE%/.ssh/id_ed25519 \u0026gt; Enter a file in which to save the key (/c/Users/you/.ssh/id_algorithm):[Press enter] 提示键入安全密码，直接回车不使用密码： \u0026gt; Enter passphrase (empty for no passphrase): [Type a passphrase] \u0026gt; Enter same passphrase again: [Type passphrase again] 查看新密钥指纹： $ cat ~/.ssh/id_ed25519 添加新密钥到ssh-agent# Window系统ssh-agent服务默认禁用，先把ssh-agent服务启动方式改为自启动。以管理员身份打开Terminal（Power Shell终端），输入： Set-Service -Name ssh-agent -StartupType automatic 添加新密钥到ssh-agent： $ ssh-add ~/.ssh/id_ed25519 Linux或Mac系统# 新建ssh密钥# 打开终端，使用ssh-keygen生成新密钥： $ ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 提示新密钥保存位置，直接回车保存到默认位置：%USERPROFILE%/.ssh/id_ed25519 \u0026gt; \u0026gt; Enter a file in which to save the key (/home/you/.ssh/algorithm): [Press enter] 提示键入安全密码，直接回车不使用密码： \u0026gt; Enter passphrase (empty for no passphrase): [Type a passphrase] \u0026gt; Enter same passphrase again: [Type passphrase again] 查看新密钥指纹： $ cat ~/.ssh/id_ed25519 添加新秘钥到ssh-agent# 启动ssh-agent服务： $ eval \u0026#34;$(ssh-agent -s)\u0026#34; 添加新密钥到ssh-agent： $ ssh-add ~/.ssh/id_ed25519 ","date":"September 11, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/%E7%94%9F%E6%88%90%E6%96%B0ssh%E5%AF%86%E9%92%A5%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0ssh-agent/","series":[],"smallImg":"","tags":[{"title":"SSH","url":"https://www.qinxiandiqi.sbs/tags/ssh/"}],"title":"生成新SSH密钥并添加到ssh-Agent"},{"authors":[],"categories":[],"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremely fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","date":"February 28, 2019","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/about/","series":[],"smallImg":"","tags":[],"title":"About"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-21# Vector与ArrayList基本类似，不同的是Vector是同步的。HaseTable与HaseMap类似，只是HaseTable是同步的，不常用HaseTable，但常用HaseTable的子类Properties。\nProperties的键值通常为String，用于Java的属性配置。System.getProperties()可以发返回一个系统配置的Properties对象。\n泛型（JDK1.5新添加的特性，之前版本的编译器无法识别泛型）：将数据类型参数化，通常使用T作为数据类型的参数，可接受多个参数，编写泛型类的时候把T当成具体数据类型来使用就可以了。泛型适用于逻辑结构完全相同，只是数据类型不相同的情况，相当于泛型提供了一个逻辑结构模板，接收不同的数据类型后模板会转换为具体数据类型的逻辑结构。例如：class Test\u0026lt;T\u0026gt;，使用类Test的时候接收一个数据类型参数T，Test类内部将T当成一个具体的数据类型使用，此时Test就是一个处理T类型的类。泛型的好处是在编译的时候就能知道调用泛型类的接收类型，不使用泛型则编译的时候无法知道具体接收的是什么数据类型，只能在运行赋值的时候才能知道使用的具体类型。由此，泛型可以在编写代码的时候明确知道调用泛型类的具体类型，从而降低抛出类型转换错误的异常。\n所有的集合都使用泛型，构造集合的时候如果不传递泛型集合类要接收的具体数据类型，则默认接收的具体类型为Object，同时编译器会提出需要具体指定接收类型的警告，但能通过编译。传递了具体制定类型的泛型类只能接收制定类型的对象，否则编译不通过，所以当给集合类传递具体数据类型后，集合类只能接收和处理这种数据类型的对象。Java提倡使用集合类的时候传递具体的数据类型，默认的Object类型虽然可以接收各种类型对象，但是带来的问题是没法直接从集合中取出一个元素，要想做关于该元素的相关操作必须强制转换为该元素原有的数据类型，也就是说使用Object的时候必须知道集合中每一个元素的数据类型，一旦数据类型指派错误，就会抛出类型转换错误的异常。\n默认泛型类的类参数T可以接收各种数据类型，如果要限制T接收的数据类型，可以在T后面\u0026lt;\u0026gt;内部使用extends +只能接收的数据类型或者接口（无论限制的是类还是接口，规定一律使用extends），那么T只能接收extends该类型或接口，以及其子类，除此之外的其他类型都不能接收。默认情况下是T extends Object，所以使用泛型类的时候没有传递具体数据类型，则会默认接收Object类型。\n2012-07-22# 使用泛型的时候，一旦明确在声明泛型引用变量时的类型参数，那么声明的引用变量类型也就确定，不能指向其他类型参数的泛型。然而，可以只用通配符?声明可以指向多种类型参数的泛型引用变量。具体实现方法：在声明引用变量的时候，使用代替具体参数类型即可，则声明后的泛型引用变量可以指向任何泛型类型参数的对象。如果要限制引用变量指向的类型参数范围，可以使用实际是引用变量可以指向任何类型对象。特别的，一旦使用通配符定义的引用变量在赋予具体对象地址后，只能使用读取或者删除对象的数据而不能修改该对象。原因在于从java设计者的角度出发，一旦可以修改，那么程序运行时在使用该引用变量的数据时，必须知道该数据的具体类型然后强制转换过来，这种做法不符合泛型的思想，失去了泛型的意思，因此java规定使用通配符的泛型引用变量只能读取或删除对象数据，而不能修改。\n泛型同样可以被继承或用于接口，但是在继承泛型类或实现接口的时候必须同时继承类型参数，也就是说在子类或者实现类中必须也有父类或接口的类型参数，因为根据继承和实现的顺序原理，实现子类或接口时传递给父类或接口的类型参数只能从子类或实现类传入。\n遍历for循环（JDK1.5新增加特性），用于遍历数组或集合中的元素，for(type element：array){}。多维数组的遍历for循环需要使用多个遍历for循环嵌套使用，内嵌for中array使用上层element表示。\n自动装箱和自动拆箱：JDK1.5针对八种原生数据类型和包装类之间的自动转换提供的新特性，因此，在JDK1.5以后的版本中，可以直接将原生数据类型直接赋值给对应包装类，或者在需要原生数据类型的地方直接使用对应包装类的对象，JAVA会自动使用相应的valueOf方法转换后再使用。\nInteger包装类中存在一个长度为255的Cache数组，其中包含了数值在-128~127这255个Integer对象作为缓冲数组。当使用valueOf()方法时，如果数值在-128到127之间时，不会生成新的Integer对象，而是直接返回Cache数组中对应值对象的引用，所以，自动装箱形成的Integer对象数值只要在这个缓冲范围内，使用==比较的结果是true。另外，如果Integer对象是使用new构造的话，那么无论数值是否在缓冲范围内都将重新构造新的对象，与构造普通对象的过程一样，不受缓冲数组的影响。\n可变参数（JDK1.5新增加的特性）：方法的参数可以不明确指定有多少个，在调用的时候才能知道究竟有多少个参数。可变参数只能是同种类型的多个参数，并且可变参数只能出现方法参数列表的最后一个，使用时在参数类型后边加3个点，例如：void method（String str,int\u0026hellip; arr）{}。可变参数的实质是一个数组，调用带可变参数方法时，运行时会自动将参数转换为相关数组再传入方法中，所以调用带可变参数方法时的参数可使用离散参数，也可用数组参数，但是如果定义方法的时候使用数组做参数，调用方法时的参数也只能是数组。基于这个原因，为了能够知道调用方法时那些参数是要形成可变参数数组，所以决定了可变参数的位置只能在参数列表的最末尾，并且一个方法中最多只能有一个可变参数。\n","date":"October 10, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%94%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"泛型","url":"https://www.qinxiandiqi.sbs/tags/%E6%B3%9B%E5%9E%8B/"},{"title":"包装类","url":"https://www.qinxiandiqi.sbs/tags/%E5%8C%85%E8%A3%85%E7%B1%BB/"},{"title":"可变参数","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"}],"title":"Java SE 学习笔记 第五记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-19# java中的链表节点使用封装的类，节点类包括节点数据和前驱后继节点的引用，java中没有指针的概念，所以使用链表只能使用引用，也就是引用类型变量做“指针”。\nLinkedList链表的底层实现实质上是由数据类型为Object和前驱后继Entry引用变量组成的Entry节点类的双向链表，所以LinkedList链表可以添加任意类元素（Object的子类）。添加新元素的时候，LinkedList会将对象封装成Entry类实例后插入到LinkedList链表中。基于链表的特性，LinkedList无长度限制，添加删除链表节点会关系到节点上下引用值的改变。\nclass Entry{ Entry previous; Object element; Entry next; } JDK提供了Stack类和Queue接口，可以通过LinkedList类的方法构造Queue类。\nJava中的Set集合与数学意义上的集合是一致的，集合中不能有相同的元素。\nHaseSet中的元素没有顺序性，符合数学集合的无序性。使用add向HaseSet添加已存在元素会返回false，表明添加不成功。\nObject类的equals()方法的特点：\n自反性，x.equals(x)的值为true，x不为null； 对称性，x.equals(y)与y.equals(x)的值一致； 传递性，x.equals(y)的值为true，且y.equals(z)的值为true，则有x.equals(z)的值也为true； 一致性，只要x和y没有改变，无论调用多少次x.equals(y)，结果都不会改变； 对于非空引用x.equals(null)的结果必定为false。 Object类的haseCode()方法特点：\n在java引用的一次执行过程中，同一个对象只要没有修改，无论调用多少次haseCode()，返回值都相同； 如果两个对象用equals比较的结果为true，那么这两个对象的haseCode()返回值一致； 如果两个对象用equals比较的结果是false，那么这两个对象的haseCode()返回值可以相同，也可以不同，Java推荐使用不同值可以提高程序的性能； Object默认的haseCode()返回值是对象的地址，所以Object的haseCode()对于不同对象的返回值是不同的。 HaseSet集合不允许存在相同的元素是通过以下机制实现：当向HaseSet添加新元素的时候，HaseSet会首先调用要添加对象的hashCode()方法，并与HaseSet已存在元素的HaseCode进行比较，如果都不相同，则直接添加新元素进集合；如果HaseCode的比较结果存在相同的元素，则进一步调用equals比较要添加的元素和HaseCode相同的元素，equals的结果为true的话，则拒绝添加新的元素，若为false，则将新元素添加进HaseSet集合。因此，如果使用Object的hashCode()和equals()，添加内容相同的对象时，由于HaseCode值相同，所以即使对象内容相同也能一起添加进去。而对于重写了hashCode()和equals()方法的子类要根据具体重写的方法决定是否能添加进内容相同的对象，比如String类的hashCode()返回采用字符串的内容进行计算获得，所以内容相同的String对象的HaseCode值也相同，自然不能添加进HaseSet。\n一般重写equals()方法的时候，最好也重写hashCode()方法。在Eclipse里可以通过Source-Generate hashCode()和 equals()命令选择一定类属性自动重写hashCode()和equals()方法。\nHaseSet没有get方法，要想从HaseSet中取出元素，需要使用迭代器来使用。利用HaseSet的iterator()可以返回一个该HaseSet的迭代器，再使用循环结构配合iterator的hasNext()方法判断是否存在下一个元素和next()返回下一个元素，返回后hasNext位置会自动指向下一个元素。当然，由于HaseSet元素是无序的，所以返回的结果顺序不一定就是元素添加进HaseSet的顺序。\nSortedSet接口继承了Set接口，同样不能存在相同的元素，但是增加了排序功能，主要的实现类由TreeSet。\n向TreeSet添加元素的时候，TreeSet会根据元素自动升序排序添加，如果添加的元素无法与已存在元素进行比较，则会抛出类型转换异常。此时的解决方法可以是在构造TreeSet的时候使用带Comparator参数的构造方法，指定一个Comparator实现类，这个类里提供了元素之间比较的方法compara()。\n指定自定义Comparator的TreeSet构造方法为TreeSet（Comparator comparator），所以实现自定义排序方法，需要自定义实现Comparator接口的类，类中必须实现方法int comparator（Object arg0，Object arg1）（默认是arg0\u0026gt;arg1时返回整数，小于时返回负数，相等时返回0）。利用自定义的比较类，在TreeSet构造方法参数中new一个自定义的Comparator实现类实例就能创建按照自定义比较规则排序的TreeSet。默认的TreeSet使用升序排序，要修改为降序也要通过以上方法重新定义降序的Comparator实现类来完成。\n类似于Arrays类为数组提供了大量static操作方法，Collections类为集合提供了大量static操作方法，例如：reverseOrder()为目标集合返回一个与目标集合排序相反的Comparator；sort（Collection，Comparator）为集合Collection进行Comparator规则的排序；shuffle（List list）为列表List打算元素顺序；min()和max()获取集合中的最小和最大值。。。。方法详见JDK开发文档Collection类。\n2012-07-20# 映射Map是一个接口，元素是一对Key和Value对象，且不能存在相同的Key，一个Key最多映射到一个值上。\nHaseMap是Map接口常用的实现类，同样HaseMap中元素是无序的，用put向HaseMap添加元素，如果先后添加的元素Key值相同，则会修改原Key的Value，不会再添加一个元素。使用get(Key)获取HaseMap中Key的值。使用KeySet()方法可以获得HaseMap中Key的集合，并且返回的Set集合是由HaseMap维护的，即当HaseMap中Key发生变化会关联到Set中元素的变化，反过来也一样；使用value()可以返回HaseMap的Value集合Collection，同样返回的Collection也是由HaseMap维护的，值的改变会互相影响。之所以返回的Key集合用Set和Value用Collection，是因为Key在HaseMap中是唯一的，使用Set则不存在相同的元素，但是value却不一定是唯一，所以使用Collection。\nHaseMap每一对映射的实质在底层上就是一个HaseMap内部类Entry实例，Entry类封装了一对Key和Value，并提供了get和set方法。使用HaseMap的entry()方法可以返回HaseMap的Entry的Set集合，利用Set和Set的迭代器iterator可以遍历整个HaseMap。\nTreeMap类似于TreeSet，可以实现元素自动排序，默认的排序方法是根据Key进行升序排序。添加自定义排序方法的TreeMap与TreeSet类似。\n策略模式（Strategy Pattern）:策略模式的实现根据是多态。\n策略模式的组成有三大部分抽象策略角色（通常是接口或者抽象类）、具体策略角色（具体的实现接口或抽象类的实现类）、环境角色（即环境类，具有接口或者抽象类的引用作为环境类的成员变量，并且提供set和get设置接口或抽象类的方法，以及其他封装接口或者抽象类的方法，以供客户类使用）。\n策略模式的实现步骤分3步：1）编写抽象策略角色，一般是公共接口，设定接口的方法；2）编写具体策略角色，即策略类，封装相关算法和行为的接口实现方法；3）在环境角色即环境类中，保存一个接口的引用，并完成环境类的set和get或者构造方法，以对接口引用的赋值。\n策略模式的使用过程：定义了公共接口和相关接口的实现类，整个策略模式的关键在于环境类中保存的成员变量是接口的引用，而不是接口实现类的引用，并且环境类中所有需要接口做参数的方法，参数类型和方法中调用接口的方法都是依据接口的引用，而不是接口具体实现类的引用。由此，只要在客户类使用环境类的时候，为环境类的接口成员赋予具体的实现类引用，在环境类中，依据多态的特征，环境类就能知道将调用哪个具体实现类对接口的实现方法。也就是说，在客户类中，传入环境类中的具体实现类不同，环境类使用的方法过程不同，虽然方法名相同（实现接口的类中必须实现接口的方法）。\n策略模式的优点：策略模式中各个组成部分是弱连接的，只要接口类型不改变，各个组成部分中实现代码可以改变而不会影响其他部分。各个策略类实现接口的代码不同，环境类中使用的是接口的方法，而非具体实现类的方法，只要客户端传入具体实现类的引用，环境类就能根据多态知道使用的是哪个实现类的方法。好处是：环境类只需要根据接口引用和接口的方法名就能编写相应的业务逻辑方法，而只要传入的实现类引用不同，环境类的方法自然就变成了另一种业务逻辑，从而提升了软件的可重用性。\nHaseSet底层实质上是一个HaseMap，HaseSet中的元素实质上是HaseMap中的Key，而每一个Key的Value都是同一个Object，所以使用add向HaseSet中添加元素本质上是向HaseMap中put一个Key为HaseSet元素，值为一个final的Object元素。\nHase负载因子：表明达到负载因子比例的时候就认为哈希数组将近满，另外开辟一个更大的数组以满足要求。\nHaseMap的在底层上的实质是一个HaseMap内部类Entry的数组，HaseMap类内部有一个成员变量table就是一个HaseMap的Entry数组，使用默认HaseMap构造方法构造的HaseMapEntry数组长度为16，hase负载因子为0.75。并且，由于Entry类内部有一个成员变量next，可以指向一个Entry对象，所以table数组每个Entry元素实际上也是一个Entry链表。根据这个本质和Hase的特点，HaseMap就是一个封装了Entry数组的类，并且具有Hase数组元素添加方式的特征。\nHaseMap添加put新元素（一对键值，实质是一个Entry类对象）的过程本质：HaseMap根据新键值的Key的HaseCode和table数组的长度，通过Hase算法计算出新键值要添加进table数组的索引号。此时，HaseMap会判断该索引号位置上是否已经存在HaseMap元素，如果不存在，则直接将新键值（Entry）添加进table数组。如果该位置已经存在一个Entry，则HaseMap会遍历这个Entry链表，将添加的新Entry与链表上的每一个Entry进行equals比较。当链表上存在一个Entry比较后的返回值是true时，说明这个Entry的Key与将要添加的Entry的Key相同，根据HaseMap规则，HaseMap会取出原有Entry的Value返回，并将新添加的Entry的Value替换这个旧的Value。当遍历整个Entry链表后无true返回值，HaseMap则会为要添加的Entry调用addEntry方法，该方法会new一个新的Entry对象存放要添加的键值，并将这个新Entry的next指向原本该table数组位置上的Entry对象，再将这个新建的Entry对象插入到table数组这位置上，形成该位置上新的Entry链表，新的Entry对象为该链表的表头（之所以要将新Entry对象作为链表的表头，是因为操作系统认为刚使用的数据在不久的将来有很大的概率会再次使用，所以将新Entry对象作为表头可以提高效率）。 注：由于put新键值的数组位置是由Key根据Hase算法计算获得，所以Key值相同的键值获得的插入位置一定在同一个位置，因此只要遍历该位置上的Entry对象就能知道HaseMap中是否已经存在相同Key的键值。另外，同一个位置上的Entry链中可能存在不同的Key值，因为不同的Key值也可能得出相同的位置。\n","date":"October 9, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"Set","url":"https://www.qinxiandiqi.sbs/tags/set/"},{"title":"List","url":"https://www.qinxiandiqi.sbs/tags/list/"},{"title":"Map","url":"https://www.qinxiandiqi.sbs/tags/map/"},{"title":"Tree","url":"https://www.qinxiandiqi.sbs/tags/tree/"},{"title":"策略模式","url":"https://www.qinxiandiqi.sbs/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}],"title":"Java SE 学习笔记 第四记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-17# java.lang包在编译的时候会自动导入，无需显示导入。此包内包含object类还有一些常用类。\nObject的equals方法实质是判断两个引用值是否一致，相当于==，即两个对象是否是同一个对象。String的equals方法是比较两个字符串的每个字符是否一样，而不是两个字符串对象的引用值。\n“==”比较的是值，无论是原生数据类型还是对象引用都是比较值，只是对象引用的值是引用地址，因此比较的结果是同一个对象才会返回true。\nString是一种特殊的对象，除了可以用new创建新对象之外，还可以使用字面值直接创建新对象，字面值就是类似于原生数据类型一样赋值，如String string=\u0026ldquo;abc\u0026rdquo;，只有String可以使用字面值创建对象。并且，String字面量对象是一种常量对象，java通过字符串池来管理这些常量。当使用字面值创建对象后，字符串池内会创建相应的String对象，而且创建后的String内容不能再改变。因此，字符串池类会有很多不能再改变的字符串对象，如“abc”是不能再改变的，所以，当使用字面值创建String的时候，会先在字符串池内搜索是否存在要创建的字符串对象，如果存在则不用再创建，直接返回该对象的引用。也就是说，字符串池内的字符串对象只创建一次，并且创建后不能再改变值，可以供多个字符串引用使用。基于这个原理，当使用字面值创建相同内容的字符串对象时，用==比较这些对象的结果是true，因为它们的值都是字符串池中同个字符串对象的引用地址。而使用new创建的字符串对象不同，因为new是在堆中创建新对象，字符串池存在于栈中，new无论怎样都会在堆中创建新的对象，并返回对象的引用。如果字符串池中已经存在要创建的字符串，则new直接在堆中创建新对象；如果字符串池中不存在要创建的对象，则java会先在字符串池中创建要创建的字符创对象后，堆中也会创建这个要创建的对象，并返回堆中这个对象的引用。因此，即使String内容相同，但是不同对象引用地址不同，==比较的结果也是false。\nString的intern()方法，如“abc”.intern()，该方法会在字符串池中查询abc是否存在，如果不存在，则会在字符串池中创建abc对象，并返回字符串池中这个对象的引用，如果字符串池中已存在，则直接返回字符串池中这个对象的引用。因此，s.intern()==q.inern()为true的必要条件是s.equals(q)为true。\nString和StringBuffer的区别：String对象是常量，定义后值不能再改变；StringBuffer是变量对象，值可以修改，修改后StringBuffer引用变量还是指向原来的StringBuffer对象（String修改的实质是String引用变量指向一个新的String对象），常用append()方法追加字符，可以用toString()方法返回当前字符串内容。\n+号不能直接用于布尔值的拼接。\n字符串字面量的拼接，返回值也是字符串池中字面量的引用，如“abc”+“def”，返回的结果是字符串池中的“abcdef”引用；而字符串字面量和字符串引用变量的拼接，其过程是在堆中创建新的对象，返回值是堆中该对象的引用。\njava中对应8个原生数据类型，有8个包装类：Boolean、Integer、Short、Long、Byte、Float、Double、Character。\n数组是一种由相同类型的变量组成的集合的特殊类，类名为数组元素类型+[]（一个或多个），如int[]。创建数组相当于创建对象，用new创建，需指明数组的长度，特别的，可以{}指定数组元素的同时创建数组，此时不用指明数组的长度。每一个数组元素相当于数组对象的成员变量，而且数组含有一个final类型的public成员变量length，表示数组的长度。\n对于二维数组type[][]（行列），实质上相当于数组的数组，可以分隔为\u0026rsquo;type[]\u0026rsquo;[]：以type[]数组作为一维数组元素类型，type类型作为二维数组元素类型，分成两层形成最终复合二维数组，所以type表示的整个二维数组（值为地址，二维数值也是对象，其length值是二维数组中一维数组的个数），type[i]表示的是第i个一维数组（值为地址，因为数组是对象，其length值是第i个一维数组的长度）。二维数组每一行的列数可以不相同，也正是因为这个原因。类比二维数组，高维数组也遵循同样的道理。\n数组声明的元素的类型可以是interface，因为数组创建后的元素interface是引用类型，但是具体每个元素赋值时使用new的必须是interface的实现子类。\njava的java.util.Arrays类提供了各种静态数组辅助操作方法，包括数组比较，排序等，详见jdk文档。\n2012-07-18# java.lang.System类包含许多辅助方法，如数组拷贝方法arraycopy()。\n冒泡排序是交换排序的一种。\njava中约定常量命名规则：全部由大写字母组成，多个单词之间用下划线隔开。\n修饰常量成员常用final与static并用，因为final不允许修改，static为类常量，节省内存。\nEclipse中快捷键Alt+/，自动补充相关代码。Ctrl+/，自动注释掉光标所在行。Ctrl+D，删除光标所在行。将鼠标放置在一个类名上，再按Ctrl，类名将变成一个超链接指向定义该类的代码。\njava提供了集合的概念，集合也就是一堆元素的集合体。集合在java以接口的形式定义为Collection，但是JDK并没有提供Collection的实现类，而是提供了向下继承了Collection的另外两个接口Set和List，并且提供了Set和List的一系列实现类。\n实现List接口的一个实现类ArrayList（数组列表），类似于数组，但是元素可以是各种类（只要是Object的继承类）（数组是同一类类型的集合），定义的时候也不用指定数组列表的长度，使用add()向数组列表添加元素，使用get()向数组列表获取指定索引值的元素（索引顺序与数组一样，从0计数），使用clean()清除数组列表所有元素，使用remove()以元素索引或元素值删除指定元素。详细方法查询JDK文档。\n使用get获取ArrayList数组列表元素后，需要将元素强制转换为该元素的类型，如果强制转换的类型不符合元素类型，编译的时候不会报错，在运行时会把抛出类型转换错误异常。\n使用ArrayList的toArray()方法，将ArrayList数组类表元素转换为数组，返回的数组类型是Object[]，Object[]不能强制转换为具体类型数组，原因在于具体数组类型并不是Object[]的子类。\nArrayList的toString()方法是按照ArrayList元素的顺序分别调用各个元素类型的toString（）方法，并将返回结果使用[]括起来，元素之间的返回结果用，号隔开。\n集合的元素依然是对象的引用，不是对象本身。\nArrayList的底层实际是一个Object[]数组，所以数组列表元素可以是任意类型的对象，因为任何类都继承Object类。使用ArrayList默认构造方法会实际会在ArrayList底层生成一个长度为10的Object[]数组。当使用add方法向ArrayList添加新元素的时候，add方法会先判断Object数组长度够不够，如果够则直接将新元素添加进Object数组；如果长度不够，则会创建新的Object数组，长度为原来数组长度的1.5倍+1，然后将原数组的内容复制到新数组当中。如此循环，直到数组长度不够的时候，再按照以上方法增加数组长度。\n","date":"October 8, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"String","url":"https://www.qinxiandiqi.sbs/tags/string/"},{"title":"集合","url":"https://www.qinxiandiqi.sbs/tags/%E9%9B%86%E5%90%88/"},{"title":"List","url":"https://www.qinxiandiqi.sbs/tags/list/"},{"title":"数组","url":"https://www.qinxiandiqi.sbs/tags/%E6%95%B0%E7%BB%84/"}],"title":"Java SE 学习笔记 第三记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-15# 同一个类中的多个重载构造方法的互相调用，要用this(params)调用，不能直接显示调用构造方法，并且调用的时候this()必须放在构造方法中的首行，也就是this()之前不能存在其他代码。params为重载构造方法的参数列表。\n创建子类实例的时候，new子类的构造方法，实际默认的构造方法的调用顺序为调用父类不带参数的构造方法，若不存在不带参数的父类构造方法则编译出错，若存在则调用该父类构造方法，之后再调用带相应参数的子类构造方法。也就是说，创建子类实例的时候永远都是要先调用父类的构造方法再调用子类的构造方法。如果需要指定调用的具体父类构造方法，需要在子类构造方法使用super（params）来表明调用父类中带有相应参数列表的构造方法，并且super之前不能出现任何可执行的代码。\n对于内存来说，创建子类实例的时候，先调用父类构造方法，说明在内存中创建了一个父类实例（包括该父类实例的属性和父类方法引用，注：方法不创建，因为一个类的所有实例共享所有类方法），之后再调用子类的构造方法，这个时候并不像创建普通类一样从头到尾在内存中完完整整的创建一个单独的类实例，而是在该父类实例连续下来的内存空间里再创建子类增加的属性和方法引用，如果子类重写了父类相关属性和方法，则在连续下来的内存中创建重写的属性和重写的方法引用。换句话说，创建子类实例的时候，子类实例和父类实例共用一块连续的内存空间，并且子类实例内存空间包含父类实例内存空间，所以父类引用变量可以指向子类实例，使用多态的父类实例引用可以强制转换为子类引用。\n重载方法和重写方法的区别：重载方法是方法名一样，参数列表不一样，返回类型可以一样也可以不一样，重载方法出现在同一个类中；重写方法是方法名、参数类表、返回类型都完全一样，是子类重新定义父类中相应的方法，重写方法不能出现在同一个类中。\n多态就是父类对象引用可以指向子类对象引用。\n父类的构造方法不能被子类继承。\n当使用多态方式调用方法时，也就是父类引用变量指向子类实例，此时，java会先查询父类中是否存在需要调用的方法，如果不存在则编译错误，如果存在则再检查子类是否重写了这个方法，如果重写则调用子类的该方法，如果没有重写则直接调用父类的这个方法。而多态的父类引用，如果使用重写的属性值，则使用的属性值是父类的属性值，因为此时是父类实例引用，指向的是父类实例内存中的属性。\n可以通过强制转换的方式将使用多态方式的父类引用变量转换为子类引用变量。\n2012-07-16# 确定引用类型是否是多态是在运行时确定的，编译的时候只能确定引用类型引用的是什么类，也就是说多态是在编译后进行的，是晚绑定的。\n抽象类定义： abstract class 类名；抽象方法定义：修饰符 abstract 返回类型 方法名（params）;（没有花括号）。抽象方法必须定义在抽象类中。抽象类中可以包含具体方法，也可以不包含具体方法，抽象方法也可包含或者不包含。\n继承抽象类的子类必须实现父类中所有的抽象方法，如果没有全部实现，则该子类还是一个抽象类，需要使用abstract关键字，同样不能实例化。\n接口定义：关键字 interface 接口名{}；接口中所有方法都是抽象方法，所以在接口中的方法不能出现方法体，并且方法的abstract抽象关键字可以省略，因为默认都是抽象的。接口可以看成是特殊的抽象类，但是一个子类只能继承一个父类，而对于接口，一个类可以实现多个接口。实现接口用关键字implements，继承类用关键字extents。接口中所有方法也都是public关键字修饰的，所以public关键字在接口中省略。\n实现一个接口必须同时实现接口中所有的方法，否则要将类定义为抽象类。\n接口多态：接口类型引用指向实现接口类的实例，具有多态特征。\n静态关键字static，当用于修饰类属性时，表明该属性为静态类属性，所有的实例都共享一份静态属性，如果一个实例修改了静态属性，那么其他实例使用的静态属性值也会改变，使用静态属性可以用实例名.属性名，但是推荐使用类名.属性名；当用于修饰方法时，可以使用类名.方法名来调用。\n静态方法只能继承，但不具备多态特征，也就是不能被子类重写，只能被隐藏。即，只能使用静态方法隐藏静态方法，不能使用静态方法覆盖非静态方法，也不能使用非静态方法覆盖静态方法。被隐藏后调用的是父类还是子类的静态方法，取决于是使用什么类型的引用。\nfinal修饰的类不能被继承，final修饰的方法不能被子类重写，final修饰的属性不能被修改（属性为原生数据类型时，则数值不能改变；属性为引用类型时，则引用指向的对象不能改变，但对象属性可以改变）。\nfinal属性定义时必须显式赋予初值，如果定义时没有赋初值则只能在构造方法中赋初值，并且所有构造方法都必须赋初值，否则编译不通过，因为此时不赋初值将没有其他机会再定义值。\nfinal{}静态代码块，是在编译器编译后的class类文件加载进虚拟机时执行的代码，一个类中的静态代码只运行一次，在加载进虚拟机的时候。所有静态代码块在构造方法之前执行，构造方法是在生成新实例的时候才执行的，此时class文件已加载进虚拟机。对于继承的静态代码跟构造方法差不多，也是父类的先执行，再执行子类的静态代码，所有静态代码执行完毕后有创建实例才按构造方法顺序调用构造方法。\nclass类文件在类被使用的时候才会加载进JVM，而且只加载一次。\nstatic静态方法中只能调用静态属性，原因在于静态方法可以通过类名调用，如果调用的是非静态属性，那么每个实例的非静态属性都不同，静态方法会无法辨认使用的是哪个实例的属性，因此编译的时候不允许。反过来，非静态方法可以调用静态属性，因为静态属性时唯一，方法知道调用的是哪个属性。\n不能在静态方法中使用关键字this，同使用非静态属性的道理一样，this只当前的实例对象，在静态方法中使用this，java会无法辨认是哪个实例对象，因此编译不通过。\n接口中的成员变量都是public、final、static关键字修饰的，可以省略。因此，接口中的成员变量必须在定义的时候赋初值。\nfinal和abstract关键字不能同时使用，因为abstract抽象定义要求继承实现，而final是终止继承，互相矛盾。\n单例模式：一个类只有唯一的一个实例，即无论创建多少个类实例，它们实际上都是同一个实例。实现的方法是：首先，将类的构造方法关键字设为private，这么一来构造方法只能在类内部调用，在类外无法调用也就无法在类外创建类实例；其次，将创建类实例转移到类内部创建，并且使用static关键字修饰创建的类实例；最后，创建static的返回类内创建类实例引用的方法，使用static的原因是无法在类外创建类实例也就无法在类外调用类的任何一个非静态方法，只能通过静态方法来获取类内创建的类实例，类实例也用static修饰也是因为它要被static方法调用。由此三个步骤决定一个类由始至终只能创建一个类实例。\n包相当于目录，用于分类管理类文件，包名推荐使用反顺序的域名，并且全部小写。\n当java源文件中使用package引入包名，则表明此源文件中的类全名为：包名.类名，调用类的时候时候必须使用类的全名，即必须将类的class文件放置到包名指示的文件路径下，虚拟机才能找到相应的类执行，否则运行出错。\n当java源文件没有使用package引入包名，则使用默认的包default，调用的时候无需包名，即无包名。\n编译java源文件使用命令时，javac -verbose 文件名，可以追踪编译器的运行情况；javac -d 路径 文件名，可以将class生成到指定路径下。\n导入包和类的时候使用import关键字，导入类要使用类的全名，即指定到类名下，导入包则在包名后加“.*”，*号是通配符的意思，即该包下所有的类文件都导入，但是没有包含子包，如果需要导入子包则要将子包当成另外一个包，按导入包的方法导入。\n源文件中，必须遵循package、import、class的顺序声明。\n同个包内的类在关键字允许下，可以直接调用。\n访问修饰符：public，所有包的类都可访问，可以被所有包的类继承；private，只有在定义为private的类内部才可访问，不能被继承；不带访问修饰符即默认访问修饰符，可以被该类内部和该类所在包内的类可以访问，可以被所在包的其他类继承，不能被其他包的类访问和继承；protected，可以被类内部、相同包内其他类访问，可以被其他包的类继承，但不能被其他包的类访问。\n包和类的导入跟访问修饰符没有直接联系，导入是关于能不能找到类，访问修饰符是关于找到的类有没有权限访问。\n关键字instanceof用于判断某实例是不是某类或其子类的实例，引用名 instanceof 类名或接口名，返回一个布尔值。\n","date":"October 7, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"面向对象","url":"https://www.qinxiandiqi.sbs/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"多态","url":"https://www.qinxiandiqi.sbs/tags/%E5%A4%9A%E6%80%81/"},{"title":"单例模式","url":"https://www.qinxiandiqi.sbs/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}],"title":"Java SE 学习笔记 第二记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-12# bin目录：binary二进制缩写 windows环境变量：用户变量只对当前用户起作用，系统变量对所有用户都起作用。 javac的c是compile缩写，编译的意思，所以javac是编译命令程序。 java.exe是java运行字节码class命令程序。 java编译后的class文件名为java源文件的类名，并非java源文件名。 java是跨平台语言在于真正执行的不是二进制代码而是字节码，并且字节码由JVM执行，也就是说java程序可以不考虑程序将在什么操作系统上运行，因为运行java程序是的JVM虚拟机，只要有虚拟机就可以执行java程序。但是JVM虚拟机不是跨平台的，它是由c语言编写的，不同平台下的JVM虚拟机不一样。 java包含8中原生数据类型：整型int（32位）、字节型byte（范围-128-127，是整型的一个子集）、短整型short（16位）、长整型long（64位）、单精度浮点型float、双精度浮点型double、字符型char、布尔型boolean（true\u0026amp;false）。 java变量名可以包含下划线、字母、美元符号、数字，但是变量名不能以数字开头。 java中有三种注释方式：单行注释，//；多行注释，/* /；java doc帮助文档注释，/* */。 java中的布尔型只允许true和false两个值，不同于c语言和C++可以将数值当做布尔型。 java中所有浮点型默认情况下都是double类型，所以将任意一个浮点值赋给float变量将会抛出损失精度错误，所以将浮点值赋给float需要将浮点值强制转换为float（加括号和类型名），或者借助java语言的支持性在浮点值后加F（大写或小写），如：float a=1.2F。 赋值准则：赋值等号左右两边类型一致或者左边类型范围大于右边类型范围，并且值大小不溢出该类型。 变量在使用之前必须声明类型和赋值，并且只能声明定义一次。 2012-07-13# 若干个数据类型参与运算，运算结果类型为参与运算类型中表值范围最大的类型。 当运算结果为int时，java舍弃结果的所有小数部分，只保留整数部分。 强制转换，如a为int，“（double）a”整个部分的结果为double类型，但是a本身还是int类型。 取模运算（%）的结果正负与被除数的符号一致。 逻辑运算与\u0026amp;\u0026amp;：当左边的值为false时，java得出结果为false，不再执行\u0026amp;\u0026amp;右边的表达式。 逻辑运算或||：当左边的值为true时，java得出结果为true，不再运行右边的表达式。 条件运算符（三目运算符）：type d=布尔表达式？a：b switch的变量类型只允许short、byte、int、char四种类型和枚举类型。 继承 inheritance；封装encapsulation；多态polymoruphism 定义类：修饰符 class 类名字 定义方法：修饰符 返回类型 方法名称（参数） java类中的方法不能嵌套定义，也就是不能在一个方法中定义另一个方法，并且java中的方法只能定义在类中，即方法是属于类的。 类的命名约定：首字母大写，如果由多个单词组成则每个单词首字母都大写并且直接拼接在一起形成类名。 方法的命名约定：首字母小写，如果由多个单词组成则第一单词首字母小写，其余单词首字母都大写，然后直接拼接在一起。 属性的命名约定：命名约定与方法的命名约定方式相同。 成员变量和局部变量在使用前都需要定义，成员变量在使用前可以不初始化，但是局部变量在使用前必须初始化，否则程序出错。成员变量使用前未初始化，则会使用java默认值：byte、short、int、long默认值为0；boolean默认值为false；float、double默认值为0.0；char默认值为\u0026rsquo;\\u0000\u0026rsquo;。 引用类型是专门使用在对象上的，相当于一个指向对象的指针变量。一个对象可以被多个引用变量引用，但是同一个时刻一个引用变量只能引用一个对象。 用new实例化一个类创建对象的实质是在内存类堆上开辟一块空间创新对象，此时若有引用类型赋值，则会返回对象地址给引用类型（引用类型存在于内存栈中）。 方法的参数是对象，实际上是对象的引用类型，因为java中对对象的操作都是通过引用类型来实现，所以当实参（引用类型）传递给形参的值实际上只是对象的引用变量，并没有生成一个新的对象，也就是说，此时实参和形参两个引用类型都指向同一个对象。 同一个类的多个对象都拥有自己的属性，但是同一个类的多个对象共同拥有类的方法。 方法参数为原生数据类型，则参数传递的是值，方法中形参值的改变不影响实参的值。方法参数参数传递都是值传递，引用类型传递的是引用类型值，即地址。 什么类型的引用只能指向什么类型的对象或者对象的父类。 构造方法的名字必须与类名完全一致，因此构造方法以大写字母开头；构造方法没有返回值，因此构造方法没有返回类型，连void也不能出现；如果没有定义构造方法，类会自动添加默认不带任何参数且方法体为空的构造方法，如果定义了构造方法，则不会自动生成默认构造方法；类的构造方法不能显示调用，由new隐式调用。 new关键字生成对象时完成三件事：为对象在内存堆内开辟内存空间；调用类的构造方法；返回对象的地址。new关键字后类名小括号内容为响应构造方法的参数列表。 2012-07-14# 一个java源文件中最多只有一个public类。且main存在的话，只能存在于这个public类中。换句话说，一个java源文件中可以存在多个不是public的类。 一个java源文件中含有多少个类，编译后就生成多少个class文件，并且文件名为相应类名。 方法重载：两个多或多个方法的名字相同，参数列表不同，包括参数个数不同和参数类型不同。不能根据方法的返回值类型来重载方法，即不能有参数列表相同，唯独返回类型不同的方法重载。 ","date":"October 6, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"float","url":"https://www.qinxiandiqi.sbs/tags/float/"},{"title":"虚拟机","url":"https://www.qinxiandiqi.sbs/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"title":"Java SE 学习笔记 第一记"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/en/contact/","series":[],"smallImg":"","tags":[],"title":"Contact Me"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/en/offline/","series":[],"smallImg":"","tags":[],"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/offline/","series":[],"smallImg":"","tags":[],"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/contact/","series":[],"smallImg":"","tags":[],"title":"联系我"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/search/","series":[],"smallImg":"","tags":[],"title":"搜索"}],"series":["Java学习笔记"],"tags":["SSH","Java","泛型","包装类","可变参数","Set","List","Map","Tree","策略模式","String","集合","数组","面向对象","多态","单例模式","float","虚拟机"]}