{"authors":["Jianan"],"categories":["opengl","Git","翻译","Android"],"pages":[{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"opengl","url":"https://www.qinxiandiqi.sbs/categories/opengl/"}],"content":"在opengl的着色器中，如果定义的uniform全局变量只是定义但并没有使用，或者使用了该uniform变量的代码不可触达或对着色器结果不产生影响，那么opengl在编译链接着色器程序之后，会自动将着色器中的这些uniform变量删除。\n这个优化可能会导致在业务代码中查询使用该uniform变量时，发生变量不能存在的错误，不了解这个自动优化机制容易让人费解。 例如：\nuniform vec4 u_color; 或者\nuniform vec4 u_color; if (u_color.a \u0026gt;= 0.0) {} 以上的u_color变量将会被自动删除。\n","date":"September 26, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/opengl/glsl/glsl%E7%9A%84uniform%E5%8F%98%E9%87%8F%E8%87%AA%E5%8A%A8%E4%BC%98%E5%8C%96/","series":[{"title":"opengl","url":"https://www.qinxiandiqi.sbs/series/opengl/"}],"smallImg":"","tags":[{"title":"glsl","url":"https://www.qinxiandiqi.sbs/tags/glsl/"},{"title":"opengl","url":"https://www.qinxiandiqi.sbs/tags/opengl/"}],"title":"GLSL的uniform变量自动优化"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"Git","url":"https://www.qinxiandiqi.sbs/categories/git/"}],"content":"在Windows平台下进行git操作可能会出现Filename too long错误，这是因为操作的文件路径或文件名超长，配置git支持长文件名可解决问题：\ngit config --global core.longpaths true ","date":"September 18, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/git/filenametoolongbygitofwindows/","series":[],"smallImg":"","tags":[{"title":"git","url":"https://www.qinxiandiqi.sbs/tags/git/"},{"title":"Windows","url":"https://www.qinxiandiqi.sbs/tags/windows/"}],"title":"Windows平台下git报错Filename Too Long"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"一、Window系统# 1.1 新建ssh密钥# 打开Terminal（Power Shell终端），使用ssh-keygen生成新密钥： $ ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 提示新密钥保存位置，直接回车保存到默认位置：%USERPROFILE%/.ssh/id_ed25519 \u0026gt; Enter a file in which to save the key (/c/Users/you/.ssh/id_algorithm):[Press enter] 提示键入安全密码，直接回车不使用密码： \u0026gt; Enter passphrase (empty for no passphrase): [Type a passphrase] \u0026gt; Enter same passphrase again: [Type passphrase again] 查看新密钥指纹： $ cat ~/.ssh/id_ed25519 1.2 添加新密钥到ssh-agent# Window系统ssh-agent服务默认禁用，先把ssh-agent服务启动方式改为自启动。以管理员身份打开Terminal（Power Shell终端），输入： Set-Service -Name ssh-agent -StartupType automatic 添加新密钥到ssh-agent： $ ssh-add ~/.ssh/id_ed25519 二、Linux或Mac系统# 2.1 新建ssh密钥# 打开终端，使用ssh-keygen生成新密钥： $ ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 提示新密钥保存位置，直接回车保存到默认位置：%USERPROFILE%/.ssh/id_ed25519 \u0026gt; \u0026gt; Enter a file in which to save the key (/home/you/.ssh/algorithm): [Press enter] 提示键入安全密码，直接回车不使用密码： \u0026gt; Enter passphrase (empty for no passphrase): [Type a passphrase] \u0026gt; Enter same passphrase again: [Type passphrase again] 查看新密钥指纹： $ cat ~/.ssh/id_ed25519 2.2 添加新秘钥到ssh-agent# 启动ssh-agent服务： $ eval \u0026#34;$(ssh-agent -s)\u0026#34; 添加新密钥到ssh-agent： $ ssh-add ~/.ssh/id_ed25519 ","date":"September 11, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/%E7%94%9F%E6%88%90%E6%96%B0ssh%E5%AF%86%E9%92%A5%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0ssh-agent/","series":[],"smallImg":"","tags":[{"title":"SSH","url":"https://www.qinxiandiqi.sbs/tags/ssh/"}],"title":"生成新SSH密钥并添加到ssh-Agent"},{"authors":[],"categories":[],"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremely fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","date":"February 28, 2019","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/about/","series":[],"smallImg":"","tags":[],"title":"About"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":" NameNodeMap接口：org.w3c.dom.NameNodeMap，其中保存了一个字符串名字与一个Node对象的映射，一般是Attr属性Node。虽然可以通过正常的索引访问NameNodeMap中的Node，但NameNodeMap中的Node实际是没有顺序的。NameNodeMap中主要方法：\nitem（int index）：返回索引值为index的Node。 getNamedItem（String name）：返回对应字符串为name的Node对象。 Comment接口：org.w3c.dom.Comment，继承Node，代表一个注释。主要方法有：getData（）：返回该Comment注释内容的字符串。\nSAX（Simple APIs for XML）：即XML简单应用程序接口，另一种解析XML文档的一种接口规范。\nSAX的工作模式：SAX提供的访问模式是一种顺序访问模式，并且是基于观察者模式的事件驱动机制来解析访问XML文档。SAX在解析一个XML文档的时候，它并不把整个XML文档都读进内存，而是按照XML文档的“行”为单位来解析。一行XML语句解析完后就继续解析下一行，被解析后的XML语句并不将其数据保存在内存中，所以SAX的解析无法再返回读取解析过的内容，除非重新解析整个XML文档，因此SAX的解析不是随机而是顺序性的。SAX在逐行解析的时候，会分析XML语句的语法，判定当前字节是XML与语法中的哪一部分，是否符合XML的语法要求，然后就会根据解析到的信息触发相应的事件给监听 器或适配器捕捉，XML数据的处理交给监听 器或适配器处理。类似于GUI的事件机制，SAX解析时触发的事件给监听 器或适配器捕捉后，处理方法的具体代码是由应用程序提供的，监听 器或适配器只是提供了相应事件处理方法的接口。之所以说SAX是简单应用程序接口也正是因为它只做了分析XML的一些简单工作，具体怎么处理交由应用程序自己控制。\nDOM与SAX的区别：DOM对XML文档的解析是可以实现数据的随即存取的，因为DOM把整个XML文档一次性读取到内容中构建了一个DOM对象树，基于DOM这个实现模式，DOM比较损耗内存，当XML过于庞大的时候可能会导致内存溢出。SAX对XML的解析是顺序访问的，基于事件处理机制，并不把整个XML文档都读取进内存，基于SAX的实现模式，SAX分析器实现比较简单，对内存的要求比较低，是实现的效率比较高，对于只读取XML文档中的数据而不对其进行更改的应用程序来说，SAX显然更加适合。\nJava对SAX的实现过程：\n同样需要先构造SAX解析器工厂对象，与DOM相似，也是基于简单工厂模式来构造SAX解析器工厂对象。Java提供了抽象类javax.xml.parsers.SAXParserFactory的静态方法newInstance()来返回一个根据当前系统环境变量参数构造的SAXParserFactory解析器工厂对象，也就是说SAXParserFactory类同样承担了既是工厂类又是产品类的角色。 通过SAXParserFactory的静态方法newSAXParser()返回一个具体的SAX解析器对象javax.xml.parsers.SAXParser。 通过SAXParser对象的parse()方法解析一个XML文档，SAXParser类提供了多个重载parse方法（详见JDK帮助文档），常用parse(File file ,DefaultHandler dh)方法解析XML文档file。 parse方法中的org.xml.sax.helpers.DefaultHandler类实现了ContentHandler、DTDHandler、EntityResolver、ErrorHandler等监听 器接口，是捕捉SAX解析器触发事件的适配器。类似于GUI的各种Adapter适配器的使用方法，其中提供了多个相应事件的处理方法供用户重写，如：遇到文档开始时促发startDocument()方法，遇到元素开始标签的时候触发startElement()方法，遇到元素之间字符内容时候触发characters()方法，遇到元素结束标签时候触发endElement()方法，遇到文档结束的时候触发endDocument()方法，详细见JDK帮助文档。 Stack栈类的peek方法是取出栈顶的值，但是不从栈中弹出该值。\n见张龙老师毕生心血之Schema学习总结pdf文档！！\nJAXP是用于对XML语法分析的Java APIs，包含了三个包：\norg.w3c.dom，W3C推荐的用于XML标准规范的文档对象模型的Java工具。 org.xml.sax，用于对XML进行语法分析的事件驱动的简单API。 javax.xml.parsers，工厂化的工具，允许应用程序开发人员获得并配置特殊的语法分析器工具。 JAXP对Java的缺点：\n可以说JAXP是完全按照DOM和SAX的规范在Java语言上的实现，DOM和SAX规定什么接口以及接口有什么功能，JAXP就完全按照这些固定在Java语言下进行实现。然而，DOM和SAX规范根据接口定义语言来写的，它们的任务是在不同语言实现中定义一个最低的通用标准，也就是不是专为Java设计的。这种设计方法虽然能够保留了在不同语言中非常相似的API，但是在Java中会让程序员感觉到麻烦，因为DOM和SAX的规则并不完全对应Java语言的规则，比如Java对于字符串有String类，但是DOM规范定义自己的Text类。 在实际应用中，SAX没有文档修改、随机访问以及输出的功能；DOM的树形层次结构非常严格，对应XML在DOM中每个元素都是一个节点，几乎都扩展与Node接口和返回Node的一系列方法，但是在Java语言中应用部方便，比如Node向叶类型做向下类型转换需要的代码冗长并难以理解。 W3C DOM是接口驱动的，公共的DOM API仅由接口组成，使用时w3c标准大量使用工厂化的类和类似的灵活性但不直接的模式，例如解析器需要工厂模式创建。 JDOM：专为Java语言开发的一个使用XML的工具，是一个开源项目，为解决Java直接使用DOM和SAX接口的JAXP带来的不方便而研发。在具体使用上是一个第三方开发的类包。\nJDOM基于树形结构，用纯Java的技术对XML文档实现解析、生成、序列化以及其它多种操作，是直接为Java编程服务的。相比较JAXP，它利用Java语言强有力的诸多特性（方法重载、集合概念等），把SAX和DON的功能有效的结合起来，提供了用Java语言读写和操作XML的新API。这些API函数在直接、简单和高效的前提下，尽可能的隐藏了原来DOM和SAX使用XML过程中的复杂性，进行了最大限度的优化。\nJDOM的优点：\nJDOM是Java平台专用的，给Java程序员提供丰富并且和Java语言类似的环境。比如，JDOM基本都使用String类处理XML中的文本值，使用JDOM还可以利用Java的一些累计，如List等。 JDOM没有层次性，对应XML中的各个部分，元素就是Element类对象，属性就是Attribute类对象，XML文档本身就是Document类对象。也就是说，在JDOM中，每一种XML部分都有具体类对应，而不是作为一个含糊的Node。 JDOM是类驱动的，JDOM的对象就是像Document、Element和Attribute这些类的对象，所以创建一个新的JDOM对象就跟Java语言中用new构造一个对象那么容易，使用起来比使用工厂化接口配置更来得直接。 JDOM类包的组成：\norg.jdom，包含了所有xml文档要素的java类，如Document等。 org.jdom.adapters，包含了与dom适配的java类。 org.jdom.filter，包含了xml文档的过滤器类。 org.jdom.input，包含了读取xml文档的类。 org.jdom.output，包含了写入xml文档的类。 org.jdom.transfrom，包含将jdomxml文档接口转换为其它xml文档接口。 org.jdom.xpath，包含了对xml文档xpath操作的类。 方法链编程风格：基于调用一个对象的方法后，方法的返回值是调用的对象。这么做的好处就是可以在方法后面直接继续调用该对象的其它方法，JDOM中类的方法大都支持这种风格。如：element.addContent(elementother).setAttribute(\u0026ldquo;name\u0026rdquo;,\u0026ldquo;value\u0026rdquo;)。\nJDOM常用org.jdom.output.XMLOutputter类的output方法来将程序新建或更改的内容写入到指定的XML文档中。\nJDOM的org.jdom.output.Format类用于设置输出XML文档的格式，XMLOutputter类的构造方法可以接收一个Format对象。\nJDOM的org.jdom.input包下的SAXBuilder类、DOMBuilder类、ResultSetBuilder类常用与解析XML文档。\nJDOM解析一个XML文档后，并在程序中进行了修改，这些修改只是保存在内存中相应的对象里，并没有直接修改到解析的XML文档中。如果要将修改保存到XML文档中，需要使用XMLOutputter对象将Document对象写会才会保存到文档中。\nJDOM的Format类的getRowFormat方法可以去除XML文档中不必要的空白，这也是XMLOutputter类默认的格式，这种格式可以减少XML在网络上传输的数据量，从而提高传输效率。\ndom4j：由第三方开发的另一种专为Java语言处理XML文档的类包，同样提供了大量符合Java语法习惯的API供开发者使用，而且大部分API的使用方式与JDOM类似（开发dom4j的成员很多是开发JDOM的成员）。与JDOM不同的是，Document、Element、Attribute等不是类，而是接口。创建Document、Element、Attribute等接口对象是由org.dom4j.DocumentHelper类对象的静态成员方法闯将，DocumentHelper类提供了大量创建这些接口对象的static方法，可以说，DocumentHelper类就是一个辅助类。\ndom4j将Document输出到XML文档是通过org.dom4j.io.XMLWriter类来实现，其中有多种构造方法，可以接收XML文档的输出流，如果输出流是一个Writer流的话，在使用write(Document document)之后，需要调用XMLWriter的flush方法或者close方法将缓冲输出才会将document的XML数据输出到文档上。\ndom4j解析一个XML文档通过org.dom4j.io.SAXReader类的read方法解析，read方法返回一个Document接口对象，通过Document可以访问XML文档中的各种部件。\norg.dom4j.io.DOMReader类同样用于解析XML文档，该类的read方法可以接收一个org.w3c.dom.Document对象，并返回一个org.dom4j.Document对象，也就是将一个JAXP的Document对象转换成dom4j的Document对象，由于在同个源文件中使用两个同名类，所以类名需要使用全名。\n开发dom4j应用程序详见dom4j帮助文档。\n","date":"June 11, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E4%BA%94%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"XML","url":"https://www.qinxiandiqi.sbs/tags/xml/"}],"title":"JavaSE学习笔记第十五记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":" 简单工厂模式：是一种创建类对象的模式，由一个工厂类根据传入的参数动态决定创建哪一个产品类的实例。\n简单工厂模式的角色：\n工厂类角色：与用户直接打交道的角色，通常是一个具体类。该角色中包含一个静态工厂方法，用户通过该静态工厂方法传入一定的参数，静态工厂方法根据传入的参数创建对应的具体产品对象返回。 抽象产品角色：简单工厂模式要创建所有对象的父类，通常是一个接口或者抽象类。在工厂类的静态工厂方法中的返回类型就是抽象产品类。 具体产品角色：实际要创建的类对象，都继承或者实现抽象产品类，是一个具体类，一个简单工厂模式中一般具有多个具体产品类。 XML文档解析的两种接口规范：DOM和SAX。接口需要实现，不同编程语言对这两种接口规范的实现代码不同，但是实现的结果是一样的，实现完成的功能必须符合接口的规范。因此，可以说这两种接口规范是与语言无关，也与平台无关的。这也导致XML可作为不同语言、不同应用程序、不同平台之间交换数据的载体。\nDOM是W3C指定的一套XML分析器的标准接口规范，全称为Document Object Model，即文档对象模型。基于DOM的XML分析器将一个XML文档转换为一个树形对象模型的集合，模型中的每一个节点都是一个对象。在应用程序中，就是通过DOM的XML分析器将XML文档进行树形结构的对象化，再通过DOM提供的接口来操作XML文档对象。可以说，XML文档代表的是数据，而DOM代表的是如何去处理这些数据。\n通过DOM接口可以在任何时候访问XML文档中的任何一部分数据（因为它们都读取到内存中），所以DOM接口的机制也称为随机访问机制。但另一方面，由于DOM是根据树形结构将XML的数据对象化，如果XML数据很多的时候，将会特别占用内存，遍历树的耗时也会比较高，这也是DOM的缺点。\nDOM树模型结构：\n文档，即根节点：文档节点是整个文档中所有其它节点的父节点，文档节点是整个文档的入口。备注：根节点不等于根元素节点，根节点之后才是根元素节点。 元素节点：跟据XML文档中对应的元素创建，元素节点可以拥有其它子元素节点，以及属性节点和文本节点。同时，元素节点也是唯一拥有属性节点的节点类型。 属性节点：根据XML文档中的属性创建，实际上也不认为它是元素节点的子节点。 文本节点：包含数据的节点，一般是对应XML文档中的元素内容。 其它不常见节点：CDATA、注释、处理指令。 DOM的四个基本接口：Node、Document、NodeList、NameNodeMap。其中Document接口是堆XML文档操作的入口，从Node接口中继承过来。Node是其它大多数接口的父接口，像Document、Element、Attribute、Text、Comment等代表一个XML元素或属性和内容的接口都是从Node中继承过来，因为DOM中把XML中的每个标签和属性都当做一个Node处理。NodeList接口是一些节点的集合，包含了某个节点的所有子节点。NameNodeMap接口也是一些节点的集合，可以建立节点名和节点之间的一一对应关系，一般用于元素和属性之间的对应关系。\nNode接口：org.w3c.dom.Node，是其它XML树结构对应节点的父接口，在DOM树结构中具有重要地位，它定义一整套处理DOM节点的基本方法。Node借口中的主要方法：\ngetElementsByTagName(String name)：该方法将返回一个NodeLise对象，对象中是该Node下所有名字为name的标签Node集合。 getFirstChild（）：返回该Node下的第一个子节点的Node，如果不存在则返回null。 getNodeValue（）：返回该Node的值，取决于其类型（见JDK帮助文档Node固定值表）。 getNodeType（）：返回该Node类型代表的short值，Node类型与short对应表详见JDK帮助文档。 getTextContent（）：返回该Node节点及其子节点的文本内容，根据Node具体类型的不同将采用不同的内容拼接方法（见JDK帮助文档），特别的，子节点之间的空格当做一个空白的Text节点。 Document接口：org.w3c.dom.Document，继承Node接口，代表了整个XML文档，XML其它Node都按照一定的顺序包含在Document节点对象内，并排雷成一个树形结构。因此，要对XML文档进行操作总是要先通过解析XML文档获得该文档的而一个Document对象才能继续后续操作。由于Document接口中定义了大量创建其它DOM节点对象的工厂方法，也提供了大量操作其它DOM节点对象的方法，从而实现成为访问XML文档的入口。Document接口中的主要方法：\ngetDocumentElement（）：获得该XML文档的根元素Element对象返回。 NodeList接口：org.w3c.dom.NodeList（没有继承Node接口）。NodeList相当于一个Node的集合，该接口中只提供了两个方法：\ngetLength（）：获取NodeList中Node的个数。 item（int index）：获取NodeList中索引号为index的Node对象，索引从0开始计算起。 Element接口：org.w3c.dom.Element，继承Node，代表XML文档中的元素，是DOM中唯一可以包含属性的节点。主要方法有：\ngetTagName（）：获得该Element元素的标签名返回。 getChildNodes()：获得该Element的子元素Node的集合NodeList返回，需要注意的是该方法将Element下子元素标签之间的空格也当做一个空Text的Node，所以此时使用NodeList的getLength方法返回值包括空格数在内。 getAttributes（）：返回一个NameNodeMap对象，其中包含该Element的Attr节点对象。 Attr接口：org.w3c.dom.Attr，继承Node，代表XML文档中元素的属性。虽然它是Node，严格来说，它不能作为一个DOM树中的节点，因为Attr实际上是包含在Element中，所以并不能看做是Element的子对象。也正是因为这原因，它从Node继承来的getparentNode（）、getpreviousSibling（）、getnextSibling（）方法的返回值都是null。\nText接口：org.w3c.dom.Text，继承Node接口，代表XML文档中元素的文本内容，在DOM树结构中，元素的文本内容也使用Node，并且它不能有子节点，继承Node的相关操作不能使用。Text节点的NodeName为“#text”。\n接口都需要实际类的实现，所以以上Node等接口在实际上是需要通过java其它包下的一些实际类来实现，而用于一般不需要直接与这些实际实现类打交道，通过接口及工厂模式的方法来实现DOM接口。\nXML解析器实质上就是一段代码，它能够读入一个XML文档并分析文档的结构。DOM的解析器通过解析XML文档就能为XML文档在逻辑上建立一个树模型，其树的节点是一个个对象，通过DOM接口存取这些对象就能存取XML文档的数据内容。\nJAXP（Java API for Parsing）：用于XML解析的Java API，由SUN公司提供。\nJava应用程序使用XML的一般步骤：\njavax.xml.parsers.DocumentBuilderFactory抽象类：通过DocumentBuilderFactory解析器工厂类的静态newInstance()方法创建一个DocumentBuilderFactory解析器工厂类对象dbf（DocumentBuilderFactory既是工厂类角色又是抽象产品角色）。newInstance()方法能根据一个系统变量（决定构建哪一种具体产品类的参数）来决定创建哪一种解析器工厂对象，只要该系统变量改变就能创建出不同的解析器。这种做法的好处是：无论最终生成的是哪一种解析器，它都符合JAXP的规范，所以只要改变系统变量就能创建出不同的解析器工厂对象，最终创建出另一种解析器，而程序照常可以使用新解析器（JAXP接口不变），不需要改变任何代码。 通过DocumentBuilderFactory类对象dbf，通过它的newDocumentBuilder()方法创建一个它对应的具体DocumentBuilder解析器对象db，也就是这个db就代表了一个具体的DOM解析器。 通过DocumentBuilder对象db的parse（type）解析一个XML文档，该方法将返回一个Document对象，也就是该XML文档的根节点。parse是重载方法，有多种类型参数可选，一般使用parse（String url）。 通过Document对象以及它提供的各种Node方法实现对XML的操作。 ","date":"June 11, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"工厂模式","url":"https://www.qinxiandiqi.sbs/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"XML","url":"https://www.qinxiandiqi.sbs/tags/xml/"},{"title":"DOM","url":"https://www.qinxiandiqi.sbs/tags/dom/"},{"title":"SAX","url":"https://www.qinxiandiqi.sbs/tags/sax/"}],"title":"JavaSE学习笔记 第十四记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[{"title":"翻译","url":"https://www.qinxiandiqi.sbs/categories/%E7%BF%BB%E8%AF%91/"},{"title":"Android","url":"https://www.qinxiandiqi.sbs/categories/android/"}],"content":" 原文作者：Google\n原文地址：http://developer.android.com/google/play-services/setup.html\n原文版权：Creative Commons 3.0 Attribution License\n译文作者：Jianan - qinxiandiqi@foxmail.com\n版本信息：本文基于2014-06-09版本开始翻译，基于2015-10-17版本重新翻译\n​译文版权：CC BY-NC-ND 4.0，允许复制转载，但必须保留译文作者署名及译文链接，不得演绎和用于商业用途\n​\n一、前言# 开发一个使用Google Play services API的应用，你需要为你的项目配置Google Play services SDK。如果还没有你还没有安装Google Play services SDK，现在你可以按照Android SDK Packages指南来获取。\n为了能够测试使用Google Play Services的应用，你需要具备：\n一个运行Android2.3或者更高系统版本，并且包含google Play stroe的Android设备 一个运行基于Android4.2.2或者更高版本google APIs平台系统的Android虚拟机 二、添加Google Play Services到你的项目中（Add Google Play Services to Your Project）# 根据你的开发环境选择下个面的步骤添加Google Play Services到你的项目中：\n2.1 Android Studio# 2.1.1 配置你的app可使用Google Play Services API：# 打开你的应用module中的build.grade文件。 注意：Android Studio项目包含一个顶级build.gradle文件以及每个module中各包含一个build.grade文件。确认编辑的是你的应用module中的文件。参考Building Your Project with Gradle获取更多耿玉Gradle的内容。\n在dependencies下面添加一个play-services最新版本的构建规则。例如\napply plugin:\u0026#39;android\u0026#39; ... dependencies{ compile \u0026#39;com.google.android.gms:play-services:8.1.0\u0026#39; } 当你每次更新Google Play services版本之后，你需要取保更新这里的版本号。\n注意：如果你的app中引用的的方法数量超过了65K限制，你的app可能会编译失败。为了解决这个问题，你可以通过只选择你的app需要的Google Play services API去参与编译，而不是全部api都包含进去。更多关于此做法的信息请参考下面选择性编译API到你的可执行程序中章节。\n保存修改，并且点击工具栏中的Sync Project with Gradle Files按钮。\n现在你开始使用Google Play services API的功能进行开发了。\n2.1.2 选择性编译API到你的可执行程序中（Selectively compiling APIs into your executable）# 在Google Play Services 6.5之前的版本，你必须将整个api的包全部编译到你的app里面去。在一些情况下，这么做很难保持app中全部方法的数量在65536这个限制之下（包括framework的api，依赖库的api，以及你自己项目的代码）。\n从6.5版本开始，你可以有选择的编译部分Google Play service API到你的app中。例如，如果只是需要Google Fit和Android Wear API，那么你可以在build.grade文件中做以下替换：\n原来是：\ncompile \u0026#39;com.google.android.gms:play-services:8.1.0\u0026#39; 替换成：\ncompile \u0026#39;com.google.android.gms:play-services-fitness:8.1.0\u0026#39; compile \u0026#39;com.google.android.gms:play-services-wearable:8.1.0\u0026#39; 表1展示了一个分离的API列表，表中描述了你可以独立选择编译到你的app中的模块，以及如何在build.gradle文件中声明。有部分API没有一个单独的library，它们被包含在基础library里面（当你需要用到一个没有分离出来的API时，这个基础library会自动包含进来。）\n表1：独立的API模块以及相应的build.grade描述\nGoogle Play services API 在build.grade中的描述 Google+ com.google.android.gms.play-services-plus:8.1.0 Google Account Login com.google.android.gms.play-services-identity:8.1.0 Google Actions,Base Client Library com.google.android.gms.play-services-base:8.1.0 Google App Indexing com.google.android.gms.play-services-appindexing:8.1.0 Google App Invites com.google.android.gms.play-services-appinvite:8.1.0 Google Analytics com.google.android.gms.play-services-analytics:8.1.0 Google Cast com.google.android.gms.play-services-cast:8.1.0 Google Cloud Messaging com.google.android.gms.play-services-gcm:8.1.0 Google Drive com.google.android.gms.play-services-drive:8.1.0 Google Fit com.google.android.gms.play-services-fitness:8.1.0 Google Location,Activity Recognition,and Places com.google.android.gms.play-services-location:8.1.0 Google Map com.google.android.gms.play-services-maps:8.1.0 Google Mobile Ads com.google.android.gms.play-services-ads:8.1.0 Mobile Vision com.google.android.gms.play-services-vision:8.1.0 Google Nearby com.google.android.gms.play-services-nearby:8.1.0 Google Panorama Viewer com.google.android.gms.play-services-panorama:8.1.0 Google Play Game services com.google.android.gms.play-services-games:8.1.0 SafetyNet com.google.android.gms.play-services-safetynet:8.1.0 Google Wallet com.google.android.gms.play-services-wallet:8.1.0 Android Wear com.google.android.gms.play-services-wearable:8.1.0 注意：在Google Play services的library中已经包含了ProGuard指令用于保留需要的类。Android Gradle Plugin会自动添加一个AAR（Android压缩包）包中的ProGuard配置文件，并将这个包添加到你的ProGuard配置里面。在项目的创建过程中，Android Studio会自动创建这个ProGuard配置文件以及build.grade属性供ProGuard（程序）使用。在Android Studio中使用ProGuard，你必须在build.grade文件中的buildTypes里面启用ProGuard设置。更多信息，请参考ProGuard指南。\n2.2 Eclipse(ADT插件)或其它方式# 2.2.1 配置你的app可使用Google Play services API：# 将\u0026lt;android-sdk\u0026gt;/extras/google/google_play_services/libproject/google-play-services_lib路径下的项目复制到你维护你的app项目的目录下。 将这个library项目导入到你的Eclipse工作空间。点击File\u0026gt;Import，选择Android\u0026gt;Existing Android Code into Workspace，然后浏览选择复制过来的library项目并导入。 在你的app项目里面，链接引入Google Play services项目。参考使用Eclipse和ADT插件管理Android项目或者使用命令行链接library项目获取更多相关信息。\n注意：你必须链接复制到你开发工作空间的库项目，不能直接链接到Android SDK目录下的库项目（译者注：SDK Manager更新的Google Play Services版本的时候可能会有变化，所以不建议）。 当你将Google Play services库项目作为依赖库链接到你的应用项目之后，你需要打开你项目中的manifest文件，并且添加以下子标签到标签下： \u0026lt;meta-data android:name=\u0026#34;com.google.android.gms.version\u0026#34; androdi:value=\u0026#34;@integer/google_play_services_version\u0026#34;/\u0026gt; 一旦你将库项目链接到你的项目，你就可以开始使用Google Play service APIs提供的功能进行开发。 2.2.2 添加Proguard排除# 为了防止ProGuard剥离了一些需要的类，需要在/proguard-project.txt文件中添加以下内容：\n-keep class * extends java.util.ListResourceBundle { protected Object[][] getContents(); } -keep public class com.google.android.gms.common.internal.safeparcel.SafeParcelable { public static final *** NULL; } -keepnames @com.google.android.gms.common.annotation.KeepName class * -keepclassmembernames class * { @com.google.android.gms.common.annotation.KeepName *; } -keepnames class * implements android.os.Parcelable { public static final ** CREATOR; } 三、确保设备安装了Google Play services APK（Ensure Devices Have the Google Play services APK）# 正如Google Play services概述中所说的，在Android 2.3或者更高版本中，Google Play通过Google Play Store应用为用户提供升级服务。但是，可能不是所有用户都能立刻收到更新。因此，在你尝试使用API之前，你应该确认当前版本是可用的。\n重要：由于很难确定每一台设备的情况，你应该经常在使用Google Play services功能之前检查Google Play services APK的版本是否兼容。\n由于每个应用对Google Play services的使用不同，你可以根据需要决定检查Google Play services版本的时机。例如，如果你的应用在各种情况下都需要使用到Google Play services，你可能就需要在应用一启动的时候就做检查。如果Google Play services只是你应用的一个可选部分，那么可以只在用户进入到需要使用Google Play services部分的时候再做检查。\n强烈建议你使用GoogleApiClient类来连接Google Play services的功能。这种方法允许你添加一个OnConnectionFailedListenter到你的GoogleApiClient，实现其中的onConnectionFailed()回调方法就能判断当前设备是否有安装合适版本的Google Play services APK。如果由于Google Play APK没有安装或者版本过时就会导致连接失败，回调可能会收到类似SERVICE_MISSING、SERVICE_VERSION_UPDATE_REQUIRED，或者SERVICE_DISABLED这样的错误码。学习更多关于如何创建自己的GoogleApiClient并处理这样的连接错误，请参考连接Google APIs.\n还有其它方法就是通过使用isGooglePlayServicesAvailable()方法。你可以在主Activity的onResume()方法中调用这个方法。如果返回的结果是SUCCESS，说明Google Play services APK的版本是最新的，你可以继续创建一个连接。如果返回的结果是SERVICE_MISSING,SERVICE_VERSION_UPDATE_REQUIRED或者SERVICE_DISABLED，那么用户将需要去安装更新。在这种情况下，可以调用GooglePlayServicesUtil.getErrorDialog()方法并且将错误码传递进去。这个方法会返回一个对话框，它会显示对应的错误信息，并且提供一个操作将用户引导去Google Play Store安装更新。\n接下来开始一个Google Play service的连接（大部分Google API，如Google Drive、Google+、Games等，都需要这个连接）。请参考连接Google APIs。\n​\n​\n","date":"June 9, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/android/%E8%AE%BE%E7%BD%AEgoogleplayservicessdk/","series":[],"smallImg":"","tags":[{"title":"Android","url":"https://www.qinxiandiqi.sbs/tags/android/"},{"title":"翻译","url":"https://www.qinxiandiqi.sbs/tags/%E7%BF%BB%E8%AF%91/"},{"title":"Google Play Service","url":"https://www.qinxiandiqi.sbs/tags/google-play-service/"}],"title":"设置Google Play Services SDK(Set Up Google Play Services SDK)"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-08-02# 单例模式的两种实现方法中，如果将构造单例对象的方法放置到获取单例对象的方法中，在多线程的情况下有可能违反单例模式的要求产生不同的单例对象。而在定义的单例对象成员时就构造对象则不会出现这种情况。\nURL包装的URL值必须包含协议名称，即使是HTTP也要包含，不同于浏览器会自动添加。\njava.net.InetAddress类：用于封装IP地址和主机名的类。该类没有明显的构造函数，是采用工厂模式设计的类，构造一个InetAddress类需要通过类中的getLocalHost（）、getByName（）、getAllByName（）等static方法获得。getLocalHost（）用于获取封装本机IP的InetAddress对象，getByName(String name)用于获取主机名为name的InetAddress对象（一般name是用主机的域名），getAllByName（String name）用于获取主机名为name的一个InetAddress对象数组（有些主机有多个网卡可以拥有多个IP）。这些静态方法一旦获取失败会引发UnknowHostException异常。\nSocket：是连接运行在网络上的两个程序间的双向通讯端点，分为服务器端Socket和客户端Socket。\njava.net.ServerSocket类：实现服务器套接字的类，基于TCP协议！用于等待通过网络传入的请求，并可能想请求者返回结果。关闭ServerSocket需要使用close方法。\n主要的构造方法有ServerSocket（int port），创建一个用于监听port端口的服务器套接字，如果port为0就会随机分配一个端口并创建监听这个端口的服务器套接字。 public Socket accept（）throws IOException：启动该ServerSocket对象监听port端口，在有连接请求传入之前一直处于阻塞状态，有连接请求传入时能够创建一个新端口号的Socket用于连接请求。 java.net.Socket类：两台机器之间通讯的端点，基于TCP协议！用于实现客户端套接字（实际上服务端套接字接收请求后也会在服务器端创建Socket）。Socket之间通过io流传送数据，当Socket要发送数据时要通过输出流，当Socket要读取数据时要通过输入流。关闭Socket需要使用它的close方法。\n主要构造方法有Socket（String address，int port）：用于创建与IP为address，端口号为port相连的流套接字。一旦创建成功，就表示已经于该IP主机的port端口正常连接上。 通过getOutputStream（）获取套接字的输出流（对方Socket的输入流），通过getInputStream（）获取套接字的输入流（对方Socket的输出流）。 使用Socket进行网络通讯的一般过程：\n服务器程序创建一个ServerSocket对象绑定到一个特定的端口，并通过ServerSocket的accept方法启动等待监听客户的连接请求功能，一般将accept方法放置于死循环中，这样每当监听到客户连接请求时才能执行一次。 客户程序根据服务器程序所在主机名或IP以及端口号，创建Socket对象向服务器程序的ServerSocket监听的端口发出连接请求。 如果服务器接收到客户端程序的连接请求后，将会创建一个新的绑定到不同端口地址的Socket与客户端的Socket通过读写（getOutputStream和getInputStream）套接字进行通讯。同时服务器程序的ServerSocket仍然继续监听其端口的连接请求。 127.0.0.1和localhost都代表本机。\n当服务器端和客户端已经各自建立起Socket连接后，如果通过Socket直接通讯的话，只能按照程序已经规定的格式依次使用读写流通讯（比如使用InputStream输入流读取数据多少次后再通过OutputStream输出多少次，顺序不能修改），而大多数情况下，什么时候读数据什么写数据是无法确定的。为了解决这个问题，需要为服务器端每一个Socket创建一个读取InputStream线程和输出OutputStream线程，也要为客户端每一个Socket创建一个读取InputStream线程和输出OutputStream线程，这么一来，读写操作分开又交由线程去处理，可以并发执行，无论服务端还是客户端在什么时候要进行读写都能正确接收。\nJava提供了java.net.DatagramSocket类和java.net.DatagramPacket类来实现基于UDP协议的网络编程。在UDP编程中，没有严格区分服务端和客户端，其通讯方法类似于信件传送，UDP数据报中包含了发送方和接收方法的IP和端口与信息，发送方和接收方的角色是相对的。\njava.net.DatagramSocket类：基于UDP协议的两台机器间的通讯端点。关闭DatagramSocket对象需要使用close方法。\n主要构造方法有DatagramSocket（int port），用于创建监听prot端口的DatagramSocket对象，如果没有数据报接收就会进入阻塞状态，不往下执行。 sent（DatagramPacket p），用于将数据报DatagramPacket对象发送出去。 receive（DatagramPacket p），用于接收数据报DatagramPacket对象。 java.net.DatagramPacket类：封装UDP数据报的类。\n主要构造方法有DatagramPacket（byte[] buf，int offset，int length，InetAddress address，int port）：创建一个DatagramPacket对象，其中buf为该对象封装的字节数组数据信息，offset表示封装buf数组数据的起始位置，length表示封装的字节数据长度，address表示该对象将要发送到的机器地址，port表示该对象将要发送往的机器上的端口位置。 setData（byte[] buf，int offset，int length）：设置DatagramPacket对象封装的字节数组buf，offset为封装的起始位置，length表示封装的字节长度。 getData（）：放回一个byte[]数组，获取DatagramPacket对象中封装的字节数组数据。 getLength（）：获取DatagramPacket对象中封装的字节数组长度。 getAddress（）：当DatagramSocket接收到一个DatagramPacket对象后，可使用此方法获取该对象是从哪个机器发过来的。 getPort（）：当DatagramSocket接收到一个DatagramPacket对象后，可使用此方法获取该对象从发送机器的哪个端口发送出来的。 使用DatagramSocket和DatagramPacket进行UDP通讯的一般过程：\n创建DatagramSocket对象和DatagramPacket对象，用DatagramPacket封装需要发送的数据和接收方的InetAddress和端口。 使用DatagramSocket对象的sent方法将DatagramPacket方法发送出去。 接收方同样需要创建DatagramSocket对象和DatagramPacket对象，以及接收数据的byte[]空数组。DatagramSocket对象需要指定发送方DatagramPacket对象设置的端口。DatagramPacket对象使用空数组byte[]构造。 接收方使用DatagramSocket的receive方法将接收的DatagramPacket对象，便可以通过DatagramPacket对象的各种方法获取发送方发送的byte数组，以及发送方InetAddress和端口等信息。 反过来，接收方向发送方发送数据时，将发送方当做接收方，将接收方当做发送方按照以上步骤便可。 同样类似于Socket，可以使用两个线程分管DatagramSocket的发送和接收。\n","date":"June 9, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"Socket","url":"https://www.qinxiandiqi.sbs/tags/socket/"},{"title":"Java网络编程","url":"https://www.qinxiandiqi.sbs/tags/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"title":"JavaSE学习笔记 第十三记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-08-01# wait（）：Object定义的方法，不能被重写。当一个线程调用该方法时，该线程必须拥有对象的锁，所以wait（）必须包含在synchronized方法或者代码块中才能保证调用wait方法是线程拥有一个对象的锁。当线程调用wait方法后，线程会自动放弃对上锁对象的锁，并进入等待重新获得锁的状态，重新获得锁后线程将从wait之后的代码继续运行。重新获得锁的方法由其它拥有该对象锁的线程调用notify（）方法。\nnotify（）：Object定义的方法，不能被重写，与wait配套使用，同样调用该方法的线程必须拥有该对象锁，所以notify方法也必须在synchronized方法或代码块中调用。当一个线程调用notify方法后，将会唤醒因与当前对象拥有同个锁，并调用wait方法进入等待的线程。如果存在多个wait线程，则会通过线程竞争的方法选择唤醒哪个线程。然而，并不是当前线程调用notify方法后就能立即唤醒被wait方法进入等待的线程，而是得等到向前线程结束或抛出异常而对上锁对象解锁后才能调用被wait进入等待的线程。\n多个线程中，有一个对象的wait出现，就一定有该对象的notify出现，但是两者在数量上可能不一致。并且，wait方法前一般有一个条件判断，当条件满足时才调用wait。通常情况下，使用while包装wait，让每次线程被唤醒后都要再检查一次条件是否满足，因为在并发线程比较多的时候，线程被唤醒时，可能由于其它线程干扰导致条件改变，若不检查容易出现并发错误。\nThread.sleep方法也能令线程暂停，并且能指定暂停多长时间。与wait不同的是，sleep方法暂停时不会释放掉对象的锁，并且当暂时时间过去后，线程能自动被唤醒（wait需要notify方法唤醒）。因此sleep线程被唤醒时已经拥有对象的锁，所以才能继续马上继续进行（wait唤醒后还要重新等待获取到对象锁才能继续运行）。\n由于wait和notify，线程对象多了wait阻塞状态。当线程调用了wait方法后，线程便进入wait阻塞状态，并进入等待池（wait pool），直到其他线程调用同锁对象的notify方法，线程便进入上锁阻塞状态，也就是进入锁池（look pool）。\n线程组：一些线程的集合，一个线程被创建后不能再修改其隶属的线程组，创建一个线程时若没有指定线程组，则新线程与创建其的父线程隶属于同一个线程组。线程组比较少用到。\n对象的浅拷贝：当对一个对象进行浅拷贝后，拷贝出来的对象会提供一套新的对象成员变量来复制接收原对象的各个成员变量值。因此，如果是原对象的原生数据类型成员变量，则直接将值复制过来，但如果是对象引用类型变量，由于对象类型引用变量的值只是个地址，所以复制过来的也是对象的对象成员地址，导致浅拷贝后对象的对象成员变量指向原对象的对象成员。一旦原对象或新对象任何一方的对象成员内的成员变量值发生改变，将会互相影响。但是，如果是对原对象或新对象任何一方的对象成员赋予另一个对象引用值的话，由于不再指向同一个对象，所以原对象和新对象之间不再互相影响。\n对象的深拷贝：在基于对象浅拷贝的基础上，除了对象原生数据类型成员的复制方法一样之外，对于对象成员，深拷贝是重新构造一个对象成员再将新对象成员的引用赋给新对象的对象成员变量。因此，深拷贝之后，原对象和新对象的对象成员变量都不指向同一个对象，它们之间互不影响。\n实现浅拷贝和深拷贝的方法：\n浅拷贝：Object类提供了clone（）方法，其作用是进行浅拷贝，但由于其修饰符是protected，在外包中不可见，Java要求对需要进行拷贝的类要重写这个clone方法，并且要实现接口Cloneable（Cloneable是一个标识性接口，里面没有定义任何方法，只是声明而已，类似于serializable接口）和将方法声明修饰符改为public（对外包可见）。在重写的clone方法中要调用Object的方法（super.clone()），便可以进行浅拷贝。Object的clone浅拷贝的结果符合x.clone()!=x为true、x.clone().getClass()==x.getClass()为true、x.clone().equals(x)为true。 深拷贝方法一：将需要深拷贝对象类在浅拷贝基础上，重写clone方法中调用super.clone()之后，调用每个对象成员的clone方法。因此，每个对象成员的类都要实现浅拷贝的方法，若对象成员又包含自己的对象成员，则它们也要编写浅拷贝，以此类推。 深拷贝方法二：利用对象序列化和反序列化。当一个对象包含多个对象成员时需要对每个对象成员都进行拷贝会很繁琐，但是借助对象序列化和反序列化能够复制对象和它对象链上的所有内容到流上，又能将所有对象信息充流上读回来的特点，可以间接的实现深拷贝。当然，前提是对象的每个对象成员都可以序列化。（序列化要点：实现Serializable接口，利用ObjectOutputstream和ObjectInputstream包装流）。这种方法是最常用的深拷贝方法。 当类实现Serializable接口表明可序列化时，定义long静态成员变量serialVersionUID的作用在于：当该类对象序列化后反序列化回来时，若此类的定义已经发生改变（删除了一些成员变量或者增加了一些成员变量），如果没有定义这个serialVersionUID就会抛出Exception，无法进行序列化。而如果有定义serialVersionUID，反序列化若遇到类已经改变的情况，不会直接抛出Exception，而是查找类的serialVersionUID值是否相同，相同话就还是可以反序列化回来，对于被删除或者增加的成员将会以成员类型的默认属性赋值。可以说，serialVersionUID提供了对象向后兼容的可能。\nIP用于确定数据包需要送达的主机位置，端口用于确定数据包需要交付给主机上哪一个程序。端口使用一个16位数字表示，范围0-65535。http协议默认使用80端口，用户程序使用的端口最好选择1024之后的端口。\n在网络分层模型中，对等层协议之间交换的信息单元统称为PDU，下层把上层的PDU当做本层PDU的数据部分封装。\nJava提供了对网络编程的支持，与网络编程相关的类包含在java.net包中。\nURL：统一资源定位符的简称（Uniform Resource Locator），表示Internet上某一资源的地址，通过URL可以访问Internet上的各种网络资源。使用URL进行网络编程，不需要对协议本身有太多的了解，功能也比较弱，相对而言比较简单。一个URL主要包括协议标识符和资源名字两个部分。\njava.net.URL类：URL类对象用于封装一个URL地址，并提供了相关URL操作方法。可以通过URL地址字符串直接创建URL对象，也可使用其它构造方法构造，如果构造失败会抛出MalfformedURLException异常。使用getProtocol（获取协议）、getHost（主机名）、getPort（端口）、getFile（文件名）、getRef（URL锚点）等方法可以获取URL对象相关属性。\n构造一个URL对象并不等于连接了URL指向的文件，需要使用URL的openConnection（）方法返回一个URLConnection对象（可能引发IOException异常），获得该URL的连接，再利用URLConnection对象的getInputStream（）方法可以获取该URL指向的文件的输入流，继而通过对输入流的操作可以获取该URL指向的文件。URL类也提供了openStream（）方法可返回URL对象指向文件的InputStream输入流，本质上是对以上两个方法的综合调用。\njava.net.URLConnection类：访问远程资源属性的一般用途类。当建立了与远程服务器之间的连接后，可以在传输它到本地之前用URLConnection对象来检察远程对象的属性，只对HTTP协议的URL对象有意义。\n","date":"June 6, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"线程","url":"https://www.qinxiandiqi.sbs/tags/%E7%BA%BF%E7%A8%8B/"},{"title":"对象拷贝","url":"https://www.qinxiandiqi.sbs/tags/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"},{"title":"Java网络编程","url":"https://www.qinxiandiqi.sbs/tags/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"title":"JavaSE学习笔记 第十二记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":" 线程的实现方法：\n继承Thread类，并重写run方法。 Thread类是专门用来创建线程和对线程进行操作的类，其中定义了许多方法对线程进行操作。继承Thread的子类线程类要把线程需要实现的代码写到run（）方法中，线程对象实现线程的时候执行的线程内容就是run方法中的内容。由于Thread类的run方法中只是个判断是否存在实现Runnable接口对象的语句，继承Tread类的子类没有传入Runnable对象，所以什么都不做，因此要求每个继承Thread的线程类都必须重写run方法，否则继承的线程类对象什么都不做。 另外，启动线程的方法只有使用线程对象的start（）方法一种，调用start方法会先为线程准备好线程需要的系统资源，然后再启动线程并运行线程的run方法。如果直接调用线程对象的run方法则跟调用一个普通类的普通方法一样，不会形成新的线程执行。另外，一个线程对象只能使用start方法启动一次，多次使用start方法不允许，将抛出异常，即使是该线程对象的run方法已经执行完毕，线程也已经结束，也不能使用start方法重新启动。 将实现Runnable接口的类对象以参数的形式传递给Thread的构造方法Thread（Runnable target），构造一个Thread对象，并使用Thread的start方法启动线程。Runnable接口只定义了一个run方法，所以实现Runable接口的类必须实现这个run方法，线程启动后也是运行这个run方法。常见的形式是使用匿名内部类的形式实现Runnable接口：new Thread（new Runnable（）{public void run（）{}}；。 Thread类和Runnable接口的联系：Thread类本身就是一个实现Runnable接口的类，所以Thread类中实现了run方法。Thread类中也包含一个Runnable接口对象target，当使用Thread（Runnable target）构造方法接收一个Runnable接口对象构造一个Thread对象时，底层代码实际是调用init方法，将接收的Runnable接口对象赋给Thread内部的target成员变量。Thread类的run方法为if（null ！= target）{target.run()}，所以，使用Thread（Runnable target）方法构造的Threa对象实际运行的是Runnable接口对象中的run方法。而继承Thread类的子类重写run方法，所以Thread子类对象实际运行的run方法是子类重写的run方法。\n构造Thread对象或者其子类对象的时候，如果没有指定线程对象的名字，默认会使用“Thread-threadInitNumber”作为线程对象的线程名。其中threadInitNumber是Thread的static整型成员变量，nextThreadNum（）方法会对其自动增加。\n线程的实现方法中，如果线程类已经继承了其他类，那么只能使用Runnable接口方法。\n线程的结束方法不建议使用Thread的stop（）方法，因为该方法非常不安全，安全的结束就是让run方法运行完毕自动结束。推荐的方法是设置一个boolean变量，并在在run方法中设置一个以boolean变量为判断依据的循环，再使用另一个方法设置boolean变量的值，通过这个方法来决定线程的运行。例如采用以下结构：\npublic class MyThread extends Thread{ private boolean flag=true; @Override public void run(){ while(flag){ ... } } public void stopRunning(){ flag=false; } } 线程的生命周期（状态）：\n创建状态：使用new构造线程对象时的状态，此时系统不为它分配资源，只是一个空的线程对象而已。 可运行状态：使用Thread的start方法后，系统为线程分配需要的系统资源（除了CPU），并调用run方法，但是此时的线程还是没有进入运行状态，只是可以随时被运行而已。 运行状态：可运行状态的线程获得CPU资源后就可以立即执行，即进入运行状态。 不可运行状态：运行状态中的线程调用了sleep方法，或者调用了wait方法等待特定条件满足，或者是线程输入或输出阻塞时，线程会放弃占有CPU进入不可运行状态，直到条件满足后再进入可运行状态。 消亡状态：当线程的run方法执行结束后，线程自然消亡。 线程的优先级：线程创建时，子线程继承父线程的优先级；线程创建后，可通过调用setPriority（int）方法改变优先级，接收的优先级参数是1-10的整数，Thread类中定义了三个优先级常量MIN_PRIORITY(1)/MAX_PRIORITY(10)/NORM_PRIORITY(5)，没有指定优先级的情况下，使用默认优先级NORM_PRIORITY。\n一般情况下，线程调度器会调用优先级最高的线程运行，但是也要根据具体操作系统的线程调度策略决定，不同操作系统的策略可能不同，线程的调度顺序可能不同。因此，最保险的方法是通过向线程代码中添加条件控制来确保线程的执行。\n当线程中调用了yield（）方法时，线程会让出CPU让其他线程先执行；当线程中调用了sleep方法时，线程会进入睡眠状态；线程也会由于I/O操作而受到阻塞，停止执行；当另一个更高优先级的线程出现是，线程也有可能阻塞；在支持时间片的系统中，线程的时间片用完后也会停止运行。\n当多个线程访问同一个对象的成员变量或者类的静态成员变量时，多个线程对该对象的成员变量或类的静态成员变量的影响是相互的，因为它们共用同一份对象的成员变量或类的静态成员变量。如果多个线程访问的是同一个对象的局部变量，则每个线程都拥有一份局部变量的拷贝，多个线程之间的局部变量互不影响。如果多个线程访问的是不同对象的成员变量，理所当然多个线程之间互不影响，它们不共同操作一份数据。\n多个线程共享同一个数据可能会由于并发性导致数据的错误，解决的方法是每个线程访问该数据之前对该数据进行加锁，加锁后的数据不能再被其他线程访问，直到加锁的线程执行完毕或者抛出异常后解锁，此方法又叫多线程的同步。\nJava中为实现多线程的同步，让每个对象都带有一个锁（Lock，也叫监视器monitor），并提供了多线程同步关键字synchronized，可用于修饰方法或者代码块：\nsynchronized修饰方法：当线程调用被synchronized修饰的方法时，会将该方法归属的对象进行上锁。对象一旦上锁，对象中所有被synchronized修饰的方法都不能被其它线程调用（没有被synchronized修饰的方法仍然可以被其它线程调用），直到上锁线程将该方法执行完毕或抛出异常后解锁。另外，对于被synchronized修饰的static方法，由于static方法归属于类，线程调用被synchronized修饰的static方法时，加锁的对象是该类的Class对象，此时由于类的所有对象都共享同一个Class对象，所以其他线程调用该类其它对象的static方法也无法进行（一般也没有利用类的对象调用类的static方法）。 synchronized修饰代码块：此方法必须在synchronized（Object obj）{}中显示指定要上锁的对象obj（只要是对象都可以）。当一个线程运行到synchronized修饰的代码块时就会将obj上锁，此时其它线程如果运行到需要将obj上锁的synchronized代码块或者方法时都无法运行，直到synchronized代码块执行完毕或者抛出异常才将对象obj解锁。代码块中必须使用obj对象来调用notify或者wait方法，否则会抛出没有获得相应对象锁但却要操作锁相关方法的异常。当obj参数为this，并且代码块中为整个方法代码时，功能与使用synchronized修饰方法一样。 synchronized修饰方法的同步是粗粒度的，synchronized修饰代码块的同步是细粒度的，适合精细控制同步。当一个方法中代码比较多，而且可能会引起并发错误的代码只有少量时，适合使用同步代码块以提高并发度提升效率。同步率越高，并发性越差，效率越低，多线程的优势就体现不出来。\n受synchronized保护的数据应该是private的，否则如果是public，外部同样可以通过对象来直接访问，那么同步保护就没有意义。\n由于同步机制，线程声明周期的状态多了上锁阻塞状态。当运行中的线程由于需要的数据被其它线程上锁时，线程就会转入上锁阻塞状态，进入锁池（Lock pool），直到该线程需要的数据解锁时，才会重新进入可运行状态。\n","date":"June 5, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"线程","url":"https://www.qinxiandiqi.sbs/tags/%E7%BA%BF%E7%A8%8B/"}],"title":"JavaSE学习笔记 第十一记 —— 线程"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-30# 装饰模式：又叫包装模式，能够在不创造更多子类的情况下动态地将对象的功能加以扩展，是继承的一种替代方案。一个类对象装饰另一个类对象，就可以以装饰对象的方法处理被装饰对象，而整个处理过程对客户端是透明的，实际的过程是装饰对象的处理方法调用被装饰对象的处理方法，并在被装饰对象的处理方法上添加新的功能，也就是说最终是把客户端的调用委托到被装饰类。这种模式的好处就是在不造成类数量增加的情况下，构造更多功能的对象。\n装饰模式与继承的区别：装饰模式用来扩展特定对象的功能，并且是动态的，在运行时分配添加的职责，因此灵活性比较好；而继承是扩展类的功能，一旦扩展就不能修改，是静态的，在编译时分配添加的职责，因此灵活性比较差。另外，一个规定的对象同时能被对个装饰对象装饰，客户端可以通过选择合适的装饰对象操作被装饰对象。\n装饰模式的角色：\n抽象构建角色（Component）：一般是一个抽象类或者接口，用来规范被装饰对象的结构。如：InputStream和OutputStream。 具体构建角色（Concrete Component）：也就是真实对象，继承或实现了抽象构建角色。如：节点流FileInputStream和FileOutputStream。 装饰角色（Decorator）：继承或实现抽象构建角色的抽象类或者接口或者类，以实现客户端对象可以使用和具体构建角色相同的方式与装饰对象进行交互。装饰角色接收客户端对象的所有请求，装饰角色内部持有一个抽象构建角色的引用变量，通过这个引用才能最终将客户端的请求转发给构建角色，由构建角色去完成。如：过滤流FilterInputStream和FileOutputStream。 具体装饰角色（Concrete Decorator）：继承或实现抽象装饰角色的类，具体实现对被装饰对象的附加功能添加在这个类中，而不是装饰角色中。如：过滤流DataInputStream和DataOutputStream。 new DataInputStream（new BufferedInputStream（new FileInputStream（“C：\\test.text”）））；\nJava中采用Unicode字符，一个字符16位，字符流Reader和Wrider处理的都是Unicode字符，一次至少两个字节16位。\nInputStreamReader直接继承Reader，是字节流通向字符流的桥梁。构造方法有InputStreamReader（InputStream in）、InputStreamReader（InputStream in，String cs）等，用于接收一个InputStream对象，并使用cs编码格式编码，如果没有cs参数则使用系统默认编码格式。类中提供了getEncoding（）方法可以返回该流使用的字符编码格式名称。可以将InputStreamReader看做是把InputStream装饰成处理字符流的过滤流。\nOutputStreamWriter直接继承Writer，是字节通向字符流的桥梁。构造方法有OutputStreamWriter（OutputStream out）. OutputStreamWriter（OutputStream out，String cs）等，用于接收一个OutputStream对象，并使用cs格式编码，如果没有cs参数则使用系统默认的编码格式编码。类中提供了getEncoding（）方法可以返回该流使用的字符编码格式名称。flush（）方法可以强制刷新该流的缓冲。可以将OutputStreamReader看做是把OutputStream装饰成处理字符流的过滤流。由于继承了Writer，所以继承了其中的writer（String str）方法，可以一次写入一个字符串。\nBufferedReader直接继承Reader，类比于BufferedInputStream，只是类中的字节缓冲数组变更为字符缓冲数组，其类中其他方法使用方式与BufferedInputStream中方法使用几乎相同，是一个接收Reader的过滤流。类中提供了一个readLine（）方法读取Reader流中的一个文本行，并将游标转移到该行的行尾，如果游标已经到行尾，则会返回null。\nBufferedWriter直接继承Writer，类比于BufferedOutputStream，只是类中的字节缓冲数组变更为字符缓冲数组，其类中的方法使用方式与BufferedOutputStream中的方法几乎相同，是一个接受Writer的过滤流。由于继承了Writer，所以继承了其中的writer（String str）方法，可以一次写入一个字符串。\nFileReader继承InputStreamReader，类似于FileInputStream，只是处理的对象是字符。\nFileWriter继承OutputStreamWriter，类似于FileOutputStream，只是处理对象是字符。如果FileWriter依赖的文件不存在则会自动创建这个文件，如果FileWriter试图打开一个只读文件就会抛出一个IOException异常。\nCharArrayReader继承Reader，类似于ByteArrayInputStream，只是字节数组更改为字符数组。\n13.CharArrayWriter继承Writer，类似于ByteArrayOutputStream，只是字节数组更爱为字符数组。\nSystem.in其实是一个InputStream标准输入流，通常是从键盘输入；System.out其实是一个PrintStream标准输出流，一般是输出到控制台。\nString的getChars（int srcBegin，int srcEnd，char[] dst，int dstBegin）方法用于将原字符串中的srcBegin到srcEnd的字符以字符数组的方式复制到字符数组dst的dstBegin位置开始。\nASCII（American Standard Code for Information Interchange）：美国信息互换标准代码，采用8位二进制位编码，将英文中常用的字符、数字符号与最高位为0，相应十进制数为0-127的数值对应进行编码。另外还有128个扩展ASCII编码，其最高位为1，用于编制一些指标附后和其它符号。\nGB2312：信息交换用汉字编码字符集-基本集，使用两个字节表示一个中文字符，并且每个字节的最高位都是1.\nGBK：GB2312的扩展，完全兼容GB2312，并且多容纳了繁体中文和一些不常用的汉字。\n19.ISO-8859-1：西方国家使用的字符编码集，属于单字节的字符集，其中英文只用了其中数值小于128的部分。不兼容汉字。\nUnicode：通用字符集，可以对所有语言文字进行编码，每个字符都使用两个字节，Java中采用这个编码方式以实现字符的跨平台。这种编码的缺点在于在internet上传输的效率比较低，因为一些使用一个字节就能表示的字符也使用两个字节表示，高字节填0。\nUTF-8：不定长字符编码方式，根据字符需要的字节长度分配字节，有些字符用一个字节，有些两个，有些三个。互联网上常用这种编码方式，传输效率高，字符容量大。\njava.io.RandomAccessFile：随即访问文件类，直接继承Object，并实现了DataInput和DataOutput接口。构造方法有RandomAccessFile（File file，String access）或者RandomAccessFile（String name，String access），其中file或者name表示依赖的File对象或者文件名，access表明使用文件的方式是“r”（只读）还是“rw”（读写）。另外，由于类中包含一个long变量pos作为流的游标，使用该类的getFilePointer（）可以获得当前游标的位置，使用该类的seek（long pos）可以将游标定位到pos位置，使用skipBytes（int n）可以将游标向后移动n个字节。由于该类实现了DataInput和DataOutput接口，所以类中提供了大量读写各种数据类型的方法，特别的有readUTF（）和writeUFT（String str）方法以UFT的格式读写数据。该类的特点在于类中包含了输入流方法和输出流方法，相当于输入流和输出流的合体。\njava.nio.Charset类中的availableCharsets（）方法可以返回一个SorteMap\u0026lt;String，Charset\u0026gt;排序映射。其中的Key为当前系统所支持的字符集名。\n序列化/反序列化：将对象转换为字节流（因为对象不是字符，转换成字符流没有意义）保存起来，并在以后从字节流中还原这个对象的机制。若把一个对象序列化后保存到永久存储设备上，这个过程也叫做持久化。\n声明对象可序列化：一个对象能够序列化的前提是对象必须实现Serializable或者Externalizable接口。其中Serializable接口只是一个标识性接口，接口中没有定义任何方法，实现该接口仅是表示这个类可以被序列化而已。继承一个可序列化的类，其子类也可序列化，即序列化特性可以被继承。\n被序列化的对象中如果存在其它对象的引用，则其它对象的引用也会被序列化，并且引用的对象又包含其它对象的引用也会被序列化，也就是序列化会根据对象中的引用一层一层连接下去序列化。\n对象序列化的时候，如果对象中的某成员无法序列化，则会抛出NotSerializableException异常。此时，若将该无法被序列化的对象使用关键字transient（瞬间）修饰，则序列化的时候不会序列化该成员，对象的序列化能够正常进行。\n对象序列化的时候，不会序列化对象中的static变量和方法（因为它们属于类，不属于对象），也不会序列化被transient修饰的成员。只会将对象中的成员变量序列化，写入到字节流中（通过字节流可写入到存储设备上永久保存）。如果成员变量是一个对象的引用，则会按照同样序列化的规则序列化引用的对象，以此类推各个对象引用。\nObjectOutputStream类：继承了OutputStream类，并且实现了ObjectOutput接口，ObjectOutput接口又实现了DataOutput接口。构造方法有ObjectOutputStream（OutputStream out），可接收一个输出字节流，是一个过滤流，主要用于实现对象的序列化。另外，由于实现了DataOutput接口，所以类中包含大量写入各种类型数据的方法。\n将对象序列化的方法：使用ObjectOutputStream类的writeObject（Object obj）方法。默认会将obj的类、类的签名、以及类和其所有超类的非transient非static成员变量写入到输出流中，即实现了序列化。\nObjectInputStream类，继承了InputStream类，并且实现了ObjectInput接口，而ObjectInput接口又实现了DataInput接口。构造方法有ObjectInputStream（InputStream in），可接收一个输入字节流，也是一个过滤流，主要用于实现对象的反序列化。另外，由于实现了DataInput接口，所以类中包含了大量读取各种数据类型的方法。\n对象反序列化的方法：使用ObjectInputStream类的readObject（）方法，返回一个Object对象。由于对象在序列化的时候保存了对象的类信息，所以readObject方法无需参数，就能将当前游标所在位置后边的对象按该对象序列化时的类信息恢复出来。恢复的时候，并不会调用该对象类的任何构造方法，仅是根据保存的状态信息在内存中重新构建对象而已。又由于对象序列化的时候不会序列化transient修饰的成员变量，但保存的类信息中存在该成员的信息，所以反序列化后，被transient由于序列化时没有将值保存下来，其值只能是其数据类型的默认值。\n序列化和反序列化过程中，如果需要对对象进行特殊处理，不按照java提供的默认序列化和反序列化方法进行，可自定义序列化和反序列化的处理方法。方法为在需要被序列化和反序列化的类中实现两个方法： 1）序列化方法：private void writeObject（java.io.ObjectOutputStream stream）throws IOException{}；在方法体中写入自己的处理对象成员变量与写入ObjectOutputStream流的代码，当对该类对象进行序列化的时候便会调用这个方法进行序列化，不再使用默认序列化方法。 2）反序列化方法：private void readObject（java.io.ObjectInputStream stream）throws IOException，ClassNotFoundException{}；在方法体重写入自己处理对象成员变量与ObjectInputStream流的代码，当对该类对象进行反序列化的时候就会自动调用这个方法进行反序列化，不再使用默认的反序列化方法处理。\n进程：进程是一个运行中的程序，每一个程序运行的时候都需要在进程中执行代码，操作系统会为一个程序分配该程序进程所需要的资源，包括内存空间等。进程与进程之间的内部数据和状态都是完全独立的，所以进程与进程之间的切换代价比较高。\n线程：每个进程至少包含一个线程，一个进程可以包含多个线程，每个线程可独立完成进程中的一个工作，是程序内的一个顺序控制流，只能使用分配给程序的资源和环境。并且线程运行时只需要很少的资源，通常只有寄存器数据以及程序执行时的堆栈，所以线程与线程之间的切换代价比较小。同一个进程之间的线程共享一块内存空间和系统资源，它们有可能会互相影响。\n多任务处理包括基于进程和基于线程两种对任务处理，它们都是为最大限度使用CPU资源，以提高CPU效率。\nJava语言内置支持多线程变成，其他大多数编程语言都需要通过外部库链接来实现多线程编程。\nJava程序中，每当程序启动的时候都会自动启动一个线程，main方法就运行在这个自动启动的主线程上，因此这个线程也叫做main thread。每个Java程序至少都有一个线程，这个线程就main线程。\n","date":"June 4, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%8D%81%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"装饰模式","url":"https://www.qinxiandiqi.sbs/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"title":"io","url":"https://www.qinxiandiqi.sbs/tags/io/"},{"title":"字符集","url":"https://www.qinxiandiqi.sbs/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"title":"序列化和反序列化","url":"https://www.qinxiandiqi.sbs/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"title":"JavaSE学习笔记 第十记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-29# Java的I/O系统主要由java.io包和java.nio包构成。\njava.io.File类对象表示了磁盘上的一个文件或者目录，在java的io系统中，文件和目录都统一使用File类对象表示，其父类是Object。File类只是对磁盘上的文件或目录的抽象表示，提供了与平台无关的对文件或目录的操作方法，比如获取路径或者文件及目录的相关信息，并对他们进行创建. 删除、改名等管理工作。然而File只是抽象描述了文件或目录的属性和操作方法，但并没有提供怎样从文件读取和向文件存储等方法。\n路径分隔符：由于java中反斜杠\\用作转义字符，所以路径中的反斜杠需要用双反斜杠\\转义表示。特别的，处理window系统中使用反斜杠做文件路径分隔符之外，其他系统都是使用正斜杠/做路径分隔符。因此，java中使用正斜杠/做抽象路径分隔符，无论什么系统使用正斜杠做路径分隔符，java都能自动转成系统适应的分隔符，所以推荐使用正斜杠/做java中的路径分隔符。\nFile的构造方法常用的有：File（String path）、File（File file，String str）、File(String str1,String str2)。值得注意的是，使用File构造方法构造一个File对象并不等于创建了这个File对象指向的文件或者目录，其中第二三个构造方法需要组合后能拼成一个正常的文件路径才不会影响到File对象对该文件或路径的操作。\nFile创建文件方法：createNewFile（）。只要File构造方法的参数路径存在，并且路径指向的文件不存在，就能够创建对应的文件。如果参数路径存在，且指向的文件也存在，则创建失败，返回false。如果参数路径不存在，则会抛出路径找不到的异常。\nFile创建目录的方法：mkdir（），该File指向的路径中，要创建的目录上一级路径不存在，则无法创建目录，返回false。mkdirs（），该File指向的路径中，要创建的目录上一级或上几级路径不存在，也能够正常创建目录，并把不存在的路径目录都创建出来。如果要创建的目录已经存在，则返回false。\nFile的isFile（）用于判断File是否指向一个文件；File的isDirectory（）用于判断File是否指向一个目录。\nFile的list（）用于将File指向目录内的所有内容的名字以字符串数组返回，包括文件和目录。File的listFiles（）方法用于将File对象指向的目录内所有File以File数组的形式返回。使用以上两个方法时，File对象必须时一个目录对象。\nFile的getName（）获取File对象指向文件的名字；File的getParent（）用于获取父目录名；File的getParnetFile（）用于获取父目录File对象；File的exists（）用于判断文件是否已经存在。File的delete（）用于删除File对象指向的文件（只有文件或者空目录才能删除，不为空的目录需要将目录内的所有文件都删除才能删除，一般是由递归算法）。\nFileNameFilter接口，常用作list（FileNameFilter filter）或listFiles（FileNameFilter filter）方法的参数，以返回目录下符合一定条件的文件名或文件File对象。一般是在参数列表中使用匿名内部类实现这个接口，该接口只包含一个方法accept（File dir，String name），筛选目录下文件的筛选方法就写在这个accept方法体中。\nFile.separator静态常量，用于表示与系统有关的默认名称分隔符，在路径中可以始终File.separator代替路径的分隔符以组成完整的路径字符串。单独的File.separator表示根目录，即盘符。\n递归：方法内部再调用自己，或者一个方法调用另一个方法，而另一个方法又调回原来的方法。递归的特点就是循环嵌套调用，并且使用递归的方法中必须提供一个结束递归的出口（一般是一个if条件判断）。递归的过程分为递进和回归，先一层一层调用到出口层，返回确定结果后再一层一层将结果返回到最顶层。\nJava的流（Stream）：Java的程序通过流来完成输入和输出，是生产或者消费信息的抽象，它通过java的输入和输出系统与物理设备连接，并且屏蔽掉设备之间的差异性，对于不同的物理设备，流都具有同样的行为方式。\n输入流和输出流：根据程序在使用数据时扮演的角色不同，流可以分为输入流和输出流。当程序从外部读取数据时，也就是程序是数据流的目的地，此时的数据流为输入流；当程序输入数据到外部时，也就是程序是数据流的源头，此时的数据流为输出流。总的来说，输出流和输入流是一种以程序为中心的相对概念。\n字节流和字符流：根据流结构上的不同，将流分为字节流和字符流。字节流以字节为处理单位，即八位二进制数据，一般用于读写图像或者声音等二进制数据。字符流以采用了统一编码标准的16位字符为单位，因此字符流可以国际化，在某些场合下，字符流具有比字节流更高的效率。\n综合输入输出流和字节字符流，可以将流再细分为：输入字节流（以InputStream抽象类为父类）、输出字节流（以OutputStream抽象类为父类）、输入字符流（以Reader抽象类为父类）、输出字符流（以Writer抽象类为父类）。\nJava 1.0只存在字节流，Java 1.1开始出现字符流。字符流的出现只是为了处理字符提供方便有效的办法，但是字符流的底层本质上还是以字节的形式处理。\n流读取数据的逻辑：\n打开一个输入流 循环判断是否还存在数据信息，如果还有数据信息，则读取一定单位的数据信息并继续循环，直到没有剩余数据信息为止。 关闭输入流 流存储数据的逻辑：\n打开一个输出流 循环判断是否还有需要存储的数据信息，如果还有数据信息，则存储一定单位的数据信息并继续循环，直到所有数据信息都存储完毕为止。 关闭输出流。 根据流是否与目标直接打交道，可以将流分为节点流和过滤流。节点流直接与需要从中读取数据或者需要从中输出数据的目标打交道，比如从硬盘上某文件读取数据的流、程序输出数据到硬盘某个文件的输出流。过滤流是与节点流或者其他过滤流打交道的流，也就是它不直接与数据目标打交道，它的作用在于将节点流或者过滤流再封装以增加更多的数据信息和处理方法，并且它是同步的。\n所有流的关闭方法都是close（）。\nInputStream的三个read方法：\nread()，三个read方法中唯一的一个抽象方法，规定从输入流中读取数据的下一个字节。因为不同子类read的具体需要不同，所以设计此read抽象方法以供子类实现时设计符合自己具体要求的read（）方法。 read（byte[] b，int off，int len），本质上是方法体内通过对read（）方法的调用，来实现从数据流中读取不超过len个字节到以off索引为起始位置的b字节数组中去，返回值为实际读取的字节个数，如果没有字节可读取则返回-1。因为每个子类的read（）实现方法不同，所以子类继承这个方法就能根据子类read（）的读取规则完成这个方法的逻辑。 read（byte[] b），本质上是调用read（b，0，b.length）。 String类具有一个将字节数组转换为字符串的构造方法：String（byte[] b，int off，int length），可以构造一个b数组中以off索引为其实位置，长度为length的字符串。String类也提供了getbyte（）方法将字符串转换为byte数组。\nOutputStream的三个write方法（类似于InputStream三个read的原理）：\nwrite(int b)，三个write方法中唯一的一个抽象方法，规定将b个字节写入到输出流中。因为不同子类write的具体需要不同，所以设计此read抽象方法以供子类实现时设计符合自己具体要求的write（int b）方法。 write（byte[] b，int off，int len），本质上是方法体内通过对write（int b）方法的调用，来实现将b字节数组中从off索引为起始位置的len个字节写入到输出流中，没有返回值。因为每个子类的write（int b）实现方法不同，所以子类继承这个方法就能根据子类write（int b）的写入规则完成这个方法的逻辑。 write（byte[] b），本质上是调用read（b，0，b.length）。 FileInputStream继承了InputStream，是关于File的字节输入流。构造方法有FileInputStream（String url）、FileInputStream（File file）等，用于获取file指向的文件或者url路径指向的文件的字节输入流。\nFileOutputSteam继承了OutputStream，是File的字节输出流。构造方法有FileOutputStream（File file，boolean append）和FileOutputStream（String url，boolean append），file或者url表示输出流要写入的file或者url指向的文件，如果文件不存在则会自动创建这个文件；append为true则当文件已经存在的情况下，使用write会将写入字节追加到文件尾，若为false则会删除文件的全部内容，然后写入。FileOutputStream（File file）和FileOutputStream（String url）的本质是对应前两个构造方法，append值为false的构造方法。\nByteArrayInputStream继承了InputStream，以byte数组为输入源的字节流，内部包含一个buf字节数组缓冲区（即要读取的数据）。构造方法有ByteArrayInputStream（byte[] buf，int off，int length），构造一个buf为缓冲区数组的字节数组输入流，并且将要读取的开始索引位置为off，读取的字节个数为length。另一个构造方法ByteArrayInputStream（byte[] buf）的本质为ByteArrayInputStream（buf，0，buf.length）。\nByteArrayOutputStream继承了OutputStream，以byte数组为输出对象的输出流，内部包含一个buf字节数组缓冲区（存放写出的数据）。构造方法有ByteArrayOutputStream（）和ByteArrayInputStream（int size）。使用它的write方法可以将一个byte数组写入到它的六种buf字节数组缓冲区，再使用它的toByArray（）方法创建一个新的byte数组存储流中的buf字节数组，也可以使用它的writeto（OutputStream out）方法将buf的全部内容写到输出流out中去。\nFilterInputStream是继承InputStream的输入字节过滤流抽象类，输入字节过滤流都必须继承这个类，java提供的子类有DataInputStream（常用）、BufferedInputStream（常用）、LineNumberInputStream、PushbackInputStream。\nFilterOutputStream是继承OutputStream的输出字节过滤流抽象类，所有输出字节过滤流都必须继承这个类，java提供的子类有DataOutputStream（常用）、BufferedOutputstream（常用）、PrintStream。\nDataInputStream：数据字节输入流，构造方法为DataInputStream（InputStream in），相当于将in输入流再进行包装成DataInputStream。内部提供了大量读取基本数据类型的方法，这些方法将按照对应数据类型的字节长度依次读取in中的数据。例如：readBoolean（）、readByte（）、readChar（）、readDouble（）等等。\nDataOutputStream：数据字节输出流，构造方法为DataOutputStream（OutputStream out），相当于将out输出流再进行包装称DataOutputStream。内部提供了大量写入基本数据类型的方法，这些方法会按照对应的基本类型占用的字节长度，以二进制的形式写入到out中。例如：writeBoolean、writeByte、writeBytes、writeChar、writeChars等。\nBufferedInputStream：字节缓冲输入流，内部具有buf字节数组缓冲区，构造方法有BufferedInputStream（InputStream in）和BufferedInputStream（InputStream in，int size），用于将in输入流包装称BufferedInputStream，带有size时可指定内部buf缓冲区数组长度为size。使用它的read读取in数据，并不会直接将读取的数据存入到接收数据的数组b中，而是先存到内部buf数组中，等到buf数组满了后再一次把数据读回，使用close关闭流之前会强制将buf中数据返回。\nBufferedOutputStream：字节缓冲输出流，内部具有buf字节数组缓冲区，构造方法有BufferedOutputStream（OutputStream out）和BufferedOutputStream（OutputStream out，int size），用于将out输出流包装称BufferedOutputStream，带有size时可指定内部buf缓冲区数组长度为size。使用它的write并不会直接将数据写出去，而是等到buf数组满了后再一次性写出去，或者调用flush（）时强制将buf中数据写出去，使用close关闭流时也会强制写出去。\n","date":"June 2, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B9%9D%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"io","url":"https://www.qinxiandiqi.sbs/tags/io/"},{"title":"文件系统","url":"https://www.qinxiandiqi.sbs/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}],"title":"JavaSE学习笔记 第九记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-27# AWT：Java第一代的GUI，是重量级的，将实际生成界面组件的操作委托给具体的操作系统GUI相关的API去完成，所以不同的操作系统生成的界面外观和感官是不同的。\nSwing：Sun推出的GUI组件，属于轻量级，可以屏蔽掉操作系统实现的细节。\nAWT中所有的容器类都继承与java.awt.Container，主要包含Window和Panel两个子类。Window主要包含Frame和Dialog框架类，是顶级窗口容器，相当于图形界面程序的最外层。Panel主要是包含各种组件面板容器（所有组件必须包含到一个容器中），并且Panel无法单独显示，必须添加到一个容器中。每个Panel都有自己的布局管理器，即使是添加到其他Panel中的Panel。\n布局管理器：能够根据相应布局管理器的规则自动管理容器中组件的大小和位置，通过setLayout（）设置容器的布局管理器。使用布局管理器后，容器中组件的setLocation（）、setSize（）、setBounds（）方法的设置都会被屏蔽。\nFrame必须设置setVisible（Boolean bool）方法为true，窗口程序才可见。Frame的pack（）方法调用后会以正常显示Frame内所有组件最佳的比例显示窗口。\nBorderLayout布局管理器：将组件分为东南西北中五个区域，是Frame默认的布局管理器。其中每个区域只能加入一个组件，如果加入过个组件，则后加入的组件会覆盖之前的组件。当容器发生大小变换的时候，南北区域只能在水平方向上缩放，东西区域只能在垂直方向上缩放，中间区域可再垂直方向和水平方向上一起缩放。当一个区域没有填充组件的时候，其他区域会自动延伸。\nFlowLayout布局管理器：流布局管理器，Panel默认的布局管理器，将组件按顺序排列，默认是按行排列，不会改变组件大小，但是当一行容不下所有组件时，会自动换行。\nGridLayout布局管理器：网格布局管理器，组件按行从左到右添加，行满换行继续添加。一个组件可以跨越多个网格。\nCardLayout布局管理器：将界面看做一系列卡片的布局，并且在一个时刻只能显示一个卡片的内容，使用show（）方法切换卡片。\n事件模型包括：事件（事件也是一个对象，集成了相关事件的信息，通过传递事件将事件信息给处理方法）、事件源、事件处理器（接收事件、解释事件并处理用户交互的方法）。\nJDK1.0的事件模型是层次模型，事件产生后会在产生事件的组件类处理，如果处理不了则会由包含组件的容器处理器，知道到Frame也无法处理的话，则不处理。这种模型的弊端是会造成事件处理方法的混乱，很难辨清事件到底会在哪里被处理，故从JDK1.1开始不再使用这种事件模型，而是委托模型，将事件处理委托给指定的监听器处理，一个组件的某个事件对应一个监听器，如果没有对应的监听器则不会由上层容器的监听器处理，即不会处理这个事件。\n典型的事件类型：MouseEvent（鼠标事件，包含了关于鼠标位置等鼠标操作信息）、WindowEvent（窗口事件，包含窗口关闭等窗口操作信息）、ActionEvent（动作事件，包含相应组件基本操作的信息）。\n委托模型的处理过程：当一个组件产生一个事件后，该组件对应这个事件所注册的监听器addXxxListener（XxxListener l)，即参数XxxListener e（一般XxxListener是一个接口，使用的时候需要使用该接口的实现类）的事件处理器方法处理事件。以Button为例，单击Button后产生一个ActionEvent事件，ActionEvent事件会传递给被其注册的所有ActionListener（Button的addActionEListener（）所注册）的actionPerformed（ActionEvent e）方法接收，并执行这个方法。\nActionEvent类的getActionCommand（）方法可放回与动作相关联的命令名称，比如Button返回的Button的标签名。另外，该类中还有方法getWhen（）返回发生该事件的事件。\n委托模型使用步骤： 1）编写监听器XxxListener中相关事件处理方法：一般AWT提供相应监听器XxxListener接口，事件的处理方法需要自定义监听器类实现这个接口，并重写这个接口中所有方法（可通过JDK帮助文档获得接口中所有的方法），把事件的处理代码放置到重写的方法中。特别的，JDK提供了适配器Adapter，Adapter适配器是实现了一个或多个接口的类，但是实现的接口方法体为空，什么事情也不做。JDK中提供了大量事件监听器接口的适配器XxxAdapter，因此，只要继承相应监听器适配器，就可以只重写监听器接口中需要用到的几个方法，以提升开发效率（如果自定义的监听器已经继承了其他类，那么只能实现接口这种方法）。 2）为组件注册相应的监听器：可通过查询JDK文档得知该组件能够注册的监听器类型的方法。一般注册方法的格式为addXxxListener（XxxListener l），只要将自定义的监听器实例引用作为该方法参数即可向该组件注册监听器。同一个组件可以注册多个XxxListener类型的监听器。 3）当组件接收到相应操作产生相应事件后，会根据该组件注册的监听器匹配处理该事件的监听器，并将事件对象发送给注册的处理这个事件类型的所有监听器，存在次事件的多个监听器时，它们都会接收到事件和执行处理。 4）特别的，经常将步骤1和2合并，使用内部类监听器作为addXxxListener（）的参数。\nInput is evil！\n观察者模式（Observer）：该模式定义了一种一对多的依赖关系，使多个观察者对象同时监听某一个主题对象。只要主题对象在状态上发生了变化，主题对象就会通知所有的观察者对象，让它们更新自己的状态。\n观察者模式的组成： 1）抽象主题角色：主题角色之所以能被观察者角色监听，原因在于主题角色中存在一个保存了该主题角色对所有观察者对象的应用的集合。抽象主题角色一般是一个抽象类或者接口，并且至少要提供增加或删除观察者角色对象应用的方法，以及通知观察者对象主题角色状态发生改变的方法。 2）具体主题角色：是抽象主题角色的子类或者实现对象，具体包含了一个或多个观察者类型的集合，并且实现了抽象主题角色中的方法，同时也具有具体自我特征的成员变量和方法。 3）抽象观察者角色：一般也是一个接口，定义了更新自己的方法以供主题角色的通知观察者方法调用。 4）具体观察者角色：实现抽象观察者角色接口的类，实现了具体供主题角色通知方法调用的更新自己状态的方法，以便与主题角色状态相协调。在需要的情况下，还可以保存一个指向具体主题角色的引用。\n观察者模式的基本使用步骤： 1）定义抽象主题角色和抽象观察者角色：一般都是接口。抽象主题角色添加或删除观察者角色方法的参数类型是观察者接口类型；它的通知观察者方法参数一般是一个对象（在事件处理机制中，一般是一个事件对象），并且会调用观察者接口中更改观察者状态的方法。抽象观察者角色更改自己状态方法的参数一般是抽象主题角色通知方法的参数类型。 2）定义具体主题角色和具体观察者角色：都是实现了抽象主题或观察者的类。具体主题角色类中要定义抽象观察者类型的集合，增加或删除观察者方法负责把参数观察者添加或删除到集合中；通知观察者的方法中要遍历每一个集合，调用每个集合中元素及观察者类的更改自己状态的方法。观察者类中要具体实现更改自己状态的方法。 3）new具体主题角色类和具体观察者类，使用主题角色的添加观察者方法添加观察者对象（也就是常说的注册观察者）。\n观察者模式运行过程：当部署好主题角色和观察者角色后，一旦主题角色触发通知观察者的方法（可以是主题角色对象显示调用，或者是主题角色上定义了某些操作可以调用这个方法），观察者的更改自己的状态方法就会被调用。由此，实现了多个观察者对主题角色对象的依赖关系。\nGUI程序的事件机制实质上就是观察者模式的运用，其中每个组件是一个具体主题对象，每个监听器是一个具体观察者对象。一旦某些操作触发了组件，底层实质是调用了通知观察者方法通知注册到组件上的每一个监听器，让它们调用更改自己状态的方法，而实现了事件处理。\n2012-07-28# Swing组件主要存放于Javax.swing和Javax.swing.event两个包中。\nSwing的三个顶层容器：JFrame、JDialog、JApplet。每一个顶层容器都默认包含一个content pane，用于包含顶层容器中所有的组件，但是不包括菜单。也就是说，顶层容器主要包括两个元素：content pane和菜单。\n菜单的三级元素：MenuBar、Menu、MenuItem。\nSwing提供的便捷关闭方法：Frame.setDefaultCloseOperation（JFrame.EXIT_ON_CLOSE）。\nJDK对观察者模式提供了内置的支持：JDK提供了java.util.Observable主题类和Observer抽象观察者接口。\nObservable主题类：该类提供了主题类应该具有的所有方法，类中存在保存Observer接口类型的观察者Vector集合。定义的主要方法有：addObserver（Observer o），当o与已有的观察者对象不同时，向集合中添加；deleteObserver（Observer o），向集合中删除观察者o；setChanged（），当主题类状态发生改变时，通过该方法记录已经发生了改变；notifyObservers（Object arg），通知所有观察者主题对象状态发生改变，会调用每个观察者对象中的update方法，并将参数arg传递过去。前提是Observable状态发生了改变，因为notifyObservers方法体中存在if语句判断状态改变常量changed是否为true，true的时候才会调用观察者中的update（如果changed为true，那么if的else最后会调用clearChange方法将changed改回false）。因此，在调用notifyObservers之前必须调用setchanged才会执行观察者中的update。\nObserver观察者接口：接口中只定义了一个方法update（Observable o，Object arg），具体的观察者需要实现这个接口。当主题类Observable的notifyObservers方法被调用时，会调用观察者这个update方法，其中o是观察者观察的主题对象，arg是被观察主题对象notifyObservers方法传递过来的参数。update实现对观察者自身状态的修改，以协调主题对象状态的改变。\n内部类：一般的类都是定义在package下，属于package级别类；而内部类是定义在类或方法内部的类。内部类分四种类型：静态内部类、成员内部类、局部内部类、匿名内部类。\n静态内部类：定义在类内部，并且被static修饰，可以访问外部类的静态成员变量和静态方法。\n静态内部类相当于外部类的一个静态成员变量，属于类的静态成员，只是这个成员是外部类内部自己定义的一个类。在外部类的内部使用静态内部类，可以直接像使用普通类的方法使用静态内部类即可。在外部类外部，由于静态内部类类似于外部类的静态成员，所以外部类外部使用静态内部类与使用外部类静态成员方法相同，格式为“外部类名.静态内部类名”，也可以看做静态内部类的实际类名为“外部类名.静态内部类名”。因此，在外部类外部构造静态内部类实例，使用“new 外部类名.静态内部类名()”格式构造（括号内参数由静态内部类的构造方法决定）。 对于静态内部类使用外部类静态成员变量和方法，只要外部类存在该静态成员和方法，在静态内部类中就可以直接调用。但如果静态内部类内部存在和外部类相同名字的静态成员变量和方法，则根据java的就近原则，静态内部类使用的是静态内部类的静态成员变量和方法。要是非得使用外部类的静态成员变量和方法，则需要在变量名和方法名前加“外部类名.”前缀来强制使用外部类的静态成员变量和方法。 含有静态内部类的类编译后，除了生成外部类的class文件之外，同样会生成静态内部类的class文件，文件名为“外部类名$静态内部类名.class”。 成员内部类：定义在类内部，与静态内部类的区别在于少了static修饰，可以访问外部类的任何成员变量和方法。\n成员内部类，相当于外部类的一个成员，只是这个成员是由外部类中自己定义的类。在外部类内部，可以像使用普通类的方法直接使用成员内部类（构造的时候，new 内部类名的new前默认存在“this.”)。在外部类外部，由于成员内部类相当于外部类的一个成员，而访问类的成员必须通过类对象访问。所以要先构造一个外部类对象才可以构造一个成员内部类的对象。成员内部类的类名依然可以看做是“外部类名.成员内部类类名”，构造成员内部类的方法本质是：外部类名.成员内部类类名 成员内部类引用变量名 = 外部类对象.new 内部类名（）。通常的做法是：外部类名.成员内部类类名 成员内部类引用变量名 = new 外部类名（）.new 内部类名（）。 对于成员内部类使用外部类成员变量和方法，只要外部类存在该成员变量和方法，成员内部类就可以直接使用。如果成员内部类定义了和外部类成员变量和方法相同名称的变量和方法，那么根据java就近原则，成员内部类将使用自己的变量和方法。但要是非得使用外部类的变量和方法，则需要在变量名和方法名之前加前缀“外部类名.this.”以表示使用的是外部类变量和方法。 含有成员内部类的类编译后，同样除了生成外部类的class文件之外，也会以“外部类名$内部类名.class”的形式生成成员内部类的class文件。 局部内部类：定义在方法内部的类，只能访问方法中final修饰的变量，外部类外部无法访问到局部内部类，局部内部类是给方法是用的，一般很少是用局部内部类。\n局部内部类，相当于类的局部成员，存在于方法中，只能被方法使用。在方法中可以像普通类使用方法一样使用。 对于局部内部类使用方法中局部变量的方法，只要是方法中存在的final修饰的局部变量，局部内部类就可以直接使用。如果方法中存在final修饰的局部变量与局部内部类中的成员变量同名，则根据就近原则，局部内部类将访问到局部内部类自己的变量，并且此时没有方法访问方法的局部变量。如果局部内部类要访问外部类的成员变量和方法，同样可以使用“外部类名.this.”前缀加外部类成员变量或者方法访问到。 包含局部内部类的类编译后，除了生成外部类的class文件之外，同样也生成“外部类名$1局部内部类名.class”的局部内部类class文件（相比前两种内部类class文件，文件名$之后多了“1”）。 匿名内部类：定义在方法内部，没有类名，没有构造方法，不需要class关键字定义，只能访问方法中final修饰的局部变量，可以说是局部类的变形，是一种比较常用的内部类，比如事件机制中的监听器常用匿名内部类定义。\n匿名内部类的使用：匿名内部类默认要继承一个类或者实现一个接口，使用“new + 默认要继承的类名或者接口名(参数由继承的类或实现的接口构造方法决定){匿名内部类代码}”的方式定义并构造一个匿名内部类对象。 同局部内部类一致，只能访问方法中final修饰的局部变量，如果局部变量名与匿名内部类变量名相同，根据就近原则使用匿名内部类变量。如果要使用外部类变量，同样加前缀“外部类名.this.”。 包含匿名内部类的类编译后，除了生成外部类的class文件之外，也同时也生成内部类“外部类名$+阿拉伯数字.class”的class文件，$后的阿拉伯数字由1向上递增。 ","date":"June 2, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%85%AB%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"AWT","url":"https://www.qinxiandiqi.sbs/tags/awt/"},{"title":"Swing","url":"https://www.qinxiandiqi.sbs/tags/swing/"},{"title":"Java内部类","url":"https://www.qinxiandiqi.sbs/tags/java%E5%86%85%E9%83%A8%E7%B1%BB/"}],"title":"JavaSE学习笔记 第八记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-25# 每一个动态代理类都对应一个动态调用处理器InvocationHandler，因为动态代理类不具备方法的实现，动态代理类的方法依赖于动态调用处理器InvocationHandler的invoke方法来实现。\n静态代理的真实类和代理类关系是：真实类和代理类都是抽象角色的子类或者实现，并且代理类含有真实类的引用，通过代理类操作真实类。而策略模式对抽象角色子类的使用都是通过抽象角色来使用，策略模式的子类之间不能互相使用，因为一个子类没有包含另一个子类的引用。\n动态代理的真实类和代理类关系与静态代理的真实类和代理类关系类似，区别在于动态类的定义和实现逻辑与静态代理类不同。静态代理每一个真实类都必须手动定义一个代理类，并且每一个静态代理类中都必须重写真实类中的每一个方法（即抽象角色中的方法），这么一来，一旦真实类的数量多起来，需要手动定义的类数量将急剧上升，造成类数量的臃肿。而动态代理类的实现是通过InvocationHandler动态调用管理器和Proxy类在运行时动态定义和构造，定义一个包含Object引用变量的InvocationHandler实现类，就可以动态定义和构造任意真实类的代理，并且由于动态代理类的方法实现是交付给InvocationHandler的invoke方法实现，而InvocationHandler的invoke方法又是由这个方法中接收的参数method的invoke实现，所以动态代理类不需要对应真实类的每一个方法重写，一律使用InvocationHandler的invoke动态实现真实类方法的重写和调用。如此一来，动态代理的好处就是不用手动定义每一个代理类和代理类中的方法，被代理的独享可以在运行时动态改变，动态代理类实现的接口也可以在运行时改变，从而实现了灵活的动态代理关系，降低了定义类的数量。\nJava Annotation：Java注解，JDK1.5新增的特性。\nJDK1.5提供的三个常用注解：\n@Override（位于java.lang.Override），只能注解方法，在方法定义前使用该注解表示这个方法必须重写一个父类或接口的方法，如果没有则编译不通过，该注解可达到在编译时检查有无重写方法的作用。 @Deprecated（位于java.lang.Deprecated），在方法定义前使用该注解表示该方法不建议被使用（一般是有更好的替代方法，或者该方法不够安全），注解后该方法名会被删除线划上，并且在调用该方法时会有不建议使用的警告。 @SuppressWarnings（String[]）（位于java.lang.SuppressWarning），可注解除了注解类型之外的其它所有类型，接收一个字符串数组，可注解一个类或者方法。注解的功能由接收的字符串数组决定，常用的参数有“unchecked”表示压制检查警告，“Deprecated”表示压制使用不建议使用方法警告等等。当一个类被一个@SuppressWranings注解后，类中每一个方法都默认被这个注解注解，当类中方法还被自己的注解注解时，这个方法同时被两个注解注解。 定义自己的注解类型：与定义接口类似，但是使用@Interface标志代替Interface，如public @Interface MyAnnotation{注解内容}。\n当自定义注解中包含定义属性时，要在属性名后加（），如“public String value（）；”，否则编译错误。如果要设定注解的默认值，要在属性名的()后使用“default + 属性值”的方式设置属性的默认值。\n使用带属性的自定义注解时，要在注解名后加（），并在括号内传递注解属性值，如@MyAnnotation（“myAnnotation”）。同时，若注解的属性名为value时，使用注解的括号内可直接写属性值，否则必须使用name=value的形式对应传递注解的属性参数，当属性有多个的时候，按照这个形式用逗号隔开就可以。\n自定义注解的方法只有使用@Interface一种，使用这个方法自定义的注解编译器默认会继承java.lang.annotation.Annotation接口。但是如果手动写一个接口继承这个java.lang.annotation.Annotation，这个接口也不是注解，就算是原来的这个java.lang.annotation.Annotation接口也不是一个注解。\n如果自定义的注解与使用注解的类不在同一个包中，那么同样需要把包含注解的包导入到使用注解的类中，导入方法与导入类包的方法相同。\n自定义的注解不能继承其它的Annotation类型（其它已定义的注解）或者接口，但是可以使用其它已定义的注解来注解自定义的注解。\n注解@Retention（位于java.lang.annotation.Retention):，只能用于注解注解类型，使用@Retention注解自定义注解类型可以告知编译器如何处理自定义的注解类型信息。\n枚举类型RetentionPolicy（位于java.lang.annotation.RetentionPolicy）：包含三个枚举常量SOURCE、CLASS、RUNTIME。SOURCE常量表示编译程序只在编译时使用注解信息，但不将注解信息保存到class文件中，所以不会在JVM中被读取；CLASS枚举常量表示编译器会在编译的时候使用注解信息，并且会将注解信息保存到class文件中，但是在VM加载class文件时不读取；RUNTIME枚举常量表示编译器在编译时会使用注解信息，并且会将注解信息保存到class文件中，在JVM运行时加载class文件会通过反射机制的API获取注解信息。\n@Retention注解中包含一个RetentionPolicy枚举类型的属性（属性名为value，所以使用这个注解时可以直接传递参数），并且属性值默认是CLASS枚举常量。通过使用@Retention注解并制定其枚举常量来注解自定义注解类型，以此达到控制编译器处理自定义注解类型信息方法的目的。\n通过实现反射机制的相关类获取@Retention（RetentionPolicy.RUNTIME）注解的注解类型信息：实现反射机制的相关类Class、Method、Constructor、Field、Package等都直接或间接实现了AnnotatedElement接口，AnnotatedElement接口中提供了四个与Annotation相关的方法。因此，使用反射机制的相关类调用实现了的AnnotatedElement接口方法，可以获得该反射相关类代表的部分上是否存在@Retention（RetentionPolicy.RUNTIME）注解的注解类型以及其注解信息。\nAnnotatedElement接口四个方法：\n\u0026lt;T extends Annotation\u0026gt; getAnnotation(Class\u0026lt;T\u0026gt; annotationClass\u0026gt;，如果存在annotationClass（该参数为注解的.class）注解类型的注解，则返回这个注解。 Annotation[] getAnnotations（），如果存在注解则以注解数组形式全部返回。 Annotation[] getDeclaredAnnotations()返回直接存在于此元素上的所有注释。 boolean isAnnotationPresent\u0026lt;Class\u0026lt;? extends Annotation\u0026raquo;，接收一个Annotation类型，如果该元素上存在这个Annotation注解类型，则返回true，否则返回false。 通过反射机制相关类获取注解引用变量后，可以利用这注解引用变量获取该注解中属性的值，获取方法为“注解引用变量.注解属性名()”，与对象获取属性值的方法后多加一个括号。\n注解@Target（ElementType[]），只能用于注解其它注解类型，接收一个ElementType枚举常量数组，表示被注解的注解类型能用于注解什么元素，由ElementType数组值决定。\nElementType枚举类型常量值：ANNOTATION_TYPE（只能注解注解类型）、CONSTRUCTOR（注解构造方法）、FIELD（注解属性）、LOCAL_VARIABLE（注解局部变量）、METHOD（注解方法）、PACKAGE（注解包）、PARAMETER（注解参数）、TYPE（注解类、接口、注解类型、枚举声明）。\n@Documented只能用于注解注解类型，被它注解的注解类型所注解的元素在生成JavaDoc帮助文档的时候，会在相应元素上显示这个注解类型。如果没有使用@Documented注解的注解类型在生成JavaDoc帮助文档的时候不会保存到文档上。\nEclipse生成JavaDoc方法：Project-Generation Javadoc\n@Inherited注解只能注解注解类型，当一个元素被它注解的注解类型注解后，继承该元素的元素能够被继承这个注解类型，反之则不会继承。\n2012-07-26# JUnit：Java单元测试，经典版本有JUnit3.8（完全基于反射机制设计）和JUnit4.x（基于反射机制和注解设计）\n使用JUnit需要导入JUnit库（JUnit.jar）。\n使用JUnit3.8的类需要导入包import junit.framework.TestCase，并且使用的类需要继承TestCase类，同时需要进行单元测试的方法名必须以test开头，如果不以test开头则进行JUnit测试的时候不会测试这个方法。\n使用JUnit4.x的类需要导入包org.junit.Test，并且在需要测试的方法前添加注解@Test，那么使用JUnit测试的时候就会测试这个方法，否则不会测试。\nJUnit原理（执行步骤）：\n先获得需要测试类的Class对象。 通过Class对象获取测试类中所有public类型方法的Method数组。 遍历Method数组，取出每一个Method对象。 如果是JUnit3.8，则判断Method对象对应的方法名是否是test开头，是则执行这个方法，否则不执行；如果是JUnit4，则会调用每一个Method对象的isAnnotationPresent（Test.class），判断方法是否被@Test注解，是则调用method.invoke（）执行该方法，否则什么都不做。 异常类：java.lang.Exception，java中所有的异常类都直接或间接的继承Exception。\n异常和错误：即Exception和java.lang.Error，它们都继承与java.lang.Throwable类，Exception异常是指可以处理的程序错误，而Error错误是不可处理的程序错误。\n运行时异常：也叫unchecked异常，java.lang.RuntimeException（直接继承Exception）或者直接及间接继承RuntimeException的异常，是运行期间抛出的异常，此类异常可以不必进行自行处理，JVM会自行处理，一般也不建议进行自行处理。\n非运行时异常：也叫checked异常，所有直接或间接继承Exception但非继承RuntimeException的异常都叫非运行时异常，此类异常必须自行进行异常处理，可以通过try-catch-finally处理，也可以使用throws处理。\n异常抛出的位置：\n当程序运行的代码行出现异常时，会自动生成相应的异常类并抛出。 new一个异常类，并使用throw关键字抛出。 处理异常的方法：\ntry{}catch（Exception e）{}finally{}： 将可能出现异常的代码放置到try后的{}代码块中，如果其中代码出现异常，则会在出现异常的代码行生成一个对应的异常对象并抛出和不再执行try中出现异常之后的代码。此时会按照catch排列顺序遍历try之后的catch（try之后可以跟多个catch，也可以将catch省略，但省略后必须跟finally），当其中一个catch参数异常类类型与抛出异常类类型符合时，则执行这个catch代码块中的方法。不存在抛出类型与所有catch不匹配的情况，因为若存在可能抛出的异常与所有catch不匹配时，程序在编译的时候根本不能编译通过。另外，匹配catch参数的时候也只会有一个catch匹配，因为每次最多只有一个异常抛出。特别的，由于匹配catch是按照前后顺序匹配，如果多个catch的异常参数类型中存在继承关系，那么必须要将父类异常类型参数的catch排在子类catch之后，否则子类catch异常将永远没有机会调用，编译时不能通过并会提示子类catch无法到达，而没有继承关系的catch则先后顺序没有关系。try-catch之后，无论异常是否处理，都会执行finally中的代码，即使是try代码块中存在return，也会在return语句调用之前先执行finally代码块。但是如果try代码块中存在System.exit（0）语句，则不会执行finally代码块，因为exit（0）是结束JVM的语句。整个try-catch-finally执行完毕后，会继续执行这个处理结构之后的代码（如果处理结构中没有catch则不会执行结构之后的代码）。注：一般不将声明变量的代码放置到try代码块中，如果在try代码快中声明变量，那么在try-catch-finally结构之外使用声明的变量将会出现编译错误。 定义类时使用throws抛出相应异常：如果定义一个类的时候，类中代码可能抛出异常，可以在定义类的参数列表括号后使用“throws+对应异常类[,对应异常类]”来将异常抛出但是不处理这个异常。处理异常的方法在于调用该类方法的方法中，要用try-catch-finally结构处理，如果调用该类方法的方法没有处理，继续使用throws将异常抛出到上一级调用方法。如果都没有提供处理方法，继续用throws抛出知道main方法都继续throws，那么这个异常会JVM处理。 try-catch-finally结构和throws组合：在catch代码块中再使用throw抛出一个异常，并用throws将异常抛到方法外。这种做法通常用于捕获代码自动生成的异常，并将这个异常重新包装成自定义的异常类，再以自定义的异常类抛出去处理，有利于形成具有特定处理信息的异常类。 常见的运行时异常：NullPointerException，空指针异常，由于调用了某个对象的方法，但是该对象引用的值为null所导致。\n自定义异常类需要继承一个异常类，一般是Exception，也有继承RuntimeException，但比较少。Exception中含有一个带参数的构造方法Exception（String str），str为异常的描述信息，使用Exception继承的printStackTrace（）方法可以打印出异常描述信息和异常出现位置（JVM处理异常一般也是调用这个方法）。\n使用自定义异常类的方法通常是利用一些判断结构，如if结构，在判断出出现自定义异常的地方使用new，构造一个自定义异常类，并用throw将其抛出，同时在该方法声明后面使用throws抛出。之后处理自定义的方法与其他异常类的处理方法一致。\n","date":"June 1, 2014","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%83%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"Java注解","url":"https://www.qinxiandiqi.sbs/tags/java%E6%B3%A8%E8%A7%A3/"},{"title":"Java异常","url":"https://www.qinxiandiqi.sbs/tags/java%E5%BC%82%E5%B8%B8/"},{"title":"JUnit","url":"https://www.qinxiandiqi.sbs/tags/junit/"}],"title":"JavaSE学习笔记 第七记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-23# 枚举类型(JDK1.5增加的新特性）：严格来说并不是类，但是具有跟类相同的级别。类似于类定义，使用与类class相同级别的关键字enum来定义枚举类型，例如：public enum Color{RED, BLUE}。可以单独用一个java源文件定义一个枚举类型。定义声明之后，使用枚举的方法都与类的使用方法一致。\n枚举类型提供了两个静态方法：values()和valueOf()。values()返回枚举类型的数据数组。valueOf()方法将一个与成员变量名称相同的字符串自动转换成对应的枚举成员。\n枚举类型的本质是一个继承java.lang.Enum的类，枚举类型的每一个枚举成员实质上就是一个枚举类，并且这个枚举成员是final和static以及public修饰的，所以枚举成员可以直接用“枚举类型.成员”使用。从本质上，在枚举类中照样可以定义普通类成员变量和方法，包括构造方法，一旦定义了构造方法，那么定义枚举成员的时候也要使用构造方法的形式（本质是构造枚举对象）。而且，枚举类型中的成员（类）不同于普通类，它们是在编译的时候直接生成，编译后在运行时不能再改变，也就是说在编译后枚举类型就已经完全确定下来了。\nJDK1.5增加了类似C语言的格式化输出，System.out.printf(\u0026quot;%d,%s\u0026quot;,a,b)。\n泛型EnumSet集合，只能接收Enum类或者其子类的类型参数，如：EnumSet\u0026lt;Color\u0026gt;。向EnumSet枚举集合添加元素可使用of(element)，of的参数列表element只能接收对应枚举类的枚举成员。EnumSet的complementOf(EnumSet enumset)方法返回接收的枚举类型中除了enumset包含的枚举成员之外的枚举成员集合。EnumSet的noneOf(Enum)方法创建一个空的Enum枚举类型的集合，使用add方法添加的时候只能添加Enum枚举类型的成员。\n普通的集合同样可以将枚举类型当成类型参数接收。\n静态导入（JDK1.5增加新特性）：使用import static导入其他包内的静态成员变量或者静态方法，路径要一直指定到具体的静态成员和静态方法上，那么在使用的时候可以直接使用不需要具体类名.成员。与普通import的区别在于普通导入的路径指定到具体类就可以了，静态导入要一直指定到成员和方法上，并且只能导入静态的成员变量和方法，另外静态导入使用时无需写具体类名。\njava的反射机制：使用new构造类实例和通过类调用类的方法等过程，在编译器编译的时候就已经知道会构造类或使用类的方法，但是反射机制不一样，反射机制强调是在运行时动态创建类对象和动态调用类方法，也就是说，编译时并不知道要创建什么类，调用什么类方法，直到运行时才能知道代码要创建类或调用类。通过反射机制，能够调用类的私有成员和方法。\n反射机制主要通过5个类来实现：\nClass\u0026lt;T\u0026gt;类，位于java.lang包中，代表了一个类，每一个类中都已有一个成员变量class保存该类所属的Class类，一个程序中的多个同类型对象都共享同一个Class。 Field类，位于java.lang.reflect包中，代表该类的成员变量，在反射机制中使用类的成员变量需要通过Field类使用。 Method类，位于java.lang.reflect包中，代表类的方法，在反射机制中使用类的方法需要通过Method类使用。 Constructor类，位于java.lang.reflect包中，代表类的构造方法，在反射机制中通过该类使用类的构造方法。 Array类，位于java.lang.reflect包中，提供了动态创建数组，以及访问数组元素的静态方法。 动态机制之所以能够在运行时实现，在于这五个类提供动态实现的方法，在运用动态机制的时候，必须通过以上五个类来间接操作。 反射机制的相关使用过程：\n首先要获取一个类的Class，Class类中提供了一个static方法forName（String）方法，参数为要获取具体的类完整类名，能够返回要获取具体类的Class，如Class classType = Class.forName(\u0026ldquo;java.lang.Object\u0026rdquo;)；另一种获取Class的方法是通过每一个类的都具有的成员变量class，直接从“类名.class”中获取；还有一种方法是利用从Object类继承下来的final方法getClass()方法返回调用该方法对象的Class，此方法需要用对象调用。 反射机制创建类实例，Class类中提供了方法newInstance()借用该Class对应类中不带参数的构造方法创建类实例，并返回对象引用。如果要使用带参数列表的构造方法，则需要借助Constructor的newInstance（Object\u0026hellip;）方法——首先利用Class的getConstructor(Class\u0026hellip;)方法获取带相应参数构造方法的Constructor（通常用Class[]数组做参数，如果是使用不带参数构造方法，要传递Class[]{}空数组），再利用该Constructor的newInstance（Object\u0026lt;T\u0026gt;\u0026hellip;）构造新实例（通常newInstance参数为Object数组，即使是不带参数也要使用空Object[]{}数组表示空），需要注意的是可变参数数组的元素要前后对应。 反射机制使用类成员变量，通过Field获取。Class提供了getDeclaredFields()返回代表所有成员变量的Field[]数组，或者通过getDeclaredField(String）返回指定变量名的Field对象。Field的方法getName()可以返回该Field代表成员变量的名称。 反射机制使用类方法，通过获取Method操作，Class类中提供了getDeclaredMethod()方法获取该类中所有方法的数组，即返回值为Method[]；Class提供的getMethod(String，Class\u0026hellip;)接收一个方法名字符串和可变参数Class（可变参数接收多个Class，通常用Class[]数组传递），可以返回一个方法名为String，参数为Class\u0026hellip;的Method。获取Method对象后，Method类中提供了方法invoke(String，Object\u0026hellip;)，String表示调用的是哪个对象，Object\u0026hellip;可变参数接收一个或多个Object类型参数（通常以Object数组传递），返回值是一个Object类型（具体使用返回值时可再强制转换）。 反射机制构造数组，通过Array的newInstance()方法。Array重载了两个newInstance静态方法，其中newInstance(Class\u0026lt;T\u0026gt; componentType,int length)构造一个一维数组，长度为length，元素类型为Class\u0026lt;T\u0026gt; componentType关联的类。如果创建的是多维数组，要使用newInstance(Class\u0026hellip; componeneType,int\u0026hellip; dimensions)，componentType表示数组的比较类型对应的Class（已知数组可通过Class的getComponentType()返回该数组的比较类型，实际也就是数组的元素类型，三维数组的比较类型是二维数组，二维数组的比较类型是一维数组，不是数组的比较类型为null），dimensions使用散列int或者int数组表示多维数组各维度的长度（从左到右为高维度到低维度）。Array的get(array，int\u0026hellip;)方法可获取数组array对应维度的值。 Class对象在构造该类的实例之前就已经存在，一个Class对象是JVM在加载一个类的时候自动创建的，里面包含了该类的所有信息，包括成员变量和方法，是java语言至关重要的类。\n原生数据类型的包装类.TYPE返回的是包装类对应的原生数据类型，.class返回的是class+包装类的完整类名。\n2012-07-24# Class中getDeclaredXxx与getXxx的区别：getXxx只能返回public修饰的成员变量和方法，getDeclaredXxx可以返回任意修饰符修饰的变量和方法。反射机制可以破坏类的封装性，使用类的私有成员和私有方法，此时要使用getDeclaredXxx获取相应的Method、Field、Constructor才有可能。\nMethod、Field、Constructor都继承于AccessibleObject，该类中提供了一个方法setAccessible（boolean），当boolean为true时，表示强制取消检查访问限制，当boolean为false时，则正常检查访问限制。只有通过setAccessible()设置为true取消访问检查，才有可能破坏类的封装性，使用类的私有成员和私有方法。\n类中定义的set和get方法，本质上也是使用反射机制才有可能实现。\nField中的set（Object obj，Object value）可以设置对象obj中该Field关联的成员变量值为value。如果是私有成员，也需要先用setAccessible（true）强制取消访问权限检查才可实现。\nnative修饰的方法表示本地方法，即不是使用java来实现，而是由C或C++来实现。\nClass的构造方法为private修饰，所以Class不能手动创建。\n类调用类对象的getSuperclass可以获取父类的Class。\n代理模式：为其它对象提供一个代理以控制这个对象的访问，代理相当于客户端与目标对象之间的中介，并带有自己附加的一些功能。\n代理模式设计的角色：\n抽象角色：声明真实对象和代理对象的共同接口或抽象类。 真实角色：即真实对象，是代理角色所代表的对象，是客户端最终要 引用的对象。 代理角色：代理角色内部包含对真实对象的引用，从而能够操作真实对象。同时，代理对象提供与真实对象相同的接口以便能够在任何时刻代替真实对象和使用真实对象。并且，代理对象可以在执行真实对象操作的时候附加自己的操作，相当于代理对象是对真实对象的封装。 静态代理设计过程：\n定义抽象角色，一个真实对象和代理对象共同要实现的抽象类或者接口。 定义真实角色，也就是要被代理的类，此类要继承或实现抽象角色的抽象类或者接口，实现里面的抽象方法。 定义代理角色，也就代理类。此类也要继承或实现抽象角色的抽象类或接口，并且实现里面的抽象方法。同时，代理类中还要声明一个真实类的引用变量，并通过相关方法从外部传递一个真实类对象引用进来，或者代理类内部new一个真实类对象。另外，代理类中实现抽象类或者接口中的方法体中，利用代理类中的这个真实类对象引用调用真实类中相应的方法，也就是代理类的方法最终实现是由它代理的真实类的方法类实现，但是此时，在调用真实类的方法前后可以插入代理类自己的一些方法，完成捆绑代理类的一些操作。 客户端使用代理类操作真实类，可以使用抽象角色引用变量接收代理类对象引用，使用抽象角色中方法时，根据多态会调用代理类中的方法，而代理类中的方法由是对真实类中相应方法的封装，由此间接操纵了真实类。 动态代理需要java.lang.reflect包下的接口InvocationHandler和类Proxy来实现。\n动态代理实际过程：\n定义抽象角色，动态代理的抽象角色只能是一个接口，不能是抽象类。 定义真实角色，也就是被代理的类，要实现抽象角色接口中的方法。 定义实现InvocationHandler接口的类。动态代理中不再需要手动定义代理角色（代理类由运行过程中生成），但是将代理类需要包含的一个真实类对象引用变量转移到实现InvocationHandler的类中，所以这个实现InvocationHandler类要定义一个可以接收真实类对象引用的引用变量（一般是Object引用变量，这样就可以代理任意类型的真实类，动态代理的特点也就在于此，可以动态生成代理类，不需要每使用一个代理类就要定义一个代理类），并在构造方法或者定义其他方法给这个变量赋真实类对象引用值。其次，这个类中最重要的是实现InvocationHandler接口中的方法public Object invoke（Object obj，Method method，Object[] args），其中第一个参数一般是指调用该方法的代理类对象（一般情况下用不到），method是被代理的方法，args是被代理的方法的参数列表。动态代理的客户端运行代理类方法的时候，实际上使用的是这个类的invoke方法，invoke方法中接收的method参数是动态代理底层利用反射机制自动生成的被调用方法对应的Method对象，args参数是动态代理将被调用方法传递的参数组合起来的数组。因此，实现InvocationHandler接口的类中invoke方法要根据传回来的Method对象使用Method对象的invoke方法，所以Method的invoke方法要接收被调用对象（一般是本类InvocationHandler中接收真实类引用的成员变量，它通过它才能调用真实类的对应方法达到通过代理控制真实类的目的）和被调用方法的参数（本类invoke方法接收到的args参数），并且代理类方法中要附加自己的代码要插入到调用Method的invoke方法前后。 客户端动态生成代理类和构造代理类对象。动态代理的客户端要构造真实类对象和实现InvocationHandler接口的类对象，然后使用Proxy.newProxyInstance（ClassLoader loader，Class[] interfaces，InvocationHandler h）动态生成代理类（类名为“$Proxy+阿拉伯数字”）和代理类对象，并将生成的代理类对象返回（Object类型，使用时可以强制转换）。该方法中loader参数接收实现InvocationHandler类的类加载器ClassLoader，可以通过Class类的getClassLoader方法获得，可以使用真实类的ClassLoader或者实现InvocationHandler类的ClassLoader，一个类的ClassLoader可以装载很多类；第二个参数interfaces接收一个接口数组，自动生成的代理类会实现interfaces数组中所有的接口，一般要接收真实类实现的接口，因为代理类要实现与真实类的共同接口；第三个参数要接收InvocationHandler，也就是实现InvocationHandler接口的类，使用生成的代理类方法时，动态代理底层会传递参数h中的invoke方法所需要的参数，将代理类的方法实现转移给h中的invoke方法。 Proxy.newProxyInstance返回的代理类对象Object可以强制转换成接收的参数interfaces数组中的任意一种接口类型（多态特性，代理类是interfaces数组中所有接口的实现类），便可以调用强制转换后的接口中拥有的每一个方法，代理都会自动包装调用过程中的方法参数传递给InvocationHandler中的invoke，让invoke实现代理方法。 ","date":"October 14, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%85%AD%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"枚举","url":"https://www.qinxiandiqi.sbs/tags/%E6%9E%9A%E4%B8%BE/"},{"title":"反射","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%8D%E5%B0%84/"},{"title":"代理模式","url":"https://www.qinxiandiqi.sbs/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}],"title":"JavaSE学习笔记 第六记 —— 代理模式"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-21# Vector与ArrayList基本类似，不同的是Vector是同步的。HaseTable与HaseMap类似，只是HaseTable是同步的，不常用HaseTable，但常用HaseTable的子类Properties。\nProperties的键值通常为String，用于Java的属性配置。System.getProperties()可以发返回一个系统配置的Properties对象。\n泛型（JDK1.5新添加的特性，之前版本的编译器无法识别泛型）：将数据类型参数化，通常使用T作为数据类型的参数，可接受多个参数，编写泛型类的时候把T当成具体数据类型来使用就可以了。泛型适用于逻辑结构完全相同，只是数据类型不相同的情况，相当于泛型提供了一个逻辑结构模板，接收不同的数据类型后模板会转换为具体数据类型的逻辑结构。例如：class Test\u0026lt;T\u0026gt;，使用类Test的时候接收一个数据类型参数T，Test类内部将T当成一个具体的数据类型使用，此时Test就是一个处理T类型的类。泛型的好处是在编译的时候就能知道调用泛型类的接收类型，不使用泛型则编译的时候无法知道具体接收的是什么数据类型，只能在运行赋值的时候才能知道使用的具体类型。由此，泛型可以在编写代码的时候明确知道调用泛型类的具体类型，从而降低抛出类型转换错误的异常。\n所有的集合都使用泛型，构造集合的时候如果不传递泛型集合类要接收的具体数据类型，则默认接收的具体类型为Object，同时编译器会提出需要具体指定接收类型的警告，但能通过编译。传递了具体制定类型的泛型类只能接收制定类型的对象，否则编译不通过，所以当给集合类传递具体数据类型后，集合类只能接收和处理这种数据类型的对象。Java提倡使用集合类的时候传递具体的数据类型，默认的Object类型虽然可以接收各种类型对象，但是带来的问题是没法直接从集合中取出一个元素，要想做关于该元素的相关操作必须强制转换为该元素原有的数据类型，也就是说使用Object的时候必须知道集合中每一个元素的数据类型，一旦数据类型指派错误，就会抛出类型转换错误的异常。\n默认泛型类的类参数T可以接收各种数据类型，如果要限制T接收的数据类型，可以在T后面\u0026lt;\u0026gt;内部使用extends +只能接收的数据类型或者接口（无论限制的是类还是接口，规定一律使用extends），那么T只能接收extends该类型或接口，以及其子类，除此之外的其他类型都不能接收。默认情况下是T extends Object，所以使用泛型类的时候没有传递具体数据类型，则会默认接收Object类型。\n2012-07-22# 使用泛型的时候，一旦明确在声明泛型引用变量时的类型参数，那么声明的引用变量类型也就确定，不能指向其他类型参数的泛型。然而，可以只用通配符?声明可以指向多种类型参数的泛型引用变量。具体实现方法：在声明引用变量的时候，使用代替具体参数类型即可，则声明后的泛型引用变量可以指向任何泛型类型参数的对象。如果要限制引用变量指向的类型参数范围，可以使用实际是引用变量可以指向任何类型对象。特别的，一旦使用通配符定义的引用变量在赋予具体对象地址后，只能使用读取或者删除对象的数据而不能修改该对象。原因在于从java设计者的角度出发，一旦可以修改，那么程序运行时在使用该引用变量的数据时，必须知道该数据的具体类型然后强制转换过来，这种做法不符合泛型的思想，失去了泛型的意思，因此java规定使用通配符的泛型引用变量只能读取或删除对象数据，而不能修改。\n泛型同样可以被继承或用于接口，但是在继承泛型类或实现接口的时候必须同时继承类型参数，也就是说在子类或者实现类中必须也有父类或接口的类型参数，因为根据继承和实现的顺序原理，实现子类或接口时传递给父类或接口的类型参数只能从子类或实现类传入。\n遍历for循环（JDK1.5新增加特性），用于遍历数组或集合中的元素，for(type element：array){}。多维数组的遍历for循环需要使用多个遍历for循环嵌套使用，内嵌for中array使用上层element表示。\n自动装箱和自动拆箱：JDK1.5针对八种原生数据类型和包装类之间的自动转换提供的新特性，因此，在JDK1.5以后的版本中，可以直接将原生数据类型直接赋值给对应包装类，或者在需要原生数据类型的地方直接使用对应包装类的对象，JAVA会自动使用相应的valueOf方法转换后再使用。\nInteger包装类中存在一个长度为255的Cache数组，其中包含了数值在-128~127这255个Integer对象作为缓冲数组。当使用valueOf()方法时，如果数值在-128到127之间时，不会生成新的Integer对象，而是直接返回Cache数组中对应值对象的引用，所以，自动装箱形成的Integer对象数值只要在这个缓冲范围内，使用==比较的结果是true。另外，如果Integer对象是使用new构造的话，那么无论数值是否在缓冲范围内都将重新构造新的对象，与构造普通对象的过程一样，不受缓冲数组的影响。\n可变参数（JDK1.5新增加的特性）：方法的参数可以不明确指定有多少个，在调用的时候才能知道究竟有多少个参数。可变参数只能是同种类型的多个参数，并且可变参数只能出现方法参数列表的最后一个，使用时在参数类型后边加3个点，例如：void method（String str,int\u0026hellip; arr）{}。可变参数的实质是一个数组，调用带可变参数方法时，运行时会自动将参数转换为相关数组再传入方法中，所以调用带可变参数方法时的参数可使用离散参数，也可用数组参数，但是如果定义方法的时候使用数组做参数，调用方法时的参数也只能是数组。基于这个原因，为了能够知道调用方法时那些参数是要形成可变参数数组，所以决定了可变参数的位置只能在参数列表的最末尾，并且一个方法中最多只能有一个可变参数。\n","date":"October 10, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%94%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"泛型","url":"https://www.qinxiandiqi.sbs/tags/%E6%B3%9B%E5%9E%8B/"},{"title":"包装类","url":"https://www.qinxiandiqi.sbs/tags/%E5%8C%85%E8%A3%85%E7%B1%BB/"},{"title":"可变参数","url":"https://www.qinxiandiqi.sbs/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"}],"title":"Java SE 学习笔记 第五记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-19# java中的链表节点使用封装的类，节点类包括节点数据和前驱后继节点的引用，java中没有指针的概念，所以使用链表只能使用引用，也就是引用类型变量做“指针”。\nLinkedList链表的底层实现实质上是由数据类型为Object和前驱后继Entry引用变量组成的Entry节点类的双向链表，所以LinkedList链表可以添加任意类元素（Object的子类）。添加新元素的时候，LinkedList会将对象封装成Entry类实例后插入到LinkedList链表中。基于链表的特性，LinkedList无长度限制，添加删除链表节点会关系到节点上下引用值的改变。\nclass Entry{ Entry previous; Object element; Entry next; } JDK提供了Stack类和Queue接口，可以通过LinkedList类的方法构造Queue类。\nJava中的Set集合与数学意义上的集合是一致的，集合中不能有相同的元素。\nHaseSet中的元素没有顺序性，符合数学集合的无序性。使用add向HaseSet添加已存在元素会返回false，表明添加不成功。\nObject类的equals()方法的特点：\n自反性，x.equals(x)的值为true，x不为null； 对称性，x.equals(y)与y.equals(x)的值一致； 传递性，x.equals(y)的值为true，且y.equals(z)的值为true，则有x.equals(z)的值也为true； 一致性，只要x和y没有改变，无论调用多少次x.equals(y)，结果都不会改变； 对于非空引用x.equals(null)的结果必定为false。 Object类的haseCode()方法特点：\n在java引用的一次执行过程中，同一个对象只要没有修改，无论调用多少次haseCode()，返回值都相同； 如果两个对象用equals比较的结果为true，那么这两个对象的haseCode()返回值一致； 如果两个对象用equals比较的结果是false，那么这两个对象的haseCode()返回值可以相同，也可以不同，Java推荐使用不同值可以提高程序的性能； Object默认的haseCode()返回值是对象的地址，所以Object的haseCode()对于不同对象的返回值是不同的。 HaseSet集合不允许存在相同的元素是通过以下机制实现：当向HaseSet添加新元素的时候，HaseSet会首先调用要添加对象的hashCode()方法，并与HaseSet已存在元素的HaseCode进行比较，如果都不相同，则直接添加新元素进集合；如果HaseCode的比较结果存在相同的元素，则进一步调用equals比较要添加的元素和HaseCode相同的元素，equals的结果为true的话，则拒绝添加新的元素，若为false，则将新元素添加进HaseSet集合。因此，如果使用Object的hashCode()和equals()，添加内容相同的对象时，由于HaseCode值相同，所以即使对象内容相同也能一起添加进去。而对于重写了hashCode()和equals()方法的子类要根据具体重写的方法决定是否能添加进内容相同的对象，比如String类的hashCode()返回采用字符串的内容进行计算获得，所以内容相同的String对象的HaseCode值也相同，自然不能添加进HaseSet。\n一般重写equals()方法的时候，最好也重写hashCode()方法。在Eclipse里可以通过Source-Generate hashCode()和 equals()命令选择一定类属性自动重写hashCode()和equals()方法。\nHaseSet没有get方法，要想从HaseSet中取出元素，需要使用迭代器来使用。利用HaseSet的iterator()可以返回一个该HaseSet的迭代器，再使用循环结构配合iterator的hasNext()方法判断是否存在下一个元素和next()返回下一个元素，返回后hasNext位置会自动指向下一个元素。当然，由于HaseSet元素是无序的，所以返回的结果顺序不一定就是元素添加进HaseSet的顺序。\nSortedSet接口继承了Set接口，同样不能存在相同的元素，但是增加了排序功能，主要的实现类由TreeSet。\n向TreeSet添加元素的时候，TreeSet会根据元素自动升序排序添加，如果添加的元素无法与已存在元素进行比较，则会抛出类型转换异常。此时的解决方法可以是在构造TreeSet的时候使用带Comparator参数的构造方法，指定一个Comparator实现类，这个类里提供了元素之间比较的方法compara()。\n指定自定义Comparator的TreeSet构造方法为TreeSet（Comparator comparator），所以实现自定义排序方法，需要自定义实现Comparator接口的类，类中必须实现方法int comparator（Object arg0，Object arg1）（默认是arg0\u0026gt;arg1时返回整数，小于时返回负数，相等时返回0）。利用自定义的比较类，在TreeSet构造方法参数中new一个自定义的Comparator实现类实例就能创建按照自定义比较规则排序的TreeSet。默认的TreeSet使用升序排序，要修改为降序也要通过以上方法重新定义降序的Comparator实现类来完成。\n类似于Arrays类为数组提供了大量static操作方法，Collections类为集合提供了大量static操作方法，例如：reverseOrder()为目标集合返回一个与目标集合排序相反的Comparator；sort（Collection，Comparator）为集合Collection进行Comparator规则的排序；shuffle（List list）为列表List打算元素顺序；min()和max()获取集合中的最小和最大值。。。。方法详见JDK开发文档Collection类。\n2012-07-20# 映射Map是一个接口，元素是一对Key和Value对象，且不能存在相同的Key，一个Key最多映射到一个值上。\nHaseMap是Map接口常用的实现类，同样HaseMap中元素是无序的，用put向HaseMap添加元素，如果先后添加的元素Key值相同，则会修改原Key的Value，不会再添加一个元素。使用get(Key)获取HaseMap中Key的值。使用KeySet()方法可以获得HaseMap中Key的集合，并且返回的Set集合是由HaseMap维护的，即当HaseMap中Key发生变化会关联到Set中元素的变化，反过来也一样；使用value()可以返回HaseMap的Value集合Collection，同样返回的Collection也是由HaseMap维护的，值的改变会互相影响。之所以返回的Key集合用Set和Value用Collection，是因为Key在HaseMap中是唯一的，使用Set则不存在相同的元素，但是value却不一定是唯一，所以使用Collection。\nHaseMap每一对映射的实质在底层上就是一个HaseMap内部类Entry实例，Entry类封装了一对Key和Value，并提供了get和set方法。使用HaseMap的entry()方法可以返回HaseMap的Entry的Set集合，利用Set和Set的迭代器iterator可以遍历整个HaseMap。\nTreeMap类似于TreeSet，可以实现元素自动排序，默认的排序方法是根据Key进行升序排序。添加自定义排序方法的TreeMap与TreeSet类似。\n策略模式（Strategy Pattern）:策略模式的实现根据是多态。\n策略模式的组成有三大部分抽象策略角色（通常是接口或者抽象类）、具体策略角色（具体的实现接口或抽象类的实现类）、环境角色（即环境类，具有接口或者抽象类的引用作为环境类的成员变量，并且提供set和get设置接口或抽象类的方法，以及其他封装接口或者抽象类的方法，以供客户类使用）。\n策略模式的实现步骤分3步：1）编写抽象策略角色，一般是公共接口，设定接口的方法；2）编写具体策略角色，即策略类，封装相关算法和行为的接口实现方法；3）在环境角色即环境类中，保存一个接口的引用，并完成环境类的set和get或者构造方法，以对接口引用的赋值。\n策略模式的使用过程：定义了公共接口和相关接口的实现类，整个策略模式的关键在于环境类中保存的成员变量是接口的引用，而不是接口实现类的引用，并且环境类中所有需要接口做参数的方法，参数类型和方法中调用接口的方法都是依据接口的引用，而不是接口具体实现类的引用。由此，只要在客户类使用环境类的时候，为环境类的接口成员赋予具体的实现类引用，在环境类中，依据多态的特征，环境类就能知道将调用哪个具体实现类对接口的实现方法。也就是说，在客户类中，传入环境类中的具体实现类不同，环境类使用的方法过程不同，虽然方法名相同（实现接口的类中必须实现接口的方法）。\n策略模式的优点：策略模式中各个组成部分是弱连接的，只要接口类型不改变，各个组成部分中实现代码可以改变而不会影响其他部分。各个策略类实现接口的代码不同，环境类中使用的是接口的方法，而非具体实现类的方法，只要客户端传入具体实现类的引用，环境类就能根据多态知道使用的是哪个实现类的方法。好处是：环境类只需要根据接口引用和接口的方法名就能编写相应的业务逻辑方法，而只要传入的实现类引用不同，环境类的方法自然就变成了另一种业务逻辑，从而提升了软件的可重用性。\nHaseSet底层实质上是一个HaseMap，HaseSet中的元素实质上是HaseMap中的Key，而每一个Key的Value都是同一个Object，所以使用add向HaseSet中添加元素本质上是向HaseMap中put一个Key为HaseSet元素，值为一个final的Object元素。\nHase负载因子：表明达到负载因子比例的时候就认为哈希数组将近满，另外开辟一个更大的数组以满足要求。\nHaseMap的在底层上的实质是一个HaseMap内部类Entry的数组，HaseMap类内部有一个成员变量table就是一个HaseMap的Entry数组，使用默认HaseMap构造方法构造的HaseMapEntry数组长度为16，hase负载因子为0.75。并且，由于Entry类内部有一个成员变量next，可以指向一个Entry对象，所以table数组每个Entry元素实际上也是一个Entry链表。根据这个本质和Hase的特点，HaseMap就是一个封装了Entry数组的类，并且具有Hase数组元素添加方式的特征。\nHaseMap添加put新元素（一对键值，实质是一个Entry类对象）的过程本质：HaseMap根据新键值的Key的HaseCode和table数组的长度，通过Hase算法计算出新键值要添加进table数组的索引号。此时，HaseMap会判断该索引号位置上是否已经存在HaseMap元素，如果不存在，则直接将新键值（Entry）添加进table数组。如果该位置已经存在一个Entry，则HaseMap会遍历这个Entry链表，将添加的新Entry与链表上的每一个Entry进行equals比较。当链表上存在一个Entry比较后的返回值是true时，说明这个Entry的Key与将要添加的Entry的Key相同，根据HaseMap规则，HaseMap会取出原有Entry的Value返回，并将新添加的Entry的Value替换这个旧的Value。当遍历整个Entry链表后无true返回值，HaseMap则会为要添加的Entry调用addEntry方法，该方法会new一个新的Entry对象存放要添加的键值，并将这个新Entry的next指向原本该table数组位置上的Entry对象，再将这个新建的Entry对象插入到table数组这位置上，形成该位置上新的Entry链表，新的Entry对象为该链表的表头（之所以要将新Entry对象作为链表的表头，是因为操作系统认为刚使用的数据在不久的将来有很大的概率会再次使用，所以将新Entry对象作为表头可以提高效率）。 注：由于put新键值的数组位置是由Key根据Hase算法计算获得，所以Key值相同的键值获得的插入位置一定在同一个位置，因此只要遍历该位置上的Entry对象就能知道HaseMap中是否已经存在相同Key的键值。另外，同一个位置上的Entry链中可能存在不同的Key值，因为不同的Key值也可能得出相同的位置。\n","date":"October 9, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"Set","url":"https://www.qinxiandiqi.sbs/tags/set/"},{"title":"List","url":"https://www.qinxiandiqi.sbs/tags/list/"},{"title":"Map","url":"https://www.qinxiandiqi.sbs/tags/map/"},{"title":"Tree","url":"https://www.qinxiandiqi.sbs/tags/tree/"},{"title":"策略模式","url":"https://www.qinxiandiqi.sbs/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}],"title":"Java SE 学习笔记 第四记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-17# java.lang包在编译的时候会自动导入，无需显示导入。此包内包含object类还有一些常用类。\nObject的equals方法实质是判断两个引用值是否一致，相当于==，即两个对象是否是同一个对象。String的equals方法是比较两个字符串的每个字符是否一样，而不是两个字符串对象的引用值。\n“==”比较的是值，无论是原生数据类型还是对象引用都是比较值，只是对象引用的值是引用地址，因此比较的结果是同一个对象才会返回true。\nString是一种特殊的对象，除了可以用new创建新对象之外，还可以使用字面值直接创建新对象，字面值就是类似于原生数据类型一样赋值，如String string=\u0026ldquo;abc\u0026rdquo;，只有String可以使用字面值创建对象。并且，String字面量对象是一种常量对象，java通过字符串池来管理这些常量。当使用字面值创建对象后，字符串池内会创建相应的String对象，而且创建后的String内容不能再改变。因此，字符串池类会有很多不能再改变的字符串对象，如“abc”是不能再改变的，所以，当使用字面值创建String的时候，会先在字符串池内搜索是否存在要创建的字符串对象，如果存在则不用再创建，直接返回该对象的引用。也就是说，字符串池内的字符串对象只创建一次，并且创建后不能再改变值，可以供多个字符串引用使用。基于这个原理，当使用字面值创建相同内容的字符串对象时，用==比较这些对象的结果是true，因为它们的值都是字符串池中同个字符串对象的引用地址。而使用new创建的字符串对象不同，因为new是在堆中创建新对象，字符串池存在于栈中，new无论怎样都会在堆中创建新的对象，并返回对象的引用。如果字符串池中已经存在要创建的字符串，则new直接在堆中创建新对象；如果字符串池中不存在要创建的对象，则java会先在字符串池中创建要创建的字符创对象后，堆中也会创建这个要创建的对象，并返回堆中这个对象的引用。因此，即使String内容相同，但是不同对象引用地址不同，==比较的结果也是false。\nString的intern()方法，如“abc”.intern()，该方法会在字符串池中查询abc是否存在，如果不存在，则会在字符串池中创建abc对象，并返回字符串池中这个对象的引用，如果字符串池中已存在，则直接返回字符串池中这个对象的引用。因此，s.intern()==q.inern()为true的必要条件是s.equals(q)为true。\nString和StringBuffer的区别：String对象是常量，定义后值不能再改变；StringBuffer是变量对象，值可以修改，修改后StringBuffer引用变量还是指向原来的StringBuffer对象（String修改的实质是String引用变量指向一个新的String对象），常用append()方法追加字符，可以用toString()方法返回当前字符串内容。\n+号不能直接用于布尔值的拼接。\n字符串字面量的拼接，返回值也是字符串池中字面量的引用，如“abc”+“def”，返回的结果是字符串池中的“abcdef”引用；而字符串字面量和字符串引用变量的拼接，其过程是在堆中创建新的对象，返回值是堆中该对象的引用。\njava中对应8个原生数据类型，有8个包装类：Boolean、Integer、Short、Long、Byte、Float、Double、Character。\n数组是一种由相同类型的变量组成的集合的特殊类，类名为数组元素类型+[]（一个或多个），如int[]。创建数组相当于创建对象，用new创建，需指明数组的长度，特别的，可以{}指定数组元素的同时创建数组，此时不用指明数组的长度。每一个数组元素相当于数组对象的成员变量，而且数组含有一个final类型的public成员变量length，表示数组的长度。\n对于二维数组type[][]（行列），实质上相当于数组的数组，可以分隔为\u0026rsquo;type[]\u0026rsquo;[]：以type[]数组作为一维数组元素类型，type类型作为二维数组元素类型，分成两层形成最终复合二维数组，所以type表示的整个二维数组（值为地址，二维数值也是对象，其length值是二维数组中一维数组的个数），type[i]表示的是第i个一维数组（值为地址，因为数组是对象，其length值是第i个一维数组的长度）。二维数组每一行的列数可以不相同，也正是因为这个原因。类比二维数组，高维数组也遵循同样的道理。\n数组声明的元素的类型可以是interface，因为数组创建后的元素interface是引用类型，但是具体每个元素赋值时使用new的必须是interface的实现子类。\njava的java.util.Arrays类提供了各种静态数组辅助操作方法，包括数组比较，排序等，详见jdk文档。\n2012-07-18# java.lang.System类包含许多辅助方法，如数组拷贝方法arraycopy()。\n冒泡排序是交换排序的一种。\njava中约定常量命名规则：全部由大写字母组成，多个单词之间用下划线隔开。\n修饰常量成员常用final与static并用，因为final不允许修改，static为类常量，节省内存。\nEclipse中快捷键Alt+/，自动补充相关代码。Ctrl+/，自动注释掉光标所在行。Ctrl+D，删除光标所在行。将鼠标放置在一个类名上，再按Ctrl，类名将变成一个超链接指向定义该类的代码。\njava提供了集合的概念，集合也就是一堆元素的集合体。集合在java以接口的形式定义为Collection，但是JDK并没有提供Collection的实现类，而是提供了向下继承了Collection的另外两个接口Set和List，并且提供了Set和List的一系列实现类。\n实现List接口的一个实现类ArrayList（数组列表），类似于数组，但是元素可以是各种类（只要是Object的继承类）（数组是同一类类型的集合），定义的时候也不用指定数组列表的长度，使用add()向数组列表添加元素，使用get()向数组列表获取指定索引值的元素（索引顺序与数组一样，从0计数），使用clean()清除数组列表所有元素，使用remove()以元素索引或元素值删除指定元素。详细方法查询JDK文档。\n使用get获取ArrayList数组列表元素后，需要将元素强制转换为该元素的类型，如果强制转换的类型不符合元素类型，编译的时候不会报错，在运行时会把抛出类型转换错误异常。\n使用ArrayList的toArray()方法，将ArrayList数组类表元素转换为数组，返回的数组类型是Object[]，Object[]不能强制转换为具体类型数组，原因在于具体数组类型并不是Object[]的子类。\nArrayList的toString()方法是按照ArrayList元素的顺序分别调用各个元素类型的toString（）方法，并将返回结果使用[]括起来，元素之间的返回结果用，号隔开。\n集合的元素依然是对象的引用，不是对象本身。\nArrayList的底层实际是一个Object[]数组，所以数组列表元素可以是任意类型的对象，因为任何类都继承Object类。使用ArrayList默认构造方法会实际会在ArrayList底层生成一个长度为10的Object[]数组。当使用add方法向ArrayList添加新元素的时候，add方法会先判断Object数组长度够不够，如果够则直接将新元素添加进Object数组；如果长度不够，则会创建新的Object数组，长度为原来数组长度的1.5倍+1，然后将原数组的内容复制到新数组当中。如此循环，直到数组长度不够的时候，再按照以上方法增加数组长度。\n","date":"October 8, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"String","url":"https://www.qinxiandiqi.sbs/tags/string/"},{"title":"集合","url":"https://www.qinxiandiqi.sbs/tags/%E9%9B%86%E5%90%88/"},{"title":"List","url":"https://www.qinxiandiqi.sbs/tags/list/"},{"title":"数组","url":"https://www.qinxiandiqi.sbs/tags/%E6%95%B0%E7%BB%84/"}],"title":"Java SE 学习笔记 第三记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-15# 同一个类中的多个重载构造方法的互相调用，要用this(params)调用，不能直接显示调用构造方法，并且调用的时候this()必须放在构造方法中的首行，也就是this()之前不能存在其他代码。params为重载构造方法的参数列表。\n创建子类实例的时候，new子类的构造方法，实际默认的构造方法的调用顺序为调用父类不带参数的构造方法，若不存在不带参数的父类构造方法则编译出错，若存在则调用该父类构造方法，之后再调用带相应参数的子类构造方法。也就是说，创建子类实例的时候永远都是要先调用父类的构造方法再调用子类的构造方法。如果需要指定调用的具体父类构造方法，需要在子类构造方法使用super（params）来表明调用父类中带有相应参数列表的构造方法，并且super之前不能出现任何可执行的代码。\n对于内存来说，创建子类实例的时候，先调用父类构造方法，说明在内存中创建了一个父类实例（包括该父类实例的属性和父类方法引用，注：方法不创建，因为一个类的所有实例共享所有类方法），之后再调用子类的构造方法，这个时候并不像创建普通类一样从头到尾在内存中完完整整的创建一个单独的类实例，而是在该父类实例连续下来的内存空间里再创建子类增加的属性和方法引用，如果子类重写了父类相关属性和方法，则在连续下来的内存中创建重写的属性和重写的方法引用。换句话说，创建子类实例的时候，子类实例和父类实例共用一块连续的内存空间，并且子类实例内存空间包含父类实例内存空间，所以父类引用变量可以指向子类实例，使用多态的父类实例引用可以强制转换为子类引用。\n重载方法和重写方法的区别：重载方法是方法名一样，参数列表不一样，返回类型可以一样也可以不一样，重载方法出现在同一个类中；重写方法是方法名、参数类表、返回类型都完全一样，是子类重新定义父类中相应的方法，重写方法不能出现在同一个类中。\n多态就是父类对象引用可以指向子类对象引用。\n父类的构造方法不能被子类继承。\n当使用多态方式调用方法时，也就是父类引用变量指向子类实例，此时，java会先查询父类中是否存在需要调用的方法，如果不存在则编译错误，如果存在则再检查子类是否重写了这个方法，如果重写则调用子类的该方法，如果没有重写则直接调用父类的这个方法。而多态的父类引用，如果使用重写的属性值，则使用的属性值是父类的属性值，因为此时是父类实例引用，指向的是父类实例内存中的属性。\n可以通过强制转换的方式将使用多态方式的父类引用变量转换为子类引用变量。\n2012-07-16# 确定引用类型是否是多态是在运行时确定的，编译的时候只能确定引用类型引用的是什么类，也就是说多态是在编译后进行的，是晚绑定的。\n抽象类定义： abstract class 类名；抽象方法定义：修饰符 abstract 返回类型 方法名（params）;（没有花括号）。抽象方法必须定义在抽象类中。抽象类中可以包含具体方法，也可以不包含具体方法，抽象方法也可包含或者不包含。\n继承抽象类的子类必须实现父类中所有的抽象方法，如果没有全部实现，则该子类还是一个抽象类，需要使用abstract关键字，同样不能实例化。\n接口定义：关键字 interface 接口名{}；接口中所有方法都是抽象方法，所以在接口中的方法不能出现方法体，并且方法的abstract抽象关键字可以省略，因为默认都是抽象的。接口可以看成是特殊的抽象类，但是一个子类只能继承一个父类，而对于接口，一个类可以实现多个接口。实现接口用关键字implements，继承类用关键字extents。接口中所有方法也都是public关键字修饰的，所以public关键字在接口中省略。\n实现一个接口必须同时实现接口中所有的方法，否则要将类定义为抽象类。\n接口多态：接口类型引用指向实现接口类的实例，具有多态特征。\n静态关键字static，当用于修饰类属性时，表明该属性为静态类属性，所有的实例都共享一份静态属性，如果一个实例修改了静态属性，那么其他实例使用的静态属性值也会改变，使用静态属性可以用实例名.属性名，但是推荐使用类名.属性名；当用于修饰方法时，可以使用类名.方法名来调用。\n静态方法只能继承，但不具备多态特征，也就是不能被子类重写，只能被隐藏。即，只能使用静态方法隐藏静态方法，不能使用静态方法覆盖非静态方法，也不能使用非静态方法覆盖静态方法。被隐藏后调用的是父类还是子类的静态方法，取决于是使用什么类型的引用。\nfinal修饰的类不能被继承，final修饰的方法不能被子类重写，final修饰的属性不能被修改（属性为原生数据类型时，则数值不能改变；属性为引用类型时，则引用指向的对象不能改变，但对象属性可以改变）。\nfinal属性定义时必须显式赋予初值，如果定义时没有赋初值则只能在构造方法中赋初值，并且所有构造方法都必须赋初值，否则编译不通过，因为此时不赋初值将没有其他机会再定义值。\nfinal{}静态代码块，是在编译器编译后的class类文件加载进虚拟机时执行的代码，一个类中的静态代码只运行一次，在加载进虚拟机的时候。所有静态代码块在构造方法之前执行，构造方法是在生成新实例的时候才执行的，此时class文件已加载进虚拟机。对于继承的静态代码跟构造方法差不多，也是父类的先执行，再执行子类的静态代码，所有静态代码执行完毕后有创建实例才按构造方法顺序调用构造方法。\nclass类文件在类被使用的时候才会加载进JVM，而且只加载一次。\nstatic静态方法中只能调用静态属性，原因在于静态方法可以通过类名调用，如果调用的是非静态属性，那么每个实例的非静态属性都不同，静态方法会无法辨认使用的是哪个实例的属性，因此编译的时候不允许。反过来，非静态方法可以调用静态属性，因为静态属性时唯一，方法知道调用的是哪个属性。\n不能在静态方法中使用关键字this，同使用非静态属性的道理一样，this只当前的实例对象，在静态方法中使用this，java会无法辨认是哪个实例对象，因此编译不通过。\n接口中的成员变量都是public、final、static关键字修饰的，可以省略。因此，接口中的成员变量必须在定义的时候赋初值。\nfinal和abstract关键字不能同时使用，因为abstract抽象定义要求继承实现，而final是终止继承，互相矛盾。\n单例模式：一个类只有唯一的一个实例，即无论创建多少个类实例，它们实际上都是同一个实例。实现的方法是：首先，将类的构造方法关键字设为private，这么一来构造方法只能在类内部调用，在类外无法调用也就无法在类外创建类实例；其次，将创建类实例转移到类内部创建，并且使用static关键字修饰创建的类实例；最后，创建static的返回类内创建类实例引用的方法，使用static的原因是无法在类外创建类实例也就无法在类外调用类的任何一个非静态方法，只能通过静态方法来获取类内创建的类实例，类实例也用static修饰也是因为它要被static方法调用。由此三个步骤决定一个类由始至终只能创建一个类实例。\n包相当于目录，用于分类管理类文件，包名推荐使用反顺序的域名，并且全部小写。\n当java源文件中使用package引入包名，则表明此源文件中的类全名为：包名.类名，调用类的时候时候必须使用类的全名，即必须将类的class文件放置到包名指示的文件路径下，虚拟机才能找到相应的类执行，否则运行出错。\n当java源文件没有使用package引入包名，则使用默认的包default，调用的时候无需包名，即无包名。\n编译java源文件使用命令时，javac -verbose 文件名，可以追踪编译器的运行情况；javac -d 路径 文件名，可以将class生成到指定路径下。\n导入包和类的时候使用import关键字，导入类要使用类的全名，即指定到类名下，导入包则在包名后加“.*”，*号是通配符的意思，即该包下所有的类文件都导入，但是没有包含子包，如果需要导入子包则要将子包当成另外一个包，按导入包的方法导入。\n源文件中，必须遵循package、import、class的顺序声明。\n同个包内的类在关键字允许下，可以直接调用。\n访问修饰符：public，所有包的类都可访问，可以被所有包的类继承；private，只有在定义为private的类内部才可访问，不能被继承；不带访问修饰符即默认访问修饰符，可以被该类内部和该类所在包内的类可以访问，可以被所在包的其他类继承，不能被其他包的类访问和继承；protected，可以被类内部、相同包内其他类访问，可以被其他包的类继承，但不能被其他包的类访问。\n包和类的导入跟访问修饰符没有直接联系，导入是关于能不能找到类，访问修饰符是关于找到的类有没有权限访问。\n关键字instanceof用于判断某实例是不是某类或其子类的实例，引用名 instanceof 类名或接口名，返回一个布尔值。\n","date":"October 7, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"面向对象","url":"https://www.qinxiandiqi.sbs/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"多态","url":"https://www.qinxiandiqi.sbs/tags/%E5%A4%9A%E6%80%81/"},{"title":"单例模式","url":"https://www.qinxiandiqi.sbs/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}],"title":"Java SE 学习笔记 第二记"},{"authors":[{"title":"Jianan","url":"https://www.qinxiandiqi.sbs/authors/jianan/"}],"categories":[],"content":"2012-07-12# bin目录：binary二进制缩写 windows环境变量：用户变量只对当前用户起作用，系统变量对所有用户都起作用。 javac的c是compile缩写，编译的意思，所以javac是编译命令程序。 java.exe是java运行字节码class命令程序。 java编译后的class文件名为java源文件的类名，并非java源文件名。 java是跨平台语言在于真正执行的不是二进制代码而是字节码，并且字节码由JVM执行，也就是说java程序可以不考虑程序将在什么操作系统上运行，因为运行java程序是的JVM虚拟机，只要有虚拟机就可以执行java程序。但是JVM虚拟机不是跨平台的，它是由c语言编写的，不同平台下的JVM虚拟机不一样。 java包含8中原生数据类型：整型int（32位）、字节型byte（范围-128-127，是整型的一个子集）、短整型short（16位）、长整型long（64位）、单精度浮点型float、双精度浮点型double、字符型char、布尔型boolean（true\u0026amp;false）。 java变量名可以包含下划线、字母、美元符号、数字，但是变量名不能以数字开头。 java中有三种注释方式：单行注释，//；多行注释，/* /；java doc帮助文档注释，/* */。 java中的布尔型只允许true和false两个值，不同于c语言和C++可以将数值当做布尔型。 java中所有浮点型默认情况下都是double类型，所以将任意一个浮点值赋给float变量将会抛出损失精度错误，所以将浮点值赋给float需要将浮点值强制转换为float（加括号和类型名），或者借助java语言的支持性在浮点值后加F（大写或小写），如：float a=1.2F。 赋值准则：赋值等号左右两边类型一致或者左边类型范围大于右边类型范围，并且值大小不溢出该类型。 变量在使用之前必须声明类型和赋值，并且只能声明定义一次。 2012-07-13# 若干个数据类型参与运算，运算结果类型为参与运算类型中表值范围最大的类型。 当运算结果为int时，java舍弃结果的所有小数部分，只保留整数部分。 强制转换，如a为int，“（double）a”整个部分的结果为double类型，但是a本身还是int类型。 取模运算（%）的结果正负与被除数的符号一致。 逻辑运算与\u0026amp;\u0026amp;：当左边的值为false时，java得出结果为false，不再执行\u0026amp;\u0026amp;右边的表达式。 逻辑运算或||：当左边的值为true时，java得出结果为true，不再运行右边的表达式。 条件运算符（三目运算符）：type d=布尔表达式？a：b switch的变量类型只允许short、byte、int、char四种类型和枚举类型。 继承 inheritance；封装encapsulation；多态polymoruphism 定义类：修饰符 class 类名字 定义方法：修饰符 返回类型 方法名称（参数） java类中的方法不能嵌套定义，也就是不能在一个方法中定义另一个方法，并且java中的方法只能定义在类中，即方法是属于类的。 类的命名约定：首字母大写，如果由多个单词组成则每个单词首字母都大写并且直接拼接在一起形成类名。 方法的命名约定：首字母小写，如果由多个单词组成则第一单词首字母小写，其余单词首字母都大写，然后直接拼接在一起。 属性的命名约定：命名约定与方法的命名约定方式相同。 成员变量和局部变量在使用前都需要定义，成员变量在使用前可以不初始化，但是局部变量在使用前必须初始化，否则程序出错。成员变量使用前未初始化，则会使用java默认值：byte、short、int、long默认值为0；boolean默认值为false；float、double默认值为0.0；char默认值为\u0026rsquo;\\u0000\u0026rsquo;。 引用类型是专门使用在对象上的，相当于一个指向对象的指针变量。一个对象可以被多个引用变量引用，但是同一个时刻一个引用变量只能引用一个对象。 用new实例化一个类创建对象的实质是在内存类堆上开辟一块空间创新对象，此时若有引用类型赋值，则会返回对象地址给引用类型（引用类型存在于内存栈中）。 方法的参数是对象，实际上是对象的引用类型，因为java中对对象的操作都是通过引用类型来实现，所以当实参（引用类型）传递给形参的值实际上只是对象的引用变量，并没有生成一个新的对象，也就是说，此时实参和形参两个引用类型都指向同一个对象。 同一个类的多个对象都拥有自己的属性，但是同一个类的多个对象共同拥有类的方法。 方法参数为原生数据类型，则参数传递的是值，方法中形参值的改变不影响实参的值。方法参数参数传递都是值传递，引用类型传递的是引用类型值，即地址。 什么类型的引用只能指向什么类型的对象或者对象的父类。 构造方法的名字必须与类名完全一致，因此构造方法以大写字母开头；构造方法没有返回值，因此构造方法没有返回类型，连void也不能出现；如果没有定义构造方法，类会自动添加默认不带任何参数且方法体为空的构造方法，如果定义了构造方法，则不会自动生成默认构造方法；类的构造方法不能显示调用，由new隐式调用。 new关键字生成对象时完成三件事：为对象在内存堆内开辟内存空间；调用类的构造方法；返回对象的地址。new关键字后类名小括号内容为响应构造方法的参数列表。 2012-07-14# 一个java源文件中最多只有一个public类。且main存在的话，只能存在于这个public类中。换句话说，一个java源文件中可以存在多个不是public的类。 一个java源文件中含有多少个类，编译后就生成多少个class文件，并且文件名为相应类名。 方法重载：两个多或多个方法的名字相同，参数列表不同，包括参数个数不同和参数类型不同。不能根据方法的返回值类型来重载方法，即不能有参数列表相同，唯独返回类型不同的方法重载。 ","date":"October 6, 2012","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E8%AE%B0/","series":[{"title":"Java学习笔记","url":"https://www.qinxiandiqi.sbs/series/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"Java","url":"https://www.qinxiandiqi.sbs/tags/java/"},{"title":"float","url":"https://www.qinxiandiqi.sbs/tags/float/"},{"title":"虚拟机","url":"https://www.qinxiandiqi.sbs/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"title":"Java SE 学习笔记 第一记"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/en/contact/","series":[],"smallImg":"","tags":[],"title":"Contact Me"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/en/offline/","series":[],"smallImg":"","tags":[],"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/offline/","series":[],"smallImg":"","tags":[],"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/contact/","series":[],"smallImg":"","tags":[],"title":"联系我"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"https://www.qinxiandiqi.sbs/search/","series":[],"smallImg":"","tags":[],"title":"搜索"}],"series":["opengl","Java学习笔记"],"tags":["glsl","opengl","git","Windows","SSH","Java","XML","工厂模式","DOM","SAX","Android","翻译","Google Play Service","Socket","Java网络编程","线程","对象拷贝","装饰模式","io","字符集","序列化和反序列化","文件系统","AWT","Swing","Java内部类","Java注解","Java异常","JUnit","枚举","反射","代理模式","泛型","包装类","可变参数","Set","List","Map","Tree","策略模式","String","集合","数组","面向对象","多态","单例模式","float","虚拟机"]}